<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>Nixum Blog</title>
        <link>http://nixum.cc/</link>
        <description>Recent content on Nixum Blog</description>
        <generator>Hugo -- gohugo.io</generator>
        <language>en-us</language>
        <lastBuildDate>Tue, 01 Oct 2024 00:00:00 +0000</lastBuildDate><atom:link href="http://nixum.cc/index.xml" rel="self" type="application/rss+xml" /><item>
        <title>公告</title>
        <link>http://nixum.cc/p/%E5%85%AC%E5%91%8A/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/%E5%85%AC%E5%91%8A/</guid>
        <description></description>
        </item>
        <item>
        <title>向量数据库在 RAG 中的应用</title>
        <link>http://nixum.cc/p/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%A8-rag-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</link>
        <pubDate>Sat, 22 Jun 2024 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%9C%A8-rag-%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&#34;一从场景出发&#34;&gt;一、从场景出发&lt;/h2&gt;
&lt;p&gt;虽然目前ChatGPT等大语言模型已经十分好用了，无论是响应速度和回答的质量，基本上能解决我们日常一些问题和简单的工作，但不可否认，目前的大语言模型仍然有很多缺陷，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回答幻觉：大语言模型回答问题的本质上是基于其已有的训练数据，&lt;strong&gt;预测&lt;/strong&gt;(概率计算)出哪些可能的文字作为答案，所以难免会出现张冠李戴、胡说八道的情况，特别是在大模型不擅长的领域，最典型的比如你在 ChatGPT-3.5问他“西红柿炒钢丝球要怎么做“，它会十分正经的回答出让人哭笑不得的答案，又或者问一些代码问题，它有时会回答出一些不存在的语法或者方法的调用，产生不正确的答案；&lt;/li&gt;
&lt;li&gt;上下文限制：比如Chat GPT-3.5 Turbo的上下文限制是4K tokens（大概3000字），GPT-4 Turbo的上下文限制是128K tokens（大概9.6万字），这意味着其最多只能处理（记忆）这么多字的内容，且随着处理的上下文越多，响应速度也会越来越慢，成本越来越高；&lt;/li&gt;
&lt;li&gt;训练的语料更新不够及时：比如Chat GPT-3.5 Turbo训练的语料库只记录了2021年9月之前的数据，GPT-4 Turbo则是2023年4月，这意味着在此之后产生的数据模型是不知道的；&lt;/li&gt;
&lt;li&gt;在某些领域还不够专业：比如某些垂直领域的训练语料往往比较封闭，不对外公开，又或者是企业的内部数据，处于对数据的安全性的考量，并不希望上传到第三方平台进行训练，大模型无法获取这些数据进行训练，此时只依赖通用大模型的能力，回答的质量就会大打折扣；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了优化上述问题，提升大语言模型回答的质量，其中一种解决方案就是外挂一个知识库，在提问时先根据问题，检索出相关更加准确且核心的资料，指导大语言模型生成更加准确的答案。&lt;/p&gt;
&lt;h2 id=&#34;二rag的基本原理&#34;&gt;二、RAG的基本原理&lt;/h2&gt;
&lt;p&gt;下面是一个最简单的RAG基本流程：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-flow.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-flow.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;阶段一&#34;&gt;阶段一&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;结构化数据并进行文本分割：将大量文档（可能是pdf、word、文本、网页等等）进行结构化，统一数据结构，分割成多个文本块；&lt;/li&gt;
&lt;li&gt;将文本块向量化：使用Embedding模型，将分割后的文本块转换成向量，通过向量将不同文本块进行关联；&lt;/li&gt;
&lt;li&gt;存入向量数据库：将向量以及对应的文本块（元数据），选择合适的算法，存入到向量数据库中；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;阶段二&#34;&gt;阶段二&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;用户提问向量化：用户提出问题时，使用阶段一中相同的Embedding模型，将问题转成向量；&lt;/li&gt;
&lt;li&gt;检索召回：将问题转换后的向量，在向量数据库中进行检索，选择合适的算法，计算向量间的距离，得到与之相似的向量以及对应的文本块；&lt;/li&gt;
&lt;li&gt;提示词增强：将用户的问题以及上一步检索到的文本数据，进行提示词优化，构建出最终的提示词，发送给大模型，由大模型生成最终的结果并返回；&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;核心步骤&#34;&gt;核心步骤&lt;/h3&gt;
&lt;p&gt;在上面整个流程中，有几个核心步骤决定了最终RAG的质量，包括后续的优化，也是从这三个步骤入手：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;文本的处理和索引：如何更好的把文本数据存起来&lt;/p&gt;
&lt;p&gt;文本分割的目的，一个是因为解决大模型输入长度的限制，另一个在保持语义连贯的同时，减少嵌入内容的噪声，更加有效的检索到用户问题更相关的文本资料；&lt;/p&gt;
&lt;p&gt;怎么分割是一个取舍的问题，如果分块太大，可能会导致分块包含了太多信息，降低检索的准确性，分块太小又可能会丢失必要的上下文信息，导致最终生成的回答缺乏连贯性或深度；&lt;/p&gt;
&lt;p&gt;分割后的文本最终需要被检索，因此需要将文本转换为向量，这也依赖embedding模型的能力，而embedding模型的训练语料、参数的数量级，决定了转换出来的向量的关联性，最终影响文本间的语义相似度；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;检索召回：如何在大量的文本数据中，找到一小部分有用的数据，给到模型参考&lt;/p&gt;
&lt;p&gt;向量和对应文本的存储和检索，又依赖向量数据库，需要解决不同数量级维度的向量要如何存储，如何才能快速计算其相似度，快速精确的定位和检索数据的问题，甚至为了进一步提升检索的质量，除了需要提供相似度检索，还需要提供传统的关键字检索等；&lt;/p&gt;
&lt;p&gt;单纯的向量召回存在精度问题，因此可能需要多种召回的方式，比如分词召回、图谱召回等，对于召回出来的数据，可能还需要进一步的处理，进行各种去重、合并和重排等，检索出到更加精确的数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内容的生成：如何让大模型生成更有用的答案&lt;/p&gt;
&lt;p&gt;通过提示词优化，指导大模型如何利用这些检索出来的数据，如何排除无关的数据，如何更好的回答问题等；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/RAG%e6%a0%b8%e5%bf%83%e6%b5%81%e7%a8%8b.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/RAG%e6%a0%b8%e5%bf%83%e6%b5%81%e7%a8%8b.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;三为什么要使用向量数据库&#34;&gt;三、为什么要使用向量数据库&lt;/h2&gt;
&lt;p&gt;或许你可能会疑惑，如果用传统数据库或者es等搜索出关联的信息，再跟着问题一起发送给大语言模型，也能实现类似的效果，这样行不行？答案当然是可以，但它不是最优的，出来的效果也并不好，原因在于传统数据库的搜索功能都是基于关键字搜索，只能匹配出对应的文本，语义上的联系其实非常弱。&lt;/p&gt;
&lt;p&gt;传统数据库都是基于B+树或者分词+倒排索引的方式进行关键字匹配和排序，得到最终结果，例如，通过传统数据库搜索”布偶猫“，只能匹配得到带有”布偶猫“这个关键字相关的结果，无法得到”银渐层“、”蓝猫“等结果，因为他们是不同的词，传统数据库无法识别他们的语义关系。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e7%bb%b4%e5%ba%a61.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e7%bb%b4%e5%ba%a61.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;而向量数据库是基于向量搜索的，需要我们事先将”蓝猫“，”银渐层“，”布偶“，根据他们的特征比如大小、毛发长短、颜色、习性、脸型等维度，计算出一组数字后作为他们的代表进行存储（这组数字也被称为向量），只要分解的维度足够多，就能将所有猫区分出来，然后通过计算向量间的距离来判断他们的相似度，产生语义上的联系；&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e7%bb%b4%e5%ba%a62.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e7%bb%b4%e5%ba%a62.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;向量数据库并不是什么特别新的技术，早在机器学习场景中就有广泛应用，比如人脸识别、以图搜图、音乐软件的听音识曲等都有应用到，只是最近被大模型带火了一把。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;向量数据库用专门的数据结构和算法来处理向量之间的相似性计算和查询。 通过构建索引结构，向量数据库可以快速找到最相似的向量，以满足各种应用场景中的查询需求。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面是AWS上找到的对向量数据库的描述，在RAG的场景下，向量数据库的核心作用，就是将用户准备好的强相关性的文本转成向量，存储到数据库中，当用户输入问题时，也将问题转成向量，然后在数据库中进行&lt;strong&gt;相似性搜索&lt;/strong&gt;，找到相关联的向量和上下文，进而找到对应的文本，最后跟着问题一起发送给大语言模型，从而达到减少模型的计算量，提升理解能力和响应速度，降低成本，绕过tokens限制，提高回答质量的目的。&lt;/p&gt;
&lt;h2 id=&#34;四向量数据库的核心要点&#34;&gt;四、向量数据库的核心要点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将事物根据特征转换为不同维度的向量的过程，就叫做&lt;strong&gt;vector embedding向量嵌入：&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;通过计算多个向量之间的距离来判断它们的相似度，就叫做&lt;strong&gt;similarity search相似性搜索；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两个步骤，都决定着搜索质量的好坏。&lt;/p&gt;
&lt;h3 id=&#34;文本分割与向量嵌入&#34;&gt;文本分割与向量嵌入&lt;/h3&gt;
&lt;p&gt;以大语言模型对话的场景来说，涉及的语料就是大量的文本了，而文本包含的特征可以是词汇、语法、语义、情感、情绪、主题、上下文等等，这些特征太多了，可能需要几百上千个特征才能区分出一段文本表达的含义，很难进行人为的标注，因此需要有一种自动化的方式来提取这些特征，这就可以通过 vector embedding来实现。&lt;/p&gt;
&lt;p&gt;这一步其实并不属于向量数据库的功能，更像是数据入库前的前置操作，向量数据库本事只提供存储向量和搜索的功能。&lt;/p&gt;
&lt;p&gt;现在常用的大语言模型，基本都提供了embedding接口，供用户把文本转换为向量，比如 OpenAI的text-embedding-ada-002模型可以把文本分解成1536维的向量，网易的bce-embedding-base_v1模型，可以把文本分解为768维的向量等等，具体排名可以参考&lt;a class=&#34;link&#34; href=&#34;https://huggingface.co/spaces/mteb/leaderboard&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;HuggingFace的大文本嵌入排行&lt;/a&gt;，多少维其实就是一个长度多少的浮点类型数组，数组内的每个元素，则代表被分解的文本的特征，共同组成一个信息密集的表示。&lt;/p&gt;
&lt;p&gt;那对于给定的文本，要如何分割，以及分解出多少个向量合适呢？&lt;/p&gt;
&lt;p&gt;如果文本分割的粒度把控不好，可能会导致分割出来的无用信息太多，或者语义丢失，语义关联性不大等问题。对于文本分割，这里找到了一篇写得很好的文章：&lt;a class=&#34;link&#34; href=&#34;https://baoyu.io/translations/rag/5-levels-of-text-splitting&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;文本分割的五个层次&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第 1 层：字符分割，比如按一定的字符数、块大小分割文本，不考虑其内容和形式。&lt;/li&gt;
&lt;li&gt;第 2 层：基于分隔符分割，比如按句号、换行符、空格等进行文本切割。&lt;/li&gt;
&lt;li&gt;第 3 层：文档类型分割，比如PDF、Markdown都有特定的语法表示语义分割，使得分割出来的文本关联性更强。&lt;/li&gt;
&lt;li&gt;第 4 层：语义分割，比如每三句话转成向量，然后去掉第一句，加上下一句，再转成向量，比较两个向量的距离，如果距离超过一定的阈值，说明找到分割点。&lt;/li&gt;
&lt;li&gt;第 5 层：使用大语言模型分割，使用适合的prompt指导大语言模型推理分割。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单来说，我们更倾向于把上下文关联性强的文本合一起分割，得到的整体效果最好，下面的demo，就是按第4层的分割方式，可以参考一下。&lt;/p&gt;
&lt;h3 id=&#34;相似性搜索&#34;&gt;相似性搜索&lt;/h3&gt;
&lt;p&gt;具体可以看这个&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV11a4y1c7SW&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;视频&lt;/a&gt;，有上下两集，讲得非常容易理解，这里仅作简单归纳。&lt;/p&gt;
&lt;p&gt;现在我们已经将文本转换为向量存储在向量数据库中，如果想要在海量的数据里找到某个相似的向量，计算量会非常大，因此需要一种高效的算法来解决这个问题，类比到传统数据库，就是通过B+树建立索引进行查找，本质都是减少查询范围，从而快速找到结果。&lt;/p&gt;
&lt;p&gt;在向量数据库中有两种主要的搜索方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少向量大小，对向量降维；&lt;/li&gt;
&lt;li&gt;减少搜索范围，通过聚类或者将向量组织成树形、图形结构实现，限制搜索范围只在特定的聚类中过滤；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里简单介绍几种算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;K-Means：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在保存向量数据后，对向量数据先进行聚类（比如随机选择某几个点），然后将这几个点最近的向量分配到这个聚类中，然后不断调整聚类的质心，形成不同的簇，这样，每次搜索时，只要先判断要搜索的向量属于哪个簇，然后再在簇中进行搜索，从而减少搜索范围。如果要搜索的向量刚好处在两个聚类的边界上，则只能动态调整搜索范围，搜索其他簇&lt;/p&gt;
&lt;p&gt;如下图，在一个二维坐标系中划定4个聚类中心，形成4个簇；&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e7%b0%87.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e7%b0%87.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;积量化Product Quantization，PQ：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;随着数据规模的增大和维度的增加，数据点间的距离也会呈指数级增长，聚类算法需要分割更多的聚类（否则会导致向量和自己聚类的中心距离太远，降低搜索速度和质量），而且消耗的内存也会增加，解决这个问题的方法是将向量分解为多个子向量，然后再对每个子向量独立进行量化（量化的意思就是通过质心进行编号形成码本，在此聚类中的向量都对应这个编号，从而不用存储完整向量），从而实现降维，但代价就是搜索的质量会下降。&lt;/p&gt;
&lt;p&gt;如下图，在一个二维的坐标系中的四个聚类，每个聚类中的向量都用质心向量来替代表示，这样就只剩下4个向量了，然后只要维护好这4个向量形成的码本，就能极大的降低内存开销。(码本的作用是记录原始向量对质心的映射，有点类似操作系统中的内存多级分页算法)&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e8%81%9a%e7%b1%bb1.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e8%81%9a%e7%b1%bb1.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e8%81%9a%e7%b1%bb2.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e8%81%9a%e7%b1%bb2.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当向量的维度越高，向量分布越稀疏，形成的聚类也就越多，单纯根据质心构建码本的方式会导致码本的存储开销越来越大，比如一个128维的向量空间，如果直接按聚类分需要分为2^64个质心才能保证搜索质量，此时的质心编码和向量值的码本的内存消耗将巨大，甚至大于量化本身所节省下来的内存；&lt;/p&gt;
&lt;p&gt;此时就需要降维，将128维的向量分成8个16维的子向量，再对8个16维的子空间中进行k-means聚类训练，从而降低聚类的数量，此时一个向量被量化为8个编码值，同时每个子空间也会构建自己的子码本（此时只需要保存这8个子码本即可），使用时用8个编码值分别从对应的子码本中查询出8个16维的子向量再拼起来复原出一个128维的向量。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e9%99%8d%e7%bb%b41.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e9%99%8d%e7%bb%b41.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e9%99%8d%e7%bb%b42.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e9%99%8d%e7%bb%b42.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;局部敏感哈希Locality Sensitive Hashing，LSH&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以理解为反向哈希，以往我们都期望往哈希表里添加数据，都期望减少哈希碰撞的次数，即桶上的数据越少越好，这样方便我们快速找到对应的value，但是在向量搜索中，因为是为了找到相似的向量，所以我们期望哈希碰撞的次数尽可能的高，这样相似的向量都会落在一个桶上。&lt;/p&gt;
&lt;p&gt;这些算法本身就在查询速度、查询质量、内存开销上进行取舍，做出一个权衡。&lt;/p&gt;
&lt;h3 id=&#34;相似性度量&#34;&gt;相似性度量&lt;/h3&gt;
&lt;p&gt;判断两个向量是否相似，其实就是计算出两个向量间的距离，根据距离来判断他们的相似度，常见的有三种相似度算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;欧几里得距离：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;欧几里得距离是指两个向量之间的距离，它的计算公式为：𝑑(𝐴,𝐵)=∑𝑖=1𝑛(𝐴𝑖−𝐵𝑖)2&lt;em&gt;d&lt;/em&gt;(&lt;strong&gt;A&lt;/strong&gt;,&lt;strong&gt;B&lt;/strong&gt;)=&lt;em&gt;i&lt;/em&gt;=1∑&lt;em&gt;n&lt;/em&gt;(&lt;em&gt;Ai&lt;/em&gt;−&lt;em&gt;Bi&lt;/em&gt;)2&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e6%ac%a7%e5%87%a0%e9%87%8c%e5%be%97.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;欧几里得距离算法的优点是可以反映向量的绝对距离，适用于需要考虑向量长度的相似性计算。例如推荐系统中，需要根据用户的历史行为来推荐相似的商品，这时就需要考虑用户的历史行为的数量，而不仅仅是用户的历史行为的相似度。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;余弦相似度：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;余弦相似度是指两个向量之间的夹角余弦值，它的计算公式为：cos⁡(𝜃)=𝐴⋅𝐵∣𝐴∣∣𝐵∣cos(&lt;em&gt;θ&lt;/em&gt;)=∣A∣∣B∣A⋅B&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e4%bd%99%e5%bc%a6.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e4%bd%99%e5%bc%a6.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;余弦相似度对向量的长度不敏感，只关注向量的方向，因此适用于高维向量的相似性计算。例如语义搜索和文档分类。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;点积相似度：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;向量的点积相似度是指两个向量之间的点积值，它的计算公式为：𝐴⋅𝐵=∑𝑖=1𝑛𝐴𝑖𝐵𝑖&lt;strong&gt;A&lt;/strong&gt;⋅&lt;strong&gt;B&lt;/strong&gt;=&lt;em&gt;i&lt;/em&gt;=1∑&lt;em&gt;nAiBi&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e7%82%b9%e7%a7%af.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-%e7%82%b9%e7%a7%af.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;点积相似度算法的优点在于它简单易懂，计算速度快，并且兼顾了向量的长度和方向。它适用于许多实际场景，例如图像识别、语义搜索和文档分类等。但点积相似度算法对向量的长度敏感，因此在计算高维向量的相似性时可能会出现问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;都是纯数学的直接代入公式即可得出结果，计算出一个数值，然后跟我们设定的相似度阈值做比较，小于该阈值说明非常相似，大于阈值说明不相似，每一种相似性测量算法都有其优点和缺点，需要开发者根据自己的数据特征和业务场景来选择。&lt;/p&gt;
&lt;h3 id=&#34;过滤&#34;&gt;过滤&lt;/h3&gt;
&lt;p&gt;向量数据库也具备传统数据库那种可以根据部分业务字段进行过滤，之后再进行相似性查询，这些字段构成的就称为元数据，所以向量数据库通常需要维护两个索引，一个是向量索引，另一个是元数据索引，两者相结合从而快速找到需要的数据。&lt;/p&gt;
&lt;h2 id=&#34;五常见的向量数据库&#34;&gt;五、常见的向量数据库&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;DB&lt;/th&gt;
&lt;th&gt;是否开源&lt;/th&gt;
&lt;th&gt;功能简述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/chroma-core/chroma&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Chroma&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;简单：类型完整、测试全面、文档完整整合：支持LangChain（python和js）、LlamaIndex等等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.pinecone.io/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Pinecone&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;否&lt;/td&gt;
&lt;td&gt;相似性搜索、推荐系统、个性化和语义搜索免费版可以支持500w的向量存储，其用法简单，价格低廉，可以快速支持向量检索业务的验证与尝试。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/weaviate/weaviate&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Weaviate&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;向量搜索，语义搜索、推荐系统可以存储对象、向量，支持将矢量搜索与结构化过滤与云原生数据库容错和可拓展性等能力相结合。 支持GraphQL、REST和各种语言的客户端访问&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/milvus-io/milvus&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Milvus&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;是，云原生版本为zilliz&lt;/td&gt;
&lt;td&gt;对包含数百万、数十亿甚至数万亿个向量的密集向量数据集进行相似性搜索；支持万亿向量数据集上的毫秒级搜索：在万亿向量数据集上测试平均延迟（毫秒级）云原生版本有免费额度，不过只支持创建两个collection&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/facebookresearch/faiss&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Faiss&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;图像识别、语义搜索Facebook背书&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/spotify/annoy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Annoy&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;Spotify背书，基于随机投影和树的算法，支持多种相似算法低维度效果会更好（比如&amp;lt;=100），但即使是1000维的维度，它的表现也还是非常优秀&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/elastic/elasticsearch&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Elasticsearch  8.0 以上版本&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;实现文本的语义搜索或者图像、视频或音频的相似度搜索提供了基础&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;a class=&#34;link&#34; href=&#34;https://supabase.com/blog/openai-embeddings-postgres-vector&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;PostgreSQL + pgvector插件&lt;/a&gt;&lt;/td&gt;
&lt;td&gt;是&lt;/td&gt;
&lt;td&gt;支持精确和近似最近搜索（ANN)，提供三种距离即使方法：欧几里得距离、余弦距离、内积&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;六rag-实战&#34;&gt;六、RAG 实战&lt;/h2&gt;
&lt;p&gt;强烈建议可以看&lt;a class=&#34;link&#34; href=&#34;https://python.langchain.com/v0.2/docs/introduction/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;langchain的官方文档&lt;/a&gt;，写得非常详细且清晰，demo也很容易跑起来，而且也可以在他们的官方文档上体验一下相似性搜索。&lt;/p&gt;
&lt;p&gt;这里也基于langchain框架，使用chroma作为向量数据库，使用ollama管理的本地大模型llama2-chinese（也用它作为vector embedding），文本预处理使用&lt;a class=&#34;link&#34; href=&#34;https://baoyu.io/translations/rag/5-levels-of-text-splitting&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;文本分割的五个层次&lt;/a&gt;提到的第四场的方法，然后按照下面的流程，实现一个简单的RAG demo。&lt;/p&gt;
&lt;p&gt;只是一个小demo，体验一下RAG的流程而已，出来的效果不一定很好哈。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-flow.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rag-flow.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装ollama作为本地LLM，跟着它&lt;a class=&#34;link&#34; href=&#34;https://github.com/ollama/ollama&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;github&lt;/a&gt;上的步骤进行安装即可，我测试的时候是用docker进行安装的，然后指定它跑在GPU上，不然推理答案的速度太慢了；&lt;/li&gt;
&lt;li&gt;准备一篇markdown文章，就可以开始写代码了，这里把整个流程分割成多个步骤，每个步骤可以独立运行；&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;将markdown文章进行预处理，分割成文本块：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_community.llms&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Ollama&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_core.prompts&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ChatPromptTemplate&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_core.output_parsers&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StrOutputParser&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_community.document_loaders&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UnstructuredMarkdownLoader&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_text_splitters&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RecursiveCharacterTextSplitter&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_community.vectorstores&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Chroma&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_community.embeddings&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OllamaEmbeddings&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain.chains&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;create_retrieval_chain&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain.chains.combine_documents&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;create_stuff_documents_chain&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;json&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;codecs&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# 解析 md 内容，并llama2-chinese作为嵌入模型计算向量，然后转成 json 文件&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;markdown_path&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;markdown文章的路径&amp;#34;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;loader&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UnstructuredMarkdownLoader&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;markdown_path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;elements&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;loader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;embeddings&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OllamaEmbeddings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;model&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;llama2-chinese&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;sentences&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;enumerate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;vectors&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;embeddings&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;embed_documents&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;page_content&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;sentences&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;({&lt;/span&gt;
                &lt;span class=&#34;s1&#34;&gt;&amp;#39;sentence&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;page_content&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;s1&#34;&gt;&amp;#39;index&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                &lt;span class=&#34;s1&#34;&gt;&amp;#39;vectors&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vectors&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;# 打印内容及其转换的向量&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;page_content&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;  &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;vectors&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;se&#34;&gt;\n&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# 将转换结果写入json文件中&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;sentencesJson&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;json&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;dumps&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sentences&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ensure_ascii&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;False&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;with&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;codecs&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;sentences.json&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;w&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;utf-8&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sentencesJson&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;将上一步得到的文本 + 嵌入的向量，存入到 chroma DB中：&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_community.llms&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Ollama&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_core.prompts&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ChatPromptTemplate&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_core.output_parsers&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StrOutputParser&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_community.document_loaders&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UnstructuredMarkdownLoader&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_text_splitters&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RecursiveCharacterTextSplitter&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_community.vectorstores&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Chroma&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_community.embeddings&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OllamaEmbeddings&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain.chains&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;create_retrieval_chain&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain.chains.combine_documents&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;create_stuff_documents_chain&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;json&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;codecs&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;chromadb&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# 加载上一步拆分出来的文本及其向量值&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;sentences&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;with&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;sentences.json&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;rb&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;as&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;sentence&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;json&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# 构建一个chroma db实例&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;chromadb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PersistentClient&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;./chroma_db&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 获取要存储的collection&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;collection&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;client&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;get_or_create_collection&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;demo&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 构建要保存的内容&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;embeddingList&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;docList&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;ids&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;item&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;in&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;enumerate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sentences&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;embeddingList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;vectors&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;docList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;sentence&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;ids&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;1-&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;index&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]))&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 保存到chroma中&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;collection&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;embeddings&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;embeddingList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;documents&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;docList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ids&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ids&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;向 ollama 提问，此时会先基于问题，使用llama2-chinese嵌入模型转换为向量，在chroma 中进行相似性搜索，查找出对应的文本，然后将检索得到的文本 + 问题，一起发给ollama，由ollama的llama2-chinese模型推理给出答案；&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-Python&#34; data-lang=&#34;Python&#34;&gt;&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_community.llms&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Ollama&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_core.prompts&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ChatPromptTemplate&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_core.output_parsers&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StrOutputParser&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_community.document_loaders&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;UnstructuredMarkdownLoader&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_text_splitters&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RecursiveCharacterTextSplitter&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_community.vectorstores&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Chroma&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain_community.embeddings&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OllamaEmbeddings&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain.chains&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;create_retrieval_chain&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;langchain.chains.combine_documents&lt;/span&gt; &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;create_stuff_documents_chain&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# 加载嵌入模型，将问题转换成向量，这一步只是为了打印相似性搜索的结果&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;embeddings&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OllamaEmbeddings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;model&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;llama2-chinese&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Chroma&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;persist_directory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;./chroma_db&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;collection_name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;demo&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;embedding_function&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;embeddings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;query&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;这里改成想要问的问题&amp;#34;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;docs&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;similarity_search&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;根据问题从db中相似性搜索出来的文本：&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;docs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;page_content&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# ----------------------------------------------------------&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 加载LLM模型&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;llm&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Ollama&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;model&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;llama2-chinese&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;prompt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ChatPromptTemplate&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;from_template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;仅依据下面提供的上下文，回答我接下来的问题:
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;lt;context&amp;gt;
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{context}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;lt;/context&amp;gt;
&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;问题: &lt;/span&gt;&lt;span class=&#34;si&#34;&gt;{input}&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;# 这里langchain已经帮我们整合了 “根据问题从db中相似性搜索出来的答案” 这个步骤了&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;document_chain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;create_stuff_documents_chain&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;llm&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;prompt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;retriever&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;as_retriever&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;retrieval_chain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;create_retrieval_chain&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;retriever&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;document_chain&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 发送问题+相关联的文本，从而实现检索增强，即RAG&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;response&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;retrieval_chain&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;invoke&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;({&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;input&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;query&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;response&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;answer&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;七rag的局限性&#34;&gt;七、RAG的局限性&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/RAG%e7%9a%84%e5%9b%9b%e4%b8%aa%e6%9f%a5%e8%af%a2%e7%ba%a7%e5%88%ab.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/RAG%e7%9a%84%e5%9b%9b%e4%b8%aa%e6%9f%a5%e8%af%a2%e7%ba%a7%e5%88%ab.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;用户的任何问题可以大致分为四类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;显性事实查询：&lt;/p&gt;
&lt;p&gt;最简单查询，可以直接从提供的数据中检索到明确的事实信息，无需复杂的推理和思考，难点在于检索的准确性和高效性。&lt;/p&gt;
&lt;p&gt;比如问”某门店上个月的营业额是多少？“这种问题，可以直接从数据源中获取；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐性事实查询：&lt;/p&gt;
&lt;p&gt;隐性事实并不会在原始数据中显现，推导隐性事实的信息可能会分散在多个段落或数据表中，需要进行关联、少量的推理和逻辑判断得出。&lt;/p&gt;
&lt;p&gt;比如问”查询过去一年营收增长率最高的门店是哪一家？“，此时就需要向LLM提供过去一年所有门店的营业额，帮助LLM计算每个门店的增长率，最后得出结论&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可解释性推理查询：&lt;/p&gt;
&lt;p&gt;可解释性推理，是指无法从显性事实和隐性事实中获取，需要综合多方数据进行较为复杂的推理、归纳和总结的问题，并且推理过程具备业务可解释性。&lt;/p&gt;
&lt;p&gt;比如问”过去一年，某地区门店营业额收入下滑5%的原因是什么？“这种问题无法从数据源中直接获取，但可以通过其他方式进行推理，比如告诉LLM 总营收由什么部分组成，让LLM直接从这些部分进行推断，最终得出结论；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隐性推理查询：&lt;/p&gt;
&lt;p&gt;隐性推理查询，是指难以通过事先约定的业务规则或决策逻辑进行判断，而必须从外部数据中进行观察和分析，最终推理出结论。&lt;/p&gt;
&lt;p&gt;比如问”预测某地区未来三个月内可能关闭的门店，并说明原因“，这种问题，除了需要给LLM提供各门店的经营数据，还需要LLM结合外部数据如市场调研报告、新闻报道、政策信息等，进行深度分析和推理才能得出结论；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/RAG%e5%9b%9b%e4%b8%aa%e6%9f%a5%e8%af%a2%e7%ba%a7%e5%88%ab%e5%af%b9%e5%ba%94%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/RAG%e5%9b%9b%e4%b8%aa%e6%9f%a5%e8%af%a2%e7%ba%a7%e5%88%ab%e5%af%b9%e5%ba%94%e7%9a%84%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到，RAG还是有其局限性，最基础的RAG流程虽然实现简单，但大部分情况下只能解决显性事实查询和部分隐性事实查询，RAG的发展，从Naive RAG，到Advanced RAG，再到Module RAG，都是在尽量优化这些问题，但对于用户来说，大多数有价值的问题都属于可解释性推理和隐性推理查询，对于这些需要推理查询的问题，RAG就无法解决了，只能依靠其他更复杂和更有针对性的解决方案；&lt;/p&gt;
&lt;h2 id=&#34;八参考&#34;&gt;八、参考&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1JF4m177Wd&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RAG + 向量数据库科普&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://juejin.cn/post/7250794190120353847&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;基于langchain 的文档问答 最佳实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/2311302&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;用GPT-4和ChromaDB与文本文件对话教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/651179780&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;基于LLM+向量库的文档对话痛点及解决方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/641132245&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LLM+Embedding构建问答系统的局限性及优化方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://python.langchain.com/v0.2/docs/how_to/markdown_header_metadata_splitter/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;langchain - How to split Markdown by Headers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://aitutor.liduos.com/02-langchain/02-1.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;langchain入门&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.wehelpwin.com/article/4387&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;chatgpt原理1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://brightliao.com/2023/04/25/chatgpt-a-technical-summary/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;chatgpt原理2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://arxiv.org/html/2409.14924v1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Retrieval Augmented Generation (RAG) and Beyond: A Comprehensive Survey on How to Make your LLMs use External Data More Wisely&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>系统设计</title>
        <link>http://nixum.cc/p/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</link>
        <pubDate>Tue, 01 Oct 2024 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;思考的维度&#34;&gt;思考的维度&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;明确需求，确定核心功能和非核心功能&lt;/li&gt;
&lt;li&gt;容量估算，比如用户数，qps，读写比例，DB存储容量，网络带宽&lt;/li&gt;
&lt;li&gt;架构设计，确定有什么模块，服务的定位和功能，DB，缓存，MQ，与外部服务的交互，API与通信协议，&lt;/li&gt;
&lt;li&gt;针对某一个模块深入思考细节&lt;/li&gt;
&lt;li&gt;扩展设计，需要考虑可靠性、可扩展性、安全性、成本等方面&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ByteByteGoHq/system-design-101&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ByteByteGoHq/system-design-101&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/checkcheckzz/system-design-interview&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/checkcheckzz/system-design-interview&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/ashishps1/awesome-system-design-resources&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/ashishps1/awesome-system-design-resources&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://github.com/donnemartin/system-design-primer/blob/master/README-zh-Hans.md&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>毕业后四年工作总结 - 第一阶段结束</title>
        <link>http://nixum.cc/p/%E6%AF%95%E4%B8%9A%E5%90%8E%E5%9B%9B%E5%B9%B4%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E7%BB%93%E6%9D%9F/</link>
        <pubDate>Tue, 09 May 2023 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/%E6%AF%95%E4%B8%9A%E5%90%8E%E5%9B%9B%E5%B9%B4%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93-%E7%AC%AC%E4%B8%80%E9%98%B6%E6%AE%B5%E7%BB%93%E6%9D%9F/</guid>
        <description>&lt;h2 id=&#34;工作经历&#34;&gt;工作经历&lt;/h2&gt;
&lt;p&gt;从19年毕业的时候，给自己定了一个期限，希望能在第三年做出点成绩，或者能跳到一家好一点的厂子，虽然比预期晚了近一年，但还算基本实现（自认为）。&lt;/p&gt;
&lt;p&gt;目前为止(2023.05.09)，主要的技术栈还是围绕着后端 + 云原生展开，经历的业务是广告 + 电商，幸好，毕业之后遇到的团队都非常不错，几任主管都很nice（巧的是他们几乎都是之前UC系的），都给了我非常大的帮助。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;2018.07 ~ 2020.05&lt;/p&gt;
&lt;p&gt;从实习到校招乃至毕业的第一年，做的是广告方向的业务，类似网盟平台，但主要是业务框架的开发，比如类GraphQL协议语法糖的实现、账号服务架构、广告主接入流程低代码等方面，量的话，高峰时一天有一亿点击，还是很猛的。&lt;/p&gt;
&lt;p&gt;开发使用的是Java，但又不使用 Spring 全家桶，除了底层的Web框架用的是Netty，像微服务间的通信协议、RPC、业务框架啥的，都是团队自研的。CTO带队，当时的Leader和CTO本身对技术很有追求，对方案的设计和代码的合理性都非常严格，这对刚毕业的我来说成长上帮助比较大。&lt;/p&gt;
&lt;p&gt;自研的框架在我看来，整体上是一个多Reactor多线程 + 事件驱动 + 状态机的模型（blog上有这个模型的简化版类图），能极大程度压榨CPU的性能，整体上吞吐确实比Spring全家桶那套要高一点，设计上确实挺巧妙的，后来甚至把整个事件驱动抽出来做成一个PaaS框架， 搭配自研的类 GraphQL 接口，实现低代码的功能，任何方向的业务写完配置就能直接往里套，就有CRUD接口可以用了，当然，代价就是实现很复杂，写得我及其痛苦。&lt;/p&gt;
&lt;p&gt;这对于刚毕业的我来说真的高维打击，很多东西都不懂，每天都要干得很晚，甚至会为某一个功能实现不出来感到焦虑，足够难，但也足够有趣，是成长得比较快的一个阶段。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2020.05 ~ 2020.11&lt;/p&gt;
&lt;p&gt;由于公司内部原因，之前所在的基础架构部门解散了，当时又由于疫情刚开始，还是有点害怕失业的，还好后面转入业务部门，不过也从Java转成go + gin那一套，从事跨境电商方向的业务开发。&lt;/p&gt;
&lt;p&gt;业务方面没什么好说的，难度对比之前真的降维打击，当然成长也比较慢，好处是这个阶段开始接触到云原生、Kubernetes + Istio那一套，这个时候还只是以用为主，初步对这些东西有了概念，当时的Leader也很支持我们自己去探索，就利用公司闲置的KVM搭了一套K8s集群，算是入了个门，开始云原生探索道路。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2020.11 ~ 2023.04&lt;/p&gt;
&lt;p&gt;在当时公司电商业务技术负责人的邀请下一起跳槽到一家做出海的创业公司，主要也是从事跨境电商方向的业务开发，自研电商平台，创业的方向总体还是围绕着电商在做，从数码3c电商平台到本地生活类型的电商平台，因此也有幸参与到了整个业务线、后端基建的从0到1。&lt;/p&gt;
&lt;p&gt;得益于之前的经历，进入公司的第一件事就是为后端团队搭建基础设施，使用AWS EKS搭建了kubernetes环境，在此基础上，采用EFK方案做日志收集、采用Prometheus、Grafana方案做指标采集和资源利用率看板等一系列的监控告警工具，基于 Gitlab 搭建整套CI/CD流程，算是基本把整个后端的基建搭建起来，有了监控告警和日志查询，动态扩缩容，基本上服务开发后就没有烦恼，自动化部署和维护起来真的很方便。&lt;/p&gt;
&lt;p&gt;在此期间也重新认识了kubernetes，对它整个架构和原理有了更深一步的理解，基本上一些常规的问题和排查思路都非常熟悉，不得不说，Kubernetes真的是一座大山，里面的理念和方案设计真的挖都挖不完，但是，个人感觉像Kubernetes这一块，如果想要更进一步的提升，还得有足够复杂的场景才行，只依赖一两个demo或者我们这种小集群（10台机器）还是远远不够；&lt;/p&gt;
&lt;p&gt;基建搭完之后，逐渐转向业务开发，先是基于以前的项目抽出一套业务开发的脚手架，对应的目录结构做分层，团队的小伙伴需要起新服务时直接命令式生成脚手架，可以直接进行业务代码的开发即可；（这里也立一下Flag，未来有时间要继续完善一下那个脚手架，反正后面做副业可能也会用到）&lt;/p&gt;
&lt;p&gt;之后才是真正的做业务开发，负责平台的核心交易线，主导开发了订单和支付服务，这里比较好的一点是前期设计的时候就考虑中台的方案，尽量将整个交易流程标准化，并提供一套接口方便各个业务方接入，在后面公司频繁变换方向的时候，仍然能提供很好的订单和支付功能的支撑。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总之，这四年总结下来，基本上从后端的开发到云原生的开发部署运维这一块，都有一定的理解，对方案的设计，架构，设计模式，代码的组织也有了自己的思考，具备独立规划和完成的能力，在后端中kubernetes还算是玩得比较溜（当然云原生这块还是比不了专门搞容器开发的，但对于一个后端来说暂时够用了）；业务方面也熟悉了交易，履约相关的功能，对电商和广告有一定的认识。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;求职感想&#34;&gt;求职感想&lt;/h2&gt;
&lt;p&gt;从离职到入职，中间gap一个月，就靠着平时的积累，离职后复习了一周就开始投简历，今年行情确实很差，没那么多机会了，Boss上来来去去也是那几家，然后我还是瞄准了百人以上，有一定规模且盈利的公司，选择就更少了，进面的有13家左右，最终offer四家，还有两家是拿到心仪offer后没有继续推进面试流程的。&lt;/p&gt;
&lt;p&gt;在整个求职过程，也是不断发现不足和补齐不足的过程，甚至比上班还累，每一次面完都快虚脱，回头还得复盘和复习，每一次面试没过就意味着少了一次机会，异常焦虑，时刻处于自我怀疑和信心十足的跌宕起伏中&amp;hellip;&lt;/p&gt;
&lt;p&gt;今时今日，面试已经不像以前那么容易，机会是面一个少一个，如果想提升面试成功率，拿到更多的offer，平时就要有所积累了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于简历&lt;/strong&gt;，个人推荐是半年更新一次，即使没有跑路的意愿也需要更新，再不济也要记录一下这段时间的工作内容。记录时，以STAR法则作为线索去写，就算是普通的CRUD，也可以通过设计模式去美化它，当然前提还是需要你真的能理解。&lt;/p&gt;
&lt;p&gt;记录的时候，需要记两份，一份是用STAR法则记录详细的内容，包括背景和场景、实现、优缺点、可改进的点，这一份是针对面试官询问的时候，能牢牢把握住你经历的项目内容，不会一问三不知，讲述的时候也要可以按照STAR法则去讲，这样就能很清晰的讲出来，面试过程中能流利的表达也是一个很重要的点；另一份是对详细内容的浓缩，提炼成一句有亮点的话写在简历上的。简历通常需要不断修改，可以给其他人看，根据他人的建议进行修改，一份好的简历基本是要迭代个三四遍吧。&lt;/p&gt;
&lt;p&gt;另外，简历上不宜出现过多业务名词，除非是对口的业务方向，因为面试的公司不同，业务也不同，不同业务的面试官可能会看不懂这些名词，最好的方式是将业务抽象为技术模型，思考它的优缺点，这样的好处是，如果遇到相同的业务场景，不管是在面试中还是工作中，都可以去套用，也能引导面试官从技术角度提问。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于基础&lt;/strong&gt;，数据库、网络、操作系统是必问的，占比大概是50%、30%、20%，这一块就比较吃基础了，微服务、服务治理、分布式架构、云原生，甚至一些业务解决方案，都是在这些基础上进行延申和借鉴的，打好基础真的很重要。&lt;/p&gt;
&lt;p&gt;如果想要速成，推荐小林coding那几个专题，应该足够应付大多数场景了。如果想更进一步，就急不来了，一些MIT的课程，一些经典的书，博客文章，慢慢啃吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于八股&lt;/strong&gt;，说实话我现在还是不太清楚八股是不是指别人整理好的一些的面试题Q&amp;amp;A，如果光靠这些Q&amp;amp;A的话，我觉得是远远不够的，这种稍微问深一点就得露馅了吧。当然，Q还是有很好的提示作用的，至少Q可以抄，但A还是得自己去找，不断的去思考，理解和延申，不断的从Q里进行发散，才能真正转换为自己的东西；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于system design&lt;/strong&gt;，这个就比较吃工作经验了，有些场景你没遇到过，没仔细思考过，当场回答起来是比较费时费力的，效果也不太好。&lt;/p&gt;
&lt;p&gt;解决办法可以是上面有提到的把自己遇到业务场景转换为技术模型，平时多看点系统设计的书，一些大佬的解决方案，或者是平时自己看到的一些功能，思考一下别人是怎么实现，通过这些方式来积累了，这也是我目前做的不够好的，还需要总结出一个指导思想出来。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于算法&lt;/strong&gt;，这个真的是性价比极低的投入，极低的ROI，基本都是靠量堆起来的，靠量变引起质变，反正个人能力有限，跟大佬们还是没得比，基本都是刷了忘，忘了刷，除开那些简单题，很少能达到一次性bug free的程度，但是至少，个人觉得leetcode Top 100还是要过个几遍来保持手感的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对于面试&lt;/strong&gt;，面试过程能录音最佳，面试完就要及时复盘，及时记录，有时候自己觉得很有信心的题目，实际上回答时却磕磕绊绊，遗漏细节，没有条理，所以才需要及时复盘，形成一个回答问题的指导思想，个人觉得STAR算一个比较好的回答方式。&lt;/p&gt;
&lt;p&gt;总之，面试这种东西，一方面看积累，一方面面的多了，熟悉了回答的一个大概思路，自然就懂得一些套路，&lt;strong&gt;最最最重要的还是运气&lt;/strong&gt;哈哈哈，毕竟前期再多的准备也只是给自己一些底气罢了。&lt;/p&gt;
&lt;h2 id=&#34;未来期望&#34;&gt;未来期望&lt;/h2&gt;
&lt;p&gt;第一阶段就算是结束了，下一个阶段还没想好要定多久，可能3年，或者4年？目前好像还看不到太远，身边也没有可以参考的目标系。&lt;/p&gt;
&lt;p&gt;当然，自己本身好奇心也还是有，对很多东西都很感兴趣，虽然，大部分还是处于光说不练的假把式状态哈哈哈。期望是能在第二阶段找到一份能做下去的副业，或者能持续探索的技术方向。&lt;/p&gt;
&lt;p&gt;做技术有个好处也有坏处，好处是有什么产品的想法可以快速通过自己的技术去实现，最近也和朋友合作了一款小品级应用，已完成基本的开发、监控和告警，尝试推广中，目标是今年能有小一千的用户，这样服务器成本也能cover了，能赚点点零花钱。&lt;/p&gt;
&lt;p&gt;对我来说，比较感兴趣的东西还是偏底层，或者框架类型这种脱离业务范畴，偏通用一点的东西，比如云原生相关、中间件、框架基建类的应用实现，但要真正的落地，还是需要有大规模的量来进行验证，真正投入到生产环境中，才能知道自己的实现的方案好还是不好，这点只能尽量在工作中找找机会了。&lt;/p&gt;
&lt;p&gt;然后，也罗列一下接下来想要去做的东西：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;目前这份工作业务方向是金融相关的，所以期望自己能多学习一些股票、基金类相关知识，本身理财也是挺重要的一环；&lt;/li&gt;
&lt;li&gt;工作还是业务侧相关的开发为主，应该会非常无聊，业余应该会尝试从：音视频、存储、IM、ES 、k8s一些组件进行相关的学习；&lt;/li&gt;
&lt;li&gt;英语，目前来看英语还是非常重要的，无论是信息获取还是日常使用，光会读写还是不太行，接下来目标是达到一个非常熟练的听说读写，期望是能达到张口就来，一听就懂那种；&lt;/li&gt;
&lt;li&gt;AI 或者 Web3，这两个方向本身就有比较大的未知和可能的存在，如果作为独立开发者来说，可能基于这两个方向可以做一些应用层相关的开发，会有比较大的回报？&lt;/li&gt;
&lt;li&gt;发展点其他兴趣爱好，比如磨练一下拍照技术、羽毛球甚至社交，健身好像也可以纳入计划中了；&lt;/li&gt;
&lt;/ol&gt;
</description>
        </item>
        <item>
        <title>Kubernetes和Istio</title>
        <link>http://nixum.cc/p/kubernetes%E5%92%8Cistio/</link>
        <pubDate>Wed, 22 Jul 2020 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/kubernetes%E5%92%8Cistio/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;kubernetes&#34;&gt;Kubernetes&lt;/h1&gt;
&lt;p&gt;当前Kubernetes社区对外宣传是单个集群最多支持5000个节点，Pod总数不超过150k，容器总数不超过300k，单节点Pod数量不超过100个。&lt;/p&gt;
&lt;h2 id=&#34;基本&#34;&gt;基本&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/k8s%e9%a1%b9%e7%9b%ae%e6%9e%b6%e6%9e%84.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/k8s%e9%a1%b9%e7%9b%ae%e6%9e%b6%e6%9e%84.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;容器的本质是进程，Kubernetes相当于操作系统&lt;/strong&gt;，管理这些进程组。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CNI：Container Network Interface，容器网络接口规范，如 Flannel、Calico、AWS VPC CNI&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CRI：Container Runtime Interface，容器运行时的各项核心操作的接口规范，是一组gRPC接口。包含两类服务，镜像服务和运行时服务。镜像服务提供下载、检查和删除镜像的RPC接口；运行时服务包含用于管理容器生命周期，与容器交互的调用的RPC接口（exec / attach / port-forward等）。dockershim、containerd、cri-o都是遵循CRI的容器运行时，称为高层级运行时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CSI：Container Storage Interface，容器存储的接口规范，如PV、PVC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OCI：Open Container Initiative，容器运行时和镜像操作规范，镜像规范规定高层级运行时会下载一个OCI镜像，并把它解压称OCI运行时文件系统包；运行时规范描述如何从OCI运行时文件系统包运行容器程序，并且定义其配置、运行环境和生命周期。定义新容器的namespaces、cgroups和根文件系统；它的一个参考实现是runC，称为底层级运行时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CRD：Custom Resource Definition，自定义的资源对象，即yaml文件中的Kind，如Operator就是实现CRD的控制器，之后直接使用Operator创建的CRD声明对象即可使用&lt;/p&gt;
&lt;p&gt;每一个对象都包含两个嵌套对象来描述规格（Spec）和状态（Status），对象的规格就算我们期望的目标状态，而状态描述了对象当前状态，这一部分由Kubernetes本身提供和管理，通过describe才能看到Status的信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Deployment&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;metav1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;TypeMeta&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;,inline&amp;#34;`&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;metav1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ObjectMeta&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;metadata,omitempty&amp;#34; protobuf:&amp;#34;bytes,1,opt,name=metadata&amp;#34;`&lt;/span&gt;

	&lt;span class=&#34;nx&#34;&gt;Spec&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;DeploymentSpec&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;spec,omitempty&amp;#34; protobuf:&amp;#34;bytes,2,opt,name=spec&amp;#34;`&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Status&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;DeploymentStatus&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;`json:&amp;#34;status,omitempty&amp;#34; protobuf:&amp;#34;bytes,3,opt,name=status&amp;#34;`&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Master节点作用：编排、管理、调度用户提交的作业&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Scheduler：编排和调度Pod，基本原理是通过监听api-server获取待调度的pod，然后基于一系列筛选和评优，为pod分配最佳的node节点，在每次需要调度Pod时执行。&lt;/li&gt;
&lt;li&gt;API-Server：提供集群对外访问的API接口实现对集群资源的CRUD以及watch，是集群中各个组件数据交互和通信的枢纽，当收到一个创建pod的请求时会进行认证、限速、授权、准入机制等检查后，写入etcd。唯一一个与etcd集群通信的组件。&lt;/li&gt;
&lt;li&gt;Controller Manager：管理控制器的，比如Deployment、Job、CronbJob、RC、StatefulSet、Daemon等，核心思想是监听、比较资源实际状态与期望状态是否一致，否则进行协调。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Device Plugin：管理节点上的硬件设备，比如GPU&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Node节点作用：运行或执行用户作业&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;kubelet：负责创建、管理各个节点上运行时的容器和Pod，这个交互依赖CRI的远程调用接口，通过Socket和CRI通信；&lt;/p&gt;
&lt;p&gt;周期性地从API Server接收新的或者修改的Pod规范并且保证节点上的Pod和其他容器的正常运行，保证节点会向目标状态迁移，向Master节点发送宿主机的健康状态；（处理Master下发到本节点的任务，管理Pod和Pod中的容器）&lt;/p&gt;
&lt;p&gt;kubelet 使用cAdvisor对worker节点资源进行监控。在 Kubernetes 系统中，cAdvisor 已被默认集成到 kubelet 组件内，当 kubelet 服务启动时，它会自动启动 cAdvisor 服务，然后 cAdvisor 会实时采集所在节点的性能指标及在节点上运行的容器的性能指标。（监控和定期向Master汇报节点资源使用率）&lt;/p&gt;
&lt;p&gt;kubelet 还通过 gRPC 协议同一个叫作 Device Plugin 的插件进行交互。这个插件，是 Kubernetes 项目用来管理 GPU 等宿主机物理设备的主要组件；
kubelet 的另一个重要功能，则是调用网络插件和存储插件为容器配置网络和持久化存储，交互的接口是CNI和CSI；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kube-Proxy：作为daemonset部署在每个节点上，负责宿主机的子网管理，用于为Pod创建代理服务，同时也能将服务暴露给外部，其原理就是在多个隔离的网络中把请求转发给正确的Pod或容器；&lt;/p&gt;
&lt;p&gt;从API-Server获取所有service信息，创建Endpoints，转发service到Pod间的请求，默认使用iptables模式，但当service数量变多时有性能问题，1.8版本后使用IPVS模式提升性能；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;coreDNS：低版本的kubernetes使用kube-dns，1.12后默认使用coreDNS，用于实现域名查找功能&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;核心组件的协作流程&#34;&gt;核心组件的协作流程&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Kubenetes%e7%bb%84%e4%bb%b6%e5%8d%8f%e4%bd%9c%e6%b5%81%e7%a8%8b.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Kubenetes%e7%bb%84%e4%bb%b6%e5%8d%8f%e4%bd%9c%e6%b5%81%e7%a8%8b.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以创建Deployment为例，用户或控制器通过kubectl、RestAPI或者其他客户端向API-Server发起创建deployment的请求；&lt;/li&gt;
&lt;li&gt;API-Server收到创建请求后，经过认证、鉴权、准入三个环节后，将deployment对象保存到etcd中，触发watch机制，通知API-Server，API-Server再调用ControllerManager对应的deployment控制器进行操作；&lt;/li&gt;
&lt;li&gt;ControllerManager中的DeploymentController会监听API-Server中所有Deployment的事件变更，当收到该deployment对象的创建事件后，就会检查当前namespace中所有的ReplicaSet对象，判断其属性是否存在该deployment对象，如果没有，DeploymentController会向API-Server发起创建ReplicaSet对象的请求，经过API-Server的检查后，将该ReplicaSet对象保存在etcd中，触发watch机制通知API-Server调用控制器&amp;hellip;；&lt;/li&gt;
&lt;li&gt;同上，会触发ReplicaSet Controller的检查，最后创建一个Pod对象，保存在etcd中；&lt;/li&gt;
&lt;li&gt;Scheduler监听到API-Server中有新的Pod对象被创建，就会查看Pod是否被调度，如果没有，Scheduler就会给它分配一个最优节点，并更新Pod对象的&lt;code&gt;spec.nodeName&lt;/code&gt;属性，随后该Pod对象被同步回API-Server里，并保存在etcd中；&lt;/li&gt;
&lt;li&gt;最后，节点的kubelet会一直监听API-Server的Pod资源变化，当发现有新的Pod对象分配到自己所在的节点时，kubelet就会通过gRPC通信，通过CRI向容器运行时创建容器，运行起来。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;api-server&#34;&gt;API-Server&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;API-Server 作为统一入口，任何对数据的操作都必须经过 API-Server。API-Server负责各个模块之间的通信，集群里的功能模块通过API-Server将信息存入到etcd中，etcd 存储集群的数据信息，其他模块通过API-Server读取这些信息，实现来模块之间的交互。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;主要场景：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;节点上的 Kubelet 会周期性的调用API-Server的接口，上报节点信息，API-Server将节点信息更新到etcd中&lt;/li&gt;
&lt;li&gt;节点上的 Kubelet 会通过API-Server上的Watch接口，监听Pod信息，判断Pod是要从本节点进行调度、删除还是修改&lt;/li&gt;
&lt;li&gt;Controller Manager的Node-Controller模块会通过API-Server的Watch接口，监控节点信息，进行相应的处理&lt;/li&gt;
&lt;li&gt;Scheduler通过API-Server的Watch接口，监听Pod的信息进行调度&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;API-Server本质上也是控制器那一套，通过List-Watch和缓存机制，来解决被大量调用的问题，保证消息实时性、可靠性、顺序性和性能，另外其他模块也是差不多的机制，对集群信息进行了缓存，通过List-Watch进行更新进行保证。&lt;/p&gt;
&lt;h3 id=&#34;流程&#34;&gt;流程&lt;/h3&gt;
&lt;p&gt;api-server在收到请求后，会进行一系列的执行链路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;认证：校验发起请求的用户身份是否合法，支持多种方式如x509客户端证书认证、静态token认证、webhook认证&lt;/li&gt;
&lt;li&gt;限速：默认读 400/s，写 200/s，1.19版本以前不支持根据请求类型进行分类、按优先级限速，1.19版本以后支持将请求按重要程度分类限速，支持多租户，可有效保障Leader选举之类的高优先级请求得到及时响应，防止一个异常client导致整个集群被限速。&lt;/li&gt;
&lt;li&gt;审计：记录用户对资源的详细操作行为&lt;/li&gt;
&lt;li&gt;授权：检查用户是否有权限对其访问的资源进行相关操作，支持RBAC、ABAC、webhook，1.12版本后默认授权机制是RBAC&lt;/li&gt;
&lt;li&gt;准入控制：提供在访问资源前拦截请求的静态和动态扩展能力，如镜像拉取策略。&lt;/li&gt;
&lt;li&gt;与etcd交互&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;调度器scheduler&#34;&gt;调度器Scheduler&lt;/h2&gt;
&lt;p&gt;主要职责就是为新创建的Pod寻找合适的节点，默认调度器会先调用一组叫Predicate的调度算法检查每个Node，再调用一组叫Priority的调度算法为上一步结果里的每个Node打分和排序，将新创建的Pod调度到得分最高的Node上。&lt;/p&gt;
&lt;h3 id=&#34;原理-1&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/k8s%e9%bb%98%e8%ae%a4%e8%b0%83%e5%ba%a6%e5%8e%9f%e7%90%86.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/k8s%e9%bb%98%e8%ae%a4%e8%b0%83%e5%ba%a6%e5%8e%9f%e7%90%86.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;第一个控制循环叫Informer Path，它会启动一系列Informer，监听etcd中的Pod、Node、Service等与调度相关的API对象的变化，将新创建的Pod添加进调度队列，默认的调度队列是优先级队列；&lt;/p&gt;
&lt;p&gt;此外，还会对调度器缓存进行更新，因为需要尽最大可能将集群信息Cache化，以提高两个调度算法组的执行效率，调度器只有在操作Cache时，才会加锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二个控制循环叫Scheduling Path，是负责Pod调度的主循环，它会不断从调度队列里出队一个Pod，调用&lt;strong&gt;Predicate算法&lt;/strong&gt;（预选）进行过滤，验证Pod是否真的能够在该节点上运行，比如资源是否可用，端口是否占用之类的问题，得到可用的Node，Predicate算法需要的Node信息，都是从Cache里直接拿到；&lt;/p&gt;
&lt;p&gt;然后调用&lt;strong&gt;Priorities算法&lt;/strong&gt;（优选）为这些选出来的Node进行打分，得分最高的Node就是此次调度的结果。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;得到可调度的Node后，调度器就会将Pod对象的nodeName字段的值，修改为Node的名字，实现绑定，此时修改的是Cache里的值，之后才会创建一个goroutine异步向API Server发起更新Pod的请求，完成真正的绑定工作；这个过程称为乐观绑定。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Scheduler内置各个阶段的插件，Predicate预选阶段和Priorities优选阶段就算遍历回调插件求出可用的Node结果。所以当节点很多的时候，如果所有节点都需要参与预先调度的过程，就会导致调度的延时很高。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/K8s%e8%b0%83%e5%ba%a6%e5%99%a8%e6%a1%86%e6%9e%b6%e6%89%a9%e5%b1%95%e7%82%b9.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/K8s%e8%b0%83%e5%ba%a6%e5%99%a8%e6%a1%86%e6%9e%b6%e6%89%a9%e5%b1%95%e7%82%b9.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;比如大集群有 2500 个节点, 注册的插件有 10 个, 那么 筛选 Filter 和 打分 Score 过程需要进行 2500 * 10 * 2 = 50000 次计算, 最后选定一个最高分值的节点来绑定 pod. k8s scheduler 考虑到了这样的性能开销, 所以加入了百分比参数控制参与预选的节点数.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;numFeasibleNodesToFind&lt;/code&gt; 方法根据当前集群的节点数计算出参与预选的节点数量, 把参与 Filter 的节点范围缩小, 无需全面扫描所有的节点, 这样避免 k8s 集群 nodes 太多时, 造成无效的计算资源开销.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;numFeasibleNodesToFind&lt;/code&gt; 策略是这样的, 当集群节点小于 100 时, 集群中的所有节点都参与预选. 而当大于 100 时, 则使用下面的公式计算扫描数. scheudler 的 &lt;code&gt;percentageOfNodesToScore&lt;/code&gt; 参数默认为 0, 源码中会赋值为 50 %.&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;numAllNodes * (50 - numAllNodes/125) / 100
&lt;/code&gt;&lt;/pre&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;整个 kubernetes scheduler 调度器只有一个协程处理主调度循环 &lt;code&gt;scheduleOne&lt;/code&gt;, 虽然 kubernetes scheduler 可以启动多个实例, 但启动时需要 leaderelection 选举, 只有 leader 才可以处理调度, 其他节点作为 follower 等待 leader 失效. 也就是说整个 k8s 集群调度核心的并发度为 1 个.&lt;/p&gt;
&lt;p&gt;云原生社区中有人使用 kubemark 模拟 2000 个节点的规模来压测 kube-scheduler 处理性能及时延, 测试结果是 30s 内完成 15000 个 pod 调度任务. 虽然 kube-scheduler 是单并发模型, 但由于预选和优选都属于计算型任务非阻塞IO, 又有 &lt;code&gt;percentageOfNodesToScore&lt;/code&gt; 参数优化, 最重要的是创建 pod 的操作通常不会太高并发. 这几点下来单并发模型的 scheduler 也还可以接受的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;调度策略&#34;&gt;调度策略&lt;/h3&gt;
&lt;p&gt;调度的本质是过滤，通过筛选所有节点组，选出符合条件的节点。&lt;/p&gt;
&lt;p&gt;Predicates阶段：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;findNodesThatFitPod&lt;/code&gt; 方法用来实现调度器的预选过程，其内部调用插件的 PreFilter 和 Filter 方法来筛选出符合 pod 要求的 node 节点集合。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;GeneralPredicates算法组，最基础的调度策略，由Admit操作执行
&lt;ul&gt;
&lt;li&gt;PodFitsResources：检查节点是否有Pod的requests字段所需的资源&lt;/li&gt;
&lt;li&gt;PodFitsHost：检查节点的宿主机名称是否和Pod的&lt;code&gt;spec.nodeName&lt;/code&gt;一致&lt;/li&gt;
&lt;li&gt;PodFitsHostPorts：检查Pod申请的宿主机端口&lt;code&gt;spec.nodePort&lt;/code&gt;是否已经被占用&lt;/li&gt;
&lt;li&gt;PodMatchNodeSelector：检查Pod的nodeSelector或nodeAffinity指定的节点是否与待考察节点匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Volume的检查
&lt;ul&gt;
&lt;li&gt;NodeDiskConflict：检查多个Pod声明的持久化Volume是否有冲突，比如一个AWS EBS不允许被多个Pod使用&lt;/li&gt;
&lt;li&gt;MaxPDVolumeCountPredicate：检查节点上某一类型的持久化Volume是否超过设定值，超过则不允许同类型Volume的Pod调度到上面去&lt;/li&gt;
&lt;li&gt;VolumeZonePredicate：检查持久化Volume的可用区(Zone)标签，是否与待考察节点的标签匹配&lt;/li&gt;
&lt;li&gt;VolumeBindingPredicate：检查Pod对应的PV的nodeAffinity是否与某个节点的标签匹配&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;与Node相关的规则
&lt;ul&gt;
&lt;li&gt;PodToleratesNodeTaints：检查Pod的Toleration字段是否与Node的Taint字段匹配&lt;/li&gt;
&lt;li&gt;NodeMeemoryPressurePredicate：检查当前节点的内存是否充足&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;与Pod相关的规则，与GeneralPredicates类似
&lt;ul&gt;
&lt;li&gt;PodAffinityPredicate：检查待调度的Pod与Node上已有的Pod的亲和(affinity)和反亲和(anti-affinity)的关系&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;筛选出可用Node之后，为这些Node进行打分&lt;/p&gt;
&lt;p&gt;Priorities阶段(打分规则)：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;prioritizeNodes&lt;/code&gt; 方法为调度器的优选阶段的实现. 其内部会遍历调用 framework 的 PreScore 插件集合里 &lt;code&gt;PeScore&lt;/code&gt; 方法, 然后再遍历调用 framework 的 Score 插件集合的 &lt;code&gt;Score&lt;/code&gt; 方法. 经过 Score 打分计算后可以拿到各个 node 的分值.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;LeastRequestedPriority：选出空闲资源（CPU和Memory）最多的宿主机。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;score = (cpu((capacity - sum(requested))10 / capacity) + memory((capacity-sum(requested))10 / capacity)) / 2&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;BalancedResourceAllocation：调度完成后，节点各种资源分配最均衡的节点，避免出现有些节点资源被大量分配，有些节点则很空闲。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;score = 10 - variance(cpuFraction, memoryFraction, volumeFraction) * 10，Fraction=Pod请求资源 / 节点上可用资源，variance=计算每两种Faction资源差最小的节点&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以修改调度器的配置，让调度器在Predicates或Priorities阶段选择不同的策略。&lt;/p&gt;
&lt;h3 id=&#34;常见的调度方式&#34;&gt;常见的调度方式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Deployment或RC：该调度策略主要功能就是自动部署一个容器应用的多份副本，以及持续监控副本的数量，在集群内始终维持用户指定的副本数量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NodeSelector：定向调度，当需要手动指定将Pod调度到特定Node上，可以通过Node的标签（Label）和Pod的nodeSelector属性相匹配。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NodeAffinity亲和性调度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;requiredDuringSchedulingIgnoredDuringExecution：硬规则，必须满足指定的规则，调度器才可以调度Pod至Node上（类似nodeSelector，语法不同）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;preferredDuringSchedulingIgnoredDuringExecution：软规则，优先调度至满足的Node的节点，但不强求，多个优先级规则还可以设置权重值。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Taints和Tolerations（污点和容忍）：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Taint：使Node拒绝特定Pod运行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Toleration：为Pod的属性，表示Pod能容忍（运行）标注了Taint的Node。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;优先级与抢占机制&#34;&gt;优先级与抢占机制&lt;/h3&gt;
&lt;p&gt;给Pod设置优先级，使得高优先级的Pod可用先调度，即使调度失败也比低优先级的Pod有优先调度的机会。&lt;/p&gt;
&lt;p&gt;需要先定义一个PriorityClass的API对象才能给Pod设置优先级。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;scheduling.k8s.io/v1beta1 &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;PriorityClass &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;high-priority &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1000000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;globalDefault&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;description&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;This priority class should be used for high priority service pods only.&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Pod内&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;priorityClassName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;high-priority&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;PriorityClass里的value值越高，优先级越大，优先级是一个32bit的整数，最大不超过 10亿，超过10亿的值是Kubernetes保留给系统Pod使用，保证系统Pod不会被用户Pod抢占；globalDefault为true表示该PriorityClass的值会成为系统默认值，为false表示只有使用了该PriorityClass的Pod才有优先级，没有声明则默认是0。&lt;/p&gt;
&lt;h4 id=&#34;抢占过程&#34;&gt;抢占过程&lt;/h4&gt;
&lt;p&gt;当一个高优先级的Pod调度失败时，调度器会试图从当前集群里寻找一个节点，当该节点上的一个或多个低优先级的Pod被删除后，待调度的高优先级的Pod可以被调度到该节点上，但是抢占过程不是立即发生，而只是在待调度的高优先级的Pod上先设置&lt;code&gt;spec.nominatedNodeName=Node名字&lt;/code&gt;，等到下一个调度周期再决定是否针对要运行在该节点上，之所以这么做是因为被删除的Pod有默认的30秒优雅退出时间，在这个过程中，可能有新的更加被适合给高优先级调度的节点加入。&lt;/p&gt;
&lt;h4 id=&#34;抢占原理&#34;&gt;抢占原理&lt;/h4&gt;
&lt;p&gt;抢占算法的实现基于两个队列，一个是activeQ队列，存放下一个调度周期里需要调度的Pod；另一个是unschedulableQ队列，存放调度失败的Pod，当一个unschedulableQ里的Pod被更新之后，调度器就会把该Pod移动到activeQ里；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当调度失败时，抢占算法开始工作，首先会检查调度失败的原因，判断是否可以为调度失败的Pod寻找一个新节点；&lt;/li&gt;
&lt;li&gt;之后调度器会把自己缓存的所有节点信息复制一份，通过这份副本模拟抢占过程，找出可以使用的节点和需要被删除的Pod列表，确定抢占是否可以发生；&lt;/li&gt;
&lt;li&gt;执行真正的抢占工作，检查要被删除的Pod列表，把这些Pod的nominatedNodeName字段清除，为高优先级的Pod的nominatedNodeName字段设置为节点名称，之后启动一个协程，移除需要删除的Pod。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第2步和第3步都执行了抢占算法Predicates，只有这两遍抢占算法都通过，才算抢占成功，之所以要两次，是因为需要满足InterPodAntiAffinity规则和下一次调度周期不一定会调度在该节点的情况。&lt;/p&gt;
&lt;h3 id=&#34;自定义调度&#34;&gt;自定义调度&lt;/h3&gt;
&lt;p&gt;K8s有默认的调度器，get Pod -o yaml时能看到， &lt;code&gt;pod.spec.schedulerName: default-scheduler&lt;/code&gt;，所以可以设置该值来选择具体某一个调度器来实现调度。&lt;/p&gt;
&lt;p&gt;有两种方式实现自定义调度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过K8s默认调度器Plugin机制实现，scheduling-framework在调度周期和绑定周期提供了很多丰富的扩展点，在这些扩展点上可以实现自定义调度逻辑。&lt;/p&gt;
&lt;p&gt;自定义插件有三个步骤：1、写一个go程序，实现调度器的插件接口；2、编写配置文件&lt;code&gt;KubeSchedulerConfiguration&lt;/code&gt;；3、将自定义插件编译进默认调度器；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;K8s也支持部署多个调度器，也可以基于scheduling-framework编写一个新的调度器，以pod的形式部署到集群，通过pod的&lt;code&gt;pod.spec.schedulerName&lt;/code&gt;指定调度器，自定义的调度器只能以主备的方式部署，Leader只能有一个，保证不会并发处理；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kubelet和cri&#34;&gt;Kubelet和CRI&lt;/h2&gt;
&lt;p&gt;Kubelet本质也是一个控制循环SyncLoop，在这个控制循环里又包含了很多小的控制循环，每个控制循环有自己的职责，比如Volume Manager、Image Manager、Node Status Manager、CPU Manager等，而驱动整个主的控制循环的事件有四种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Pod的更新事件&lt;/li&gt;
&lt;li&gt;Pod生命周期变化&lt;/li&gt;
&lt;li&gt;Kubelet本身设置的执行周期&lt;/li&gt;
&lt;li&gt;定期的清理事件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;每个节点上的Kubelet里的SyncLoop主控制循环通过Watch机制，监听nodeName是自己节点的Pod，在内存里缓存这些Pod的信息和状态，当接收到新事件时，执行相应的操作。在管理Pod内的容器时，不会直接调用docker的API，而是通过CRI的grpc接口来间接执行，这样无论底层容器可以简单的从docker换成其他容器程序。&lt;/p&gt;
&lt;p&gt;每台工作节点上的docker容器会使用dockershim提供CRI接口，来与kubelet交互，如果不是使用docker容器，则需要额外部署CRI shim来处理，通过这些shim转发kubelet的请求来操作容器。&lt;/p&gt;
&lt;p&gt;CRI是对容器操作相关的接口，而不是对于Pod，分为两组类型的API，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RuntimeService：处理容器相关操作，比如创建和启动容器，删除容器，执行命令&lt;/li&gt;
&lt;li&gt;ImageService：处理容器镜像的相关操作，比如拉取镜像、删除镜像&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/CRI_work_flow.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/CRI_work_flow.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;exec命令执行原理&#34;&gt;exec命令执行原理&lt;/h3&gt;
&lt;p&gt;对标docker的exec命令，docker的exec原理：一个进程可以选择加入某个进程已有的Namespace中，从而达到进入容器的目的。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/kubectl_exec_%e5%91%bd%e4%bb%a4%e5%8e%9f%e7%90%86.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/kubectl_exec_%e5%91%bd%e4%bb%a4%e5%8e%9f%e7%90%86.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里以docker作为容器引擎为例：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;kubectl执行exec命令后，首先发送Get请求到API-Server，获取pod的相关信息；&lt;/li&gt;
&lt;li&gt;获取到信息后，kubectl再发送Post请求，API-Server返回&lt;code&gt;101 upgrade&lt;/code&gt;响应给kubectl，表示切换到 SPDY 协议。SPDY协议允许在单个TCP连接上复用独立的 stdin / stdout / stderr / spdy-err 流。&lt;/li&gt;
&lt;li&gt;API-Server找到对应的Pod和容器，将Post请求转发到节点的Kubelet，再转发到向对应容器的Docker shim请求一个流式端点URL，并将exec请求转发到Docker exec API。Kubelet再将这个URL以 redirect 的方式返回给API-Server，请求就会重定向到对应的Streaming Server上发起exec请求，并维护长连接，之后就是在这个长连接的基础上执行命令和获取结果了。&lt;/li&gt;
&lt;li&gt;之后，用户端就可以和API-Server通信，比如执行容器里的命令，API-Server会转发命令到容器，或者转发容器内的执行结果给用户端。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除了exec命令意外，其他的如 attach、port-forward、logs 等命令也是类似的模式。&lt;/p&gt;
&lt;h3 id=&#34;节点notready原因&#34;&gt;节点NotReady原因&lt;/h3&gt;
&lt;p&gt;notReady一般是因为节点的Kubelet无法与API-Server通信，导致没办法把节点的信息及时同步给API-Server，此时节点就会被标记为NotReady，所以问题就变成了，为啥Kubelet无法与API-Server通信，原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Kubelet启动失败&lt;/li&gt;
&lt;li&gt;网络组件故障，导致无法通信&lt;/li&gt;
&lt;li&gt;集群网络分区&lt;/li&gt;
&lt;li&gt;节点OOM&lt;/li&gt;
&lt;li&gt;Kubelet与容器通信时响应超时，死锁，导致无法处理其他事情&lt;/li&gt;
&lt;li&gt;节点上Pod的数量太多，导致relist操作无法在3分钟内完成&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当节点出现NotReady时，节点上的容器依然可以提供服务，只是脱离了Kubenetes的调度，不会做任何改变，此时Kubernetes会将NotReady节点上的Pod调度到其他正常的节点上。&lt;/p&gt;
&lt;p&gt;时间段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Kubelet默认每&lt;strong&gt;10s&lt;/strong&gt;会上报一次节点的数据到API-Server，可以通过参数&lt;code&gt;--node-status-update-frequency&lt;/code&gt;配置上报频率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Controller-Manager会定时检查Kubelet的状态，默认是&lt;strong&gt;5s&lt;/strong&gt;，可以通过参数&lt;code&gt;--node-monitor-period&lt;/code&gt;配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kubelet在更新状态失败时，会进行重试，默认是&lt;strong&gt;5次&lt;/strong&gt;，可通过参数&lt;code&gt;nodeStatusUpdateRetry&lt;/code&gt;配置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当节点失联一段时间后，节点就会被判定为NotReady状态，默认时间是&lt;strong&gt;40s&lt;/strong&gt;，可通过参数&lt;code&gt;--node-monitor-grace-period&lt;/code&gt;配置；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NotReady一段时间后，节点的状态转为UnHealthy状态，默认时间是&lt;strong&gt;1m&lt;/strong&gt;，可通过参数&lt;code&gt;--node-startup-grace-period&lt;/code&gt;配置；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当节点UnHealthy状态一段时间后，节点上的Pod将被转移，默认是&lt;strong&gt;5m&lt;/strong&gt;，可通过参数&lt;code&gt;--pod-eviction-timeout&lt;/code&gt;配置。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于Controller-Manager和Kubelet是异步工作，可能存在信息获取的延迟，所以Pod整体被迁移的时间也会有延迟。&lt;/p&gt;
&lt;p&gt;Kubernetes 1.13版本后，节点处于不同的状态时将被打上不同的污点，节点上的Pod就可以基于污点在不同的状态被驱逐了，这个时候Pod被迁移的时间就不定了。&lt;/p&gt;
&lt;h2 id=&#34;etcd&#34;&gt;etcd&lt;/h2&gt;
&lt;p&gt;etcd作为Kubernetes的元数据存储，API-Server是唯一直接跟etcd交互的组件，API-Server对外提供的监听机制底层实现就是etcd的watch。&lt;/p&gt;
&lt;h3 id=&#34;资源存储格式&#34;&gt;资源存储格式&lt;/h3&gt;
&lt;p&gt;资源以 &lt;code&gt;prefix + / + 资源类型 + / + namespace + / + 具体资源名称&lt;/code&gt; 组成，作为key。基于etcd提供的范围查询能力，支持按具体资源名称查询、namespace查询。默认的prefix是 /registry。&lt;/p&gt;
&lt;p&gt;对于基于label查询，是由API-Server通过范围查询遍历etcd获取原始数据，然后再通过label过滤。&lt;/p&gt;
&lt;h3 id=&#34;资源创建流程&#34;&gt;资源创建流程&lt;/h3&gt;
&lt;p&gt;创建资源时，会经过 BeforeCreate 策略做etcd的初始化工作，Storgae.Create接口调用etcd进行存储，最后在经过AfterCreate和Decorator。&lt;/p&gt;
&lt;p&gt;由于put并不是并发安全的接口，并发时可能导致key覆盖，所以API-Server会调用Txn接口将数据写入etcd。&lt;/p&gt;
&lt;p&gt;当资源信息写入etcd后，API-Server就会返回给客户端了。资源的真正创建是基于etcd的Watch机制。&lt;/p&gt;
&lt;p&gt;controller-manager内配备多种资源控制器，当触发etcd的Watch机制时会通知api-server，api-server在调用对应的控制器进行资源的创建。比如，当我们创建一个deployment资源写入etcd，通过Watch机制，通知给api-server，api-server调用controller-manager里的deployment-controller创建ReplicaSet资源对象，写入etcd，再次触发Watch机制，经过api-server调用ReplicaSet-controller，创建一个待调度的Pod资源，写入etcd，触发Watch机制，经过api-server，scheduler监听到待调度的Pod，就会为其分配节点，通过api-server的Bind接口，将调度后的节点IP绑定到Pod资源上。kubelet通过同样的Watch机制感知到新建的Pod，发起Pod创建流程。&lt;/p&gt;
&lt;p&gt;Kubernetes中使用Resource Version实现增量监听逻辑，避免客户端因为网络等异常出现中断后，数据无法同步的问题；同时，客户端可通过它来判断资源是否发生变化。&lt;/p&gt;
&lt;p&gt;在Get请求中ResourceVersion有三种取值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;未指定，默认为空串：API-Server收到后会向etcd发起共识读/线性读，获取集群最新数据，所以在集群规模较大时，未指定查的性能会比较差。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;=字符串0：API-Server收到后会返回任意资源版本号的数据，优先返回最新版本；一般情况下先从API-Server缓存中获取数据返回给客户端，有可能读到过期数据，适用于一致性要求不高的场景。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;=非0字符串：API-Server收到后，会保证Cache中的最新ResouorceVersion大于等于请求中的ResourceVersion，然后从Cache中查询返回。&lt;/p&gt;
&lt;p&gt;Cache的原理是基于etcd的Watch机制来更新，=非0字符串且Cache中的ResourceVersion没有大于请求中的ResourceVersion时，会进行最多3秒的等待。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;若使用的Get接口，那么API-Server会取资源key的ModRevision字段填充Kubernetes资源的ResourceVersion字段（ v1. meta/ ObjectMeta.ResourceVersion）。若你使用的是List接口，API-Server会在查询时，使用etcd当前版本号填充ListMeta.ResourceVersion字段（ v1. meta/ ListMeta.ResourceVersion）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Watch请求中ResourceVersion的三种取值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;未指定，默认为空串：一是为了帮助客户端建立初始状态，将当前已存在的资源通过Add事件返回给客户端；二是会从当前版本号开始监听，后续新增写请求导致数据变化时会及时推给客户端。&lt;/li&gt;
&lt;li&gt;=字符串0：帮助客户端建立初始状态，但它会从任意版本号开始监听，接下来的行为和 未指定 时一致。&lt;/li&gt;
&lt;li&gt;=非0字符串：从精确的版本号开始监听，只会返回大于等于精确版本号的变更事件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;pod&#34;&gt;Pod&lt;/h2&gt;
&lt;p&gt;Pod是最小的API对象。Pod中的容器会作为一个整体被Master打包调度到一个节点上运行。&lt;/p&gt;
&lt;p&gt;由于不同容器间需要共同协作，如war包和tomcat，就需要把它们包装成一个pod，概念类似于进程与进程组，pod并不是真实存在的，只是逻辑划分。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同一个pod里的所有容器，共享同一个Network Namespace，也可以共享同一个Volume&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;这种把多个容器组合打包在一起管理的模式也称为容器设计模式。&lt;/p&gt;
&lt;p&gt;另外还有静态Pod：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;静态pod是由kubelet进行管理的仅存在于特定Node的Pod上，他们不能通过API-Server进行管理，无法与ReplicationController、Deployment或者DaemonSet进行关联，并且kubelet无法对他们进行健康检查。静态Pod总是由kubelet进行创建，并且总是在kubelet所在的Node上运行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;原理-2&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;由于不同容器间可能存在依赖关系（如启动顺序的依赖），因此k8s会起一个中间容器Infra容器，来关联其他容器，infra容器一定是最先起的，其他容器通过Join Network Namespace的方式与Infa容器进行关联。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一个 Pod 只有一个 IP 地址，由Pod内容器共享，Pod 的生命周期只跟 Infra 容器一致，Infra管理共享资源&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;kubelet会为每个节点上创建一个基本的cbr0网桥，并为每一个Pod创建veth虚拟网络设备，绑定一个IP地址，同一个Pod中的所有容器会通过这个网络设备共享网络，从而能通过localhost相互访问彼此暴露的端口和服务。&lt;/p&gt;
&lt;p&gt;对于initContainer命令的作用是按配置顺序最先执行，执行完之后才会执行container命令，例如，对war包所在容器使用initContainer命令，将war包复制到挂载的卷下后，再执行tomcat的container命令启动tomcat以此来启动web应用，这种先启动一个辅助容器来完成一些独立于主进程（主容器）之外的工作，称为sidecar，边车。&lt;/p&gt;
&lt;p&gt;Pod可以理解为一个机器，容器是里面的进程，凡是调度、网络、储存、安全相关、跟namespace相关的属性，都是Pod级别的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PID Namespace：默认不共享，但是可以调参&lt;code&gt;shareProcessNamespace=true&lt;/code&gt;打开，默认情况下，容器内的PID一致，但是PID名词空间不一致；&lt;/li&gt;
&lt;li&gt;Network Namespace：Pod中的多个容器共享同一个IP和端口范围；&lt;/li&gt;
&lt;li&gt;IPC Namespace：Pod中的多个容器能够使用共享内存，信号量，消息队列等IPC机制进行通信；&lt;/li&gt;
&lt;li&gt;UTS Namespace：Pod中的多个容器共享一个主机名和域名；&lt;/li&gt;
&lt;li&gt;Mount Namespace：Pod中的各个容器可以访问在Pod级别定义的Volumes；&lt;/li&gt;
&lt;li&gt;User Namespace：算是比较特殊的，高版本才有，把宿主机的一个普通用户映射到容器中的root用户，这样容器进程以为自己是root并且在它所在的名称空间内有各种权限，以此控制容器的用户权限&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;关于pause容器--infra容器&#34;&gt;关于Pause容器 / Infra容器&lt;/h3&gt;
&lt;p&gt;pause容器，也叫Infra容器，每个Pod都会自动创建的容器，但不属于用户自定义容器。因为Pod的作用，就是管理Pod内多个容器之间最高效的共享某些资源和数据，而Pod内的容器是被namespace和cgroups隔开的。Infra容器在Pod中担任Linux Namespace共享的基础，启用Pid namespace，开启init进程。Infra容器可使得Pod内的容器共享pid namespace、network namespace、ipc namespace(用于共享systemV IPC或POSIX消息队列进行通信)、uts namespace(共享主机名)、共享Pod级别的Volumes。&lt;/p&gt;
&lt;p&gt;以network namespace为例，如果里面只有用户自己的容器，没有Infra容器这个第三方容器，只要network的owner容器退出了，Pod内的其他容器的网络就都异常了，这显然不合理。所以在同一个Pod内的其他容器通过 join namespace的方式加入到Infra container的netword namespace中，这样，Pod内的所有容器共享同一份网络资源，Pod的IP地址 = Pod第一次创建的Infra container的IP地址。&lt;/p&gt;
&lt;p&gt;Infra container是一个只有700KB左右的镜像，永远处于pause状态。整个Pod的生命周期等于Infra container的生命周期，与内部的其他容器无关，且Infra conatiner一定是第一个启动的，这也是Kubernetes里运行更新Pod里的某一个镜像，而整个Pod不会被重建和重启的原因。即使把Pod里的所有用户容器都kill掉，Pod也不会退出。&lt;/p&gt;
&lt;h3 id=&#34;pod在k8s中的生命周期&#34;&gt;Pod在K8s中的生命周期&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Pending：Pod的yaml文件已经提交给k8s了，API对象已经被创建保存在etcd中，但是这个Pod里有容器因为某些原因导致不能被顺利创建。&lt;/li&gt;
&lt;li&gt;Running：Pod已经调度成功，跟一个具体的节点绑定，内部容器创建成功，并且至少有一个正在运行。&lt;/li&gt;
&lt;li&gt;Succeeded：Pod里所有容器都正常运行完毕，并且已经退出，在运行一次性任务时比较常见。&lt;/li&gt;
&lt;li&gt;Failed：Pod里至少有一个容器以不正常的状态退出，需要查看Events和日志查看原因。&lt;/li&gt;
&lt;li&gt;Unknown：异常状态，Pod的状态不能持续通过kubelet汇报给API-Server，可能是主从节点间通信出现问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外，Pod的status字段还能细分一组Conditions，主要是描述造成当前status的具体原因，比如PodScheduled、Ready、Initialized以及Unschedulable。&lt;/p&gt;
&lt;p&gt;在Pod的containers定义中，有个lifecycle字段，用于定义容器的状态发生变化时产生的hook。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Pod被删除时的流程&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Pod 被删除，状态变为 &lt;code&gt;Terminating&lt;/code&gt;。通过API-Server修改Pod的信息，设置DeletionTimestamp和DeletionGracePeriodSeconds信息，给Pod标记上删除时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;endpoint-controller接收到Pod删除的通知，向API-Server发送请求，修改service的endpoints对象，删除该Pod的endpoint。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;kube-proxy也会接收到Pod删除的通知，开始更新转发规则，修改本机的iptables / ipvs规则，将 Pod 从 service 的 endpoint 列表中摘除掉，新的流量不再转发到该 Pod。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;kubelet watch 到了就开始销毁 Pod。&lt;/p&gt;
&lt;p&gt;3.1. 如果 Pod 中有 container 配置了 [preStop Hook] 将会执行（这里的作用，比如说kube-proxy处理得太慢，会导致Pod被删除了，但是iptables的规则还在，所以可以通过在这里配置处理）&lt;/p&gt;
&lt;p&gt;3.2. 发送 &lt;code&gt;SIGTERM&lt;/code&gt; 信号给容器内主进程以通知容器进程&lt;strong&gt;开始优雅停止&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;3.3. 等待 container 中的主进程完全停止，如果在 &lt;code&gt;terminationGracePeriodSeconds&lt;/code&gt; 内 (默认 30s) 还未完全停止，就发送 &lt;code&gt;SIGKILL&lt;/code&gt; 信号将其强制杀死。&lt;/p&gt;
&lt;p&gt;3.4. 所有容器进程终止，清理 Pod 资源。&lt;/p&gt;
&lt;p&gt;3.5. 通知 API-Server Pod 销毁完成，删除etcd中Pod的信息，完成 Pod 删除。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;side-car&#34;&gt;Side Car&lt;/h3&gt;
&lt;p&gt;在声明容器时，使用initContainers声明，用法同containers，initContainers作为辅助容器，必定比containers先启动，如果声明了多个initContainers，则会按顺序先启动，当所有initContainers都运行成功后，才会开始初始化Pod的各自信，并创建和启动containers。&lt;/p&gt;
&lt;p&gt;因为Pod内所有容器共享同一个Network Namespace的特性，initContainers辅助容器常用于与Pod网络相关的配置和管理，比如常见的实现是Istio。&lt;/p&gt;
&lt;h3 id=&#34;pod中的projected-volume投射数据卷&#34;&gt;Pod中的Projected Volume(投射数据卷)&lt;/h3&gt;
&lt;p&gt;k8s将预先定义好的数据投射进容器，支持的种类：secret、ConfigMap、Downward API，这三种PV一般存放不经常更新的数据，ServiceAccountToken则是在访问Kubernetes API Server时会使用到。&lt;/p&gt;
&lt;h4 id=&#34;secret&#34;&gt;Secret&lt;/h4&gt;
&lt;p&gt;将Pod想要访问的加密数据，存放到etcd中，通过在Pod中的容器里挂载Volume的方式访问这些数据。如果etcd里的这些数据发生了改变，挂载到容器里的数据会在一定的延时后进行更新。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;test-projected-volume &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;test-secret-volume&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;busybox&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;sleep&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;86400&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeMounts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;mysql-cred&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/projected-volume&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;mysql-cred&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;projected&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;sources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;secret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;secret&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;pass&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;这里是挂载了一个类型为projected的volume，存放数据的sources是一个secret对象(有属性name)，name的值表示数据存放的名字，比如通过这个名字取得对于的值（值可以是对应的存放数据的文件路径），&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;如：kubectl create secret generic user --from-file=./username.txt
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;也可直接在yaml文件中定义 secret对象，如下，通过data字段定义，kind是secret，值需要经过base64编码&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Secret&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;mysecret&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Opaque&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;YWRtaW4=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;pass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;MWYyZDFlMmU2N2Rm&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;通过这种方式进行定义并运行后，会先将信息保存到ectd中，然后在以文件的形式挂载在容器的Volume目录里，文件名是${name}或者${data.key}。&lt;/p&gt;
&lt;h4 id=&#34;configmap&#34;&gt;configMap&lt;/h4&gt;
&lt;p&gt;configMap的作用、用法同secret，只是其内容不需要经过加密&lt;/p&gt;
&lt;h4 id=&#34;downward-api&#34;&gt;downward API&lt;/h4&gt;
&lt;p&gt;让Pod里的容器能够直接获取到这个Pod API对象本身的信息，只能获取Pod启动之前就能确定的信息，Pod运行之后的信息只能通过sidecar容器获取。&lt;/p&gt;
&lt;p&gt;比如下面这份配置，volume的类型是projected，数据来源是downwardAPI，声明要暴露的信息是当前yaml文件定义的metadata.labels信息，K8S会自动挂载为容器里的/podInfo/labels文件。&lt;/p&gt;
&lt;p&gt;Downward API支持的字段是固定的，使用fieldRef字段可以查看宿主机名称、IP、Pod的标签等信息；resourceFieldRef字段可以查看容器CPU、内存等信息。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;test-downwardapi-volume&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;zone&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;us-est-coast&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cluster&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;test-cluster1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rack-22&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;client-container&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeMounts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;podinfo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/podInfo&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;podinfo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;projected&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;sources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;downwardAPI&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;items&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;labels&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;                &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fieldRef&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;                  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;fieldPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;metadata.labels&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;serviceaccounttoken&#34;&gt;serviceAccountToken&lt;/h4&gt;
&lt;p&gt;serviceAccountToken是一种特殊的Secret，一般用于访问Kubernetes API Server时提供token作为验证的凭证。Kubernets提供了一个默认的default Service Account，任何运行在Kubernets中的Pod都可以使用，无需显式声明挂载了它。&lt;/p&gt;
&lt;p&gt;默认挂载路径：&lt;code&gt;/var/run/secrets/kubernetes.io/serviceaccount&lt;/code&gt;，里面包含了&lt;code&gt;ca.crt，namespace，token&lt;/code&gt;三个文件，用于授权当前Pod访问API Server。&lt;/p&gt;
&lt;p&gt;如果要让Pod拥有不同访问API Server的权限，就需要不同的service account，也就需要不同的token了。&lt;/p&gt;
&lt;h4 id=&#34;挂载宿主机上的目录&#34;&gt;挂载宿主机上的目录&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;two-containers&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;restartPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Never&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx-container&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeMounts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;shared-data&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/usr/share/nginx/html&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;debian-container&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;debian&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeMounts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;shared-data&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/pod-data&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/bin/sh&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;-c&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;echo Hello from the debian container &amp;gt; /pod-data/ index.html&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;shared-data&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hostPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/data&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;声明了两个容器，都挂载了shared-data这个Volume，且该Volume是hostPath，对应宿主机上的/data目录，所以么，nginx-container 可 以 从 它 的&lt;code&gt;/usr/share/ nginx/html&lt;/code&gt; 目 录 中， 读取到debian-container生 成 的 index.html文件。&lt;/p&gt;
&lt;h3 id=&#34;pod的资源分配-qos&#34;&gt;Pod的资源分配 QoS&lt;/h3&gt;
&lt;p&gt;Pod的资源分配由定义的Container决定，比如&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;requests&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;memory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;64Mi&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 单位是bytes，注意1Mi=1024*1024，1M=1000*1000&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cpu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;250m&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 单位是个数，250m表示250millicpu，使用0.25个CPU的算力，也可以直接写成0.25，默认是1，且是cpu share的&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;limits&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;memory&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;128Mi&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cpu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;500m&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;CPU属于可压缩资源，当CPU不足时，Pod只会&amp;quot;饥饿&amp;quot;，不会退出；&lt;/p&gt;
&lt;p&gt;内存数与不可压缩资源，当内存不足时，Pod会因为OOM而被kill掉；&lt;/p&gt;
&lt;p&gt;Matser的kube-scheduler会根据requests的值进行计算，根据limits设置cgroup的限制，即request用于调度，limit用于限制，不同的requests和limits设置方式，会将Pod划分为不同的QoS类型，用于对Pod进行资源回收和调度。QoS按优先级从高到低：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Guaranteed：只设置了limits或者limits和requests的值一致；&lt;/p&gt;
&lt;p&gt;在保证是Guaranteed类型的情况下，requests和limits的CPU和内存设置相等，此时是cpuset设置，容器会绑到某个CPU核上，不会与其他容器共享CPU算力，减少CPU上下文切换的次数，提升性能。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;绑核只会在设置的值是整数时才会生效。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Burstable：不满足Guaranteed级别，但至少有一个Container设置了requests；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Best-Effort：requests和limits都没有设置，当节点资源充足时可以充分使用，但是当节点被Guaranteed或Burstable Pod抢占时，资源就会被压缩；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当设置&lt;code&gt;limits&lt;/code&gt;而没有设置&lt;code&gt;requests&lt;/code&gt;时，Kubernetes 默认令&lt;code&gt;requests&lt;/code&gt;等于&lt;code&gt;limits&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;K8s会将节点上的CPU资源分成两类：共享池和独享池，如果在Guaranteed上设置了绑核，就会占用独享池，否则是使用共享池，所以，如果一个节点上有比较多的Pod设置绑核，会导致非绑核的Pod都使用共享池，使得竞争严重，使用共享池的Pod性能下降。&lt;/p&gt;
&lt;p&gt;节点上除了运行用户容器，还运行了其他系统进程，比如kubelet、ssh等，为了保证这些外部的进程有足够的资源运行，Kubernetes引入 Eviction Policy特性，设置了默认的资源回收阈值，当Kubernetes所管理的不可压缩资源短缺时，就会触发Eviction机制，不可压缩节点资源有：内存、磁盘、容器运行镜像的存储空间等。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每个运行状态容器都有其 OOM 得分，得分越高越会被优先杀死；其中Guaranteed级别的Pod得分最低，BestEffort级别的Pod得分最高，所以优先级Guaranteed&amp;gt; Burstable&amp;gt; Best-Effort，优先级低的Pod会在资源不足时优先被杀死；同等级别优先级的 Pod 资源在 OOM 时，与自身的 requests 属性相比，其内存占用比例最大的 Pod 对象将被首先杀死。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;kubelet默认的资源回收阈值&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;memory.available &amp;lt; 100Mi&lt;/code&gt;；&lt;code&gt;nodefs.available &amp;lt; 10%&lt;/code&gt;；&lt;code&gt;nodefs.inodesFree &amp;lt; 5%&lt;/code&gt;；&lt;code&gt;imagefs.available &amp;lt; 15%；&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;达到阈值后，会对node设置状态，避免新的Pod被调度到这个node上。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当发生资源（Eviction）回收时的策略：&lt;/p&gt;
&lt;p&gt;首当其冲的，自然是BestEffort类别的Pod。&lt;/p&gt;
&lt;p&gt;其次，是属于Burstable类别、并且发生“饥饿”的资源使用量已经超出了requests的Pod。&lt;/p&gt;
&lt;p&gt;最后，才是Guaranteed类别。并且，Kubernetes会保证只有当Guaranteed类别的Pod的资源使用量超过了其limits的限制，或者宿主机本身正处于Memory Pressure状态时，Guaranteed的Pod才可能被选中进行Eviction操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;pod中的健康检查&#34;&gt;Pod中的健康检查&lt;/h3&gt;
&lt;p&gt;对于Web应用，最简单的就是由Web应用提供健康检查的接口，我们在定义的API对象的时候设置定时请求来检查运行在容器中的web应用是否健康，主要是为了防止服务未启动完成就被打入流量或者长时间未响应依然没有重启等问题。&lt;/p&gt;
&lt;p&gt;livenessProbe：保活探针，当不满足检查规则时，直接重启Pod；&lt;/p&gt;
&lt;p&gt;readnessProbe：只读探针，当不满足检查规则时，不放流量进Pod；&lt;/p&gt;
&lt;p&gt;startupProbe：启动检查探针，应用一些启动缓慢的业务，避免业务长时间启动而被上面两类探针kill掉；&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;livenessProbe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;     &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;httpGet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 除此之外还有Exec命令、TCPSocket两种不同的probe方式&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/healthz&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;httpHeaders&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;X-Custom-Header&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;         &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Awesome&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;initialDelaySeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 容器启动后多久开始探测&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;periodSeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 探测周期&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;pod的恢复机制&#34;&gt;Pod的恢复机制&lt;/h3&gt;
&lt;p&gt;API对象中&lt;code&gt;spec.restartPolicy&lt;/code&gt;字段用来描述Pod的恢复策略，默认是always，即容器不在运行状态则重启，OnFailure是只有容器异常时才自动重启，Never是从来不重启容器&lt;/p&gt;
&lt;p&gt;Pod的恢复过程，永远发生在当前节点，即跟着API对象定义的&lt;code&gt;spec.node&lt;/code&gt;的对应的节点，如果要发生在其他节点，则需要deployment的帮助。&lt;/p&gt;
&lt;p&gt;当Pod的restartPolicy是always时，Pod就会保持Running状态，无论里面挂掉多少个，因为Pod总会重启这些容器；当restartPolicy是never时，Pod里的所有容器都挂了，才会变成Failed，只有一个容器挂了也是Running。&lt;/p&gt;
&lt;p&gt;不能简单的依赖Pod的status字段，而是要通过livenessProbe或者readnessProbe来的健康检查来判断是否需要恢复。&lt;/p&gt;
&lt;h3 id=&#34;podpreset&#34;&gt;PodPreset&lt;/h3&gt;
&lt;p&gt;预置类型的Pod，是Pod配置文件上追加字段的预置模板，PodPreset里定义的内容，只会在Pod对象被创建之前追加在这个对象本身，不会影响任何Pod控制器的定义。&lt;/p&gt;
&lt;p&gt;一个Pod可以对应多个PodPreset，多个PodPreset间会进行合并，如果有冲突字段，则后面执行的PodPreset不会修改前面的字段。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;settings.k8s.io/v1alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;PodPreset&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;allow-database&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchLabels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;role&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;frontend &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;env&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DB_PORT &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;6379&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeMounts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/cache &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;cache-volume &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;cache-volume &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;emptyDir&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;{}&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在先创建完这个API对象后，在创建对应Pod，这个PodPreset会根据selector，选择lables中有role: frontend的Pod，为其添加env、volumeMounts、volumes等声明。&lt;/p&gt;
&lt;h3 id=&#34;pod的通信&#34;&gt;Pod的通信&lt;/h3&gt;
&lt;p&gt;Kubernetes上的CNI网桥相当于docker0网桥，容器(Pod)与宿主机通信，仍然使用VethPair设备，CNI网桥会接管所有CNI插件负责的容器(Pod)，主要是与Pod中的Infra容器的Network Namespace交互。&lt;/p&gt;
&lt;p&gt;CNI网络方案主要由两部分工作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1：实现网络方案，比如创建和配置所需要的虚拟设备、配置路由表、ARP和FDB表；&lt;/li&gt;
&lt;li&gt;2：实现对应的CNI插件，比如通过该插件可以配置Infra容器里的网络栈，并把它连接在CNI网桥上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本质上Kubernetes的网络跟docker是类似的，在集群中，所有的容器都可以直接使用IP地址与其他容器通信，而无需IP映射；宿主机也可直接使用IP与所有容器通信，而无需IP映射；每个容器都拥有自己的IP地址，且在其他容器，宿主机看到的是一样的。&lt;/p&gt;
&lt;h4 id=&#34;pod内的容器间通信&#34;&gt;Pod内的容器间通信&lt;/h4&gt;
&lt;p&gt;Pod内部容器是共享一个网络命名空间的。&lt;/p&gt;
&lt;p&gt;在Pod内部有一个默认的叫Pause的容器，作为独立共享的网络命名空间，其他容器启动时使用 -net=container就可用让当前容器加入的Pause容器，以此拥有同一个网络命名空间，所以Pod中的容器可以通过localhost来互相通信。&lt;/p&gt;
&lt;p&gt;对容器来说，hostname就是Pod的名称。因为Pod中的所有容器共享同一个IP地址和端口空间，所以需要为每个需要接收连接的容器分配不同的端口，也就是说，Pod内的容器应用需要自己协调端口的使用。&lt;/p&gt;
&lt;p&gt;另外，也可以使用PV和PVC来实现通信。&lt;/p&gt;
&lt;h4 id=&#34;同一节点下pod间的通信&#34;&gt;同一节点下Pod间的通信&lt;/h4&gt;
&lt;p&gt;通过节点上的网桥和Pod上的 Veth Pair 实现，整体跟同一节点上容器间的通信 很像，只不过 Veth Pair 是挂在Pod的共享网络空间上的。Veth Pair将节点上的网桥和Pod上的共享网络空间进行连接，再通过网桥，连接不同的Pod的共享网络空间，实现不同Pod间网络通信。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%90%8c%e4%b8%80%e8%8a%82%e7%82%b9%e4%b8%8bPod%e9%97%b4%e9%80%9a%e4%bf%a1.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%90%8c%e4%b8%80%e8%8a%82%e7%82%b9%e4%b8%8bPod%e9%97%b4%e9%80%9a%e4%bf%a1.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;不同节点下pod间的通信&#34;&gt;不同节点下Pod间的通信&lt;/h4&gt;
&lt;p&gt;不同的节点下Pod间的通信，通过一套接口规范（CNI, Container Network Interface）来实现，常见的有CNI插件实现有Flannel、Calico以及AWS VPC CNI。&lt;/p&gt;
&lt;p&gt;其中，flannel有VXLAN、host-gw、UDP三种实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;flannel UDP模式下的跨主机通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;下图container-1发送请求给container-2流程:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;container-1发送数据包，源：100.96.1.2，目标：100.96.2.3，经过docker0，发现目标IP不存在，此时会把该数据包交由宿主机处理。&lt;/li&gt;
&lt;li&gt;通过宿主机上的路由表，发现flannel0设备可以处理该数据包，宿主机将该数据包发送给flannel0设备。&lt;/li&gt;
&lt;li&gt;flannel0设备（TUM）由flanneld进程管理，数据包的处理从内核态(Linux操作系统)转向用户态(flanneld进程)，flanneld进程知道目标IP在哪个节点，就把该数据包发往node2。&lt;/li&gt;
&lt;li&gt;node2对该数据包的处理，则跟node1相反，最后container2收到数据包。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/flannel_udp%e8%b7%a8%e4%b8%bb%e6%9c%ba%e9%80%9a%e4%bf%a1.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/flannel_udp%e8%b7%a8%e4%b8%bb%e6%9c%ba%e9%80%9a%e4%bf%a1.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;flanneld通过为各个宿主机建立子网，知道了各个宿主机能处理的IP范围，子网与宿主机的对应关系，都会保存在etcd中，flanneld将原数据包再次封装成一个UDP包，同时带上目标节点的真实IP，发往对应节点。&lt;/p&gt;
&lt;p&gt;再由fannel管理的容器网络里，一个节点上的所有容器，都属于该宿主机被分配的一个子网。flannel会在宿主机上注册一个flannel0设备，保存各个节点的容器子网信息，flanneld进程会处理由flannel0传入的IP包，匹配到对应的子网，从etcd中找到该子网对应的宿主机的IP，封装成一个UDP包，交由flannel0，接着就跟节点间的网络通信一样，发送给目标节点了。因为多了一步flanneld的处理，涉及到了多次用户态与内核态间的数据拷贝，导致性能问题，优化的原则是减少切换次数，所以有了VXLAN模式、host-gw模式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;UDP模式下，在发送IP包的过程，经过三次用户态与内核态的数据拷贝&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户态的容器进程发出IP包经过docker0网桥进入内核态&lt;/li&gt;
&lt;li&gt;IP包根据路由表进入flannel0设备，从而回到用户态的flanneld进程&lt;/li&gt;
&lt;li&gt;flanneld进行UDP封包后重新进入内核态，将UDP包通过宿主机的eth0发送出去&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;flannel VXLAN模式下的跨主机通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过VXLAN模式（Virtual Extensible LAN）解决UDP模式下上下文切换频繁带来的性能问题。&lt;/p&gt;
&lt;p&gt;原理是通过在二层网络上再设置一个VTEP设备，该设备是Linux内核中一个模块，可以在内核态完成数据的封装和解封。flannel.1设备（VTEP）既有IP地址又有MAC地址，在数据包发往flannel.1设备时，通过二层数据帧，将原数据包加上目标节点的MVC地址，再加上VTEP标识，封装成一个二层数据帧，然后再封装成宿主机网络里的普通UDP数据包，发送给目标节点，目标节点在内核网络栈中发现了VTEP标识，就知道可以在内核态处理了。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/flannel_vxlan%e8%b7%a8%e4%b8%bb%e6%9c%ba%e9%80%9a%e4%bf%a1.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/flannel_vxlan%e8%b7%a8%e4%b8%bb%e6%9c%ba%e9%80%9a%e4%bf%a1.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;数据包的发送都要经过OSI那几层模型的，经过的每一层都需要进行包装和解封，才能得到原始数据，在这期间二层网络(数据链路层)是在内核态处理，三层网络(网络层)是在用户态处理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;flannel host-gw模式（三层网络方案）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;二层指的是在知道下一跳的IP对应的MAC地址后，直接在数据链路层通信，如果不知道，就需要在网络层设置路由表，通过路由通信，此时就是三层网络。&lt;/p&gt;
&lt;p&gt;将每个Flannel子网的下一跳设置成该子网对应的宿主机的IP地址，用这台宿主机充当网关，Flannel子网和主机信息都保存在ETCD中，由flanneld进程WATCH这些数据的变化，实时更新路由表，这种方案的性能最好。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/flannel_host_gw%e8%b7%a8%e4%b8%bb%e6%9c%ba%e9%80%9a%e4%bf%a1.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/flannel_host_gw%e8%b7%a8%e4%b8%bb%e6%9c%ba%e9%80%9a%e4%bf%a1.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;calico的跨主机通信&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;类似flannel host-gw模式，calico会在宿主机上创建一个路由表，维护集群内各个物理机、容器的路由规则，通过这张路由表实现跨主机通信。通过边界网关协议BGP，在集群的各个节点中实现路由信息共享。&lt;/p&gt;
&lt;p&gt;因此calico不需要在宿主机上创建任何网桥设备，通过Veth Pair设备 + 路由表的方式，即可完成节点IP寻找和转发。&lt;/p&gt;
&lt;p&gt;但这种方案会遇到路由表的规模问题，且最优情况是集群节点在同一个子网。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/calico%e8%b7%a8%e4%b8%bb%e6%9c%ba%e9%80%9a%e4%bf%a1.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/calico%e8%b7%a8%e4%b8%bb%e6%9c%ba%e9%80%9a%e4%bf%a1.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;pod中的网络隔离&#34;&gt;Pod中的网络隔离&lt;/h3&gt;
&lt;p&gt;通过NetworkPolicy对象来实现，控制Pod的入站和出站请求，实现了NetworkPolicy的网络插件包括Calico、Weave，不包括Flannel。通过NetworkPolicy Controller监控NetworkPolicy，修改宿主机上的iptable。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.k8s.io/v1 &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;NetworkPolicy &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;test-network-policy &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;default &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;podSelector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchLabels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;role: db # 标签为role&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;db的Pod拥有该NetworkPolicy，如果为空，则该namespace下所有Pod都无法通信&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;policyTypes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;Ingress &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;Egress &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ingress&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# from数组内元素是or关系，元素内可以包含其他Selector，他们是and关系&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;ipBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cidr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;172.17.0.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/16&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 只允许这个网段的节点访问，且不允许172.17.1.0/24网段的节点访问&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;except&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;- &lt;span class=&#34;m&#34;&gt;172.17.1.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/24&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;namespaceSelector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchLabels: # 只允许标签为 project&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;myproject 的Pod访问&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;project&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;myproject &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;podSelector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchLabels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;role&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;frontend &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 只允许访问这些pod的6379端口&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;TCP &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;6379&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;egress&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;to&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;ipBlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cidr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;10.0.0.0&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/24&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 只允许这些Pod对外访问这个网段的节点，且端口是5978&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;TCP &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;5978&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;pvpvcstoageclass&#34;&gt;PV、PVC、StoageClass&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;PVC（Persistent Volume Claim）：定义持久化卷的声明，作用类似于接口，开发人员直接使用而不用知道其具体实现，比如定义了数据库的用户名和密码之类的属性。&lt;/p&gt;
&lt;p&gt;PVC的命名方式：&lt;code&gt;&amp;lt;PVC名字&amp;gt;-&amp;lt;StatefulSet名字&amp;gt;-&amp;lt;编号&amp;gt;&lt;/code&gt;，StatefulSet创建出来的所有Pod都会使用此PVC，Kubernetes通过Dynamic Provisioning的方式为该PVC匹配对应的PV。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PV（Persistent Volume）：持久化卷的具体实现，即定义了持久化数据的相关属性，如数据库类型、用户名密码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;StorageClass：创建PV的模板，只有同属于一个StorageClass的PV和PVC，才可以绑定在一起，K8s内默认有一个名字为空串的DefaultStorageClass。&lt;/p&gt;
&lt;p&gt;StorageClass用于&lt;strong&gt;自动&lt;/strong&gt;创建PV，StorageClass的定义比PV更加通用，一个StorageClass可以对应多个PV，这样就无需手动创建多个PV了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;集群中的每一个卷在被Pod使用时都会经历四个操作：附着Attach、挂载Mount、卸载Unmount和分离Detach；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果 Pod 中使用的是 EmptyDir、HostPath 这种类型的卷，那么这些卷并不会经历附着和分离的操作，它们只会被挂载和卸载到某一个的 Pod 中； EmptyDir、HostPath、ConfigMap 和 Secret，这些卷与所属的 Pod 具有相同的生命周期，对于ConfigMap和Sercet，在挂载时会创建临时的volume，随着Pod的删除而删除，而不会影响本身的ConfigMap和Secret对象；&lt;/p&gt;
&lt;p&gt;如果使用的云服务商提供的存储服务，这些持久卷只有附着到某一个节点之后才可以被挂在到相应的目录下，不过在其他节点使用这些卷时，该存储资源需要先与当前的节点分离。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;pvc与pv的绑定条件&#34;&gt;PVC与PV的绑定条件&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;PV和PVC的spec字段要匹配，比如存储的大小&lt;/li&gt;
&lt;li&gt;PV和PVC的storageClassName字段必须一样&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Volume 的创建和管理在 Kubernetes 中主要由卷管理器 VolumeManager 和 AttachDetachController 和 PVController三个组件负责。其中VolumeManager 会负责卷的创建和管理的大部分工作，而 AttachDetachController 主要负责对集群中的卷进行 Attach 和 Detach，PVController 负责处理持久卷的变更。&lt;/p&gt;
&lt;p&gt;当用户提交请求创建pod，Kubernetes发现这个pod声明使用了PVC，那就靠PersistentVolumeController帮它找一个PV配对。&lt;/p&gt;
&lt;p&gt;如果没有现成的PV，就去找对应的StorageClass，帮它新创建一个PV，然后和PVC完成绑定。&lt;/p&gt;
&lt;p&gt;新创建的PV，还只是一个API 对象，需要经过“两阶段处理”变成宿主机上的“持久化 Volume”才真正有用：
第一阶段Attach：由运行在master上的AttachDetachController负责，为这个PV完成 Attach 操作，为宿主机挂载远程磁盘；
第二阶段Mount：运行在每个节点上kubelet组件的内部，把第一步attach的远程磁盘 mount 到宿主机目录。这个控制循环叫VolumeManagerReconciler，运行在独立的Goroutine，不会阻塞kubelet主循环。&lt;/p&gt;
&lt;p&gt;完成这两步，PV对应的“持久化 Volume”就准备好了，Pod可以正常启动，将“持久化 Volume”挂载在容器内指定的路径。当需要卸载时，则先Unmount再进行Dettach。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;访问模式&#34;&gt;访问模式&lt;/h3&gt;
&lt;p&gt;由卷的提供商提供，比如AWS的EBS中的GP2、GP3磁盘，是ReadWriteOnce模式，所以一个卷只能被一个节点使用，否则会出现写冲突，即使用pod的复制集只能设置为1，且更新策略为recreate，保证只有一个pod使用才行；而如果是ReadWriteMany模式，比如AWS的EFS（EFS本质上是AWS对NFS的一次封装），则允许多个pod共享同一个持久卷&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ReadWriteOnce：卷可以被一个节点以读写方式挂载，允许同一个节点上的多个Pod访问；&lt;/li&gt;
&lt;li&gt;ReadOnlyMany：卷可以被多个节点以只读方式挂载；&lt;/li&gt;
&lt;li&gt;ReadWriteMany：卷可以被多个节点以读写方式挂载；&lt;/li&gt;
&lt;li&gt;ReadWriteOncePod：卷可以被单个 Pod 以读写方式挂载；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;回收策略&#34;&gt;回收策略&lt;/h3&gt;
&lt;p&gt;当PVC对象被删除时，kubernetes就需要对卷进行回收。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Retain：保留PV中的数据，如果PV想被重新使用，系统管理员就需要删除被使用的PV对象，并手动清除存储和相关存储上的数据。&lt;/li&gt;
&lt;li&gt;Delete：PV和相关的存储会被自动删除，如果当前PV上的数据确实不再需要，使用此策略可以节省手动处理的时间并快速释放无用的资源。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;apps/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;StatefulSet&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;web &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;nginx&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;replicas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchLabels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 声明Pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx:1.9.1 &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;web &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeMounts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;www &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/usr/share/nginx/html&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 声明挂载的PVC&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeClaimTemplates&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;www &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;accessModes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;ReadWriteOnce &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;requests&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;storage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;10Gi&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 声明要挂载的PV&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;PersistentVolume&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx-pv&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;capacity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;storage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;500Gi&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeMode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Filesystem&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;accessModes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;ReadWriteMany&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;persistentVolumeReclaimPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Retain&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;storageClassName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;efs-sc&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;csi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;driver&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;efs.csi.aws.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeHandle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;fs-09b712ab658f73e6f::fsap-xxx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 声明要挂载的StorageClass&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;StorageClass&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;storage.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;efs-sc&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;provisioner&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;efs.csi.aws.com&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;控制器模型&#34;&gt;控制器模型&lt;/h2&gt;
&lt;p&gt;常见的控制器有Deployment、Job、CronbJob、ReplicaSet、StatefulSet、DaemonSet等，他们是用于创建和管理Pod的实例，能够在集群层面提供复制、发布以及健康检查等功能，这些控制器都运行在Kubernetes集群的Master节点上，这些控制器会随Controller Manager的启动而运行，监听集群状态的变更来调整对应对象的状态。&lt;/p&gt;
&lt;h3 id=&#34;原理-3&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;控制循环：在一个无限循环内不断的轮询集群中的对象，将其状态与期望的状态做对比后，对该对象采取相应的操作。实际状态来自集群本身，如Kubelet汇报的容器状态、节点状态，监控系统的监控数据；期望状态来自用户提交的yaml文件；对象X指的是Pod或是其他受控制器控制的对象。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
    &lt;span class=&#34;nx&#34;&gt;实际状态&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;获取集群中对象X的实际状态&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;（&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Actual&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;State&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;）&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;期望状态&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;获取集群中对象X的期望状态&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;（&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Desired&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;State&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;）&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;实际状态&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;期望状态&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;什么都不做&lt;/span&gt; 
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
        &lt;span class=&#34;nx&#34;&gt;执行编排动作&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;将实际状态调整为期望状态&lt;/span&gt; 
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; 
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;与事件驱动的区别：事件驱动是被动型，接收到事件就执行相应的操作，事件是一次性，因此操作失败比较难处理，控制循环是不断轮询判断实际状态是否与期望一致。&lt;/p&gt;
&lt;h3 id=&#34;deployment&#34;&gt;Deployment&lt;/h3&gt;
&lt;p&gt;最基本的控制器对象，管理Pod的工具，比如管理多个相同Pod的实例，Deployment和ReplicaSet都能控制Pod的数量，但一般我们使用的还是Deployment，因为其还有其他功能，比如滚动更新、回滚、暂停和恢复等。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;apps/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Deployment&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx-deployment&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;paused&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 暂停：false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 通过spec.selector.matchLabels根据Pod的标签选择Pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchLabels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;replicas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 上面的部分定义了控制内容，判断实际与期望，并进行相应的操作，下面是被控制的对象&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx:1.7.9&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;containerPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;strategy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RollingUpdate&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rollingUpdate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 可使用值也可以使用百分比，使用百分比时，与replca值相乘得到最终的值&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;maxUnavailable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;25&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 在更新过程中能够进入不可用状态的Pod的最大值&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;maxSurge&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;25&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 能额外创建的Pod的个数&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Deployment想要实现水平扩展/收缩，实际操控的是ReplicaSet对象，而ReplicaSet管理着定义数量的Pod，所以它是一种三层结构，Deployment -&amp;gt; ReplicaSet -&amp;gt; 多个平行的Pod，Deployment是一个两层控制器，Deployment控制的是RepliocaSet的版本，ReplicaSet控制的是Pod的数量。&lt;/p&gt;
&lt;p&gt;ReplicaSet表示版本，比如上面那份配置，&lt;code&gt;replicas: 2&lt;/code&gt;是一个版本，&lt;code&gt;replicas: 3&lt;/code&gt;是一个版本，这里是因为数量不同产生两个版本，每一个版本对应着一个ReplicaSet，由Deployment管理。&lt;/p&gt;
&lt;p&gt;ReplicaSet是ReplicationController的升级版，都用于确保运行指定数量的Pod副本（像滚动更新、回滚、启动、暂停之类的功能则由Deployment提供），ReplicationController只支持基于等式的selector，比如&lt;code&gt;xxx = yyy或xxx != yyy&lt;/code&gt;，而ReplicaSet支持基于集合的selector，比如 &lt;code&gt;matchExpressions: {key: tier, operator: In, values: [frontend]}&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当我们修改Deployment的replicas字段时，会触发水平扩展/收缩，修改&lt;code&gt;template.Image&lt;/code&gt;或者版本号时，就会触发滚动更新，默认是滚动更新RollingUpdate，另外还能设置成重建Recreate，表示Deployment在更新Pod时，先kill掉所有在运行的Pod，然后创建新的Pod。&lt;/p&gt;
&lt;p&gt;Controller Manager中的DeploymentController作为管理Deployment资源的控制器，会在启动时通过Informer监听Pod、ReplicaSet和Deployment的变更，一旦变更就会触发DeploymentController中的回调；&lt;/p&gt;
&lt;p&gt;初始化创建Deployment时，Kubernetes会创建了一个ReplicaSet，并按用户的需求创建了对应数量的Pod副本，当Deployment更新时，Kubernetes会再创建一个新的ReplicaSet，然后按照相同的更新策略逐个调整，将老的ReplicaSet的副本数-1，新ReplicaSet的副本数+1，直到新的ReplicaSet的副本数符合预期，老的ReplicaSet副本数缩减为0。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# 设置更新策略&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;strategy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RollingUpdate&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 滚动更新策略&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rollingUpdate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;maxSurge&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 指定Desired数量，&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;maxUnavailable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 一次更新中，可以删除的旧的Pod的数量&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Deployment只适合控制无状态的Pod，如果是Pod与Pod之间有依赖关系，或者有状态时，deployment就不能随便杀掉任意的Pod再起新的Pod，比如多个数据库实例，因为数据库数据是存在磁盘，如果杀掉后重建，会出现实例与数据关系丢失，因此就需要StatefulSet。&lt;/p&gt;
&lt;h3 id=&#34;statefulset&#34;&gt;StatefulSet&lt;/h3&gt;
&lt;p&gt;StatefulSet可以解决两种情况下的状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;拓扑状态，如果PodA和PodB有启动的先后顺序，当它们被再次创建出来时也会按照这个顺序进行启动，且新创建的Pod和原来的Pod拥有同样的网络标识（比如DNS记录），保证在使用原来的方式通信也可行。&lt;/p&gt;
&lt;p&gt;StatefulSet通过Headless Service，使用这个DNS记录维持Pod的拓扑状态。在声明StatefulSet时，在&lt;code&gt;spec.serviceName&lt;/code&gt;里指定Headless Service的名称，因为serviceName的值是固定的，StatefulSet在为Pod起名字的时候又会按顺序编号，为每个Pod生成一条DNS记录，通过DNS记录里的Pod编号来进行顺序启动。&lt;/p&gt;
&lt;p&gt;StatefulSet只会保证DNS记录不变，Pod对应的IP还是会随着重启发生改变的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;存储状态，PodA第一次读取到的数据，隔了一段时间后读取到的仍然是同一份，无论其他有没有被重建过。&lt;/p&gt;
&lt;p&gt;StatefulSet通过PVC + PV + 编号的方式，实现 数据存储与Pod的绑定。每个Pod都会根据编号与对应的PVC绑定，当Pod被删除时，并不会删掉对应的PV，因此在起新的Pod的时候，会根据PVC找到原来的PV。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;StatefulSet直接管理Pod&lt;/strong&gt;，每个Pod不再认为只是复制集，而是会有hostname、名字、编号等的不同，并生成对应的带有相同编号的DNS记录，对应的带有相同编号的PVC，保证每个Pod都拥有独立的Volume。&lt;/p&gt;
&lt;p&gt;对于一个副本数为n的StatefulSet，Pod被部署时是按照0~n-1的序号顺序创建的，会等待前一个Pod变为Running和Ready才会启动下一个Pod。使用配置&lt;code&gt;spec.podManagementPolicy: &amp;quot;Parallel&amp;quot;&lt;/code&gt;则可以使得Pod同时创建。&lt;/p&gt;
&lt;p&gt;StatefulSet的滚动更新，会按照与Pod编号相反的顺序，逐一更新，如果发生错误，滚动更新会停止；&lt;/p&gt;
&lt;p&gt;StatefulSet支持按条件更新，通过对&lt;code&gt;spec.updateStrategy.rollingUpdate的partition字段&lt;/code&gt;进行配置，可实现金丝雀部署或灰度发布。比如：&lt;code&gt;{&amp;quot;spec&amp;quot;:{&amp;quot;updateStrategy&amp;quot;:{&amp;quot;type&amp;quot;:&amp;quot;RollingUpdate&amp;quot;,&amp;quot;rollingUpdate&amp;quot;:{&amp;quot;partition&amp;quot;:3}}}}&lt;/code&gt;进行设置后，再继续对&lt;code&gt;spec.template&lt;/code&gt;里进行修改，StatefulSet会对序号大于或等于此序号的Pod进行更新，小于此序号的保存旧版本不变，即使这些Pod被删除和重建，也是用的旧版本。&lt;/p&gt;
&lt;p&gt;也可以设置&lt;code&gt;spec.updateStrategy.type: OnDelete&lt;/code&gt;时，当&lt;code&gt;spec.template&lt;/code&gt;发生变化时，Pod不会进行更新，需要手动删除，让StatefulSet来重新产生Pod，才会使用新的设置。&lt;/p&gt;
&lt;p&gt;StatefulSet可用于部署有状态的应用，比如有主从节点MySQL集群，在这个case中，虽然Pod会有相同的template，但是主从Pod里的sidecar执行的动作不一样，而主从Pod可以根据编号来实现，不同类型的Pod存储通过PVC + PV实现。&lt;/p&gt;
&lt;p&gt;StatefulSet的删除支持级联和非级联两种，非级联删除时，只会删除StatefulSet控制器，不会删除对应的Pod，需要使用参数&lt;code&gt;--cascade=orphan&lt;/code&gt;。当StatefulSet被重新创建时，会再执行一遍Pod的创建，同时下掉之前非级联删除的Pod。&lt;strong&gt;非级联删除StatefulSet时，不会删除其对应的Pod相关联的PV卷&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;StatefulSet主要由StatefulSetController、StatefulSetControl和StatefulPodControl三个组件协作来完成；StatefulSet的管理，StatefulSetController会同时从PodInformer和ReplicaSetInformer中接受增删查改事件并将事件推送到队列中。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;apps/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;StatefulSet&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;web&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;nginx&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;replicas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchLabels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;k8s.gcr.io/nginx-slim:0.8&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeMounts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;www&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/usr/share/nginx/html&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeClaimTemplates&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;www&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;accessModes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;ReadWriteOnce&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;requests&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;storage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;1Gi&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;daemonset&#34;&gt;DaemonSet&lt;/h3&gt;
&lt;p&gt;一般的Pod都需要节点准备好了(即node的状态是Ready)才可以调度上去，但是有些Pod需要在节点还没准备好的时候就需要部署上去，比如网络相关的Pod，因此需要使用DaemonSet。&lt;/p&gt;
&lt;p&gt;DaemonSet 的会在Kubernetes 集群里的每个节点都运行一个 Daemon Pod，每个节点只允许一个，当有新的节点加入集群后，该Pod会在新节点上被创建出来，节点被删除，该Pod也被删除。&lt;/p&gt;
&lt;p&gt;DaemonSet Controller通过 控制循环，在etcd上获取所有Node列表，判断节点上是否已经运行了标签为xxx的Pod，来保证每个节点上只有一个。可以通过在Pod上声明nodeSelector、nodeAffinity、tolerations字段告诉控制器如何选择node。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在node上打上标签，即可通过nodeSelector选择对应的node；&lt;/li&gt;
&lt;li&gt;nodeAffinity的功能比nodeSelector强大，支持更加灵活的表达式来选择节点；&lt;/li&gt;
&lt;li&gt;tolerations来容忍Pod在被打上污点标签的节点也可以部署，因为一般有污点的节点是不允许将Pod部署在上面的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;DaemonSet是直接管理Pod的&lt;/strong&gt;，DaemonSet所管理的Pod的调度过程，都由它自己完成，而不是通过Kube-Scheduler完成， 是因为DaemonSet在创建Pod时，会为其增加&lt;code&gt;spce.nodeName&lt;/code&gt;字段，此时以及明确了该Pod要运行在哪个节点，就不需要kube-scheduler来调度了，但也带了问题，无论节点可不可用，DaemonSet都会将该Pod往上面调度。&lt;/p&gt;
&lt;p&gt;DaemonSet的应用一般是网络插件的Agent组件、存储插件的Agent组件、节点监控组件、节点日志收集等。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;apps/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DaemonSet&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;fluentd-elasticsearch&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kube-system&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;matchLabels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;fluentd-elasticsearch&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;fluentd-elasticsearch&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;fluentd-elasticsearch&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;k8s.gcr.io/fluentd-elasticsearch:1.20&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumeMounts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;varlog&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;mountPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/var/log&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;volumes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;varlog&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hostPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/var/log&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;job&#34;&gt;Job&lt;/h3&gt;
&lt;p&gt;Job是一种特殊的Pod，即那些计算完成之后就退出的Pod，状态变为complated。&lt;/p&gt;
&lt;p&gt;Job 会使用这种携带了 UID 的 Label，为了避免不同 Job 对象所管理的 Pod 发生重合，Job是直接控制Pod的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;backoffLimit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;//默认是6&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;activeDeadlineSeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;//单位：秒&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;parallelism&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;completions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;backoffLimit表示失败后的重试次数，下一次重试的动作分别发生在10s、20s、40s&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;activeDeadlineSeconds表示最长运行的时间，如果超过该限定时间，则会立即结束&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;parallelism表示一个 Job 在任意时间最多可以启动多少个 Pod 同时运行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;completions表示 Job 至少要完成的 Pod 数目，即 Job 的最小完成数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Job Controller 在控制循环中进行的调谐（Reconcile）操作，是根据实际在 Running 状态 Pod 的数目、已经成功退出的 Pod 的数目，以及 parallelism、completions 参数的值共同计算出在这个周期里，应该创建或者删除的 Pod 数目，然后调用 Kubernetes API 来执行这个操作，当Job执行完处于complate状态时，并不会退出。&lt;/p&gt;
&lt;h3 id=&#34;cronjob&#34;&gt;CronJob&lt;/h3&gt;
&lt;p&gt;如果仍然使用Deployment管理，因为它会对退出的Pod进行滚动更新，所以并不合适，因此需要使用CronJob，作用类似于Job类似于Pod，CronJob类似于Deployment；&lt;/p&gt;
&lt;p&gt;Cronjob会每隔10s从api-server中取出资源并进行检查是否触发调度创建新的资源，所以&lt;strong&gt;Cronjob并不能保证在准确的目标时间执行，有一定的滞后性&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;CronJob使用 &lt;code&gt;spec.schedule&lt;/code&gt; 来控制，使用jobTemplate来定义job模板，&lt;code&gt;spec.concurrencyPolicy&lt;/code&gt;来控制并行策略&lt;/p&gt;
&lt;p&gt;&lt;code&gt;spec.concurrencyPolicy&lt;/code&gt;：=Allow：一个Job没执行完，新的Job就能产生、=Forbi：新Job不会被创建、Replace：新的Job会替换旧的，没有执行完的Job；&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;batch/v1beta1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;CronJob&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;order-cronjob-auto-close-order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;regoo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;schedule&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;*/5 * * * *&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;successfulJobsHistoryLimit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;failedJobsHistoryLimit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;completions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 当前任务要等待1个pod的成功执行&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;parallelism&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 最多有1个并发执行的任务，此时所有任务会依次顺序进行，只有前一个成功才能执行下一个&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;concurrencyPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Forbid&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;startingDeadlineSeconds&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;120&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;suspend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 是否暂停&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;jobTemplate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;template&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;sidecar.istio.io/inject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;false&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;curlimages/curl:7.77.0&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;curl&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;imagePullPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;IfNotPresent&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;curl&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;-X&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;POST&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;http://order:8080/order/schedule/auto_close_order&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;restartPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;OnFailure&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;operator-与-控制器原理&#34;&gt;Operator 与 控制器原理&lt;/h3&gt;
&lt;p&gt;本质是一个控制器，控制自定义的CRD的流程控制，执行自定义CRD的行为。&lt;/p&gt;
&lt;p&gt;CRD（ Custom Resource Definition），一种API插件机制，允许用户在k8s中添加一个跟Pod、Node类型的，新的API资源，即kind为CustomResourceDefinition，类似于类的概念，这样就可以通过这个类，来创建属于这个类的实例(编写yaml文件)，这个实例就称为CR。&lt;/p&gt;
&lt;p&gt;比如有CRD为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;apiextensions.k8s.io/v1beta1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;CustomResourceDefinition&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networks.samplecrd.k8s.io&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;samplecrd.k8s.io&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;names&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Network&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;plural&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networks&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;scope&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Namespaced&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;CR为&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;samplecrd.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Network&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;example-network&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;cidr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;192.168.0.0/16&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;gateway&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;192.168.0.1&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中的资源类型、组、版本号要一一对应&lt;/p&gt;
&lt;p&gt;上面这些操作只是告诉k8s怎么认识yaml文件，接着就需要编写代码，让k8s能够通过yaml配置生成API对象，以及如何使用这些配置的字段属性了，接着，还需要编写操作该API对象的控制器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于Webhook&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Operator中的Webhook，外部对CRD资源的变更，在Controller处理之前都会交给Webhook提前处理，即：Webhook的处理早于Controller的Reconcile方法执行。&lt;/p&gt;
&lt;p&gt;Webhook的职责是修改和验证，可以集成在Operator中。&lt;/p&gt;
&lt;h4 id=&#34;client-go&#34;&gt;Client-Go&lt;/h4&gt;
&lt;p&gt;编写一个Operator时，需要用到Client-Go，实现与API-Server的交互。Client-Go提供了4种交互对象：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;RESTClient：最基础的客户端，对HTTP请求做封装，支持Json和Protobuf格式，是对DiscoveryClient、ClientSet、DynamicClient的封装；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DiscoveryClient：发现客户端，负责发现API-Server支持的支援组、版本和资源信息，等同于&lt;code&gt;kubectl api-resources&lt;/code&gt;；由于GVR数据很少变动，所以可以将GVR数据缓存在本地，减少Client与API-Server的交互。使用CachedDiscoveryClient和MemCacheClient请求时，会先从缓存里取，取不到才请求API-Server。&lt;/p&gt;
&lt;p&gt;在使用kubectl命令时，也会进行缓存，以json文件的形式缓存存在 &lt;code&gt;~/.kube/cache&lt;/code&gt; 中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ClientSet：负责操作Kubernetes内置的资源对象，如Pod、Service等；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DynamicClient：动态客户端，可以对任意的Kubernetes资源对象进行通用操作，包括CRD；本质是通过一个嵌套的&lt;code&gt;map[string]interface{}&lt;/code&gt;对象存储API-Server的返回值，再使用反射机制进行数据绑定，虽然灵活，但无法获取强数据类型的检查和验证。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本质上都是发送HTTP请求给API-Server，只是RESTClient比较原始，其他Client都对具体资源做了结构体封装。&lt;/p&gt;
&lt;h4 id=&#34;控制器的原理&#34;&gt;控制器的原理&lt;/h4&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e6%8e%a7%e5%88%b6%e5%99%a8%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e6%8e%a7%e5%88%b6%e5%99%a8%e5%b7%a5%e4%bd%9c%e6%b5%81%e7%a8%8b.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Informer&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;控制器通过Watch机制，与API-Server交互，获取它所关心的对象，依靠Informer通知器来完成，Informer与API对象一一对应；&lt;/p&gt;
&lt;p&gt;Informer是一个自带缓存和索引机制，通过增量里的事件触发 Handler 的客户端库，查询时，优先从本地缓存里查找数据，而创建、更新、删除操作，则根据事件通知机制写入队列DeltaFIFO中，同时，当对应的事件处理后，更新本地缓存，使得本地缓存与etcd里的数据一致；&lt;/p&gt;
&lt;p&gt;这个本地缓存在 Kubernetes 中一般被称为 LocalStore，索引一般被称为 Indexer；一般是一个资源一个Informer；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Reflector&lt;/strong&gt;：通过 &lt;strong&gt;List-Watch&lt;/strong&gt; 机制监听并获取API-Server中资源的create、update、delete事件，并针对事件类型调用对应的处理函数，是k8s统一的异步消息处理机制，保证了消息的实时性、可靠性，保证本地缓存数据的准确性、顺序性和一致性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;List：获取资源的全量列表数据，并同步到本地缓存中；List基于HTTP短连接实现；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Watch：负责监听变化的数据，当Watch的资源发生变化时，并将资源对象的变化事件存放到本地队列DeltaFIFO中，触发对应的变更事件进行处理，同时更新本地缓存，使得本地缓存与etcd里的数据一致。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Watch的原理&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;Watch基于HTTP长链接，1.5以前使用HTTP1.1，并采用分块传输编码&lt;code&gt;响应头加上Transfer-Encoding=chunked基于HTTP/1.1，因为在短连接里，客户端需要通过Content-Length或连接是否关闭来判断是否接收完成，可以关掉，使用chunked后，服务端无需使用来告诉客户端响应体的结束位置，结束位置通过/n, /r或0来表示&lt;/code&gt;，将数据分解成一系列数据块，一个或多个地发送。&lt;/p&gt;
&lt;p&gt;1.5以后使用HTTP/2，引入Frame二进制帧为单位进行传输，etcd v3的gRPC stream协议。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定时同步：定时器触发同步机制，定时更新缓存数据，定时同步的周期时间可配。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据更新的依据来源于 ResourceVersion，当资源发生变化时，ResourceVersion就会以递增的形式更新，保证事件的顺序性，通过比较这个值，来判断资源是否有变化。&lt;/p&gt;
&lt;p&gt;List-Watch必须一起配合才能保证消息的可靠性，如果仅依靠Watch，当连接断开后，消息就有可能丢失，此时通过List来获取所有数据，还有判断ResourceVersion的值，纠正数据不一致，保证事件不丢失。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DeltaFIFO&lt;/strong&gt;：增量队列，记录资源变化，Relector相当于队列的生产者；&lt;/p&gt;
&lt;p&gt;Delta是资源对象存储，保存存储对象的消费类型，作为队列里的消息体，有两个属性，Type表示事件类型，比如&lt;code&gt;Added、Updated、Deleted、Replaced、Sync&lt;/code&gt;，Object表示资源对象，如Pod、Service；&lt;/p&gt;
&lt;p&gt;FIFO队列负责接收Reflector传递过来的事件，并将其按顺序存储，然后等待事件的处理函数进行处理，如果出现多个相同事件，则只会被处理一次；&lt;/p&gt;
&lt;p&gt;DeltaFIFO只会存储Watch返回的各种事件，而LocalStorae只会被Lister的List/gGet方法访问。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Indexer&lt;/strong&gt;：用来存储资源对象，并自带索引功能的本地存储LocalStore，可以理解为里面有很多map组成的倒排索引和对应的索引处理器；&lt;/p&gt;
&lt;p&gt;IndexFunc：索引器函数，用于计算资源对象的索引列表；&lt;/p&gt;
&lt;p&gt;Index：存储数据，比如：要查找某个命名空间下的Pod，对应的Index类型可以是&lt;code&gt;map[{namespace}]{sets.pod}&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;Indexers：存储索引器，key为索引器名称，value为 IndexFunc， 比如&lt;code&gt;map[&amp;quot;namespace&amp;quot;]{IndexFunc}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Indices：存储缓存器，key为索引器名称，value为缓存的数据，比如：&lt;code&gt;map[&amp;quot;namespace&amp;quot;]map[{namespace}]{sets.pod}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;SharedInformer&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在K8s中，每一个资源都有一个Informer，Informer使用Reflector来监听资源，如果统一资源的Informer实例化太多次，就会有很多重复的步骤。为了解决多个控制器操作同一资源的问题，导致对同一资源的重复操作，比如重复缓存。使用SharedInformer后，不管有多少个控制器同时读取事件，都只会调用一个Watch API来Watch上游的API-Server，降低Api-Server的负载，比如 Controller-Manager。&lt;/p&gt;
&lt;p&gt;Informer是一种机制，SharedInformer是其中一种实现。&lt;/p&gt;
&lt;p&gt;通常自定义Controller要求只有一个实例在运行，因为当出现多个实例的时候，会出现并发问题，重复消费事件，如果要实现高可用，需要主从部署，只有主服务处于工作状态，从服务处于暂停状态，当主服务出现问题时，实现主从切换。Client-Go本身提供了leaderelection机制来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WorkQueue&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;WorkQueue支持三种队列：FIFO队列、延时队列、限速队列，供不同场景下使用。&lt;/p&gt;
&lt;p&gt;从event handler触发的事件会先放入WorkQueue中，WorkQueue是一个去重队列，内部除了 Queue队列 外还带有 Processing Set 和 Dirty Set记录，用来实现同一个资源对象的多次事件触发，入队列后会去重，不会被多个worker同时处理。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Queue队列：实际存储元素的地方，保证元素有序，本质是一个slice；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Dirty Set：保证去重，还能保证处理一个元素之前哪怕被添加多次（并发），也只会被处理一次；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Processing Set：标记机制，标记一个元素是否被处理，保证只有一个元素在Queue队列里被处理；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;并发处理流程：&lt;/p&gt;
&lt;p&gt;Add方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;元素被Add时，首先会检查其是否存在于Dirty Set中，如果存在则直接丢弃，不存在才加入，保证Dirty Set中不会有多个指向同一resource的相同元素存在；&lt;/li&gt;
&lt;li&gt;元素被添加进Dirty Set后，再判断Processing Set是否存在，如果存在则跳出，防止同一元素被并发处理，不存在则加入Queue队列；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Get方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;元素被Get时，Reconcile Loop从Queue队列队首中取出元素，并放入Processing Set中，防止并发处理同一元素；&lt;/li&gt;
&lt;li&gt;最后从Dirty Set中删除该元素，因为 Dirty Set 是为了实现的待消费去重, 既然从 Queue队列 拿走元素, Dirty Set 也需要删除；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Done方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Reconcile Loop处理结束后，从Processing Set中删除元素；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果 Dirty Set 中存在相同resource的元素，就会被放入Queue队列，此时Dirty Set和Queue持有同一份元素；&lt;/p&gt;
&lt;p&gt;这里的意思是，如果一个元素正在被处理，又再次加入了相同的元素，由于该元素还没处理完，只能把该元素先放入Dirty Set中，因为Queue队列会被多个协程消费，只放在Dirty Set中保证同一元素不会被并发消费，当元素处理完时，再重新进入Queue队列，因为此时该元素已经被处理过，是最新的了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;这样就解决了去重的问题，还解决了同一个对象并发处理的顺序问题，只不过可能和原来请求的顺序不太一致，相同资源的请求被delay了，但是不影响最终结果，也实现了无锁的操作。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;整体流程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Reflector通过List罗列资源，通过Watch监听资源的变更事件，将结果放到DeltaFIFO队列中；&lt;/li&gt;
&lt;li&gt;然后从 DeltaFIFO中 将消费出来的资源对象存储到Indexer中，Indexer把增量里的API对象保存到本地缓存，并创建索引；&lt;/li&gt;
&lt;li&gt;Indexer与etcd中的数据完全保持一致，handler处理时，先从本地缓存里拿，拿不到再请求API-Server，减少Client-Go与API-Server交互的压力。&lt;/li&gt;
&lt;li&gt;Informer 与我们要编写的控制循环ControlLoop之间，则使用了一个工作队列WorkQ来进行协同，实际应用中，informers、listers、clientset都是通过CRD代码生成，开发者只需要关注控制循环的具体实现就行。&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;leaderelection机制&#34;&gt;leaderelection机制&lt;/h4&gt;
&lt;p&gt;一些特定的组件需要确保同一时刻只有一个实例在工作，就需要通过leaderelection机制来实现。&lt;/p&gt;
&lt;p&gt;原理是通过K8s的 &lt;code&gt;endpoints、configmap或lease&lt;/code&gt;实现一个分布式锁（通过resourceVersion + 乐观锁实现，判断资源的id和自己所持有的id是否一致），只有抢到锁的服务才能成为leader，并定期更新（比如2s一次），而抢不到的节点会周期性的检查是否能更新以成为新Leader。&lt;/p&gt;
&lt;p&gt;抢锁update时，采用乐观锁机制，通过resourceVersion字段判断对象是否已被修改。&lt;/p&gt;
&lt;p&gt;当 leader 因为某些异常原因挂掉后，租约到期，其他节点会尝试抢锁，成为新的 leader，成为leader时，对应pod的annotations会更新&lt;code&gt;control-plane.alpha.kubernetes.io/leader&lt;/code&gt;字段，值为该Pod的一些信息，如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;err&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;Leader的Id&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;holderIdentity&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;instance-o24xykos-3_9d68-33ec5eadb906&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
 	&lt;span class=&#34;err&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;Follower获得leadership需要的等待LeaseDuration时间，Leader以leaseDuration为周期不断的更新renewTime的值&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;leaseDurationSeconds&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;acquireTime&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;2020-04-23T06:45:07Z&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;renewTime&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;2020-04-25T07:55:58Z&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; 
    &lt;span class=&#34;nt&#34;&gt;&amp;#34;leaderTransitions&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;所谓的选主，就看哪个Follower能将自己的信息更新到&lt;code&gt;endpoints、configmap或lease&lt;/code&gt;的&lt;code&gt;control-plane.alpha.kubernetes.io/leader&lt;/code&gt;上。&lt;/p&gt;
&lt;h2 id=&#34;service&#34;&gt;Service&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;工作在第四层，传输层，一般转发TCP、UDP流量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每次Pod的重启都会导致IP发生变化，导致IP是不固定的，Service可以为一组相同的Pod套上一个固定的IP地址和端口（这个IP就是clusterIP），让我们能够以&lt;strong&gt;TCP/IP&lt;/strong&gt;负载均衡的方式进行访问。&lt;/p&gt;
&lt;p&gt;虽然Service每次重启IP也会发生变化，但是相比Pod会更加稳定。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建一个新的Service对象需要两大模块同时协作，一个是控制器，它需要在每次客户端创建新的Service对象时，生成其他用于暴露一组Pod的对象，即Endpoint；另一个是kube-proxy，它运行在集群的每个节点上，根据Service和Endpoint的变动改变节点上iptables或者ipvs中保存的规则。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般是Pod指定一个访问端口和label，Service的selector指明绑定的Pod，配置端口映射，Service并不直接连接Pod，而是在selector选中的Pod上产生一个Endpoints资源对象，通过Service的clusterIP就能访问它代理的Pod了。&lt;/p&gt;
&lt;p&gt;Service对应的固定IP就是clusterIP，clusterIP + Endpoint的记录会被kube-proxy转成宿主机上的iptables规则，如果是Headless Service，kube-proxy则不会处理它，也不会生成iptables规则；&lt;/p&gt;
&lt;p&gt;只有在Service中设置了selector，才会创建Endpoint记录，Endpoint与Service同名，跟Service一样的生命周期；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;service负载分发策略有两种模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RoundRobin：轮询模式，即轮询将请求转发到后端的各个pod上（默认模式）&lt;/li&gt;
&lt;li&gt;SessionAffinity：基于客户端IP地址进行会话保持的模式，第一次客户端访问后端某个pod，之后的请求都转发到这个pod上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于gRPC的负载均衡：&lt;/p&gt;
&lt;p&gt;对于HTTP/1.1 + KeepAlive的长连接，还是可以实现负载均衡的，因为HTTP/1.1是串行的，当请求到达时，如果没有空闲连接，那就新建一个连接，如果有空闲就复用，同一个时间点，一个连接最多只能承载一个请求，所以HTTP/1.1可以连接多个Pod；&lt;/p&gt;
&lt;p&gt;由于gRPC是基于HTTP/2实现的，请求发起后是长连接，多个请求发起后进行多路复用，结果就只连接了一个Pod，无法实现负载均衡，解决方法有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端负载均衡：接入istio-proxy，服务与side car继续保持长连接，由side car向请求的服务实现负载均衡；&lt;/li&gt;
&lt;li&gt;客户端负载均衡：NameResolver + Headless-Service方案：Headless-Service为服务端每个Pod实例的IP以A记录形式存储，客户端通过NameResolver解析出服务端对应的IP地址列表，与各个IP建立长连接，实现负载均衡，但这种方案存在问题是当Pod扩容之后，客户端不能感知（缩容是可以的，因为gRPC可以感知连接断开），解决方案是使用kuberesolver，通过它来检查Service对应的Endpoints变化，动态更新连接信息；&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;regoo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;TCP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;targetPort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;NodePort&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;sessionAffinity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;None&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;externalTrafficPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Cluster&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;kube-proxy&#34;&gt;kube-proxy&lt;/h3&gt;
&lt;p&gt;Kubernetes集群中每一个节点都运行着一个kube-proxy，这个进程负责监听&lt;strong&gt;Service的增加和删除事件并修改运行代理的配置，比如节点的iptables或ipvs，为节点内的客户端提供流量转发和负载均衡等功能&lt;/strong&gt;，kube-proxy有三种模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;userspace：运行在用户空间的代理，对于每一个Service都会在当前的节点上开启一个端口，所有连接到当前代理端口的请求都会被转发到service背后的一组pod上，本质上是在节点的iptable上添加一条规则，通过iptables将流量转发给kube-proxy处理。&lt;/p&gt;
&lt;p&gt;如果选择userspace模式，每当有新的service被创建时，kube-proxy就会增加一条iptables记录并启动一个goroutine，前者用于将节点中服务对外发出的流量转发给kube-proxy，再由后者一系列goroutine将流量转发到目标的pod上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;iptables：（默认）直接使用iptables转发当前节点上的全部流量，比userspace模式有更高的吞吐量，相比userspace模式，是直接转发流量，不用经过Kube-proxy转发。&lt;/p&gt;
&lt;p&gt;如果选择iptables模式，所有流量会先经过PREROUTING或者OUTPUT链 ，随后进入Kubernetes自定义的链入口KUBE_SERVICES、单个Service对应的链KUBE-SVC-XXX以及每个pod对应的链KUBE-SEP-XXX，经过这些链的处理，最终才能访问一个服务真正的IP地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ipvs：解决在大量 Service 时，iptables 规则同步变得不可用的性能问题，ipvs 的实现虽然也基于 netfilter 的钩子函数，但是它却使用哈希表作为底层的数据结构，使用ipset来生成规则链（ipset可以理解为一个IP段的集合，这个集合可以是IP地址、网段、端口等，可以动态修改），并且工作在内核态，而iptables规则链是一个线性的数据结构，查找是需要遍历查找，这也就是说 ipvs 在重定向流量和同步代理规则有着更好的性能。&lt;/p&gt;
&lt;p&gt;除了能够提升性能之外，ipvs 也提供了多种类型的负载均衡算法，除了最常见的 Round-Robin 之外，还支持最小连接、目标哈希、最小延迟等算法，能够很好地提升负载均衡的效率。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;endpoints的作用&#34;&gt;Endpoints的作用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;当service使用了selector指定带有对应label的pod时，endpoint controller才会自动创建对应的endpoint对象，产生一个endpoints，endpoints信息存储在etcd中，用来记录一个service对应的所有pod的访问地址&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;说白了，因为Pod ip比较容易变化，而Endpoint的作用就是维护Service和一组Pod的映射，不用频繁修改Service。&lt;/p&gt;
&lt;p&gt;Endpoints controller的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;负责生成和维护所有endpoint对象的控制器；&lt;/li&gt;
&lt;li&gt;负责监听service和对应pod的变化；&lt;/li&gt;
&lt;li&gt;监听到service被删除，则删除和该service同名的endpoint对象；&lt;/li&gt;
&lt;li&gt;监听到新的service被创建，则根据新建service信息获取相关pod列表，然后创建对应endpoint对象；&lt;/li&gt;
&lt;li&gt;监听到service被更新，则根据更新后的service信息获取相关pod列表，然后更新对应endpoint对象；&lt;/li&gt;
&lt;li&gt;监听到pod事件，则更新对应的service的endpoint对象，将pod IP记录到endpoint中；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;service的实现&#34;&gt;Service的实现&lt;/h3&gt;
&lt;p&gt;Service由kube-proxy组件 + kube-dns组件(coreDNS) + iptables或IPVS共同实现。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;coreDNS创建时会调用kubelet修改每个节点的&lt;code&gt;/etc/resolv.conf&lt;/code&gt;文件，添加coreDNS的Service的clusterIP作为DNS服务的IP；&lt;/li&gt;
&lt;li&gt;coreDNS会监听service和endpoints的变化，缓存到内存中，主要是Service名称与其clusterIP的映射；&lt;/li&gt;
&lt;li&gt;kube-proxy也会监听Service和Endpoints的变化，然后更新由Service到Pod路由规则，并添加到宿主机的iptables中；&lt;/li&gt;
&lt;li&gt;通过Service域名请求时，会先请求coreDNS服务获取对应Service的clusterIP，再根据这个ip在iptables中转发到对应的pod，iptables会负责负载均衡；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;kube-proxy只是controller，对iptables进行更新，基于iptables的kube-proxy的主要职责包括两大块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;监听Service更新事件，并更新Service相关的iptables规则；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;监听Endpoint更新事件，更新Endpoint相关的iptables规则，然后将包请求转入Endpoint对应的Pod；&lt;/p&gt;
&lt;p&gt;如果某个Service尚没有Pod创建，那么针对此Service的请求将会被丢弃。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;kube-proxy对iptables的链进行了扩充，自定义了KUBE-SERVICES，KUBE-NODEPORTS，KUBE-POSTROUTING，KUBE-MARK-MASQ和KUBE-MARK-DROP五个链，并主要通过为KUBE-SERVICES chain增加rule来配制traffic routing 规则。通过iptables，修改流入的IP包的目的地址和端口，从而实现转发。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先给 Service 分配一个VIP，然后增加 iptables 规则将访问该 IP 的请求转发到后续的 iptables 链。&lt;/p&gt;
&lt;p&gt;KUBE-SERVICES 或者 KUBE-NODEPORTS 规则对应的 Service 的入口链，这个规则应该与 VIP 和 Service 端口一一对应；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;iptables 链实际是一个集合，包含了各个 Pod 的IP（这些称为 Service 的 Endpoints），使用 Round Robin 方式的负载均衡。&lt;/p&gt;
&lt;p&gt;KUBE-SEP-(hash) 规则对应的 DNAT 链，这些规则应该与 Endpoints 一一对应；
KUBE-SVC-(hash) 规则对应的负载均衡链，这些规则的数目应该与 Endpoints 数目一致；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;然后，这些 Endpoints 对应的 iptables 规则，正是 kube-proxy 通过监听 Pod 的变化事件，在宿主机上生成并维护的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;大量的Pod会产生大量的iptables导致性能问题，因为其实现方式是全量的，会对文件上锁，把iptables里的内容拷贝出来进行修改，然后再保存回去，当有5000个服务时，就要耗时11分钟了，所以kube-proxy使用IPVS模式来解决这个问题。IPVS 是建立于 Netfilter之上的高效四层负载均衡器，支持 TCP 和 UDP 协议，支持3种负载均衡模式：NAT、直接路由（通过 MAC 重写实现二层路由）和IP 隧道。&lt;/p&gt;
&lt;h3 id=&#34;关于headless&#34;&gt;关于Headless&lt;/h3&gt;
&lt;p&gt;Service在集群内部被访问，有两种方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Service的VIP，即clusterIP，访问该IP时，Service会把请求转发到其代理的某个Pod上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Service的DNS方式，比如Service有&lt;code&gt;[svc名称].[namespace名称].svc.cluster.local&lt;/code&gt;这条DNS记录，访问这条DNS记录，根据这条DNS记录，查询出对应的clusterIP，根据clusterIP + iptables转发给对应的pod，实现负载均衡。&lt;/p&gt;
&lt;p&gt;如果这条DNS记录没有对应的Service VIP，即Service的clusterIP是None，则称为Headless Service，此时的DNS记录格式为&lt;code&gt;&amp;lt;pod-name&amp;gt;.&amp;lt;svc-name&amp;gt;.&amp;lt;namespace &amp;gt;.svc.cluster.local&lt;/code&gt;，直接映射到被代理的某个Pod的IP，由客户端来决定自己要访问哪个pod，并直接访问。通过headless service访问不会进行负载均衡。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Service和Pod都会被Kubernetes分配对应的DNS A记录。&lt;/p&gt;
&lt;p&gt;ClusterIp模式下的A记录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service：.. svc.cluster.local，对应Cluster IP&lt;/li&gt;
&lt;li&gt;Pod：.. pod.cluster.local，对应Pod的IP&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Headless模型下的A记录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Service：.. svc.cluster.local，对应的是所有被代理的Pod的IP地址的集合&lt;/li&gt;
&lt;li&gt;Pod：.. svc.cluster.local，对应Pod的IP&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;service的几种设置&#34;&gt;Service的几种设置&lt;/h3&gt;
&lt;p&gt;Service的本质是通过kube-proxy在宿主机上设置iptables规则、DNS映射，工作在第四层传输层。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;type=ClusterIP，此时该service只能在集群内部被访问&lt;/strong&gt;，如果集群外想访问，只能通过kubernetes的proxy模式来访问，比如先开启&lt;code&gt;kubectl proxy --port=8080&lt;/code&gt;在本机打开集群访问的代理，然后通过该端口进行访问，kubernetes会帮我们转发到对应的pod上：&lt;code&gt;curl http://localhost:8080/api/v1/proxy/namespaces/{名称空间}/services/{service名称}/{path}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;type=NodePort，集群外部使用 &lt;code&gt;{任何一个节点的IP}:{nodePort}&lt;/code&gt; 访问这个service&lt;/strong&gt;，会将请求转发到对应的Pod，本质上是kube-proxy为该模式配置一条iptables规则；&lt;/p&gt;
&lt;p&gt;默认下nodePort会使用主机的端口范围：30000 - 32767；&lt;/p&gt;
&lt;p&gt;在这里，请求可能会经过SNAT操作，因为当client通过node2的地址访问一个Service，node2可能会负载均衡将请求转发给node1，node1处理完，经过SNAT，将响应返回给node2，再由node2响应回client，保证了client请求node2后得到的响应也是node2的，此时Pod只知道请求的来源，并不知道真正的发起方；&lt;/p&gt;
&lt;p&gt;如果Service设置了&lt;code&gt;spec.extrnalTrafficPolicy=local&lt;/code&gt;，Pod接收到请求，可以知道真正的外部发起方是谁了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;type=LoadBalancer，设置一个外部均衡服务，这个一般由公有云提供&lt;/strong&gt;，比如aws的NLB，阿里云的LB服务，此时会有ExternalIP，执行LB的域名。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;**type=ExternalName，**并设置externalName的值，此时不会产生EndPoints、clusterIP，&lt;strong&gt;作用是为这个externalName设置了CName，主要用于集群内的Pod访问集群外的服务&lt;/strong&gt;。比如ExternalName设置为www.google.com，此时pod可以直接通过&lt;code&gt; [svc名称].[namespace名称].svc.cluster.local&lt;/code&gt;即可访问www.google.com&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;设置externalIPs的值，这样也能通过该ip进行访问，前提是该IP对公网暴露，比如aws的弹性ip。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过port forward的方式，将Pod端口转发到执行命令的那台机器上，通过端口映射提供访问，而不需要Service。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;检查网络是否有问题，一般先检查Master节点的Service DNS是否正常、kube-dns(coreDns)的运行状态和日志；&lt;/p&gt;
&lt;p&gt;当无法通过ClusterIP访问Service访问时，检查Service是否有Endpoints，检查Kube-proxy是否正确运行；&lt;/p&gt;
&lt;p&gt;最后检查宿主机上的iptables。&lt;/p&gt;
&lt;h3 id=&#34;关于服务发现&#34;&gt;关于服务发现&lt;/h3&gt;
&lt;p&gt;Kubernetes支持两种服务发现：环境变量和DNS服务&lt;/p&gt;
&lt;h4 id=&#34;环境变量&#34;&gt;环境变量&lt;/h4&gt;
&lt;p&gt;创建Service时，会在Service selector的Pod中的容器注入同一namespace下所有service的IP和端口作为环境变量，该环境变量会随着Service的IP和端口的改变而改变，但设置到容器里的环境变量不会。&lt;/p&gt;
&lt;p&gt;可以使用&lt;code&gt;kubectl exec -it {pod名字} -n {名称空间} env&lt;/code&gt;查看，HOST为service的cluster-IP&lt;/p&gt;
&lt;p&gt;Kubernetes会设置两类环境变量：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;service环境变量&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span class=&#34;na&#34;&gt;{service名称}_SERVICE_HOST&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;172.20.97.162&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;{service名称}_SERVICE_PORT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;8080&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Docker Link环境变量&lt;/p&gt;
&lt;p&gt;DockerLink的作用：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;同一个宿主机上的多个docker容器之间如果想进行通信，可以通过使用容器的ip地址来通信，也可以通过宿主机的ip加上容器暴露出的端口号来通信，前者会导致ip地址的硬编码，不方便迁移，并且容器重启后ip地址会改变，除非使用固定的ip，后者的通信方式比较单一，只能依靠监听在暴露出的端口的进程来进行有限的通信。通过docker的link机制可以通过一个name来和另一个容器通信，link机制方便了容器去发现其它的容器并且可以安全的传递一些连接信息给其它的容器。&lt;/p&gt;
&lt;p&gt;使用时需要先连接容器，使用命令&lt;code&gt;docker run -d --name {容器名称} --link {另一个容器名称}&lt;/code&gt;，之后在容器内即可使用对方容器的名称进行通信&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span class=&#34;na&#34;&gt;{service名称}_PORT_8080_TCP_ADDR&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;172.20.97.162&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;{service名称}_PORT_8080_TCP_PORT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;8080&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;{service名称}_PORT_8080_TCP_PROTO&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;tcp&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;{service名称}_PORT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;tcp://10.100.251.57:8080&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;{service名称}_PORT_8080_TCP&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;tcp://10.100.251.57:8080&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然后，服务即可通过环境变量获取要访问的服务的IP和端口，但是这种服务发现方式有一些&lt;strong&gt;缺点&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;先前的服务必须先运行起来，否则环境变量无法被注入，导致Pod无法使用该环境变量；&lt;/li&gt;
&lt;li&gt;如果依赖的service被删了或绑定了新地址，环境变量不会被修改，仍然使用旧有地址；&lt;/li&gt;
&lt;li&gt;只有在同一namespace下的Pod内才可以使用此环境变量进行访问，不同namespace下无法通过变量访问；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;dns服务&#34;&gt;DNS服务&lt;/h4&gt;
&lt;p&gt;一般情况下，会使用CoreDNS作为Kubernetes集群的DNS，&lt;strong&gt;CoreDNS默认配置的缓存时间是30s&lt;/strong&gt;，增大cache时间对域名解析TTL敏感型的应用有一定的影响，会延缓应用感知域名解析配置变更时间。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Kubernetes 通过修改每个 Pod 中每个容器的域名解析配置文件&lt;code&gt;/etc/resolv.conf&lt;/code&gt; 来达到服务发现的目的&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# /etc/resolv.conf&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# nameserver表示DNS服务器&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;nameserver 172.20.0.10&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 主机名查询列表，默认只包含本地域名，阈值为6个，256个字符，会以 {名称空间}.svc.cluster.local、svc.cluster.local、cluster.local 3个后缀，最多进行8次查询 (IPV4和IPV6查询各四次) 才能得到正确解析结果&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;search {名称空间}.svc.cluster.local svc.cluster.local cluster.local&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 阈值为 15&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;options ndots:5&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 等待 DNS 服务器响应的超时时间，单位为秒。阈值为 30 s。&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;options timeout: 30&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;# 向同一个 DNS 服务器发起重试的次数，单位为次。阈值为 5。&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;options attempts: 1&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;nameserver指向的IP，就是 coreDNS 的service的ClusterIP，所有的域名解析都需要经过coreDNS的ClusterIP来进行解析，不论是Kubernetes内部域名还是外部域名；&lt;/p&gt;
&lt;p&gt;coreDNS会监听集群内所有ServiceAPI，以在服务不可用时移除记录，在新服务创建时插入新记录，记录存储在coreDNS的本地缓存中。&lt;/p&gt;
&lt;p&gt;在这个&lt;code&gt;/etc/resolv.conf&lt;/code&gt;里配置含义为：DNS服务器为172.20.0.10，当查询的关键词中的 &lt;code&gt;.&lt;/code&gt; 的数量少于5个，则根据search中配置的域名进行查询，当查询都没有返回正确响应时再尝试查询关键词本身，比如执行&lt;code&gt;host -v cn.bing.com&lt;/code&gt;，会得到&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span class=&#34;na&#34;&gt;Trying &amp;#34;cn.bing.com.{名称空间}.svc.cluster.local&amp;#34;&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;Trying &amp;#34;cn.bing.com.svc.cluster.local&amp;#34;&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;Trying &amp;#34;cn.bing.com.cluster.local&amp;#34;&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;Trying &amp;#34;cn.bing.com.us-west-2.compute.internal&amp;#34;&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;Trying &amp;#34;cn.bing.com&amp;#34;&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;...&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;所以，直接请求集群内部同一namespace下的域名时效率最高，因为只需要查询一次即可找到，比如在同一namespace下直接&lt;code&gt;curl {服务service名} &lt;/code&gt;的效率是比&lt;code&gt;curl {服务service名}.{namespace}&lt;/code&gt;要高，因为少了一次域名查询。这种DNS查询解析叫&lt;strong&gt;非全限定域名查找&lt;/strong&gt;，因为我们配置了&lt;code&gt;ndots=5&lt;/code&gt;，所以当域名中&lt;code&gt;.&lt;/code&gt; 的个数小于5个，就会走search查询解析，如果要使用全限定域名查找，则需要在域名后面加&lt;code&gt;.&lt;/code&gt;，就不会走search查询解析了，比如当&lt;code&gt;cn.bing.com.&lt;/code&gt;此时就只会查询一次了，查不到才会走search查询。也可以通过修改&lt;code&gt;ndots&lt;/code&gt;的数量，来减少域名查询次数的问题，可以在Pod的配置中添加&lt;code&gt;dnsConfig&lt;/code&gt;修改&lt;code&gt;ndots&lt;/code&gt;的值。当容器内部的&lt;code&gt;/etc/resolv.config&lt;/code&gt;都找不到时，就会使用宿主机的&lt;code&gt;/etc/resolv.config&lt;/code&gt;进行查找。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Kubernetes 集群中支持通过 dnsPolicy 字段为每个 Pod 配置不同的 DNS 策略。目前支持四种策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ClusterFirst：通过集群 DNS 服务来做域名解析，Pod 内 /etc/resolv.conf 配置的 DNS 服务地址是集群 DNS 服务的 CoreDNS 地址。该策略是集群工作负载的默认策略；&lt;/li&gt;
&lt;li&gt;None：忽略集群 DNS 策略，需要您提供 dnsConfig 字段来指定 DNS 配置信息；&lt;/li&gt;
&lt;li&gt;Default：Pod 直接继承集群节点的域名解析配置。即在集群直接使用节点的 /etc/resolv.conf 文件；&lt;/li&gt;
&lt;li&gt;ClusterFirstWithHostNetwork：强制在 hostNetWork 网络模式下使用 ClusterFirst 策略（默认使用 Default 策略）&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;另外，Kubernates的DNS服务支持Service的A记录、SRV记录（用于通用化地定位服务）和CNAME记录。&lt;/p&gt;
&lt;p&gt;当设置了service并select了一类pod之后，DNS服务就会产生以下A记录和SRV记录&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span class=&#34;na&#34;&gt;{service名称}.{名称空间}.svc.cluster.local. 5 IN A 10.100.71.56&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;_http._tcp.{service名称}.{名称空间}.svc.cluster.local. 30 IN SRV 10 100 443 {service名称}.{名称空间}.svc.cluster.local.&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果是headless service，则生成的A记录如下&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-ini&#34; data-lang=&#34;ini&#34;&gt;&lt;span class=&#34;na&#34;&gt;{service名称}.{名称空间}.svc.cluster.local. 5 IN A 192.168.62.111&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;{service名称}.{名称空间}.svc.cluster.local. 5 IN A 192.168.62.112&lt;/span&gt;
&lt;span class=&#34;na&#34;&gt;{service名称}.{名称空间}.svc.cluster.local. 5 IN A 192.168.62.113&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;ingress&#34;&gt;Ingress&lt;/h2&gt;
&lt;p&gt;工作在第七层，应用层，即一般代理HTTP流量。&lt;/p&gt;
&lt;p&gt;作用与Service类似，主要是用于对多个service的包装，作为service的service，设置一个统一的负载均衡（这样可以避免每个Service都设置一个LB，也可以避免因为节点扩缩容导致service的端口变化需要修改访问配置），设置Ingress rule，进行反向代理，实现的是HTTP负责均衡。&lt;/p&gt;
&lt;p&gt;Ingress是反向代理的规则，Ingress Controller是负责解析Ingress的规则后进行转发。可以理解为Nginx，本质是将请求通过不同的规则进行路由转发。常见的Ingress Class实现有Nginx-Ingress-Controller、AWS-LB-Ingress-Controller，使用Ingress时会在集群中创建对应的controller pod。&lt;/p&gt;
&lt;p&gt;Ingress Controller可基于Ingress资源定义的规则将客户端请求流量直接转发到Service对应的后端Pod资源上（比如aws-lb-ingress-controller 的 IP mode），其会绕过Service资源，直接转发到Pod上，省去了kube-proxy实现的端口代理开销。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;c&#34;&gt;# 使用aws alb作为ingress，并将流量转发istio-ingressgateway service&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;extensions/v1beta1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Ingress&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-system&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-api&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-api&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;annotations&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kubernetes.io/ingress.class&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;alb&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;alb.ingress.kubernetes.io/load-balancer-name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;online-api&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;alb.ingress.kubernetes.io/target-type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;instance&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;alb.ingress.kubernetes.io/listen-ports&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;[{&amp;#34;HTTPS&amp;#34;:443}, {&amp;#34;HTTP&amp;#34;:80}]&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;alb.ingress.kubernetes.io/certificate-arn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;xxx&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;alb.ingress.kubernetes.io/scheme&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;internet-facing&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;alb.ingress.kubernetes.io/tags&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;app=eks&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;alb.ingress.kubernetes.io/load-balancer-attributes&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;deletion_protection.enabled=true,access_logs.s3.enabled=true,access_logs.s3.bucket=regoo-logs,access_logs.s3.prefix=alb&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;paths&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;backend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-ingressgateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;servicePort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;80&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/*&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;backend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;serviceName&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-ingressgateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;servicePort&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;443&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;和istio-ingressgateway的区别&#34;&gt;和Istio Ingressgateway的区别&lt;/h3&gt;
&lt;p&gt;Istio Ingressgateway是Kubernate Ingress Controller的一种实现，能够支持更多方式的流量管理。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Nginx Ingress Controller&lt;/th&gt;
&lt;th&gt;Istio Ingressgateway&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;根据HTTP Header选择路由规则&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Header规则支持正则表达式&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;服务之间设置权重拆分流量&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Header和权重规则组合使用&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;路由规则检查&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;路由规则粒度&lt;/td&gt;
&lt;td&gt;Service&lt;/td&gt;
&lt;td&gt;Service下的不同Pod&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;支持的协议&lt;/td&gt;
&lt;td&gt;HTTP1.1/HTTP2/gRpc&lt;!-- raw HTML omitted --&gt;TCP/Websockets&lt;/td&gt;
&lt;td&gt;HTTP1.1/HTTP2/gRpc&lt;!-- raw HTML omitted --&gt;TCP/Websockets/MongoDB&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;rbac&#34;&gt;RBAC&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Role和RoleBinding：只针对某一namespace的操作授权，namespace只是逻辑上的隔离&lt;/strong&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下配置就是给用户名为example-user绑定了一个example-role的角色，该角色只能操作namespace为mynamespace下的pod的所有读操作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Role &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;mynamespace &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;example-role &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;apiGroups&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;pods&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;verbs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;get&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;watch&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;list&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;RoleBinding&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;example-rolebinding &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;mynamespace &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subjects&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;User &lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 这里的User，是Kubernetes内置的用户类型，只是一个授权的逻辑概念&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;example-user &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;roleRef&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Role &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;example-role &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ClusterRole和ClusterRoleBinding：针对的是整个集群的操作的授权&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以下配置就是给用户名为example-user绑定了一个example-role的角色，该角色能对整个集群下的Pod进行读操作。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ClusterRole &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;example-clusterrole &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;rules&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;apiGroups&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;resources&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;pods&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;verbs&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;get&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;watch&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;list&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ClusterRoleBinding&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;example-clusterrolebinding &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subjects&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;User &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;example-user &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;roleRef&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ClusterRole &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;example-clusterrole &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;rbac.authorization.k8s.io&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;verbs操作可以有get、list、watch、create、update、patch、delete。&lt;/p&gt;
&lt;p&gt;resources指的是configmaps、pods、services、deployments、nodes，即所有定义的CRD。&lt;/p&gt;
&lt;p&gt;resourceNames指定是对应资源的名称。&lt;/p&gt;
&lt;p&gt;subjects的类型不止有User，也可以是ServiceAccount，创建该service后，k8s会自动为其分配一个Secret对象，该字段保存一个用来与API Server交互的token，token的内容可以是证书或者密码，以Secret对象的方式保存在etcd中。&lt;/p&gt;
&lt;p&gt;在Pod中也可以使用ServiceAccount，通过serviceAccountName字段配置使用，如果Pod没有显式使用ServiceAccount，K8s会使用默认的拥有绝大多数权限的default ServiceAccount。创建完ServiceAccount后，会在K8s中产生一个用户名和用户组，&lt;/p&gt;
&lt;p&gt;用户名：system:serviceaccount:&amp;lt;Namespace名字&amp;gt;:&amp;lt;ServiceAccount名字&amp;gt;&lt;/p&gt;
&lt;p&gt;用户组：system:serviceaccount:&amp;lt;Namespace名字&amp;gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1 &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ServiceAccount &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;mynamespace &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;example-user&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在K8s内，已经内置了很多系统保留的ClusterRole，给Master节点内的组件使用，以system:开头；此外，还有一些权限粒度比较大的ClusterRole，如cluster-admin(拥有最高权限)、admin、edit、view&lt;/p&gt;
&lt;h2 id=&#34;声明式api&#34;&gt;声明式API&lt;/h2&gt;
&lt;p&gt;通过编排对象，在为它们定义服务的这种方法，就称为声明式API。&lt;/p&gt;
&lt;p&gt;Pod就是一种API对象，每一个API对象都有一个Metadata字段，表示元数据，通过里面的labels字段（键值对）来找到这个API对象；每一个API对象都有一个Spec字段，来配置这个对象独有的配置，如为Pod添加挂载的Volume。&lt;/p&gt;
&lt;p&gt;命令式配置文件操作：编写一个yaml配置，使用&lt;code&gt;kubectl create -f config.yaml&lt;/code&gt;创建controller和Pod，然后修改yaml配置，使用&lt;code&gt;kubectl replace -f config.yaml&lt;/code&gt;，更新controller和Pod，API-Server一次只能处理一个命令；或者直接使用命令 &lt;code&gt;kubectl set image ... &lt;/code&gt;或 &lt;code&gt;kubectl edit ...&lt;/code&gt; 这些都属于命令式的。&lt;/p&gt;
&lt;p&gt;声明式配置文件操作：编写yaml配置和更新yaml配置均使用&lt;code&gt;kubectl apply -f config.yaml&lt;/code&gt;，API-Server一次处理多个命令，并且具备merge能力。&lt;/p&gt;
&lt;p&gt;命令式是告诉API-Server我要做什么操作，而声明式是告诉API-Server我要达到什么样的效果，幂等的操作。&lt;/p&gt;
&lt;p&gt;所以声明式API可以解决命令式API因为反复重试导致的错误，或者 并发执行时产生的问题。&lt;/p&gt;
&lt;h3 id=&#34;工作原理&#34;&gt;工作原理&lt;/h3&gt;
&lt;p&gt;k8s根据我们提交的yaml文件创建出一个API对象，一个API对象在etcd里的完整资源路径是由Group（API 组）、Version（API 版本）和 Resource（API 资源类型）三个部分组成的。&lt;/p&gt;
&lt;p&gt;一个资源可以有多个版本，版本和资源的信息会存储在etcd中，但&lt;strong&gt;etcd只会存储资源的一个指定版本&lt;/strong&gt;，当客户端传入的yaml文件中指定的资源版本和客户端向API-Server请求的资源版本可能并不是etcd中存储的版本时，会进行版本转换（通过在资源中定义 &lt;code&gt;served：控制某个版本是否可读写；storage：判断是否有多个版本&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;API-Server会维护一个internal版本，当需要版本转换时，任意版本都会先转换为internal版本，再由internal版本转换为指定的目标版本，所以只要保证每个版本都能转换成internal版本，即可支持任意版本间的转换了，对应的CRD代码也要支持新老版本的切换。需要编写conversion webhook，这样请求在到达controller时，就会经过webhook进行转换。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/API%e5%af%b9%e8%b1%a1%e6%a0%91%e5%bd%a2%e7%bb%93%e6%9e%84.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/API%e5%af%b9%e8%b1%a1%e6%a0%91%e5%bd%a2%e7%bb%93%e6%9e%84.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;G：group、V：version、R：resource、K：kind&lt;/p&gt;
&lt;p&gt;分为有组名，比如&lt;code&gt;/apis/app/v1/deployment&lt;/code&gt; 和 无组名，比如&lt;code&gt;/api/v1/pods&lt;/code&gt;，无组名也被称为核心资源组，CoreGroup。&lt;/p&gt;
&lt;p&gt;接口调用时，只需要知道GVR即可，通过GVR操作资源对象。通过GVK信息获取要读取的资源对象的GVR，进而构建RESTful API请求获取对应的资源，通过GVK和GVR的映射叫做RESTMapper，其作用是在ListerWatcher时，根据Schema定义的类型GVK解析出GVR，向API-Server发起HTTP请求获取资源，然后Watch。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;batch/v2alpha1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;CronJob&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;以上面的配置为例，CronJob是API对象的资源类型、batch是组、v2alpha1是版本&lt;/p&gt;
&lt;p&gt;核心API对象如Pod、Node是没有Group的，k8s是直接在/api这个层级进行下一步的匹配&lt;/p&gt;
&lt;p&gt;过程步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;yaml文件被提交给API-Server，API-Server接收到后完成前置工作，如授权、超时处理、审计；&lt;/li&gt;
&lt;li&gt;进入MUX和Routes流程，API-Server根据yaml提供的信息，使用上述的匹配过程，找到CronJob的类型定义；&lt;/li&gt;
&lt;li&gt;API-Server根据这个类型定义，根据yaml里CronJob的相关字段，创建一个CronJob对象，同时也会创建一个SuperVersion对象，它是API资源类型所有版本的字段全集，用于处理不同版本的yaml转成的CronJob对象；&lt;/li&gt;
&lt;li&gt;API-Server 会先后进行 Admission() 和 Validation() 操作，进行初始化和校验字段合法性，验证过后保存在Registry的数据结构中；&lt;/li&gt;
&lt;li&gt;API-Server把验证过的API对象转换成用户最初提交的版本，进行序列化操作，保存在etcd中；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;配置相关&#34;&gt;配置相关&lt;/h2&gt;
&lt;h3 id=&#34;pod级别下的一些配置即当kind-pod&#34;&gt;Pod级别下的一些配置，即当kind: Pod&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;NodeSelector&lt;/strong&gt;：将Pod和Node进行绑定的字段&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;nodeSelector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;disktype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ssd&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;表示该Pod只能运行在携带了disktype:ssd标签的节点上，否则它将调度失败&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HostAliases&lt;/strong&gt;：定义了Pod的hosts文件（比如/etc/hosts）里的内容&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hostAliases&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;10.1.2.3&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hostnames&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;foo.remote&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;bar.remote&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;表示在/etc/hosts文件的内容是将 ip 10.1.2.3映射为 foo.remote和bar.remote&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;shareProcessNamespace&lt;/strong&gt;: true，Pod里面的容器共享PID namespace，即在同一个Pod里的容器可以相互看到对方&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;hostNetwork&lt;/strong&gt;: true、hostIPC: true、hostPID: true表示共享宿主机的network、IPC、namespace&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;ImagePullPolicy&lt;/strong&gt;=alaways(默认)、never、ifNotPresent，每次创建Pod都会${value}拉取镜像&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Lifecycle&lt;/strong&gt;: 容器状态发生变化时触发的一系列钩子，属于container级别&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;lifecycle-demo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;containers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;lifecycle-demo-container&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;nginx&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;lifecycle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;postStart&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/bin/sh&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;-c&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;echo Hello from the postStart handler &amp;gt; /usr/share/message&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;preStop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;exec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;          &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;command&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;/usr/sbin/nginx&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;-s&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;quit&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在lifecycle里的postStart，指的是容器启动后，要执行的操作，但是它不是串行的，即在docker的ENTRYPOINT命令执行后就开始执行了，此时ENTRYPOINT命令执行的动作可能还没完成；preStart，指的是在容器被杀死之前，要执行的操作，只有这个动作执行完成，才允许容器被杀死&lt;/p&gt;
&lt;h2 id=&#34;常用命令&#34;&gt;常用命令&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;l&#34;&gt;对于处于terminating的pod或namespace的删除方法&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;. 将对应的pod或namespace转成json形式，将属性finalizers改为[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubectl get [pod或namespace] [对应的名称]  -o json |jq &amp;#39;.spec = {&amp;#34;finalizers&amp;#34;:[]}&amp;#39; &amp;gt; json文件名.json&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2.&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;打开另一个窗口，起一个代理&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubectl proxy --port=8081&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;3.&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;访问kubelet接口进行删除&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;curl -k -H &amp;#34;Content-Type: application/json&amp;#34; -X PUT --data-binary @json文件.json 127.0.0.1:8081/api/v1/[pod或namespaces]/[对应的名称]/finalize&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;或者：&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;删除状态为Terminating的命名空间&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubectl get ns [命名空间的值] -o json &amp;gt; xxxx.json，修改finialize为空数组[]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubectl replace --raw &amp;#34;/api/v1/namespaces/[命名空间的值]/finalize&amp;#34; -f xxx.json&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;删除指定命名空间下所有资源例如pod、deployment、svc，包括里面所有副本&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubectl delete all -n [命名空间] --all&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;删除命名空间下的event&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubectl delete events -n [命名空间] --all&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;启动busybox调试网络&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubectl run -it --rm --restart=Never busybox --image=busybox sh&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;查看node标签&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubectl get nodes --show-labels&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;给node设置标签&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubectl label nodes &amp;lt;your-node-name&amp;gt; disktype=ssd&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;删除节点&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;. 先排干上面的pod&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubectl drain node名称 --delete-local-data --force --ignore-daemonsets&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;. 删除&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubectl delete node node名称 &lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;查看滚动更新的流程&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubectl describe deploy [deploy名称] -n [名称空间]或者kubectl rollout status deploy [deploy名称] -n [名称空间]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;当新的版本有问题时，回滚到上个版本&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubectl rollout undo deploy [deploy名称] [--to-revision=n]&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;查看每次变更的版本，但最好在执行apply -f deployment.yaml后加上-record参数；&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubectl rollout history&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;如果不想每次修改都触发滚动更新，可以先使用`kubectl rollout pause deploy xx -n yy`暂停Ddeployment的行为，修改为yaml后使用`kubectl rollout resume deploy xx -n yy`恢复，让其只触发一次修改。&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;将镜像打成压缩包&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker save -o 压缩包名字  镜像名字:标签&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;还原成镜像&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker load &amp;lt; 压缩包名字&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;直接使用命令，不保持容器启动&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker run --rm --name kubectl bitnami/kubectl:latest version&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;启动时修改entrypoint&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker run --rm -it --entrypoint env 镜像:tag /bin/bash&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;构建镜像&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker build -t xxx:tag .&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;从容器里复制文件出来&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;docker cp 容器id:/容器内文件路径/文件名 /宿主机路径/文件名&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;滚动更新&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubectl patch deployment $APP-stable -n $NAMESPACE --patch &amp;#39;{&amp;#34;spec&amp;#34;: {&amp;#34;template&amp;#34;: {&amp;#34;metadata&amp;#34;: {&amp;#34;labels&amp;#34;:{&amp;#34;cm&amp;#34;:&amp;#34;stable&amp;#34;},&amp;#34;annotations&amp;#34;: {&amp;#34;version/config&amp;#34;: &amp;#34;&amp;#39;$DATE&amp;#39;&amp;#34; }}}}}&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;复制pod里的文件到当前机器&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;l&#34;&gt;kubectl cp [pod名字]:[work_dir]/文件名 -n [名称空间] -c [容器名称] ./复制后的文件名&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;servicemersh&#34;&gt;ServiceMersh&lt;/h1&gt;
&lt;h2 id=&#34;基本-1&#34;&gt;基本&lt;/h2&gt;
&lt;p&gt;Service Mesh本质上是分布式的微服务&lt;strong&gt;网络控制的代理&lt;/strong&gt;，以side car的方式实现：通过envoy+iptable对流量进行劫持，通过对流量的控制，实现诸如注册中心、负载均衡器、路由策略、熔断降级、限流、服务追踪等功能，而不需要耦合在具体的业务服务中，而Istio是其中一种实现。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;业务无需感知微服务组件，诸如限流、熔断、容错、降级、负载均衡等服务治理相关的中间件，这些功能全由ServiceMersh提供&lt;/li&gt;
&lt;li&gt;不限制开发语言和框架，提供多语言服务治理能力&lt;/li&gt;
&lt;li&gt;服务零成本升级，对服务无侵入，不会产生SDK依赖&lt;/li&gt;
&lt;li&gt;使得微服务体系统一管理和演进&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;部署复杂，比如跨集群、跨机房等一些复杂环境覆盖不易&lt;/li&gt;
&lt;li&gt;每次网络请求会多一跳，带来一定的资源消耗和延时&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在没有Service Mesh的情况下，Kubernetes仅依靠kube-proxy + iptable + service + ingress来实现对流量的管理，管理的是进出集群的流量，而Service Mersh通过iptables + sidecar的方式控制的是进出pod的流量，控制的粒度会更细。&lt;/p&gt;
&lt;p&gt;kube-proxy的设置是全局的，如果转发的pod不能正常服务，它不会自动尝试其他pod；另外，kube-proxy实现的是集群内多个pod实例之间的流量负载均衡，但无法对服务之间流量的精细化控制，比如灰度发布、蓝绿发布等。&lt;/p&gt;
&lt;h1 id=&#34;istio&#34;&gt;Istio&lt;/h1&gt;
&lt;p&gt;upstream和downstream是针对Envoy而言的，&lt;/p&gt;
&lt;p&gt;upstream：Envoy发送请求给服务，发出的流量是upstream&lt;/p&gt;
&lt;p&gt;downstream：发送请求给Envoy，Envoy接收的流量是downstream&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/envoy%e6%b5%81%e9%87%8f%e6%a8%a1%e5%9e%8b.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/envoy%e6%b5%81%e9%87%8f%e6%a8%a1%e5%9e%8b.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;xDS：控制平面与数据平面通信的统一API标准，包括 LDS（监听器发现服务）、CDS（集群发现服务）、EDS（节点发现服务）、SDS（密钥发现服务）和 RDS（路由发现服务）&lt;/p&gt;
&lt;p&gt;Istio核心功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;流量控制：路由（如灰度发布、蓝绿部署、AB测试）、流量转移、弹性（如超时重试、熔断）测试（如故障注入、流量镜像，模拟生产环境的流量进行测试）&lt;/li&gt;
&lt;li&gt;安全：认证、授权&lt;/li&gt;
&lt;li&gt;可观察：指标、日志、追踪&lt;/li&gt;
&lt;li&gt;策略：限流、黑白名单&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Istio分为控制平面control plane和数据平面data plane，控制面主要负责资源管理、配置下发、证书管理、控制数据面的行为等，数据面则负责流量出入口。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;控制平面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在低版本中分为Pilot、Mixer、Citadel；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Pilot负责配置下发，将配置文件转化为Istio可识别的配置项，分发给各个sidecar代理(piloy-agent)；Pilot能为sidecar提供服务发现、智能路由、流量管理、超时、重试、熔断灯功能，原理是将这些功能转化为路由规则配置，下发到各个sidecar中；&lt;/p&gt;
&lt;p&gt;pilot有两个子组件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;pilot-discovery：是控制面与数据面的桥梁，从kubernetes中获取服务信息，如service、endpoint、pod、node的资源信息；监控istio控制面的信息，如vs、gw、dr等，将服务信息和流量规则信息转化为数据面可以理解的格式，通过xDS下发到各个sidecar中；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pilot-agent：根据API-Server中配置的信息生成sidecar配置文件，负责启动、监控sidecar进程，是istio-proxy的一部分，注入到pod中；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;pilot-proxy：即pod中的istio-proxy，负责流量代理，直接连接pilot-discovery，间接获取集群中各个微服务的注册情况；istio-proxy发起的连接都是长连接，不受业务服务的影响，通过连接池维护；&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Citadel负责安全、授权认证，比如证书的分发和轮换，让sidecar代理两端实现双向TLS认证、访问授权；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Gallery负责配置管理，负责将istio组件与底层平台如Kubernetes获取用户配置的细节隔离开，对配置信息格式和正确性校验，将配置信息提供pilot使用，只与控制面的其他组件打交道，实现与底层平台解耦；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sidecar injector：在为配置了istio自动注入的pod自动注入istio-proxy；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mixer负责从数据平面收集数据指标以及流量策略，是一种插件组件，插件提供了很好的扩展性，独立部署，但每次修改需要重新部署，之后1.1版本将插件模块独立一个adaptor和Gallery，但是Mixer由于需要频繁的与sidecar进行通信，又是部署在应用进程外的，因此性能不高。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;高版本1.5后中分为将Pilot、Citadel、Gallery整合为istiod，同时istiod里也包含了CA、API-Server，配合ingressgateway、egressgateway管理流量。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;数据平面&lt;/strong&gt;：Pod中的每个Envoy容器，即istio-proxy；Envoy会以side car的方式运行在Pod中，利用Pod中的所有容器共享同一个Network Namespace的特性，通过配置Pod里的iptables规则，管理进出Pod的流量。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Istio-%e6%9e%b6%e6%9e%84.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Istio-%e6%9e%b6%e6%9e%84.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;istio-proxy的作用：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;客户端功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发现和负载平衡。代理可以使用几个标准的服务发现和负载平衡API，以有效地将流量分配给服务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;凭证注入。代理可以通过连接隧道或特定于协议的机制（例如HTTP请求的JWT令牌）注入客户端身份。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接管理。代理管理与服务的连接，处理运行状况检查，重试，故障转移和流控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;监控和记录。代理可以报告客户端指标并记录到混合器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务器端功能：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;速率限制和流量控制。代理可以防止后端系统过载，并提供客户端感知的速率限制。&lt;/li&gt;
&lt;li&gt;协议翻译。代理是gRPC网关，提供JSON-REST和gRPC之间的转换。&lt;/li&gt;
&lt;li&gt;认证与授权。代理支持多种身份验证机制，并且可以使用客户端身份通过混合器执行授权检查。&lt;/li&gt;
&lt;li&gt;监控和记录。代理可以报告服务器端指标并记录到混合器。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;自动注入实现&#34;&gt;自动注入实现&lt;/h2&gt;
&lt;p&gt;依赖Kubernetes中的Dynamic Admission Control的功能，也叫Initializer。&lt;/p&gt;
&lt;p&gt;Istio会将Envoy容器本身的定义，以configMap的方式进行保存，当用户提交自己的Pod时，Kubernetes就会通过类似git merge的方式将两份配置进行合并。这个合并的操作会由envoy-initializer的Pod来实现，该Pod使用 循环控制，不断获取用户新创建的Pod，进行配置合并。&lt;/p&gt;
&lt;h2 id=&#34;核心crd&#34;&gt;核心CRD&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;VirtualService&lt;/strong&gt;：路由规则，主要是把请求的流量路由到指定的目标地址，解耦请求地址与工作负载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DistinationRule&lt;/strong&gt;：定义了VirtualService里配置的具体的目标地址形成子集，设置负载均衡模式，默认是随机策略。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上面两个主要是管理服务网格内部的流量。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Gateway（ingress gateway）&lt;/strong&gt;：是网格的边界，管理进出网格的流量，比如为进出的流量增加负载均衡的能力，增加超时重试的能力，有ingress gateway和egress gateway分别管理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;与k8s Ingress的区别&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;k8s Ingress只支持7层协议，比如http/https，不支持tcp、udp这些，没有VirtualService，直接对的Service&lt;/li&gt;
&lt;li&gt;Gateway支持 4 - 6 层协议，只设置入口点，配合VirtualService解耦路由规则的绑定，实现路由规则复用。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ServiceEntry&lt;/strong&gt;：面向服务，将外部的服务注册到服务网格中，为其转发请求，添加超时重试等策略，扩展网格，比如连接不同的集群，使用同一个istio管理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sidecar使用Envoy，代理服务的端口和协议。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;Gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;public-api-gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;regoo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;istio-ingressgateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;istio&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;ingressgateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 入口配置&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;servers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;protocol&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;HTTP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;api.xxx.com&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;VirtualService&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;regoo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 只允许请求来自该host的流量&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;hosts&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;s2&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 绑定Gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;gateways&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;l&#34;&gt;public-api-gateway&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  	&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 路由匹配&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;uri&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;prefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;/order/v1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;route&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;destination&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;              &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;stable&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nn&#34;&gt;---&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DestinationRule&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;namespace&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;regoo&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;app&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;subsets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;- &lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;stable&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;labels&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;stable&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;VirtualService和DestinationRule：按服务版本路由、按比例切分流量、根据匹配规则进行路由(比如请求头必须包含xx)、路由策略(如负载均衡，连接池)&lt;/p&gt;
&lt;p&gt;蓝绿部署：同时准备两套环境，控制流量流向不同环境或版本：两套集群，一套是现有在使用的集群（蓝色），另一套用于上线前的测试和验证后进行切换的集群（绿色），都可以接受流量，先放少量流量到绿色集群，没问题之后再把蓝色集群的所有流量切到绿色集群，蓝色集群再进行升级；&lt;/p&gt;
&lt;p&gt;灰度发布(金丝雀发布)：小范围测试和发布，即按比例切分流量；让一部分用户先用老服务A，一部分用新服务B，后面再根据具体情况，全部迁移到B；&lt;/p&gt;
&lt;p&gt;A/B测试：类似灰度发布，只是侧重点不同，灰度发布最终流量会流向最新版本，而A/B测试只是用于测试A、B两个环境带来的影响。&lt;/p&gt;
&lt;p&gt;这两个可以用于ingressgateway或egressgateway&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Gateway：暴露集群内的服务给外界访问、将集群内部的服务以https的方式暴露、作为统一应用入口、API聚合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ServiceEntry：添加外部的服务到网格，从而管理外部服务的请求，扩大网格，默认情况下，Istio允许网格内的服务访问外部服务，当全部禁止后，需要使用ServiceEntry注册外部服务，以供网格内部的服务使用，一般配合engressgateway，控制网格内部向外部服务发出的请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;超时和重试：通过virtualService的route配置&lt;code&gt;timemout&lt;/code&gt;设置服务接收请求处理的超时时间，&lt;code&gt;retries.attempts&lt;/code&gt;和&lt;code&gt;retries.perTryTimeout&lt;/code&gt;设置重试次数和重试时间间隔，&lt;code&gt;retries.retryOn&lt;/code&gt;设置重试条件&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;熔断：通过DestinationRule的trafficPolicy里connectionPool和outlierDection的配置实现&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-yaml&#34; data-lang=&#34;yaml&#34;&gt;&lt;span class=&#34;nt&#34;&gt;apiVersion&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;networking.istio.io/v1alpha3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;kind&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;DestinationRule&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;metadata&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;httpnin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;spec&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;httpbin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;trafficPolicy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;connectionPool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;tcp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;maxConnections&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 	&lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# tcp最大连接数&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;http1MaxPendingRequests&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 每个连接能处理的请求数&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;maxRequestsPerConnection&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 最大被阻挡的请求数&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;outlierDetection&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;consecutiveErrors&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 允许出错的次数&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;interval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;1s&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 失败次数计数时间&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;baseEjectionTime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;l&#34;&gt;3m&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 最小驱逐时间，经过此时间后将pod重新加入，默认30s，乘于触发次数后作为熔断持续时间&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;      &lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;maxEjectionPercent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;m&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c&#34;&gt;# 熔断触发时驱逐pod的比例&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;故障注入：通过VirtualService的fault配置实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流量镜像：通过VirtualService的&lt;code&gt;mirror&lt;/code&gt;和&lt;code&gt;mirrorPercentage&lt;/code&gt;配置，比如将发送给v1版本的真实流量镜像一份给v2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;限流：1.5之前有Mixer提供，但是1.5之后移除了Mixer，只能使用Envoy + filter实现，不属于istio生态的了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;授权认证，Istio的认证更多的是服务间的访问认证，可根据namespace、具体的服务、服务的接口、请求方法、请求头、请求来源等进行设置&lt;/p&gt;
&lt;p&gt;对外提供HTTPS mTLS访问方式，设置域名证书和Gateway即可；设置网格内部的mTLS双向认证；设置JWT认证，使用RequestAuthentication资源进行认证配置，使用AuthorizationPolicy 资源进行授权配置；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;调试&#34;&gt;调试&lt;/h2&gt;
&lt;p&gt;使用istioctl的dashboard工具、Envoy的admin接口、Pilot的debug接口等，查看网格的信息，比如资源使用率、日志级别、Envoy性能相关信息等&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;istioctl x describe pod [pod名称]&lt;/code&gt;，查看pod是否在网格内，验证其VirtualService、DestinationRule、路由等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;istioctl analyze [-n 命名空间名称] 或 [具体的yaml文件] 或 --use-kube=false [yaml文件]；只分析文件&lt;/code&gt;进行网格配置的诊断&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;istioctl d [istiod的pod名称] -n istio-system&lt;/code&gt;使用controlZ可视化自检工具，调整日志输出级别、内存使用情况、环境变量、内存信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;istioctl d envoy [pod名称].[命名空间] &lt;/code&gt;使用Envoy的admin接口，进行Envoy的日志级别调整、性能数据分析、配置、指标信息的查看&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;kubectl port-forward service/istio-pilot -n istio-system 端口:端口&lt;/code&gt;使用pilot的debug接口，查看xDS和配置信息、性能问题分析、配置同步情况&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;istioctl dashboard [controlZ/envoy/Grafana/jaeger/kiali/Prometheus/zipkin]&lt;/code&gt;使用istio提供的工具&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;istioctl ps(proxy-status的缩写) [pod名称]&lt;/code&gt;进行配置同步检查。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;istioctl pc(proxy-config的缩写) [cluster/route...] [pod名称].[命名空间]&lt;/code&gt;查看配置详情。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;istioctl proxy-config routes [istio-ingressgateway pod的名字] -n istio-system&lt;/code&gt;查看istio整个服务网格的配置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;envoy调试&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;进到pod里之后，修改envoy的日志级别
curl -XPOST http://localhost:15000/logging?level=debug
curl -XPOST http://localhost:15000/logging?level=info
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;极客时间-深入剖析k8s-张磊&lt;/p&gt;
&lt;p&gt;极客时间-ServiceMesh实战-马若飞&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.lixueduan.com/post/kubernetes/04-service-core/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Service核心原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/80141656&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;KubeDNS和CoreDNS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://draveness.me/kubernetes-volume/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;详解 Kubernetes Volume 的实现原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://draveness.me/kubernetes-replicaset/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;详解 Kubernetes ReplicaSet 的实现原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://draveness.me/kubernetes-garbage-collector/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;详解 Kubernetes 垃圾收集器的实现原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://draveness.me/kubernetes-daemonset/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;详解 Kubernetes DaemonSet 的实现原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://draveness.me/kubernetes-deployment/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;详解 Kubernetes Deployment 的实现原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://draveness.me/kubernetes-service/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;详解 Kubernetes Service 的实现原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://draveness.me/kubernetes-pod/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;详解 Kubernetes Pod 的实现原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://draveness.me/understanding-kubernetes/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;谈 Kubernetes 的架构设计与实现原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://kingjcy.github.io/post/cloud/paas/base/kubernetes/k8s-apiserver/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;云计算K8s组件系列（一）&amp;mdash;- K8s apiserver 详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/rfyiamcool/notes/blob/main/kubernetes_client_go_workqueue_code.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;源码分析 kubernetes client-go workqueue 的实现原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/rfyiamcool/notes/blob/main/kubernetes_scheduler_code.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;源码分析 kubernetes scheduler 核心调度器的实现原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.infoq.cn/article/cpxr35bwjttgncltyekz&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gRPC 长连接在微服务业务系统中的实践&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.hwchiu.com/k8s-network-issue.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;從網路觀點來看導入 Kubernetes 的可能痛點&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>容器</title>
        <link>http://nixum.cc/p/%E5%AE%B9%E5%99%A8/</link>
        <pubDate>Sat, 06 Nov 2021 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/%E5%AE%B9%E5%99%A8/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;底层原理&#34;&gt;底层原理&lt;/h1&gt;
&lt;p&gt;容器技术的核心功能，就是通过约束和修改进程的动态表现，从而为其创造出一个边界。&lt;/p&gt;
&lt;h2 id=&#34;namespace---隔离&#34;&gt;Namespace - 隔离&lt;/h2&gt;
&lt;p&gt;进程只能看到被规定的视图，即 隔离，比如通过docker启动一个/bin/sh，再在容器里通过ps命令查看该/bin/sh进程的pid，会发现它的pid是1，但是实际上它在外部的宿主机里的pid是10，使得让在容器里运行的进程以为自己就在一个独立的空间里，实际上只是进行了逻辑的划分，本质还是依赖宿主机。&lt;/p&gt;
&lt;p&gt;作用：在同一台宿主机上运行多个用户的容器，充分利用系统资源；不同用户之间不能访问对方的资源，保证安全。&lt;/p&gt;
&lt;p&gt;常见的Namespace类型有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PID Namespace：隔离不同容器的进程&lt;/li&gt;
&lt;li&gt;Network Namespace：隔离不同容器间的网络&lt;/li&gt;
&lt;li&gt;Mount Namespace：隔离不同容器间的文件系统&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;与虚拟化的区别&lt;/strong&gt;：虚拟化是在操作系统和硬件上进行隔离，虚拟机上的应用需要经过虚拟机再经过宿主机，有两个内核，本身就有消耗，而容器化后的应用仅仅只是宿主机上的进程而已，只用到宿主机一个内核；&lt;/p&gt;
&lt;p&gt;因为namespace隔离的并不彻底，由于内核共享，容器化应用仍然可以把宿主机的所有资源都吃掉，有些资源不能通过namespace隔离，比如修改了容器上的时间，宿主机上的时间也会被改变，因此需要Cgroups；&lt;/p&gt;
&lt;h2 id=&#34;cgroups---资源限制&#34;&gt;Cgroups - 资源限制&lt;/h2&gt;
&lt;p&gt;是用来制造约束的主要手段，即控制进程组的优先级，设置进程能够使用的资源上限，如CPU、内存、IO设备的流量等&lt;/p&gt;
&lt;p&gt;比如，限定容器只能使用宿主机20%的CPU&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;docker run -it --cpu-period&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;100000&lt;/span&gt; --cpu-quota&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;20000&lt;/span&gt; ubuntu /bin/bash
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;Cgroups 通过不同的子系统限制了不同的资源，每个子系统限制一种资源。每个子系统限制资源的方式都是类似的，就是把相关的一组进程分配到一个控制组里，然后通过树结构进行管理，每个控制组都设有自己的资源控制参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;相互关系&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;每个子系统是一个控制组，每个控制组可以被看作是一个树的节点，每个控制组下可以有多个子节点，比如我们在在CPU子系统中，创建一个DB控制组，然后把所有运行的数据库服务放在其中，然后再在该组下再创建 MySQL和MongoDB两个子组来，分别划分不同的使用资源，所以形成了一颗树，大致就如下图&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Cgroup%e7%9b%b8%e4%ba%92%e5%85%b3%e7%b3%bb.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Cgroup%e7%9b%b8%e4%ba%92%e5%85%b3%e7%b3%bb.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/sys/fs/cgroup/cpu/{task}/&lt;/code&gt;目录表示task这个任务挂在了CPU Cgroup下，在这个目录下有很多的配置文件，比如&lt;code&gt;cpu.cfd_quota_us、cgroup.procs&lt;/code&gt;等，文件内容是该task所属进程的PID；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;/proc/{PID号}/cgroup&lt;/code&gt;文件表示这个进程涉及到的所有cgroup子系统的信息&lt;/p&gt;
&lt;p&gt;常见的Cgroups子系统&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CPU 子系统，用来限制一个控制组（一组进程，你可以理解为一个容器里所有的进程）可使用的最大 CPU，配合cfs（完全公平调度算法）实现CPU的分配和管理。&lt;/p&gt;
&lt;p&gt;cpu share：用于cfs中调度的权重，条件相同的情况下，cpushare值越高，分得的时间片越多。&lt;/p&gt;
&lt;p&gt;cpu set：主要用于设置CPU的亲和性，可以限制cgroup中的进程只能在指定的CPU上运行，或者不能在指定的CPU上运行，同时cpuset还能设置内存的亲和性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;memory 子系统，用来限制一个控制组最大的内存使用量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pids 子系统，用来限制一个控制组里最多可以运行多少个进程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cpuset 子系统， 这个子系统来限制一个控制组里的进程可以在哪几个物理 CPU 上运行。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Cgroups 有 v1 和 v2 两个版本，v1中每个进程在各个Cgroups子系统中独立配置，可以属于不同的group，比较灵活但因为每个子系统都是独立的，会导致对同一进程的资源协调困难，比如同一容器配置了Memory Cgroup和Blkio Cgroup，但是它们间无法相互协作。&lt;/p&gt;
&lt;p&gt;v2针对此做了改进，使各个子系统可以协调统一管理资源。&lt;/p&gt;
&lt;h2 id=&#34;mount-namespace与rootfs根文件系统&#34;&gt;Mount Namespace与rootfs(根文件系统)&lt;/h2&gt;
&lt;p&gt;挂载在容器根目录上、用来为容器进程提供隔离后执行环境的文件系统，即容器镜像，也是容器的根文件系统。Mount Namespace保证每个容器都有自己独立的文件目录结构。&lt;/p&gt;
&lt;p&gt;镜像可以理解为是容器的文件系统（一个操作系统的所有文件和目录），它是只读的，挂载在宿主机的一个目录上。同一台机器上的所有容器，都共享宿主机操作系统的内核，如果容器内应用修改了内核参数，会影响到所有依赖的应用。而虚拟机则都是独立的内核和文件系统，共享宿主机的硬件资源。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;上面的读写层通常也称为容器层，下面的只读层称为镜像层，所有的增删查改操作都只会作用在容器层，相同的文件上层会覆盖掉下层。比如修改一个文件的时候，首先会从上到下查找有没有这个文件，找到，就复制到容器层中，进行修改，修改的结果就会作用到下层的文件，这种方式也被称为copy-on-write。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;注意点&#34;&gt;注意点&lt;/h2&gt;
&lt;p&gt;容器是“单进程模型”，单进程模型并不是指容器只能运行一个进程，而是指容器没有管理多个进程的能力，它只能管理一个进程，即如果在容器里启动了一个Web 应用和一个nginx，如果nginx挂了，你是不知道的。&lt;/p&gt;
&lt;p&gt;另外，直到JDK 8u131以后，java应用才能很好的运用在docker中，在此之前可能因为docker隔离出的配置和环境，导致JVM初始化默认数值出错，因此如果使用以前的版本，需要显示设置默认配置，比如直接规定堆的最大值和最小值、线程数之类的&lt;/p&gt;
&lt;h1 id=&#34;进程&#34;&gt;进程&lt;/h1&gt;
&lt;p&gt;Linux中的进程状态&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Linux%e8%bf%9b%e7%a8%8b%e7%8a%b6%e6%80%81.jpeg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Linux%e8%bf%9b%e7%a8%8b%e7%8a%b6%e6%80%81.jpeg&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;活着的进程有两种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;运行态(TASK_RUNNING)：进程正在运行，或 处于run queue队列里等待&lt;/li&gt;
&lt;li&gt;睡眠态(TASK_INTERRUPTIBLE、TASK_UNINTERRUPTIBLE)：因为需要等待某些资源而被放在了wait queue队列，该状态包括两个子状态：
&lt;ul&gt;
&lt;li&gt;可被打断状态(TASK_INTERRUPTIBLE)：此时ps查看的Stat的值为 S&lt;/li&gt;
&lt;li&gt;不可被打断状态(TASK_UNINTERRUPTIBLE)：此时ps查看的Stat的值为 D&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;进程退出时会有两个状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;EXIT_ZOMBIE状态：僵尸状态；之所以有这个状态是为了给父进程可以查看子进程PID、终止状态、资源使用信息的机会，如果子进程直接消失，父进程则没有机会掌握子进程具体的终止情况。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;EXIT_DEAD状态：真正结束退出时一瞬间的状态&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;init进程&#34;&gt;init进程&lt;/h2&gt;
&lt;p&gt;init进程也称1号进程，是第一个用户态进程，由它直接或间接创建了Namespace中的其他进程。Linux系统本身在启动后也是这么干的，会先执行内核态代码，然后根据缺省路径尝试执行1号进程的代码，从内核态切换到用户态，比如Systemd。&lt;/p&gt;
&lt;p&gt;在容器中，无法使用SIGKILL(-9)和SIGTOP(19)这两个信号杀死1号进程，但对于其他kill信号(比如默认的kill信号是SIGTERM)，如果init进程注册了自己处理该信号的handler，则1号进程可以做出响应。但是，如果SIGKILL和SIGTOP信号是从Host Namespace里发出的，则可以被响应，因为此时容器里的1号进程在宿主机上只是一个普通进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;有时无法被kill掉的原因：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux执行kill命令，实际上只是发送了一个信号给到Linux进程，&lt;strong&gt;可被调度的进程&lt;/strong&gt;在收到信号后，一般会从 **默认行为(每个信号都有)、忽略、捕获后处理（需要用户进程自己针对这个信号做handler）**中进行操作，但SIGKILL和SIGTOP这两个信号是特权信号，不允许被自行捕获处理也无法忽略，只能执行系统的默认行为。&lt;/p&gt;
&lt;p&gt;执行kill命令时，会调用一系列内核函数进行处理，其中有一个函数&lt;code&gt;sig_task_ignored&lt;/code&gt;会判断是否要忽略这个信号。Linux内核里的每个Namespace里的init进程，会忽略只有默认handler的信号，即如果我们的进程有处理相关信号的handler，就可以响应。可以通过&lt;code&gt;cat /proc/{进程pid}/status | grep -i SigCgt&lt;/code&gt;查看该进程注册了哪些handler。&lt;/p&gt;
&lt;h2 id=&#34;zombie进程&#34;&gt;ZOMBIE进程&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;ps aux&lt;/code&gt;查看Linux进程，STAT里的状态是Z，ps后有defunct标记，表示该进程为&lt;strong&gt;僵尸进程，此时该进程不可被调度。僵尸进程是Linux进程退出状态的一种，进程处于此状态下，无法响应kill命令，虽然资源被释放，但是仍然占用着进程号&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;形成的原因：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;父进程在创建完子进程后，没有对子进程进行后续的管理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;影响：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Linux内核在初始化系统时，会根据CPU数目限制进程最大数量，通过&lt;code&gt;/proc/sys/kernel/pid_max&lt;/code&gt;查看，对Linux系统而言，容器是一组进程的集合，如果容器中的应用创建过多，就会出现fork bomb行为，不断建立新进程消耗系统资源，如果达到了Linux最大进程数，导致系统不可用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;因此对于容器，也要限制容器内的进程数量，通过pids Cgroup来完成，限制进程数目大小。在一个容器建立后，创建容器的服务会在&lt;code&gt;/sys/fs/cgroup/pids&lt;/code&gt;下建立一个子目录作为控制组，里面的pids.max文件表示容器允许的最大进程数目。当容器内进程达到最大限制后再起新进程，会报错&lt;code&gt;Resource temporarily unavailable&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当出现僵尸进程后，父进程可以调用wait函数（该函数是同步阻塞）或者调用waitpid函数（该函数仅在调用时检查僵尸进程，如果没有则返回，不会阻塞等待）回收子进程资源，避免僵尸进程 的产生。或者kill掉僵尸进程的父进程，此时僵尸进程会归附到init进程下，利用init进程的能力回收僵尸进程的资源。&lt;/p&gt;
&lt;p&gt;init进程是所有进程的父进程，init进程具备回收僵尸进程的能力。&lt;/p&gt;
&lt;p&gt;或者把容器内的init进程替换为tini进程，该进程具备自动回收收子进程的能力。&lt;/p&gt;
&lt;h2 id=&#34;进程的退出&#34;&gt;进程的退出&lt;/h2&gt;
&lt;p&gt;当我们停止一个容器时，比如&lt;code&gt;docker stop&lt;/code&gt;，容器内的init进程会收到SIGTERM信号，而其他进程会收到SIGKILL信号，这意味着只有init进程才能注册handler处理信号实现graceful shotdown，而其他进程不行，直接就退出了。&lt;/p&gt;
&lt;p&gt;如果想要容器内的其他进程能收到SIGTERM信号，只能在init进程中注册一个Handler，将收到的信号转发到子进程中，在init进程退出之前把子进程都停掉，子进程就不会收到SIGKILL信号了。&lt;/p&gt;
&lt;h1 id=&#34;cpu&#34;&gt;CPU&lt;/h1&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Linux_CPU%e4%bd%bf%e7%94%a8%e5%88%86%e7%b1%bb.jpeg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Linux_CPU%e4%bd%bf%e7%94%a8%e5%88%86%e7%b1%bb.jpeg&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;cpu-cgroup&#34;&gt;CPU Cgroup&lt;/h2&gt;
&lt;p&gt;容器会使用CPU Cgroup来控制CPU的资源使用。CPU Cgroup只会对用户态us和ni、内核态sys做限制，不对wa、hi、si这些I/O或者中断相关做限制。&lt;/p&gt;
&lt;p&gt;CPU Cgroup一般会通过一个虚拟文件系统挂载点的方式，挂载在&lt;code&gt;/sys/fs/cgroup/cpu&lt;/code&gt;目录下，每个子目录为一个控制组，各个目录间是一个树状的层级关系。&lt;/p&gt;
&lt;p&gt;对于普通调度类型，每个目录下有三个文件对应三个参数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cpu.cfs_period_us&lt;/code&gt;：CFS的调度周期，单位微秒&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cpu.cfs_quota_us&lt;/code&gt;：一个调度周期内该控制组被允许运行的时间，单位微秒，&lt;code&gt;CPU最大配额 = cpu.cfs_quota_us / cpu.cfs_period_us &lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;cpu.shares&lt;/code&gt;：CPU Cgroup对控制组之间的CPU分配比例，只有当控制组间的CPU配额超过了CPU可以资源的最大值，则会启用该参数进行配额分配。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux中 &lt;code&gt;cpu.cfs_period_us&lt;/code&gt; 是个固定值，Kubernetes的pod中，限制容器CPU使用率的requestCPU和limitCPU是通过调整其余两个参数来实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;在容器内使用top命令查看CPU使用率，显示的是宿主机的CPU使用率以及单个进程的CPU使用率，无法查到该容器的CPU使用率&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;因为top命令对于单个进程读取&lt;code&gt;/proc/[pid]/stat&lt;/code&gt;里面包含进程用户态和内核态的ticks数目，对于整个节点读取的是&lt;code&gt;/proc/stat&lt;/code&gt;里各个不同CPU类型的ticks数目，因为这些文件不属于任何一个Namespace，因此无法读取单个容器CPU的使用率，只能通过CPU Cgroup的控制组内的&lt;code&gt;cpuacct.stat&lt;/code&gt;参数文件计算得到，该参数文件包含了这个控制组里所有进程的内核态ticks和用户态ticks的值，带入公式即可计算得到。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ticks是Linux操作系统中的一个时间单位，Linux通过自己的时钟周期性产生中断，每次中断会触发内核做一次进程调度，一次中断就是一个ticks&lt;/p&gt;
&lt;p&gt;utime：表示进程在用户态部分在Linux调度中获得CPU的ticks，这个值会一直累加&lt;/p&gt;
&lt;p&gt;stime：表示进程在内核态部分在Linux调度中获得CPU的ticks，这个值会一直累加&lt;/p&gt;
&lt;p&gt;HZ：时钟频率&lt;/p&gt;
&lt;p&gt;et：utime_1和utime_2这两个值的时间间隔&lt;/p&gt;
&lt;p&gt;进程的 CPU 使用率 =((utime_2 – utime_1) + (stime_2 – stime_1)) * 100.0 / (HZ * et * CPU个数 )&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;load-average平均负载&#34;&gt;Load Average平均负载&lt;/h2&gt;
&lt;p&gt;Load Average是指&lt;strong&gt;Linux进程调度器中一段时间内，可运行队列里的进程平均数 + 休眠队列中不可打断的进程平均数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;所以，有可能在使用top命令时观察到 明明CPU空闲率很高，但是Load Average的数值也很高，CPU性能下降，因为此时休眠队列中有很多在等待的进程，这些进程的stat是D，这种状态可能是IO或者信号量锁的访问导致。&lt;/p&gt;
&lt;h1 id=&#34;内存&#34;&gt;内存&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;Linux进程的内存申请策略&lt;/strong&gt;：Linux允许进程在申请内存时overcommit，即允许进程申请超过实际物理内存上限的内存。因为申请只是申请内存的虚拟地址，只是一个地址范围，只有真正写入数据时，才能得到真实的物理内存，当物理内存不够时，Linux就会根据一定的策略杀死某个正在运行的进程，当容器内存使用率超过限制值时，容器就会出现OOM Killed。&lt;/p&gt;
&lt;p&gt;OOM Killed的标准是通过&lt;code&gt;oom_badness函数&lt;/code&gt;决定，通过以下两个值的乘积决定：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程已经使用的物理内存页面数&lt;/li&gt;
&lt;li&gt;每个进程的OOM校准值oom_score_adj，在&lt;code&gt;/proc/[pid]/oom_score_adj&lt;/code&gt;文件中，该值用于调整进程被OOM Kill的几率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Linux的内存类型&lt;/strong&gt;：有两类，一类是内核使用的内存，如页表、内核栈、slab等各种cache pool（匿名页）；另一类是用户态使用的内存，如堆内存、栈内存、共享库内存、文件读写的Page Cache（文件页）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;RSS（Resident Set Size）&lt;/strong&gt;：进程真正申请到的物理页面的内存大小，RSS内存包括了进程的代码段内存，堆内存、栈内存、共享库内存，每一部分RSS内存的大小可查看&lt;code&gt;/proc/[pid]/smaps&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Page Cache&lt;/strong&gt;：为了提高磁盘文件的读写性能，Linux在有空闲的内存时，默认会把读写过的页面放在Page Cache里，一旦进程需要更多的物理内存，但剩余的内存不够，则会使用(page frame reclaim)这种内存页面回收机制，根据系统里空闲物理内存是否低于某个阈值，决定是否回收Page Cache占用的内存。&lt;/p&gt;
&lt;h2 id=&#34;memory-cgroup&#34;&gt;Memory Cgroup&lt;/h2&gt;
&lt;p&gt;Memory Cgroup一般会通过一个虚拟文件系统挂载点的方式，挂载在&lt;code&gt;/sys/fs/cgroup/memory&lt;/code&gt;目录下，每个子目录为一个控制组，各个目录间是一个树状的层级关系。每个目录有很多参数文件，跟OOM相关的有3个&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;memory.limit_in_bytes&lt;/code&gt;：控制控制组里进程可使用的内存最大值，父节点的控制组内该值可以限制它的子节点所有进程的内存使用，Kubernetes的limit改的就是该值，而request仅在调度时计算节点是否满足。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memory.oom_control&lt;/code&gt;：当控制组中的进程内存使用达到上限时，该参数决定是否触发OOM Killed，默认是会触发OOM Killed，只能杀死控制组内的进程，无法杀死节点上的其他进程。当值设置为1时，表示控制组内进程即使达到limit_in_bytes设置的值，也不会触发OOM Killed，但是这可能会影响控制组中正在申请物理内存页面的进程，造成该进程处于停止状态，无法继续运行。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;memory.usage_in_bytes&lt;/code&gt;：表示当前控制组里所有进程实际使用的内存总和，与limit_in_bytes的值越接近，越容易触发OOM Killed。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当发送OOM killed时，可以查看内核日志 &lt;code&gt;journalctl -k 或者 查看日志文件 /var/log/message&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;Memory Cgroup只统计了RSS和Page Cache这两部分内存，两者的和等于 &lt;code&gt;memory.usage_in_bytes&lt;/code&gt;，当控制组里的进程要申请新的物理内存，但&lt;code&gt;memory.usage_in_bytes&lt;/code&gt;已超过&lt;code&gt;memory.limit_in_bytes&lt;/code&gt;，此时会启用&lt;code&gt;page frame reclaim内存页面&lt;/code&gt;回收机制，回收Page Cache的内存。&lt;/p&gt;
&lt;p&gt;判断容器真实的内存使用量，不能仅靠Memory Cgroup里的&lt;code&gt;memory.usage_in_bytes&lt;/code&gt;，而需要&lt;code&gt;memory.stat&lt;/code&gt;里的rss值，该值才真正反应了容器使用的真实物理内存的大小。&lt;/p&gt;
&lt;h2 id=&#34;swap&#34;&gt;Swap&lt;/h2&gt;
&lt;p&gt;容器可以使用Swap空间，但会导致Memory Cgroup失效，比如在Swap空间足够的情况下，设置容器limit为512MB，然后容器申请了1G内存，是可以申请成功的，此时容器的RSS为512MB，Swap只剩下512MB空闲。&lt;/p&gt;
&lt;p&gt;为了解决这个问题，可以使用swapiness，参数文件在&lt;code&gt;/proc/sys/vm/swapiness&lt;/code&gt;，通过它来设置Swap使用的权重，用于定义Page Cache内存和匿名内存释放的比例值，取值范围是0到100，默认是60。100表示匿名内存和Page Cache内存的释放比例是100：100；60表示匿名内存和PageCache内存的释放比例是60：140，此时PageCache内存的释放优先于匿名内存；0不会完全禁止Swap的使用，在内存特别紧张的时候才会启用Swap来回收匿名内存。&lt;/p&gt;
&lt;p&gt;swapiness也存在于Memory Cgroup控制组中，参数文件是&lt;code&gt;memory.swappiness&lt;/code&gt;，该值的优先级会大于全局的swappiness，但有一点跟全局的swappiness不太一样，当&lt;code&gt;memory.swappiness=0&lt;/code&gt;时，是完全不使用Swap空间的。&lt;/p&gt;
&lt;p&gt;通过&lt;code&gt;memory.swappiness&lt;/code&gt;参数可以使得需要使用Swap容器和不需要使用Swap的容器，同时运行在同一个节点上。&lt;/p&gt;
&lt;h1 id=&#34;存储&#34;&gt;存储&lt;/h1&gt;
&lt;p&gt;Linux两种文件 I / O模式：&lt;/p&gt;
&lt;p&gt;Direct I/O：用户进程写磁盘文件，通过Linux内核文件系统 -&amp;gt; 块设备层 -&amp;gt; 磁盘驱动 -&amp;gt; 磁盘硬件，直到落盘。&lt;/p&gt;
&lt;p&gt;Buffer I/O：先把文件数据写入内存就返回，Linux内核有现成会把内存中的数据再写入磁盘，性能更佳。&lt;/p&gt;
&lt;p&gt;当文件数据先写入内存时，存在内存的数据叫 dirty pages&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当 dirty pages 数量超过 dirty_background_ratio（百分比，默认是10%） 对应的内存量的时候，内核 flush 线程就会开始把 dirty pages 写入磁盘 ;&lt;/p&gt;
&lt;p&gt;当 dirty pages 数量超过 dirty_ratio （百分比，默认是20%）对应的内存量，这时候程序写文件的函数调用 write() 就会被阻塞住，直到这次调用的 dirty pages 全部写入到磁盘；&lt;/p&gt;
&lt;p&gt;dirty_writeback_centisecs，时间值，单位是百分之一秒，默认是5秒，即每5s会唤醒内核的flush线程来处理dirty pages；&lt;/p&gt;
&lt;p&gt;dirty_expire_centisecs，时间值，单位是百分之一秒，默认是30s，定义dirty pages在内存的存放的最长时间，如果超过该时间，就会唤醒内核的flush线程处理dirty pages；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;unionfs&#34;&gt;UnionFS&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;将多个目录(处于不同的分区)一起挂载在一个目录下，实现多目录挂载&lt;/strong&gt;。这种方式可以使得同一节点上，多个容器使用同一份基础镜像，减少磁盘冗余的镜像数据。OverlayFS是其中的一种实现。&lt;/p&gt;
&lt;p&gt;比如容器A和容器B都使用了ubuntu作为基础镜像，放在目录/ubuntu上，容器A使用的额外应用程序放在appA目录，容器B的放在appB目录，将/ubuntu目录和appA目录同时挂载在containA目录下，作为容器A看到的文件系统，同理容器B也是，此时节点就只需要保存一份ubuntu镜像文件即可。&lt;/p&gt;
&lt;h2 id=&#34;overlayfs&#34;&gt;OverlayFS&lt;/h2&gt;
&lt;p&gt;OverlayFS是一种堆叠文件系统，依赖并建立在其他文件系统之上，如EXT4FS、XFS等，并不直接参与磁盘空间结构的划分，仅将原来底层文件系统中不同目录进行合并，用户见到的Overlay文件系统根目录下的内容就来自挂载时指定的不同目录的合集，OverlayFS会将挂载的文件进行分层。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lower：文件的最底层，不允许被修改，只读，OverlayFS支持多个lowerdir，最多500个；&lt;/li&gt;
&lt;li&gt;upper：可读写层，文件的创建、修改、删除都会在这一层反应，只有一个；&lt;/li&gt;
&lt;li&gt;merged：挂载点目录，用户实际对文件的操作都在这里进行；&lt;/li&gt;
&lt;li&gt;work：存放临时文件的目录，如果OverlayFS中有文件修改，中间过程中会临时存放文件到这里；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;上下层同名目录合并，上下层同名文件覆盖，lower层文件写时会拷贝(copy_up)到upper层进行修改，不影响lower层的文件。&lt;/p&gt;
&lt;p&gt;比如，在merged目录里新建文件，这个文件会出现在upper目录中；删除文件，这个文件会在upper目录中消失，但在lower目录里不会有变化，只是upper目录中会增加一个特殊文件告诉OverlayFS该文件不能出现在merged目录里，表示它被删除；修改文件，会在upper目录中新建一个修改后的文件，而lower目录中原来的文件不会改变。&lt;/p&gt;
&lt;p&gt;在Docker中，容器镜像文件可以分成多个层，每层对应lower dir的一个目录，容器启动后，对镜像文件中的修改会保存在upper dir里。Docker会将镜像层作为lower dir，容器层作为upper dir，最后挂载到容器的merged挂载点，即容器的根目录下。&lt;/p&gt;
&lt;p&gt;OverlayFS本身没有限制文件写入量的功能，需要依赖底层文件系统，比如XFS文件系统的quota，限制upper目录的写入大小。&lt;/p&gt;
&lt;h2 id=&#34;blkio-cgroup&#34;&gt;Blkio Cgroup&lt;/h2&gt;
&lt;p&gt;IOPS：每秒钟磁盘读写的次数&lt;/p&gt;
&lt;p&gt;吞吐量：每秒钟磁盘读取的数据量，有时也称为带宽&lt;/p&gt;
&lt;p&gt;两者的关系：吞吐量 = 数据块大小 * IOPS&lt;/p&gt;
&lt;p&gt;Blkio Cgroup一般会通过一个虚拟文件系统挂载点的方式，挂载在&lt;code&gt;/sys/fs/cgroup/blkio&lt;/code&gt;目录下，每个子目录为一个控制组，各个目录间是一个树状的层级关系。每个目录有很多参数文件，有4个主要参数来限制磁盘 I/O性能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;blkio.throttle.read_iops_device&lt;/code&gt;：磁盘读取IOPS限制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blkio.throttle.read_bps_device&lt;/code&gt;：磁盘读取吞吐量限制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blkio.throttle.write_iops_device&lt;/code&gt;：磁盘写入IOPS限制&lt;/li&gt;
&lt;li&gt;&lt;code&gt;blkio.throttle.write_bps_device&lt;/code&gt;：磁盘写入吞吐量限制&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但在Cgroup V1，只有Direct I/O才能通过Blkio Cgroup限制，Buffered I/O不能，因为Buffered I/O会用到Page Cache，但V1版本各个Cgroup子系统相互独立，所以没办法做限制。&lt;/p&gt;
&lt;p&gt;Cgroup V2才可以，通过配置Blkio Cgroup和Memory Cgroup即可解决。有个问题是，如果Memory Cgroup的&lt;code&gt;memory.limit_in_bytes&lt;/code&gt;设置得比较小，而容器中进程有大量的IO、这样申请新的Page Cache内存时，又会不断释放老的内存页面，带来了额外的开销，可能会产生写入波动。&lt;/p&gt;
&lt;h1 id=&#34;网络&#34;&gt;网络&lt;/h1&gt;
&lt;p&gt;容器网络一个Network Namespace网络栈包括：网卡、回环设备、路由表、iptables规则。&lt;/p&gt;
&lt;h2 id=&#34;network-namespace&#34;&gt;Network Namespace&lt;/h2&gt;
&lt;p&gt;Network Namespace主要用来隔离网络资源，如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;网络设备，比如 lo(回环设备)、eth0等，可以通过&lt;code&gt;ip link&lt;/code&gt;命令查看&lt;/li&gt;
&lt;li&gt;IPv4和IPv6协议栈，IP层以及上面的TCP和UDP协议栈都是每个Namespace独立工作，这些参数大都在&lt;code&gt;/proc/sys/net&lt;/code&gt;目录下，包括TCP和UDP的port资源。&lt;/li&gt;
&lt;li&gt;IP路由表，也是每个Namespace独立工作，使用&lt;code&gt;ip route&lt;/code&gt;命令查看&lt;/li&gt;
&lt;li&gt;防火墙规则，即iptables，每个Namespace可独立配置&lt;/li&gt;
&lt;li&gt;网络状态信息，可以从&lt;code&gt;/proc/net&lt;/code&gt;和&lt;code&gt;/sys/class/net&lt;/code&gt;里查看，包括了上面几种资源的状态信息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在宿主机上，可以使用&lt;code&gt;lsns -t net&lt;/code&gt;命令查看系统已有的Network Namespace，使用&lt;code&gt;nsenter或ip netns&lt;/code&gt;这个命令进入某个Network Namespace里查看具体的网络配置。&lt;/p&gt;
&lt;p&gt;网络相关参数很大一部分放在了&lt;code&gt;/proc/sys/net&lt;/code&gt;目录下，比如tcp相关的参数，可以直接修改，也可以使用sysctl命令修改。&lt;/p&gt;
&lt;p&gt;出于安全考虑，对于非privileged容器，&lt;code&gt;/proc/sys&lt;/code&gt;是read-only挂载的，容器启动后无法内部修改该目录下相关的网络参数，只能通过runC sysctl相关接口，在容器启动时对容器内的网络参数进行修改，比如&lt;/p&gt;
&lt;p&gt;如果使用Docker，可以加上 &lt;code&gt;--sysctl 参数名=参数值&lt;/code&gt;来修改，如果是K8s，则需要用到 &lt;code&gt;allowed unsaft sysctl&lt;/code&gt;这个特性了。&lt;/p&gt;
&lt;p&gt;可以使用系统函数clone()或unshare()来创建Namespace，比如Docker或者containerd启动容器时，是通过runC间接调用unshare函数启动容器的。&lt;/p&gt;
&lt;h2 id=&#34;网络通信&#34;&gt;网络通信&lt;/h2&gt;
&lt;p&gt;容器与外界通信，总共分成两步：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;数据包从容器的Network Namespace发送到Host Network Namespace&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据包从Host Network Namespace，从宿主机的eth0上发送出去&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;可以使用 tcpdump抓包工具 查看数据包在各个设备接口的日志&lt;/p&gt;
&lt;p&gt;比如查看容器内eth0接收数据包的情况 &lt;code&gt;ip netns exec [pid] tcpdump -i eth0 host [目标ip地址] -nn&lt;/code&gt;，查看veth_host或其他设备使用 &lt;code&gt;tcpdump -i [设备名如veth_host、docker0、eth0] host [目标ip地址] -nn &lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;同一节点下容器间的通信&#34;&gt;同一节点下容器间的通信&lt;/h3&gt;
&lt;p&gt;在 Linux 中能够起到虚拟交换机作用的网络设备，是网桥。它是一个工作在数据链路层的设备，主要功能是根据 MAC 地址来将数据包转发到网桥的不同端口（Port）上，因此Docker 项目会默认在宿主机上创建一个名叫 docker0 的网桥，凡是连接在 docker0 网桥上的容器，就可以通过它来进行通信。&lt;/p&gt;
&lt;p&gt;容器里会有一个eth0网卡，作为默认的路由设备，连接到宿主机上一个叫vethxxx的虚拟网卡，而vethxxx网卡又插在了docker0网桥上，这一套虚拟设备就叫做Veth Pair。每个容器对应一套VethPair设备，多个容器会将其Veth Pair注册到宿主机的docker0网桥上，即&lt;strong&gt;Veth Pair相当于是连接不同Network Namespace的网线，一端在容器，一端在宿主机&lt;/strong&gt;。此时，数据包就能从容器的Network Namespace发送到Host Network Namespace上了。&lt;/p&gt;
&lt;p&gt;docker0和容器会组成一个子网，docker0上的ip就是这个子网的网关ip。&lt;/p&gt;
&lt;p&gt;网络请求实际上就是在这些虚拟设备上进行映射（经过路由表，IP转MAC，MAC转IP）和转发，到达目的地。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同一节点内，容器间通信一般流程&lt;/strong&gt;：容器A往容器B的IP发出请求，请求先经过容器A的eth0网卡，发送一个ARP广播，找到容器B IP对应的MAC地址，宿主机上的docker0网桥，把广播转发到注册到其身上的其他容器的eth0，容器B收到该广播后把MAC地址发给docker0，docker0回传给容器A，容器A发送数据包给docker0，docker0接收到数据包后，根据数据包的目的MAC地址，将其转发到容器B的eth0，&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同一节点内，宿主机与容器通信一般流程&lt;/strong&gt;：宿主机往容器的IP发出请求，这个请求的数据包先根据路由规则到达docker0网桥，转发到对应的Veth Pair设备上，由Veth Pair转发给容器内的应用。&lt;/p&gt;
&lt;p&gt;关于容器缺省使用的peer veth方案，由于从容器的veth0到宿主机的veth0会有一次软中断，带来了额外的开销，时延会高一些，可以使用 ipvlan/macvlan的网络接口替代，ipvlan/macvlan 直接在物理网络接口上虚拟出接口，容器发送网络数据包时直接从容器的eth0发送给宿主机的eth0，减少了转发次数，实延就降低了。但是该方案无法使用iptables规则，Kubernetes的service就无法使用该方案。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%90%8c%e4%b8%80%e8%8a%82%e7%82%b9%e4%b8%8b%e7%9a%84%e5%ae%b9%e5%99%a8%e9%80%9a%e4%bf%a1.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%90%8c%e4%b8%80%e8%8a%82%e7%82%b9%e4%b8%8b%e7%9a%84%e5%ae%b9%e5%99%a8%e9%80%9a%e4%bf%a1.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;容器访问另一节点&#34;&gt;容器访问另一节点&lt;/h3&gt;
&lt;p&gt;一个节点内的容器访问另一个节点一般流程：先经过docker0网桥，出现在宿主机上，根据路由表或者nat的方式，知道目标节点是其他机器，则将数据转发到宿主机的eth0网卡上，再发往目标节点。&lt;/p&gt;
&lt;p&gt;其实跟同一节点内，宿主机与容器通信类似，最终转化为节点间的通信。&lt;/p&gt;
&lt;p&gt;所以当容器无法访问外网时，就可以检查docker0网桥是否能ping通，查看docker0和Veth Pair设备的iptables规则是否有异常。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%ae%b9%e5%99%a8%e8%ae%bf%e9%97%ae%e5%8f%a6%e4%b8%80%e8%8a%82%e7%82%b9.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%ae%b9%e5%99%a8%e8%ae%bf%e9%97%ae%e5%8f%a6%e4%b8%80%e8%8a%82%e7%82%b9.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;不同节点下容器间的通信&#34;&gt;不同节点下容器间的通信&lt;/h3&gt;
&lt;p&gt;默认配置下，不同节点间的容器、docker0网桥，是不知道彼此的，没有任何关联，想要跨主机容器通信，就需要在多主机间在建立一个公共网桥，所有节点的容器都往这个网桥注册，才能进行通信。通过每台宿主机上有一个特殊网桥来构成这个公用网桥，这个技术被称为overlay network（覆盖网络）。&lt;/p&gt;
&lt;p&gt;常见的解决方案是Flannel、Calico等。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%ae%b9%e5%99%a8%e7%bd%91%e7%bb%9c.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%ae%b9%e5%99%a8%e7%bd%91%e7%bb%9c.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;docker的网络模型&#34;&gt;Docker的网络模型&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;bridge模式（默认）&lt;/p&gt;
&lt;p&gt;Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会分配一个Network Namespace，通过eth0-veth虚拟设备连接到宿主机的docker0网桥上。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;host模式&lt;/p&gt;
&lt;p&gt;此模式下容器不会获得独立的Network Namespace，和宿主机共用一个Network Namespace，容器也不会虚拟自己的网卡和ip，而是用宿主机的ip和端口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;container模式&lt;/p&gt;
&lt;p&gt;指定新创建的容器和一个已存在的容器共享一个Network Namespace，新创建的容器不会创建自己的网卡和IP，而是和指定的容器共享IP、端口范围&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;none模式&lt;/p&gt;
&lt;p&gt;Docker容器拥有自己的Network Namespace，但并不为Docker容器进行任何网络配置，需要手动添加。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;安全&#34;&gt;安全&lt;/h1&gt;
&lt;p&gt;进程的权限分为两类，特权用户进程(进程有效用户ID是0，root用户的进程)、非特权用户进程(进程有效用户ID非0，非root用户的进程)，特权用户可以执行Linux系统上所有操作，而非特权用户执行这些操作会被内核限制。&lt;/p&gt;
&lt;p&gt;在kernel2.2开始，Linux把特权用户的特权做了划分，每个被划分出来的单元称为capability，比如运行iptables命令，对应的进程需要有CAP_NET_ADMIN这个capability。非root用户启动的进程默认没有任何capabilities，root用户则包含了所有。子父进程的capabilities有继承属性。查看进程拥有的capability命令：&lt;code&gt;cat /proc/[pid]/status | grep Cap&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;对于privileged容器，实际上就是拥有了所有capability，允许执行所有特权操作，比如docker容器启动时增加参数 &lt;code&gt;--privileged&lt;/code&gt;。容器缺省启动时，是root用户，但只允许了15个capabilities。&lt;/p&gt;
&lt;p&gt;一般只给容器所需操作的最小capabilities，而不是直接给privileged，因为privileged的权限太大，容器可以轻易获取宿主机上的所有资源，比如直接访问磁盘设备，修改宿主机上的文件。&lt;/p&gt;
&lt;p&gt;为了保证容器运行不对宿主机造成安全影响，可以在容器中指定用户。&lt;/p&gt;
&lt;p&gt;在docker中，启动容器命令后面加&lt;code&gt;-u [uid]/[gid]&lt;/code&gt;，或者在写Dockerfile时指定(这样启动容器就不用加-u)，&lt;strong&gt;容器里的用户与宿主机上的用户共享，即容器上的uid实际上是宿主机上的uid(root用户也是，只是容器里capabilities只有15个，而宿主机上的root有全部)&lt;/strong&gt;，这样会产生限制，因为在Linux上每个用户的资源是有限的，比如打开文件数目、最大进程数等，如果有多个容器共享同一个uid，就会互相影响。&lt;/p&gt;
&lt;p&gt;为了解决容器uid共享问题，可以使用User Namespace。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;User Namespace本质上是将容器中的uid/gid与宿主机上的uid/gid建立映射&lt;/strong&gt;，同时也支持嵌套映射。比如划分宿主机上的uid的范围1000-1999，对应容器uid的0到999，容器里uid也可以继续嵌套映射。&lt;/p&gt;
&lt;p&gt;使用User Namespace，可以把容器中root用户映射称宿主机上的普通用户，解决uid冲突共享问题，&lt;strong&gt;目前Kebernetes还不支持User Namespace(当前时间20210920，不过github上有pr了)&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;runc-与-oci&#34;&gt;runC 与 OCI&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;OCI：Open Container Initiatives，围绕容器格式和运行时制定一个开放的工业化标准，包含容器运行时标准 （runtime spec）和 容器镜像标准（image spec）。&lt;/p&gt;
&lt;p&gt;容器镜像标准 image spec：包含了文件系统、config文件、manifest文件、index文件；&lt;/p&gt;
&lt;p&gt;容器运行时标准 runtime spec：包含容器运行状态以及需要提供的命令；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;runC：一个轻量工具，基于libcontainer库，由golang语言实现，不需要docker引擎，它根据 OCI 标准来创建和运行容器的，即runC是OCI运行时标准的一个实现，不包含镜像管理功能。&lt;/p&gt;
&lt;p&gt;runC成为容器运行时实现的标准，而containerd是Docker出的一个中间层，为runC提供接口，供上层Docker Daemon调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;OCI bundle ：包括容器的文件系统和一个 config.json 文件。有了容器的根文件系统后就可以通过 runc spec 命令来生成 config.json 文件，config.json 文件用于说明如何运行容器，包括要运行的命令、权限、环境变量等等内容&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;OCI 定义的容器状态：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;creating：使用 create 命令创建容器，这个过程称为创建中。&lt;/li&gt;
&lt;li&gt;created：容器已经创建出来，但是还没有运行，表示镜像文件和配置没有错误，容器能够在当前平台上运行。&lt;/li&gt;
&lt;li&gt;running：容器里面的进程处于运行状态，正在执行用户设定的任务。&lt;/li&gt;
&lt;li&gt;stopped：容器运行完成，或者运行出错，或者 stop 命令之后，容器处于暂停状态。这个状态，容器还有很多信息保存在平台中，并没有完全被删除。&lt;/li&gt;
&lt;li&gt;paused：暂停容器中的所有进程，可以使用 resume 命令恢复这些进程的执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;docker&#34;&gt;Docker&lt;/h1&gt;
&lt;h2 id=&#34;进程-1&#34;&gt;进程&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;dockerd ：Docker Engine守护进程，直接面向操作用户。dockerd 启动时会启动 containerd 子进程，他们之前通过RPC进行通信。&lt;/li&gt;
&lt;li&gt;containerd ：dockerd和runc之间的一个中间交流组件。他与 dockerd 的解耦是为了让Docker变得更为的中立，而支持OCI 的标准 。&lt;/li&gt;
&lt;li&gt;containerd-shim ：用来真正运行的容器的，每启动一个容器都会起一个新的shim进程， 它主要通过指定的三个参数：容器id，boundle目录（containerd的对应某个容器生成的目录，一般位于：/var/run/docker/libcontainerd/containerID）， 和运行命令（默认为 runc）来创建一个容器。&lt;/li&gt;
&lt;li&gt;docker-proxy ：用户级的代理路由。只要你用 ps -elf 这样的命令把其命令行打出来，你就可以看到其就是做端口映射的。如果不想要这个代理的话，可以在 dockerd 启动命令行参数上加上：  &amp;ndash;userland-proxy=false 这个参数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;dockerfile&#34;&gt;Dockerfile&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/panwenbin-logs/p/8007348.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;指令详解&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RUN&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;后面一般接shell命令，但是会构建一层镜像&lt;/p&gt;
&lt;p&gt;要注意RUN每执行一次指令都会在docker上新键一层，如果层数太多，镜像就会太过膨胀影响性能，虽然docker允许的最大层数是127层。&lt;/p&gt;
&lt;p&gt;有多条命令可以使用&amp;amp;&amp;amp;连接&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CMD&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要注意CMD只允许有一条，如果有多条只有最后一条会生效&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;极客时间-深入剖析k8s-张磊&lt;/p&gt;
&lt;p&gt;极客时间-容器实战高手课&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tech.meituan.com/2015/03/31/cgroups.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux资源管理之cgroups简介&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go Sync包相关</title>
        <link>http://nixum.cc/p/go-sync%E5%8C%85%E7%9B%B8%E5%85%B3/</link>
        <pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/go-sync%E5%8C%85%E7%9B%B8%E5%85%B3/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;变量可见性&#34;&gt;变量可见性&lt;/h1&gt;
&lt;p&gt;由于不同的架构和不同的编译器优化，会发生指令重排，导致程序运行时不一定会按照代码的顺序执行，因此两个goroutine在处理共享变量时，能够看到其他goroutine对这个变量进行的写结果。&lt;/p&gt;
&lt;p&gt;happens-before：程序的执行顺序和代码的顺序一样，就算真的发生了重排，从行为上也能保证和代码的指定顺序一样。&lt;/p&gt;
&lt;p&gt;Go不像Java有volatile关键字实现CPU屏障来保证指令不重排，而是使用不同架构的内存屏障指令来实现同一的并发原语。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Go只保证goroutine内部重排对读写顺序没有影响&lt;/strong&gt;，如果存在共享变量的访问，则影响另一个goroutine。因此当有多个goroutine对共享变量的操作时，需要保证对该共享变量操作的happens-before顺序。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 例子：
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 当两个goroutine同时执行时，因为指令重排的缘故，第二个goroutine打印a可能是5，也可能是0
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;证heppens-before的手段&#34;&gt;证heppens before的手段&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;init函数：同一个包下可以有多个init函数，多个签名相同的init函数；main函数一定在导入的包的init函数执行之后执行；当有多个init函数时，从main文件出发，递归找到对应的包 - 包内文件名顺序 - 一个文件内init函数顺序执行init函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局变量：包级别的变量在&lt;strong&gt;同一个文件中是按照声明顺序逐个初始化&lt;/strong&gt;的；当该变量在初始化时&lt;strong&gt;依赖其它的变量时，则会先初始化该依赖的变量&lt;/strong&gt;。&lt;strong&gt;同一个包下的多个文件，会按照文件名的排列顺序进行初始化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;init函数也是如此，当init函数引用了全局变量a，运行main函数时，肯定是先初始化a，再执行init函数。&lt;/p&gt;
&lt;p&gt;当init函数和全局变量&lt;strong&gt;无引用关系时，先初始化全局变量，再执行init函数&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// == 9
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// == 4
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// == 5
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// 全部初始化完成后 == 5 
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;---&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 运行后，输出2，3，4
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;---&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 运行后，输出2，4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;goroutine：启动goroutine的go语句执行，一定happens before此goroutine内的代码&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;hello&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;执行hello方法&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;必定打印出hello&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;channel：
&lt;ul&gt;
&lt;li&gt;send操作必定heppen before于receive操作；&lt;/li&gt;
&lt;li&gt;close一个channel的操作，必定happen before从关闭的channel中读取一个零值；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;此外还有Mutex / RWMutex、WaitGroup、Once、atomic&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;mutex---互斥锁&#34;&gt;Mutex - 互斥锁&lt;/h1&gt;
&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 分成四部分，最小一位表示锁是否被持有，第二位表示是否有唤醒的goroutine，第三位表示是否处于饥饿状态，剩余的位数表示等待锁的goroutine的数量，最大数量为2^(32-3)-1个，以goroutine初始空间为2k，则达到最大数量时需要消耗1TB内存
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;sema&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;uint32&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 信号量变量，用来控制等待goroutine的阻塞休眠和唤醒
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;iota&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 持有锁的标记，此时被锁定
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;mutexWoken&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 唤醒标记，从正常模式被唤醒
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 饥饿标记，进入饥饿模式
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;mutexWaiterShift&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;iota&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 阻塞等待的waiter数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;starvationThresholdNs&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mf&#34;&gt;1e6&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_mutex_state.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_mutex_state.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;mutexLocked 对应右边低位第一个bit，1 代表锁被占用，0代表锁空闲&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mutexWoken 对应右边低位第二个bit，1 表示已唤醒，0表示未唤醒&lt;/p&gt;
&lt;p&gt;从正常模式被唤醒，用于加锁和解锁过程中的通信，比如同一时刻，一个协程在解锁，一个协程在加锁，正在加锁的协程可能在自旋，此时标记为唤醒，另一个协程解锁后，锁立马被这个协程拿到，避免唤醒存在阻塞队列中的协程；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mutexStarving 对应右边低位第三个bit，1 代表锁处于饥饿模式，0代表锁处于正常模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mutexWaiterShift 值为3，根据 &lt;code&gt;mutex.state &amp;gt;&amp;gt; mutexWaiterShift&lt;/code&gt; 得到当前阻塞的&lt;code&gt;goroutine&lt;/code&gt;数目，最多可以阻塞&lt;code&gt;2^29&lt;/code&gt;个&lt;code&gt;goroutine&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;starvationThresholdNs 值为1e6纳秒，也就是1毫秒，当等待队列中队首goroutine等待时间超过&lt;code&gt;starvationThresholdNs&lt;/code&gt;也就是1毫秒，mutex进入饥饿模式。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基本&#34;&gt;基本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;只有Lock和Unlock两个方法，用于锁定临界区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mutex的零值是没有goroutine等待的未加锁状态，不会因为没有初始化而出现空指针或者无法获取到锁的情况，so无需额外的初始化，直接声明变量即可使用&lt;code&gt;var lock sync.Mutex&lt;/code&gt;，或者是在结构体里的属性，均无需初始化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锁有两种模式：正常模式和饥饿模式&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正常模式下&lt;/strong&gt;，如果Mutex已被一个goroutine获取了锁，其他等待的goroutine们会一直等待，组成等待队列，当该goroutine释放锁后，等待的goroutine是以先进先出的队列排队获取锁；&lt;/p&gt;
&lt;p&gt;如果此时有新的goroutine也在获取锁，会参与到获取锁的竞争中，这是非公平的，因为新请求锁的goroutine是在CPU上被运行，并且数量也可能很多，所以被唤醒的goroutine获取锁的概率并不大，所以，如果等待队列中的goroutine等待超过1ms，则会优先加入到队列的头部，如果超过1ms都没有获取到锁，则进入饥饿模式；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;饥饿模式下&lt;/strong&gt;，锁的所有权会直接从释放锁的goroutine转交给队首的goroutine，新请求锁的goroutine就算锁的空闲状态也不会去获取锁，也不会自旋，直接加入等待队列的队尾，以此解决等待的goroutine的饥饿问题；&lt;/p&gt;
&lt;p&gt;恢复为正常模式的条件：一个goroutine获取锁后，当前goroutine是队列的最后一个，退出饥饿模式；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Unlock方法可以被任意goroutine调用，释放锁，即使它本身没有持有这个锁，so写的时候要牢记，谁申请锁，就该谁释放锁，保证在一个方法内被调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;必须先使用Lock方法才能使用Unlock方法，否则会panic，重复释放锁也会panic&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;是否进入自旋，还跟自旋的次数与cpu核数，p的数量有关&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意Mutex在使用时不能被复制，比如方法传参的没有使用指针，导致执行方法的参数时被复制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mutex是不可重入锁，获取锁的goroutine无法重复获取锁，因为Mutex本身不记录哪个goroutine拥有这把锁，因此如果要实现可重入锁，则需要对Mutex进行包装，实现Locker接口，同时记录获取锁的goroutine的id和重入次数&lt;/p&gt;
&lt;p&gt;获取goroutine id的方法：&lt;/p&gt;
&lt;p&gt;​	1.使用runtime.Stack()方法获取栈帧里的goroutine id&lt;/p&gt;
&lt;p&gt;​	2.获取运行时的G指针，反解出G的TLS结构，获取存在TLS结构中的goroutine id&lt;/p&gt;
&lt;p&gt;​	3.给获取锁的goroutine设置token，进行标记&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;lock方法&#34;&gt;Lock方法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;调用Lock的goroutine通过&lt;strong&gt;CAS的方式设置锁标志&lt;/strong&gt;，如果获取到了直接返回；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;否则进入&lt;code&gt;lockSlow方法&lt;/code&gt;，&lt;code&gt;lockSlow方法&lt;/code&gt;主要是通过自旋等待锁的释放；自旋是为了不让goroutine进入休眠，让其在一段时间内保持运行，忙等待快速获取锁；&lt;/p&gt;
&lt;p&gt;goroutine本身进入自旋的条件比较苛刻：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;互斥锁只有在正常模式才能进入自旋；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;runtime.sync_runtime_canSpin&lt;/code&gt;需要返回true：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;运行在多 CPU 的机器上；&lt;/li&gt;
&lt;li&gt;当前 Goroutine 为了获取该锁进入自旋的次数小于四次；&lt;/li&gt;
&lt;li&gt;当前机器上至少存在一个正在运行的处理器 P 并且处理的运行队列为空；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在lockSlow方法内，意味着锁已经被持有，当前调用Lock方法的goroutine正在等待，且非饥饿状态，其首先会自旋，尝试获取锁，无需休眠，否则进入 4&lt;/p&gt;
&lt;p&gt;不满足自旋时，当前锁可能有如下几种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;锁还没有被释放，锁处于正常状态&lt;/li&gt;
&lt;li&gt;锁还没有被释放， 锁处于饥饿状态&lt;/li&gt;
&lt;li&gt;锁已经被释放， 锁处于正常状态&lt;/li&gt;
&lt;li&gt;锁已经被释放， 锁处于饥饿状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于lock方法会被多个goroutine执行，所以锁的状态会不断变化，此时会生成当前goroutine的 new state 作为期望状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是非饥饿状态，锁的new state设置为已持有锁&lt;/li&gt;
&lt;li&gt;如果已经持有锁，或者是饥饿状态，waiter数量 + 1&lt;/li&gt;
&lt;li&gt;如果已经持有锁，且是饥饿状态，锁的new state设置为饥饿状态&lt;/li&gt;
&lt;li&gt;如果当前goroutine被唤醒，锁的new state设置为唤醒状态&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CAS更新当前锁的状态&lt;/strong&gt;为new state，如果更新成功&lt;/p&gt;
&lt;p&gt;5.1. 如果锁的原状态old state是未被锁，且非饥饿状态，表明当前goroutine获取到了锁，&lt;strong&gt;退出结束&lt;/strong&gt;
5.2. 判断当前goroutine是新加入的还是被唤醒的，新加入的放到等待队列的尾部，刚被唤醒的加入等待队列的头部，&lt;strong&gt;通过信号量阻塞&lt;/strong&gt;，直到当前goroutine被唤醒
5.3. 从这里开始被唤醒的goroutine，都是表示是从阻塞队列里出来的。goroutine被唤醒后，判断当前state是否是饥饿状态，如果不是则更新锁的状态为被唤醒，表示有G被唤醒，继续循环，跳到 2
5.4. 如果当前state是饥饿状态，当前goroutine获取锁，waiter数量 - 1，设置当前锁的状态是饥饿状态，如果当前goroutine是队列中最后一个goroutine，清除当前锁的饥饿状态，&lt;strong&gt;更新当前锁的状态和waiter数量，退出结束&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果更新失败，设置old state 等于 当前锁的状态&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当前goroutine能获取锁，是通过是否能成功修改锁的状态修改为持有锁实现的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;95
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;96
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;97
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;98
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// cas的方式获取锁，获取到之后立即返回
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;CompareAndSwapInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 获取不到锁，说明已被其他goroutine获取到了锁，此时会尝试通过自旋的方式等待锁的释放
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;lockSlow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 这个方法的代码，是会被多个G同时执行的
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;lockSlow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;waitStartTime&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;starving&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 当前goroutine是否被唤醒
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;awoke&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;iter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// 判断当前state已被锁，且非饥饿状态，且能自旋（能否自旋的条件见上）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;runtime_canSpin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;iter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;c1&#34;&gt;// 自旋过程中如果发现state还没有设置woken标识，则进行设置，标记自己被唤醒
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 自旋是为了让其他goroutine在释放锁后能第一时间唤醒此goroutine
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;awoke&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWoken&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWaiterShift&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;CompareAndSwapInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWoken&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;awoke&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 进入自旋
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nf&#34;&gt;runtime_doSpin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;iter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;continue&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// old是当前锁状态，new是期望锁状态
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// 如果此时是非饥饿状态，期望锁状态设置为持有锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 如果已经持有锁 或者 是饥饿状态，state的waiter数量+1，表示当前goroutine在等待
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWaiterShift&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// 如果此时是饥饿状态，还持有锁，期望锁状态设置为饥饿
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;starving&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// goroutine被唤醒，期望锁状态设置为唤醒
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;awoke&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 如果此时非唤醒，说明锁的状态不一致，抛错误
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWoken&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nf&#34;&gt;throw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;sync: inconsistent mutex state&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;^=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexWoken&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// cas更新锁的状态，这里锁的状态可能是4种中其中一种
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;CompareAndSwapInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 如果old不是饥饿状态也不是被锁状态，表明当前goroutine已通过cas获取到了锁，break
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
			&lt;span class=&#34;c1&#34;&gt;// 如果之前已经在等了，就排在队首
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nx&#34;&gt;queueLifo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;waitStartTime&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 如果之前没在等，则初始化等待时间
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;waitStartTime&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;waitStartTime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;runtime_nanotime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 该方法会不断尝试获取锁并陷入休眠等待信号量的释放，一旦当前 goroutine 可以获取信号量，它就会立刻返回
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nf&#34;&gt;runtime_SemacquireMutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sema&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;queueLifo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 走到这一步，说明当前goroutine是进过阻塞队列的，所以接下来在饥饿状态下会优先获取锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 如果当前goroutine是饥饿状态，或者已经等待超过1ms，就设置为饥饿状态
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nx&#34;&gt;starving&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;starving&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;runtime_nanotime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;waitStartTime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;starvationThresholdNs&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 如果是饥饿模式
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;c1&#34;&gt;// 如果goroutine被唤醒，且处于饥饿状态，锁的所有权转移给当前goroutine
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;				&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWoken&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWaiterShift&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
					&lt;span class=&#34;nf&#34;&gt;throw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;sync: inconsistent mutex state&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
				&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 当前goroutine获取锁，waiter数量-1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;				&lt;span class=&#34;nx&#34;&gt;delta&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWaiterShift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 如果当前goroutine非饥饿状态，或者 当前goroutine是队列中最后一个goroutine
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;				&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;starving&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWaiterShift&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
					&lt;span class=&#34;c1&#34;&gt;// 退出饥饿模式
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;					&lt;span class=&#34;nx&#34;&gt;delta&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt;
				&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 当前goroutine成功修改锁状态为持有锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;				&lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 不是饥饿模式，就把当前goroutine设置为被唤醒，自旋次数重置为0
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nx&#34;&gt;awoke&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;iter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// cas不成功，没有拿到锁，锁被其他goroutine获取或者锁没有被释放，更新状态，重新循环
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;unlock方法&#34;&gt;Unlock方法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;将state的锁位-1，如果state=0，即此时没有加锁，且没有正在等待获取锁的goroutine，则直接结束方法，如果state != 0，执行unlockSlow方法，唤醒等待的goroutine；&lt;/li&gt;
&lt;li&gt;如果Mutex处于饥饿状态，当前goroutine不更新锁状态，直接唤醒等待队列中的waiter，继续执行，相当于解锁了，然后由等待队列中的队首goroutine获得锁；&lt;/li&gt;
&lt;li&gt;如果Mutex处于正常状态，如果没有waiter，或者已经有在处理的waiter的情况，则直接释放锁，state锁位-1，返回；否则，waiter数-1，设置唤醒标记，通过CAS解锁，唤醒在等待锁的goroutine，此时新老goroutine一起竞争锁；&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 修改state的状态为释放锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// 说明此时没有成功解锁，或者有其他goroutine在等待解锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;unlockSlow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;unlockSlow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;throw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;sync: unlock of unlocked mutex&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 非饥饿模式下
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;c1&#34;&gt;// 如果没有等待的goroutine，或者 锁有以下几种情况时，直接返回
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 1. 锁被其他goroutine获取了
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 2. 或者有等待的goroutine被唤醒，不用再唤醒阻塞队列里的goroutine，可以直接返回
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 3. 或者锁是饥饿模式，锁之后要直接交给等待队列队首的goroutine
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWaiterShift&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWoken&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexStarving&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
			&lt;span class=&#34;c1&#34;&gt;// 能走到这这里说明此时锁的状态还是空闲，
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 且没有goroutine被唤醒，且队列中有goroutine在等待获取锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 等待获取锁的goroutine数量-1，设置woken标识
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mutexWaiterShift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutexWoken&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 设置新的state，通过信号量唤醒一个阻塞的goroutine获取锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;c1&#34;&gt;// 此时可能会新老的waiter一起竞争
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;CompareAndSwapInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nf&#34;&gt;runtime_Semrelease&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sema&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// 饥饿模式下，直接将锁的所有权给队首的goroutine，即第二个参数为true
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 此时的state还没加锁，被唤醒的goroutine会设置它，如果此时有新的goroutine来请求锁，因为还处于饥饿状态，就仍然认为还被锁，新来的goroutine不会抢到锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nf&#34;&gt;runtime_Semrelease&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sema&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;基于mutex的拓展&#34;&gt;基于Mutex的拓展&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;可重入锁&lt;/li&gt;
&lt;li&gt;增加tryLock方法，通过返回true或false来表示获取锁成功或失败，主要用于控制获取锁失败后的行为，而不用阻塞在方法调用上&lt;/li&gt;
&lt;li&gt;增加等待计数器，比如等待多少时间后还没获取到锁则放弃&lt;/li&gt;
&lt;li&gt;增加可观测性指标，比如等待锁的goroutine的数量，需要使用&lt;code&gt;unsafe.Pointer方法&lt;/code&gt;获取Mutex中的state的值，解析出正在等待的goroutine的数量&lt;/li&gt;
&lt;li&gt;实现线程安全的队列，通过在出队和入队方法中使用Mutex保证线程安全&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;关于mutex中的sema&#34;&gt;关于Mutex中的sema&lt;/h2&gt;
&lt;p&gt;golang底层通过&lt;code&gt;runtime_SemacquireMutex&lt;/code&gt;和&lt;code&gt;runtime_Semrelease&lt;/code&gt;来实现切换阻塞协程和释放被阻塞协程重新运行等操作。&lt;/p&gt;
&lt;p&gt;在runtime中，有一个长度是251的全局semtable数组，每个元素是一棵平衡树的根，树的每个节点是sudog结构组成的一个双向链表。&lt;/p&gt;
&lt;p&gt;semtable会被多个协程操作，有并发问题，底层使用真正的锁，依赖操作系统实现，不能被用户使用。&lt;/p&gt;
&lt;p&gt;Mutex中的sema是一个信号量，Mutex通过sema字段，取其地址右移三位再对数组长度取模，得到semtable的索引，映射到semtable数组，从而知道goroutine被包装成sudog之后要存在semtable数组中的哪一棵平衡树上，以此就可以通过同一个信号量找到对应的在等待的协程双向链表。&lt;/p&gt;
&lt;p&gt;但是不同的信号量地址可能会映射到同一个semtable索引，为了避免唤醒错误的协程，会对拿出来的平衡树进行遍历，匹配sema的地址，取出对应的协程。&lt;/p&gt;
&lt;h1 id=&#34;rwmutex---读写锁&#34;&gt;RWMutex - 读写锁&lt;/h1&gt;
&lt;h2 id=&#34;数据结构-1&#34;&gt;数据结构&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;RWMutex&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;           &lt;span class=&#34;c1&#34;&gt;// 互斥锁解决多个writer的竞争
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;writerSem&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint32&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// writer信号量 
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;readerSem&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint32&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// reader信号量 
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;readerCount&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// reader的数量，可以是负数，负数表示此时有writer等待请求锁，此时会阻塞reader
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;readerWait&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 等待读完成的reader的数量，保证写操作不会被读操作阻塞而饿死
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rwmutexMaxReaders&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;30&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 最大的reader数量
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;基本-1&#34;&gt;基本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主要提升Mutex在读多写少的场景下的吞吐量，读时共享锁，写时排他锁，基于Mutex实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由5个方法构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lock/Unlock：写操作时调用的方法。如果锁已经被 reader 或者 writer 持有，那么，Lock 方法会一直阻塞，直到能获取到锁；Unlock 则是配对的释放锁的方法。&lt;/li&gt;
&lt;li&gt;RLock/RUnlock：读操作时调用的方法。如果锁已经被 writer 持有的话，RLock 方法会一直阻塞，直到能获取到锁，否则就直接返回；而 RUnlock 是 reader 释放锁的方法。&lt;/li&gt;
&lt;li&gt;RLocker：这个方法的作用是为读操作返回一个 Locker 接口的对象。它的 Lock 方法会调用 RWMutex 的 RLock 方法，它的 Unlock 方法会调用 RWMutex 的 RUnlock 方法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同Mutex，RWMutex的零值是未加锁状态，无需显示地初始化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于读写锁的存在，可能会有饥饿问题：比如因为读多写少，导致写锁一直加不上，因此go的RWMutex使用的是写锁优先策略：&lt;/p&gt;
&lt;p&gt;如果已经有一个writer在等待请求锁的话，会阻止新的reader请求读锁，优先保证writer。&lt;/p&gt;
&lt;p&gt;如果已经有一些reader请求了读锁，则新请求的writer会等待在其之前的reader都释放掉读锁后才请求获取写锁，等待writer解锁后，后续的reader才能继续请求锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同Mutex，均为不可重入，使用时应避免复制；&lt;/p&gt;
&lt;p&gt;要注意reader在加读锁后，想要加写锁，则必须要先解除读锁后才能解除写锁，否则会形成相互依赖导致死锁；比如先加读锁，再加写锁，解除写锁，解除读锁，这样就会导致死锁，因为加写锁时，需要读锁先释放，而读锁释放又依赖写锁释放，从而导致死锁&lt;/p&gt;
&lt;p&gt;注意reader是可以重复加读锁的，重复加读锁时，外层reader必须等里层的reader释放锁后自己才能释放锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;必须先使用RLock / Lock方法才能使用RUnlock / Unlock方法，否则会panic，重复释放锁也会panic。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以利用RWMutex实现线程安全的map&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;rlock--runlock-方法&#34;&gt;RLock / RUnlock 方法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;仅对readerCount值进行原子操作&lt;/strong&gt;，还有就是操作当前goroutine和reader信号量&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RLock时，对readerCount的值+1，判断是否&amp;lt; 0，如果是，说明此时有writer在竞争锁或已持有锁，则将当前goroutine加入readerSem指向的队列中，进行等待，防止写锁饥饿。&lt;/li&gt;
&lt;li&gt;RUnlock时，对readerCount的值-1，判断是否&amp;lt;0，如果是，说明当前有writer在竞争锁，调用&lt;code&gt;rUnlockSlow方法&lt;/code&gt;，对readerWait的值-1，判断是否=0，如果是，说明当前goroutine是最后一个要解除读锁的，此时会唤醒要请求写锁的writer。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RWMutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;RLock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readerCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// readerCount小于0，说明有Writer，此时阻塞读操作
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nf&#34;&gt;runtime_SemacquireMutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readerSem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RWMutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;RUnlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readerCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// readerCount小于0，说明有Writer，判断要不要唤醒被阻塞的Writer
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;rUnlockSlow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 进入此方法说明有正在等待的writer
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RWMutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;rUnlockSlow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rwmutexMaxReaders&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Enable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;throw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;sync: RUnlock of unlocked RWMutex&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readerWait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// readerWaiter等于0，说明此时是最后一个reader，此时可以唤醒被阻塞的writer
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nf&#34;&gt;runtime_Semrelease&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;writerSem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;lock方法-1&#34;&gt;Lock方法&lt;/h2&gt;
&lt;p&gt;RWMutex&lt;strong&gt;内部使用Mutex实现写锁互斥&lt;/strong&gt;，解决多个writer间的竞争，readerWait字段实现写操作不会被读操作阻塞而饿死。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用w的Lock方法加锁，防止其他writer上锁，cas反转 readerCount的值并更新到RWMutex中，使其变成负数&lt;code&gt;readerCount - rwmutexMaxReaders&lt;/code&gt; 告诉reader有writer要请求锁；&lt;/li&gt;
&lt;li&gt;如果此时&lt;code&gt;readerCount != 0&lt;/code&gt;，说明当前有reader持有读锁，需要记录需要等待完成的reader的数量，即readerWait的值（readerWaiter + readerCount），并且如果此时readerWait != 0，将当前goroutine加入writerSema指向的队列中，进行等待。直到有goroutine调用RUnlock方法且是最后一个释放锁时，才会被唤醒。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RWMutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 加锁，保证只有一个writer能处理
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// readerCount取反进行更新，表示有writer在执行，阻塞后面的读操作，
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 因为readerCount，readerWait都是全局变量，在读锁方法那边是没有锁保护的，所以是cas保证并发安全
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// readerCount再取反回来，用来更新readerWait的值，判断是否有读操作在等待
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readerCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rwmutexMaxReaders&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rwmutexMaxReaders&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// readerWait 不等于0，说明有reader在执行，需要挂起当前的写操作，直到RUnlock被调用来唤醒
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readerWait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;runtime_SemacquireMutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;writerSem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;unlock方法-1&#34;&gt;Unlock方法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;cas反转readerCount的值（readerCount + rwmutexMaxReaders），使其变成reader的数量，唤醒这些reader&lt;/li&gt;
&lt;li&gt;调用w的Unlock方法释放当前goroutine的锁，让其他writer可以继续竞争。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RWMutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 反转readerCount值使其变正数，表示可以进行读操作
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readerCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rwmutexMaxReaders&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rwmutexMaxReaders&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Enable&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;throw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;sync: Unlock of unlocked RWMutex&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 根据readerWait唤醒正在阻塞的读操作
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;runtime_Semrelease&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readerSem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 解锁，允许其他写操作执行
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;syncmap&#34;&gt;sync.Map&lt;/h1&gt;
&lt;h2 id=&#34;数据结构-2&#34;&gt;数据结构&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Map&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 锁，用于保护dirty
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 存读的数据，只读，由dirty提升得到
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Value&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 包含最新写入的数据，并且在写的时候，如果dirty是nil，会把read中未被删除的数据拷贝到该dirty中
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;dirty&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;entry&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 当从read中读不到数据，但在dirty中读到数据时该值+1, 当len(dirty) == misses时，将dirty拷贝到read中，此动作会发生在get和delete的操作中
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;misses&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;readOnly&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;       &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;entry&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// true表明dirty中存在read中没有的键值对，有两种情况：1.被删除的key，只能在read中找到；2.新增加的key，只能在dirty中找到
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;amended&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// read和dirty都包含了*entry，里面的p是一个指针，read和dirty各自维护了一套key，但他们都指向同一个value
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;entry&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// p的状态有三种：1.=nil，表示键值对已被删除；2.=expunged，表示该key被标记删除；3.=正常值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;基本-2&#34;&gt;基本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基本的并发安全map的实现：将map与RWMutex封装成一个结构体，使用读写锁封装map的各种操作即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用RWMutex封装的并发安全的map，因为锁的粒度太大，性能不会太好；通过减少锁的粒度和持有锁的时间，可以提升性能，常见的减少锁的粒度是将锁分片，将锁进行分片，分别控制map中不同的范围的key，类似JDK7中的ConcurrentHashMap的segment锁实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;官方出品的sync.Map，有六个方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;LoadOrStore：根据key获取value，如果该key存在且没有被标记为删除，则返回原来的value和true，不存在则进行store，返回该value和false&lt;/li&gt;
&lt;li&gt;Load：根据key获取value&lt;/li&gt;
&lt;li&gt;Delete：删除&lt;/li&gt;
&lt;li&gt;LoadAndDelete：根据key删除对应的键值对，如果可以存在，返回对应的value和true&lt;/li&gt;
&lt;li&gt;Range：遍历&lt;/li&gt;
&lt;li&gt;Store：添加key和value&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;官方出品的sync.Map，但它只有在部分特殊的场景里才有优势，比如一个只会增长的map，一个key只会被写一次，读很多次；或者 多个goroutine为不相交的键集读、写和重写键值对；&lt;/p&gt;
&lt;p&gt;sync.Map内部有两个map，一个只读read，一个可写dirty，对只读read的操作(读、更新、删除)不需要加锁，以此减少锁对性能的影响；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sync.Map没有len方法，要获取里面有多少个key只能遍历获取；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;store方法&#34;&gt;Store方法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;创建新dirty时，将read中非删除的键值对赋值给dirty是在store方法中执行。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;更新或写入键值对时，先判断read中是否存在，如果存在，会自旋更新该键值对直到成功；&lt;/p&gt;
&lt;p&gt;原因是&lt;strong&gt;read中的键值对，一定包含了dirty中的键值对&lt;/strong&gt;，另外，read和dirty指向同一个value，所以直接修改一次即可；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果read中读不到，才会进行加锁；&lt;/p&gt;
&lt;p&gt;加锁后再次判断read中是否存在，确定read中真的不存在才会操作dirty；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果read中存在，判断该key是否被删除，如果是，更新dirty的键值对，如果不是，更新read中的键值对；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果read中不存在，则读取dirty，判断dirty是否存在，存在则更新dirty的键值对；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果dirty不存在，且dirty中不存在有的键值对在read中没有，如果dirty为空，创建新dirty，同时需要遍历把read中非删除的键值对赋给dirty；更新&lt;code&gt;read.amended&lt;/code&gt;的值，表明dirty中存在read中没有的键值对；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最后再将新的键值对添加到dirty中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解锁；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结：如果是新key，则加锁，优先put到dirty中，如果是dirty为空，则创建新dirty，将read中非删除键值对赋值给新dirty，将read标记为有key在dirty中但不存在在read中，解锁；如果是已存在的key，由于read和dirty的value是同一个引用，直接cas更新read即可。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;tryStore&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;unexpungeLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dirty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;storeLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dirty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;storeLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;amended&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 将readMap中非删除的键值对赋值给dirtyMap
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;dirtyLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 标记dirtyMap中包含readMap中不存在的键值对
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Store&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;amended&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dirty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;newEntry&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;load方法&#34;&gt;Load方法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;将dirty提升为read这个操作在load方法中执行。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;不加锁，优先读取read中的键值对，判断key是否存在，存在则返回；&lt;/li&gt;
&lt;li&gt;如果read中不存在，且dirty中包含了read中不存在的键值对，加锁，再次读取read中的键值对；&lt;/li&gt;
&lt;li&gt;判断read中的键值对是否存在，存在则返回；&lt;/li&gt;
&lt;li&gt;如果read中不存在，且dirty中包含了read中不存在的键值对，查询dirty中是否存在；&lt;/li&gt;
&lt;li&gt;同时增加miss的值(miss表示读取穿透的次数)，当miss的值等于dirty的长度时，就会将dirty提升为read，只需简单的赋值即可，然后将dirty置为null，重置miss数，避免总是从dirty中加锁读取；&lt;/li&gt;
&lt;li&gt;解锁，将dirty中的查询结果返回；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结：优先读read中的key，读不到，判断read的标记（dirty是否包含read中不存在的key），加锁，再读read，还读不到，再判断dirty是否包含read中不存在的key，如果是，才会去读dirty，同时miss值+1，当miss值=dirty长度时，将dirty中的键值对赋值给read，解锁。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{},&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;amended&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;amended&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dirty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 增加miss的值，判断释放要将dity提升为read
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;missLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;missLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;misses&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;misses&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dirty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 将dirtyMap提升给readMap
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Store&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dirty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dirty&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;misses&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;delete方法&#34;&gt;Delete方法&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;将dirty提升为read这个操作也会在delete方法中执行。&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;判断read中是否存在该key；&lt;/li&gt;
&lt;li&gt;如果read中不存在，且dirty中包含了read中不存在的key，加锁；&lt;/li&gt;
&lt;li&gt;如果read中真的不存在，且dirty中包含了read中不存在的key，删除dirty中该key和value，此时miss也会 + 1，当miss值=dirty长度时，将dirty中非删除的键值对赋值给read，解锁；&lt;/li&gt;
&lt;li&gt;如果存在该key（此时该键值对只会在read中存在），自旋，直接在该key对应的entry打上expunged标记，表示删除；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结：优先读read，读不到，加锁，如果dirty中存在该key，dirty中该键值对会被真正的删除，但此时read中的键值对还没被删除，只是其key对应的value被打上一个expunged标记，表示删除，使其在被get的时候能分辨出来，read中该key真正的删除只有在将dirty提升为read的时候；&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Delete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;LoadAndDelete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;LoadAndDelete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{},&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;loaded&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;amended&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;readOnly&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;amended&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dirty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
			&lt;span class=&#34;nb&#34;&gt;delete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dirty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;c1&#34;&gt;// 增加miss的值，判断释放要将dity提升为read
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;missLocked&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 自旋，cas给key打上删除标记
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;delete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;loadorstore方法&#34;&gt;LoadOrStore方法&lt;/h2&gt;
&lt;p&gt;基本上和Store方法一样，只是增多一点逻辑：如果该key存在且没有被标记为删除，则返回原来的value和true，不存在则进行store，返回该value和false。&lt;/p&gt;
&lt;h1 id=&#34;waitgroup&#34;&gt;WaitGroup&lt;/h1&gt;
&lt;h2 id=&#34;数据结构-3&#34;&gt;数据结构&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
    &lt;span class=&#34;c1&#34;&gt;// 避免复制，使用vet工具在编译时检测是否被复制
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;noCopy&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;noCopy&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 因为64bit值的原子操作需要64bit对齐，但是32bit编译器不支持，所以数组中的元素在不同的架构中不一样
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果地址是64bit对齐，数组前两个元素做state，后一个元素做信号量；如果地址是32bit对齐，数组后两个元素做state，第一个元素做信号量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 高32bit是WaitGroup的计数值，低32bit是waiter的计数,另外32bit是用作信号量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;state1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint32&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;信号量的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当信号量&amp;gt;0时，表示资源可用，获取信号量时系统自动将信号量减1；&lt;/li&gt;
&lt;li&gt;当信号量==0时，表示资源暂不可用，获取信号量时，当前线程会进入睡眠，当信号量为正时被唤醒。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基本-3&#34;&gt;基本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;state的值由32bit的值表示信号量，64bit的值表示计数和waiter的数量组成。因为原子操作只能64bit对齐，而计数值和waiter的数量是一个64bit的值，在64bit的编译器上，一次读取是64bit，刚好可以直接操作，但是如果是32bit的机器，一次只能读32bit，为了保证进行64bit对齐时一定能获取到计数值和waiter的值，在进行64bit的原子操作对齐时，第一次是对齐到了一个空32bit和第一个32bit的值，第二次对齐就能保证获取了。&lt;/li&gt;
&lt;li&gt;同RWMutex，WaitGroup的三个方法内还很多data race检查，保证并发时候共享数据的正确性，一旦检查出有问题，会直接panic&lt;/li&gt;
&lt;li&gt;一开始设置WaitGroup的计数值必须大于等于0，否则会过不了data race检查，直接panic&lt;/li&gt;
&lt;li&gt;Add的值必须 等于 调用Done的次数，当Done的次数超过计数值，也会panic&lt;/li&gt;
&lt;li&gt;Wait方法的调用一定要晚于Add，否则会导致死锁&lt;/li&gt;
&lt;li&gt;WaitGroup可以在计数值为0时可重复使用&lt;/li&gt;
&lt;li&gt;noCopy是一个实现了Lock接口的结构体，且不对外暴露，其Lock方法和Unlock方法都是空实现，用于vet工具检查WaitGroup在使用过程中有没有被复制；当我们自定义的结构不想被复制使用时，也可以使用它。&lt;/li&gt;
&lt;li&gt;使用时要避免复制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;add方法&#34;&gt;Add方法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;原子的将WaitGroup的计数值加到state上，如果当前的计数值 &amp;gt; 0，或者 waiter的数量等于0，直接返回&lt;/li&gt;
&lt;li&gt;否则，即代表当前的计数值为0，但waiter的数量不一定为0，此时state的值就是waiter的数量&lt;/li&gt;
&lt;li&gt;将state的值设置为0，即waiter的数量设置为0，然后唤醒所有waiter&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;statep&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;semap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)),&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])),&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;delta&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;statep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;semap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddUint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;statep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 计数器
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uint32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 等待计数器
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;sync: negative WaitGroup counter&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 等待计数器不为0，说明已经执行了wait方法，此时不允许调用add方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;delta&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;delta&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;sync: WaitGroup misuse: Add called concurrently with Wait&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 如果执行到这里，说明计数器为0，但等待计数器不为0
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 说明此时发生了并发调用Add方法和wait方法，并发调用导致状态不一致
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;statep&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;sync: WaitGroup misuse: Add called concurrently with Wait&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 状态位清零，唤醒等待的goroutine
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;statep&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;runtime_Semrelease&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;semap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;done方法&#34;&gt;Done方法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;调用Add方法，只是参数为-1，表示计数值 - 1，有一个waiter完成其任务；waiter指的是调用Wait方法的goroutine&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;wait方法&#34;&gt;Wait方法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;循环内不断检测state的值，当其计数值为0时，说明所有任务已经完成，调用这个方法的goroutine不必继续等待，直接返回，结束该方法&lt;/li&gt;
&lt;li&gt;否则，说明此时还有任务没完成，调用该方法的goroutine成为waiter，把waiter的数量 + 1，加入等待队列，阻塞自己&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;statep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;semap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;LoadUint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;statep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uint32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 计数器为0，说明goroutine执行结束
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// 调用wait方法的goroutine的数目+1，此时调用Add方法时就能知道有多少goroutine在等待
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;CompareAndSwapUint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;statep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;c1&#34;&gt;// 阻塞等待，直至被唤醒
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nf&#34;&gt;runtime_Semacquire&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;semap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;statep&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;sync: WaitGroup is reused before previous Wait has returned&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;cond--condition--waitnotify&#34;&gt;Cond = condition + Wait/Notify&lt;/h1&gt;
&lt;h2 id=&#34;数据结构-4&#34;&gt;数据结构&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Cond&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
    &lt;span class=&#34;nx&#34;&gt;noCopy&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;noCopy&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 使用vet工具在编译时检测是否被复制
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;checker&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;copyChecker&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 用于运行时被检测是否被复制
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;L&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Locker&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 当观察或者修改等待条件的时候需要加锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;notify&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;notifyList&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 等待队列 
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;基本-4&#34;&gt;基本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;初始化时，要指定使用的锁，比如Mutex&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Cond 是等待某个条件满足，这个条件的修改可以被任意多的 goroutine 更新，而且 Cond 的 Wait 不关心也不知道其他 goroutine 的数量，只关心等待条件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Signal方法，类似Java的notify方法，允许调用者唤醒一个等待此Cond的goroutine，如果此时没有waiter，则无事发生；如果此时Cond的等待队列中有多个goroutine，则移除队首的goroutine并唤醒；&lt;/p&gt;
&lt;p&gt;使用Signal方法时不强求已调用了加锁方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Broadcast方法，类似Java的notifyAll方法，允许调用者唤醒等待此Cond的所有goroutine，如果此时没有waiter，则无事发生；如果此时Cond的等待队列中有多个goroutine，则清空整个等待队列，全部唤醒；&lt;/p&gt;
&lt;p&gt;使用Broadcast方法时不强求已调用了加锁方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Wait方法，类似Java的wait方法，把调用者的goroutine放入Cond的等待队列中并阻塞，直到被Signal或Broadcast方法唤醒&lt;/p&gt;
&lt;p&gt;调用Wait方法时必须已调用了加锁方法，否则会panic，因为Wait方法内是&lt;strong&gt;先解锁&lt;/strong&gt;，将当前goroutine加入到&lt;strong&gt;等待&lt;/strong&gt;队列，然后&lt;strong&gt;解锁&lt;/strong&gt;，阻塞休眠当前goroutine，直到被&lt;strong&gt;唤醒&lt;/strong&gt;，然后&lt;strong&gt;加锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;调用Wait后一定要检测等待条件是否满足，还需不需要继续等待，在等待的goroutine被唤醒不等于等待条件已满足，可能只是被某个goroutine唤醒而已，被唤醒时，只是得到了一次检测机会。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;once&#34;&gt;Once&lt;/h1&gt;
&lt;h2 id=&#34;数据结构-5&#34;&gt;数据结构&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Once&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint32&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;基本-5&#34;&gt;基本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;sync.Once只有一个Do方法，入参是一个无参数无返回值的函数，当且仅当第一次调用Do方法的时候该函数才会执行，即使之后调用了n次、入参的值不一样都不会被执行&lt;/li&gt;
&lt;li&gt;可以将sync.Once与想要只初始化一次的对象封装成一个结构体，提供只初始化一次该值的方法，常用于初始化单例资源、并发访问只初始化一次的共享资源、需要延迟初始化的场景等&lt;/li&gt;
&lt;li&gt;Once传入的函数参数，就算在执行时发生panic，Once也会认为已经执行过了，so如果要知道Once里传入的方法是否执行成功，模仿Do函数自己写一个返回参数的入参方法&lt;/li&gt;
&lt;li&gt;内部的实现非常简单，就是一个flag + 一个双重校验锁&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Once&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Do&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 判断flag是否被置为0，即函数是否还没被执行过
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;LoadUint32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
        &lt;span class=&#34;nx&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;doSlow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;o&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Once&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;doSlow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; 
    &lt;span class=&#34;nx&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; 
    &lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 因为其他最外层的判断+LoadUnit32没有被锁保护，so这里得原子操作
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;StoreUint32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;o&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
        &lt;span class=&#34;nf&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; 
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;pool&#34;&gt;Pool&lt;/h1&gt;
&lt;p&gt;这里是针对go 1.13之后的版本&lt;/p&gt;
&lt;h2 id=&#34;数据结构-6&#34;&gt;数据结构&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Pool&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 使用go vet工具可以检测用户代码是否复制了pool
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;noCopy&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;noCopy&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 每个 P 的本地队列，实际类型为 [P]poolLocal数组，长度是固定的，P的id对应[P]poolLocal下标索引，通过这样的设计，多个 G 使用同一个Pool时，减少竞争，提升性能
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;local&lt;/span&gt;     &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// [P]poolLocal 本地队列的长度
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;localSize&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// GC 时使用，分别接管 local 和 localSize，victim机制用于减少GC后冷启动导致的性能抖动，让对象分配更平滑，降低GC压力的同时提高命中率，由poolCleanup()方法操作
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;victim&lt;/span&gt;     &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;victimSize&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt;

	&lt;span class=&#34;c1&#34;&gt;// 自定义的对象创建回调函数，当 pool 中无可用对象时会调用此函数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;New&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当Pool没有缓存对象时，调用 New 函数生成以下对象&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;poolLocal&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;poolLocalInternal&lt;/span&gt;

	&lt;span class=&#34;c1&#34;&gt;// 将 poolLocal 补齐至两个缓存行的倍数，防止 false sharing,
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 每个缓存行具有 64 bytes，即 512 bit
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 目前我们的处理器一般拥有 32 * 1024 / 64 = 512 条缓存行
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 伪共享，仅占位用，防止在 cache line 上分配多个 poolLocalInternal
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;pad&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;128&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sizeof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;poolLocalInternal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;%&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;128&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// Local 每个P都有一个
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;poolLocalInternal&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// P 的私有对象，使用时无需要加锁，用于不同G执行get和put
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 双向链表
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 同一个P上不同G可以多次执行put方法，需要有地方能存储, 并且别的P上的G可能过来偷，通过cas实现
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;shared&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;poolChain&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;poolChain 是一个双向链表的实现；&lt;/p&gt;
&lt;p&gt;poolDequeue 被实现为单生产者，多消费者的固定大小无锁的环形队列，生产者可以从 head 插入和删除，而消费者仅能从 tail 删除&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;poolChain&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 只有生产者会 push to，不用加锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;poolChainElt&lt;/span&gt;

	&lt;span class=&#34;c1&#34;&gt;// 读写需要原子控制，pop from
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;poolChainElt&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;poolChainElt&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;poolDequeue&lt;/span&gt;

	&lt;span class=&#34;c1&#34;&gt;// next 被 producer 写，consumer 读。所以只会从 nil 变成 non-nil
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// prev 被 consumer 写，producer 读。所以只会从 non-nil 变成 nil
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;prev&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;poolChainElt&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;poolDequeue&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// headTail 包含一个 32 位的 head (高32位)和一个 32 位的 tail(低32位) 指针。这两个值都和 len(vals)-1 取模过。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// tail 是队列中最老的数据，head 指向下一个将要填充的 slot
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// slots 的有效范围是 [tail, head)，由 consumers 持有。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 通过对其cas操作保证并发安全
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;headTail&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint64&lt;/span&gt;

	&lt;span class=&#34;c1&#34;&gt;// vals 是一个存储 interface{} 的环形队列，它的 size 必须是 2 的幂，初始化长度为8
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 如果 slot 为空，则 vals[i].typ 为空；否则，非空。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 一个 slot 在这时宣告无效：tail 不指向它了，vals[i].typ 为 nil
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 由 consumer 设置成 nil，由 producer 读
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;vals&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;eface&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_syncPool%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_syncPool%e6%95%b0%e6%8d%ae%e7%bb%93%e6%9e%84.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每次垃圾回收时，Pool会把victim中的对象移除，然后把local的数据给victim，local置为nil，如果此时有Get方法被调用，则会从victim中获取对象。通过这种方式，避免缓存元素被大量回收后再再次使用时新建很多对象；&lt;/li&gt;
&lt;li&gt;获取重用对象时，先从local中获取，获取不到再从victim中获取；&lt;/li&gt;
&lt;li&gt;poolLocalInternal用于CPU缓存对齐，避免false sharing；&lt;/li&gt;
&lt;li&gt;private字段代表一个可复用对象，且只能由相应的一个P存取，因为一个P同时只能执行一个goroutine，所以不会有并发问题；&lt;/li&gt;
&lt;li&gt;shared字段可以被任意的P访问，但是只有本地的P能pushHead/popHead，其他P可以popTail，相当于只有一个本地P作为生产者，多个P作为消费者，它由一个lock-free的队列实现；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基本-6&#34;&gt;基本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;sync.Pool用于保存一组可独立访问的临时对象，它池化的对象如果没有被其他对象持有引用，可能会在未来某个时间点（GC发生时）被回收掉；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sync.Pool是并发安全的，多个gotoutine可以并发调用它存取对象；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能复制使用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在1.13以前，保证并发安全使用了带锁的队列，且在GC时，直接清空所有Pool的&lt;code&gt;local&lt;/code&gt;和&lt;code&gt;poollocal.shared&lt;/code&gt;，GC的时间可能会很长;&lt;/p&gt;
&lt;p&gt;1.13后，改成了lock-free的队列实现，避免锁对性能的影响，且在GC时，使用victim作为次级缓存，GC时将对象放入其中，下次GC来临之前，如果有 Get 调用则会从victim中取，直到下一次GC来临时回收，拉长实际回收时间，使得单位时间内GC的开销减少；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;包含了三个方法：New、Get、Put；&lt;strong&gt;Get方法调用时，会从池中移走该元素&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当Pool里没有元素可用时，Get方法会返回nil；可以向Pool中Put一个nil的值，Pool会将其忽略；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在使用Put归还对象时，需要将对象的属性reset；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当使用Pool作为buffer池时，要注意buffer如果太大，reset后它就会占很大空间，引起内存泄漏，因此在回收元素时，需要检查大小，如果太大了就直接置为null，丢弃即可；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pool 里对象的生命周期受 GC 影响，不适合于做连接池，因为连接池需要自己管理对象的生命周期；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Pool 不可以指定大小，大小只受制于 GC 临界值；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;procPin&lt;/code&gt; 将 G 和 P 绑定，防止 G 被抢占。在绑定期间，GC 无法清理缓存的对象；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;sync.Pool&lt;/code&gt; 的最底层使用链表，链表元素是切片(当作环形队列)，并将缓存的对象存储在切片中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;底层切片初始化长度为8，始终保持2的n次幂的增长，最大的容量是2^30，达到上限时，再生成的队列容量都是2^30；链表的节点的环形队列长度是 &lt;code&gt;head -&amp;gt; 32 -&amp;gt; 16 -&amp;gt; 8 -&amp;gt; tail&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Get方法调用时，&lt;strong&gt;如果是从其他P的local.shared的尾部窃取复用对象&lt;/strong&gt;，同时会移除环形队列里的元素，当环形队列被窃取到为空时，会移除当前节点；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;get方法&#34;&gt;Get方法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;如果非第一次访问，调用&lt;code&gt;p.pin()&lt;/code&gt;函数，&lt;strong&gt;将当前 G 固定在P上，防止被抢占&lt;/strong&gt;，并获取pid，再根据pid号找到当前P对应的poolLocal；如果P的数量大于poolLocal的数量，就会进入&lt;code&gt;p.pinSlow()&lt;/code&gt;方法，加锁，创建P个poolLocal。&lt;/li&gt;
&lt;li&gt;拿到poolLocal后，优先从local的private字段取出一个元素，将private置为null；&lt;/li&gt;
&lt;li&gt;如果从private取出的元素为null，则从当前的&lt;code&gt;local.shared&lt;/code&gt;的head中取出一个双端环形队列，遍历队列获取元素，如果有pop出来并返回；如果还取不到，沿着pre指针到下一个双端环形队列继续获取，直到获取到或者遍历完双向链表；&lt;/li&gt;
&lt;li&gt;如果还没有的话，调用&lt;code&gt;getSlow&lt;/code&gt;函数，遍历其他P的poolLocal（从pid+1对应的poolLocal开始），从它们shared 的 tail 中弹出一个双端环形队列，遍历队列获取元素，如果有，pop出来并返回；如果还取不到（如果当前节点为null，则删除），沿着next指针到下一个双端环形队列继续获取，如果还没有，直到获取到或者遍历完双向链表；如果还没有，就到别的P上继续获取；&lt;/li&gt;
&lt;li&gt;如果所有P的poolLocal.shared都没有，则对victim中以在同样的方式，先从当前P的poolLocal的private里找，找不到再在shared里找，获取一遍；&lt;/li&gt;
&lt;li&gt;Pool相关操作&lt;strong&gt;执行完，调用&lt;code&gt;runtime_procUnpin()&lt;/code&gt;解除非抢占&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;如果还取不到，则调用New函数生成一个，然后返回；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因为当前的G被固定在了P上，在查找元素时不会被其他P执行。&lt;/p&gt;
&lt;h2 id=&#34;pin方法&#34;&gt;pin方法&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;pin&lt;/code&gt; 的作用就是将当前 G 和 P 绑定在一起，禁止抢占，并返回对应的 poolLocal 以及 P 的 id。&lt;/p&gt;
&lt;p&gt;如果 G 被抢占，则 G 的状态从 running 变成 runnable，会被放回 P 的 LRQ 或 GRQ，等待下一次调度。下次再执行时，就不一定是和现在的 P 相结合了。因为之后会用到 pid，如果被抢占了，有可能接下来使用的 pid 与所绑定的 P 并非同一个。&lt;/p&gt;
&lt;p&gt;所谓的抢占，就是把 M 绑定的 P 给剥夺了，因为我们后面获取本地的 poolLocal 是根据pid获取的，如果这个过程中 P 被抢走，就乱套了，所以需要设置禁止抢占，实现的原理就是让 M 的locks字段不等于0，比如+1，实际上也相当于对M上锁，让调度器知道 M 不适合抢占，这里就很好体现了数据的局部性：让G和M在被抢占后，仍然找回原来的P，这里通过禁止抢占，来保证数据局部性。&lt;/p&gt;
&lt;p&gt;执行完之后，P 不可抢占，且 GC 不会清扫 Pool 里的对象。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Pool里，还有一个全局Pool数组，allPools和oldPools，用于保存所有声明的Pool对象，便于GC时遍历所有声明的Pool，使用了victim cache机制让GC更平滑（调用poolCleanup方法）。&lt;/p&gt;
&lt;p&gt;当P的数量大于 poolLocal 数组的长度时，就会进入 pinSlow 方法，构建新的 poolLocal 节点。&lt;/p&gt;
&lt;p&gt;进入pinSlow方法后，首先会解除G和P的绑定，再上锁，锁定allPools（因为是全局变量），之所以先解除绑定再上锁，主要是锁的粒度比较大，被阻塞的概率也大，如果还占用着P，浪费资源；锁定成功后，才再次进行绑定，由于此时P可能被其他线程占用了，p.local可能会发生变化，此时还需要对pid进行检查，如果P的数量大于 poolLocal 的长度，才创建新的poolLocal数组，长度为P的个数，这一步其实是懒加载，懒汉式初始化 poolLocal数组 作为 P的本地数组，如果是首次创建，p还会加入allPools。&lt;/p&gt;
&lt;h2 id=&#34;put方法&#34;&gt;Put方法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;如果Put进来的元素是null，直接返回；&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;p.pin()&lt;/code&gt;函数，将当前 G 固定在P上，防止被抢占，并获取pid，再根据pid号找到当前P对应的poolLocal；&lt;/li&gt;
&lt;li&gt;尝试将put进来的元素赋值给private，如果本地private没有值，直接赋值；&lt;/li&gt;
&lt;li&gt;否则，原子操作将其加入到shared对应的双端队列的队首；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;gc前&#34;&gt;GC前&lt;/h2&gt;
&lt;p&gt;Pool会在init方法中使用&lt;code&gt;runtime_registerPoolCleanup&lt;/code&gt;注册GC的钩子&lt;code&gt;poolCleanup&lt;/code&gt;来进行pool回收处理。&lt;/p&gt;
&lt;p&gt;其中一个主要动作是 &lt;code&gt;poolCleanup()&lt;/code&gt; 方法，该方法主要就是在GC开始前：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;遍历oldPools数组，将其中的pool对象的victim置为nil；&lt;/li&gt;
&lt;li&gt;遍历allPools数组，将local对象赋值给victim，local对象赋值为nil；&lt;/li&gt;
&lt;li&gt;然后将allPools赋值给oldPools，allPools置为nil；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当GC开始时候，就会将 oldPools数组中 pool对象 已释放的 victim cache 中所有对象的回收（因为已经被置为null了）。因为victim cache的设计，pool中的复用对象会在每两个GC循环中清除；&lt;/p&gt;
&lt;h1 id=&#34;原子操作&#34;&gt;原子操作&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;依赖atomic包，因为没有泛型，目前该包支持int32、int64、uint32、unit64、uintptr、Pointer的原子操作，比如Add、CompareAndSwap、Swap、Load、Store等（Pointer不支持Add），对于有符号的数值来说，Add一个负数相当于减；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于现代多核操作系统来说，由于cache、指令重排、可见性问题，一个核对地址的值的更改，在更新到主内存中前，会先存在多级缓存中，此时，多个核看到该数据可能还没看到更新的数据，还在使用旧数据，而atomic包提供的方法会提供内存屏障的功能，保证赋值数据的完整性和可见性；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;atomic操作的对象是一个地址，不是变量值；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用atomic实现的lock-free的队列&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;queue&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
  &lt;span class=&#34;s&#34;&gt;&amp;#34;sync/atomic&amp;#34;&lt;/span&gt;
  &lt;span class=&#34;s&#34;&gt;&amp;#34;unsafe&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// lock-free的queue
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;LKQueue&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 通过链表实现，这个数据结构代表链表中的节点
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewLKQueue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LKQueue&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LKQueue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 入队
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;q&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LKQueue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Enqueue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 尾还是尾
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 还没有新数据入队
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;cas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//增加到队尾
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;          &lt;span class=&#34;nf&#34;&gt;cas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//入队成功，移动尾巴指针
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;          &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 已有新数据加到队列后面，需要移动尾指针
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;cas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 出队，没有元素则返回nil
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;q&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LKQueue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Dequeue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// head还是那个head
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// head和tail一样
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 说明是空队列
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;          &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 只是尾指针还没有调整，尝试调整它指向下一个
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nf&#34;&gt;cas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 读取出队的数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 既然要出队了，头指针移动到下一个
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;cas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;q&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
          &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// Dequeue is done.  return
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 将unsafe.Pointer原子加载转换成node
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;LoadPointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 封装CAS,避免直接将*node转换成unsafe.Pointer
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;cas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;CompareAndSwapPointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;weighted--semaphore信号量&#34;&gt;Weighted = Semaphore信号量&lt;/h1&gt;
&lt;h2 id=&#34;数据结构-7&#34;&gt;数据结构&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Weighted&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// 最大资源数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;cur&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// 当前已被使用的资源
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 互斥锁，对字段的保护
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;waiters&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;List&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;// 等待队列，通过channel实现通知机制
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;基本-7&#34;&gt;基本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;信号量中的PV操作，P：获取资源，如果获取不到，则阻塞，加入到等待队列中；V：释放资源，从等待队列中唤醒一个元素执行P操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二进位信号量，或者说只有一个计数值的信号量，其实相当于go中的Mutex互斥锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;初始化时，必须指定初始的信号量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只调用Release方法会直接panic；Release方法传入负数，会导致资源被永久持有；因此要保证请求多少资源，就释放多少资源&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Mutex中使用的sema是一个信号量，只是其实现是在runtime中，并没有对外暴露，在扩展包中，暴露了一个信号量工具Weighted&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Weighted分为3个方法：Acquire方法，相当于P操作，第一个参数是context，可以使用context实现timeout或cancel机制，终止goroutine；正常获取到资源时，返回null，否则返回ctx.Err，信号量计数值不变。&lt;/p&gt;
&lt;p&gt;Release方法，相当于V操作，可以释放n个资源，返回给信号量；&lt;/p&gt;
&lt;p&gt;TryAcquire方法，尝试获取n个资源，但不会阻塞，成功时返回true，否则一个也不获取，返回false&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号量的实现也可通过buffer为n的channel实现，只是一次只能请求一个资源，而Weighted一次可以请求多个&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;acquire方法&#34;&gt;Acquire方法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;加锁，判断可用资源 &amp;gt;= 入参所需的资源数，且没有waiter，说明资源足够，直接cur+上所需资源数，解锁返回&lt;/li&gt;
&lt;li&gt;如果所需资源数&amp;gt;最大资源数，说明是不可能任务，解锁，依赖ctx的Done方法返回，否则一直等待&lt;/li&gt;
&lt;li&gt;如果资源数不够，将调用者加入等待队列，并创建一个read chan，用于通知唤醒，解锁&lt;/li&gt;
&lt;li&gt;等待唤醒有两种条件，一种是通过read chan唤醒，另一种是通过ctx.Done唤醒&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;release方法&#34;&gt;Release方法&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;加锁，当前已使用资源数cur - 入参要释放的资源数，唤醒等待队列中的元素，解锁&lt;/li&gt;
&lt;li&gt;唤醒等待队列的元素时，会遍历waiters队列，按照先入先出的方式唤醒调用者，前提是释放的资源数要够队首的元素资源的要求，比如只释放了100个资源，但是队首元素要求101个资源，那队列中的所有等待者都将继续等待，直到队首元素出队，这样做是为了避免饥饿&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;singleflight&#34;&gt;SingleFlight&lt;/h1&gt;
&lt;h2 id=&#34;结构体&#34;&gt;结构体&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 代表一个正在处理的请求，或者已经处理完的请求
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 这个字段代表处理完的值，在waitgroup完成之前只会写一次, waitgroup完成之后就读取这个值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;
  
    &lt;span class=&#34;nx&#34;&gt;forgotten&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 指示当call在处理时是否要忘掉这个key
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;dups&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 相同的key的请求数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;chans&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Result&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  
&lt;span class=&#34;c1&#34;&gt;// group代表一个singleflight对象
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Group&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// protects m
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;call&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// lazily initialized
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;基本-8&#34;&gt;基本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SingleFlight可以合并多个请求为一个请求，再将该请求的结果返回给多个请求，从而达到合并并发请求的目的，减少并发调用的数量。比如有多个相同的读请求查库，那就可以合并成一个请求查库，再把结果响应回这多个请求中；或者是解决缓存击穿问题，降低对下游服务的并发压力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;底层由Mutex和Map实现，Mutex保证并发读写保护，Map保存同一个key正在处理的请求&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;包含3个方法，Do方法：提供一个key和一个函数，对于同一个key，在同一时间只有一个函数在执行，之后同一个key并发的请求会等待，等到第一个执行的结果就是该key的所有结果，调用完成后，会移除这个key。返回值shared表示结果是否来自多个相同请求。&lt;/p&gt;
&lt;p&gt;DoChan方法：类似Do方法，只是返回是一个chan，待入参函数执行完，产生结果后就能在chan中接收这个结果&lt;/p&gt;
&lt;p&gt;Forget方法：告诉Group忽略这个key，之后这个key的请求会执行入参函数，而不是等待前一个未完成的入参函数的结果&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;cyclicbarrier---循环栅栏&#34;&gt;CyclicBarrier - 循环栅栏&lt;/h1&gt;
&lt;h2 id=&#34;数据结构-8&#34;&gt;数据结构&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;CyclicBarrier&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 等待所有的参与者到达，如果被ctx.Done()中断，会返回ErrBrokenBarrier
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;Await&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 重置循环栅栏到初始化状态。如果当前有等待者，那么它们会返回ErrBrokenBarrier
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;Reset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 返回当前等待者的数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;GetNumberWaiting&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 参与者的数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;GetParties&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 循环栅栏是否处于中断状态
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;IsBroken&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;基本-9&#34;&gt;基本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;类似Java的CyclicBarrier，允许一组goroutine相互等待，到达一个共同的执行点再继续往下执行；同时也可被重复使用。&lt;/li&gt;
&lt;li&gt;CyclicBarrier是一个接口，然后有两个初始化的方法，New方法，指定循环栅栏的参与者数量即可初始化；NewWithAction方法，除了指定参与者数量，第二个参数是一个函数，表示在最后一个参与者到达之后，但其他参与者还没放行之前，会调用该函数&lt;/li&gt;
&lt;li&gt;每个参与的goroutine都会调用Await方法进行阻塞，当调用Await方法的goroutine的个数=参与者的数量时，Await方法造成的阻塞才会解除&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;errgroup&#34;&gt;ErrGroup&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类似WaitGroup，只是功能更丰富，多了与Context集成，可以通过Context监控是否发生cancel；error可以向上传播，把子任务的错误传递给Wait的调用者&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ErrGroup用于并发处理子任务，将一个大任务拆成几个小任务，通过Go方法并发执行。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ErrGroup有三个方法：withContext、Go、Wait，用法与WaitGroup相似，只是不需要设置计数值，且可以通过Wait方法获取子任务返回的错误，但它只会返回第一个出现的错误，如果所有子任务都执行成功，返回null；当发生错误时不会立即返回，而是等到其他任务完成了才会返回。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Go方法会创建一个goroutine来执行子任务，如果并发的量太大，会导致创建大量的goroutine，带来goroutine的调度和GC压力，占用更多资源，解决方案可以是使用worker pool或者信号量来控制goroutine的数量或保持重用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子任务如果发生panic会导致程序崩溃&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;检测工具&#34;&gt;检测工具&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;go race detector：主要用于检测多个goroutine对共享变量的访问是否存在协程安全问题。编译器通过探测所有内存的访问，加入代码监视对内存地址的访问，在程序运行时，监控共享变量的非同步访问，出现race时，打印告警信息。比如在运行时加入race参数&lt;code&gt;go run -race main.go&lt;/code&gt;，当执行到一些并发操作时，才会检测运行时是否有并发问题&lt;/li&gt;
&lt;li&gt;命令&lt;code&gt;go vet xxx.go&lt;/code&gt;可以进行死锁检测&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/ricklz/p/14535653.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;go中sync.Mutex源码解读&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/ricklz/p/14496612.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;go中waitGroup源码解读&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/344834329&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深度解密Go语言之sync.map&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/99710992&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;golang的对象池sync.pool源码解读&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/qcrao-2018/p/12736031.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深度解密 Go 语言之 sync.Pool&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go Goroutine和GC</title>
        <link>http://nixum.cc/p/go-goroutine%E5%92%8Cgc/</link>
        <pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/go-goroutine%E5%92%8Cgc/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;runtime&#34;&gt;runtime&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;不同于Java，Go没有虚拟机，很多东西比如自动GC、对操作系统和CPU相关操作都变成了函数，写在runtime包里。&lt;/li&gt;
&lt;li&gt;runtime提供了go代码运行时所需要的基础设施，如协程调度、内存管理、GC、map、channel、string等内置类型的实现、对操作系统和CPU相关操作进行封装。&lt;/li&gt;
&lt;li&gt;诸如go、new、make、-&amp;gt;、&amp;lt;-等关键字都被编译器编译成runtime包里的函数&lt;/li&gt;
&lt;li&gt;build成可执行文件时，runtime会和用户代码一起进行打包。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;pprof&#34;&gt;pprof&lt;/h1&gt;
&lt;p&gt;使用&lt;code&gt;net/http/pprof&lt;/code&gt;库，进行HTTP服务进行分析，需要主动开启，比如&lt;code&gt;import _ &amp;quot;net/http/pprof&amp;quot;&lt;/code&gt;，使用默认的&lt;code&gt;http.DefaultServeMux&lt;/code&gt;，默认端口是6060；也可自定义Mux，手动注册路由。&lt;/p&gt;
&lt;p&gt;pprof提供应用运行的过程中分析当前应用的各项指标来辅助进行性能优化以及问题排查功能，提供以下功能：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;allocs&lt;/td&gt;
&lt;td&gt;查询内存分配情况，所有对象的内存分配，在堆（Heap）分配的时候，记录一下调用堆栈。默认情况下，是每 1000 次分配，取样一次，这个数值可以改变。栈(Stack)分配 由于会随时释放，因此不会被内存分析所记录。由于内存分析是取样方式，并且也因为其记录的是分配内存，而不是使用内存。开启后会对runtime产生压力，通过&lt;code&gt;runtime.MemProfileRate&lt;/code&gt;设置采样的内存比例，默认大小是512kb。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;blocks&lt;/td&gt;
&lt;td&gt;查询阻塞操作情况，类似于 CPU 性能分析，但是它所记录的是 goroutine 等待资源所花的时间。阻塞分析对分析程序并发瓶颈非常有帮助，阻塞性能分析可以显示出什么时候出现了大批的 goroutine 被阻塞了。阻塞性能分析是特殊的分析工具，在排除 CPU 和内存瓶颈前，不应该用它来分析。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;cmdline&lt;/td&gt;
&lt;td&gt;应用启动命令及参数&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;goroutine&lt;/td&gt;
&lt;td&gt;当前所有协程的堆栈信息，开启时会STW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;heap&lt;/td&gt;
&lt;td&gt;堆上内存使用情况采样信息，活跃对象的内存分配&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;mutex&lt;/td&gt;
&lt;td&gt;锁持有的堆栈，次数(采样)的信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;profile&lt;/td&gt;
&lt;td&gt;CPU占用情况采样，启动后会对runtime产生压力，runtime每10ms会STW，记录当前运行的 goroutine 的调用堆栈及相关数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;threadcreate&lt;/td&gt;
&lt;td&gt;系统线程创建情况的采样信息，不会STW&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;trace&lt;/td&gt;
&lt;td&gt;程序运行跟踪信息，跟踪GC和G调度&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;curl  http://ip:port/debug/pprof/{上面列表的功能} &amp;gt; profile文件名&lt;/code&gt; 把此时的统计下载下来；像trace、profile 默认采集时间是30s，可以使用参数 seconds=xx 来调整采样时间；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除了trace使用&lt;code&gt;go tool trace 文件名&lt;/code&gt;打开外，其他都是使用&lt;code&gt;go tool pprof -http=:8080 profile文件名&lt;/code&gt;，打开web终端，左上角view里就有各种视图；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于火焰图&lt;/p&gt;
&lt;p&gt;Y轴表示调用栈，从上到下每一层都是一个函数，调用栈越深火焰就越高，最底部是正在执行的函数，上面是它的父函数；&lt;/p&gt;
&lt;p&gt;X轴表示这个函数的抽样数，如果一个函数在X轴占的越宽，代表抽样数越高，CPU占用的时间越长；注意，X轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的；&lt;/p&gt;
&lt;p&gt;火焰图就是看顶层的哪个函数占据的宽度最大。只要有&amp;quot;平顶&amp;quot;（plateaus），就表示该函数可能存在性能问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;debug包下有几个可以读取运行时指标的方法，但需要手动编写输出&lt;/p&gt;
&lt;p&gt;&lt;code&gt;debug.ReadGCStatus()&lt;/code&gt;，具体的指标可以看&lt;code&gt;debug.GCStats{}&lt;/code&gt;里的字段&lt;/p&gt;
&lt;p&gt;&lt;code&gt;runtime.ReadMemStats()&lt;/code&gt;，具体的指标可以看&lt;code&gt;runtime.MemStats&lt;/code&gt;里的字段&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;printGCStats&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 每隔一秒钟监控一次 GC 的状态
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;NewTicker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;debug&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;GCStats&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;nx&#34;&gt;debug&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ReadGCStats&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
            &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;gc %d last@%v, PauseTotal %v\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;NumGC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LastGC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PauseTotal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;printGCStats&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;netpoller&#34;&gt;netpoller&lt;/h1&gt;
&lt;p&gt;参考：https://strikefreedom.top/go-netpoll-io-multiplexing-reactor，讲得足够详细了&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.luozhiyun.com/archives/439&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.luozhiyun.com/archives/439&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/272891398&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://zhuanlan.zhihu.com/p/272891398&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;netpoller本质上是利用操作系统本身的非阻塞IO模型 + IO多路复用的封装，从而实现&lt;code&gt;goroutine-per-connection&lt;/code&gt;模式，使用同步编程模式达到异步执行的效果。&lt;/p&gt;
&lt;p&gt;netpoller算是运行在go scheduler中的一个子系统，但它主要是处理网络请求的，使其不阻塞整个调度。&lt;/p&gt;
&lt;p&gt;netpoller中的几个方法：&lt;code&gt;对epoll的封装 netpollinit、netpollopen、netpoll&lt;/code&gt;、&lt;code&gt;net.listen&lt;/code&gt;、&lt;code&gt;Listener.Accept&lt;/code&gt;、&lt;code&gt;Conn.Read / Conn.Write&lt;/code&gt;，对网络的fd会设置成NonBlocking模式，根据不同的返回值设置G的状态，在M的调度、sysmon、gc STW结束等阶段会poll出ready的G进行运行或者添加到GRQ中。&lt;/p&gt;
&lt;p&gt;这里记一下Go网络相关的goroutine是如何被规划调度的：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首先，client 连接 server 的时候，listener 通过 accept 调用接收新 connection，每一个新 connection 都启动一个 goroutine 处理，accept 调用会把该 connection 的 fd 连带所在的 goroutine 上下文信息封装注册到 epoll 的监听列表里去，当 goroutine 调用 &lt;code&gt;conn.Read&lt;/code&gt; 或者 &lt;code&gt;conn.Write&lt;/code&gt; 等需要阻塞等待的函数时，会被 &lt;code&gt;gopark&lt;/code&gt; 给封存起来并使之休眠，让 P 去执行本地调度队列里的下一个可执行的 goroutine，往后 Go scheduler 会在循环调度的 &lt;code&gt;runtime.schedule()&lt;/code&gt; 函数以及 sysmon 监控线程中调用 &lt;code&gt;runtime.netpoll&lt;/code&gt; 以获取可运行的 goroutine 列表并通过调用 injectglist 把剩下的 g 放入全局调度队列或者当前 P 本地调度队列去重新执行。&lt;/p&gt;
&lt;p&gt;当IO事件发生之后，netpoller通过 &lt;code&gt;runtime.netpoll&lt;/code&gt; 即可在epoll监听列表获取到已就绪的fd列表对应的goroutine，具体：&lt;code&gt;runtime.netpoll&lt;/code&gt;会调用 &lt;code&gt;epollwait&lt;/code&gt; 等待发生了可读/可写事件的fd，循环 &lt;code&gt;epollwait&lt;/code&gt; 返回的事件列表，处理对应的事件类型，组装可运行的goroutine链表并返回。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sysmon监控线程&lt;/code&gt;会在循环过程中检查距离上一次 &lt;code&gt;runtime.netpoll&lt;/code&gt; 被调用是否超过10ms，若是则回去调用它拿到可运行的goroutine列表并调用 injectglist 把 g 列表放入全局调度队列或者当前 P 本地调度队列等待被执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结：当处理网络IO的goroutine被阻塞住时，通过netpoll + 非阻塞IO，让G不会因为系统调用而陷入内核态，只是被runtime调用gopark住，此时G会被放置到某个wait queue中；当IO可用时，在 epoll 的 &lt;code&gt;eventpoll.rdr&lt;/code&gt; 中等待的 G 会被放到 &lt;code&gt;eventpoll.rdllist&lt;/code&gt; 链表里并通过 &lt;code&gt;netpoll&lt;/code&gt; 中的 &lt;code&gt;epoll_wait&lt;/code&gt; 系统调用&lt;strong&gt;返回放置到GRQ或者 P 的LRQ&lt;/strong&gt;，标记为 &lt;code&gt;_Grunnable&lt;/code&gt; ，等待 P 绑定 M 恢复执行。&lt;/p&gt;
&lt;h1 id=&#34;goroutine&#34;&gt;Goroutine&lt;/h1&gt;
&lt;h2 id=&#34;结构&#34;&gt;结构&lt;/h2&gt;
&lt;h3 id=&#34;g&#34;&gt;G&lt;/h3&gt;
&lt;p&gt;goroutine本质是一个执行流，通过&lt;code&gt;go func(){}()&lt;/code&gt;会开启一个协程，等待被调度，编译的时候，会变成 &lt;code&gt;runtime.g&lt;/code&gt; 结构体，用于调度，func函数会挂在 &lt;code&gt;runtime.g&lt;/code&gt; 的startpc字段，func函数的入参会拷贝到栈中，sched用于保存协程切换时的pc位置和栈位置；&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 实际不止这些字段
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;g&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;goid&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 协程id
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;status&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint32&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 协程状态
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;stack&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 协程使用的栈
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;lo&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 该协程拥有的栈低位
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;hi&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 该协程拥有的栈高位
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;sched&lt;/span&gt;       &lt;span class=&#34;nx&#34;&gt;gobuf&lt;/span&gt;          &lt;span class=&#34;c1&#34;&gt;// g的运行现场，用于切换时保存上下文
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;stackgroud0&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 用于栈扩张
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;stackgroud1&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 用于栈收缩
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;           &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;             &lt;span class=&#34;c1&#34;&gt;// 当前g绑定的m
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;param&lt;/span&gt;       &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// wakeup时使用，参数传入
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;waitsince&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;          &lt;span class=&#34;c1&#34;&gt;// g被阻塞后的近似时间
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;waitreason&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;waitReason&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;// g被阻塞的原因
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;preempt&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;           &lt;span class=&#34;c1&#34;&gt;// 抢占调度标志
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;lockedm&lt;/span&gt;     &lt;span class=&#34;nx&#34;&gt;muintptr&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// 如果调用了LockOsThread，g就会被绑定在m上
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;gopc&lt;/span&gt;        &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 创建goroutine语句的指令地址
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;startpc&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// goroutine函数的指令地址
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;timeer&lt;/span&gt;      &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;timer&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// time.Sleep缓存的定时器
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gobuf&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;sp&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 栈指针的位置
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;pc&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 运行到的程序位置，程序计数器的值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;m&#34;&gt;M&lt;/h3&gt;
&lt;p&gt;G要调度到M上才能运行，M是真正工作的实体，保存了自身使用的栈信息，当前正在M上执行的G信息，与之绑定的P信息等。m结构体记录了与之对应的内核线程的栈信息，在执行调度时使用。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 实际不止这些字段
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;g0&lt;/span&gt;         &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;g&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// 执行用户goroutine时，使用用户goroutine自己的栈，因此调度时会发生栈的切换
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;tls&lt;/span&gt;        &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// LocalThreadStorage，通过tls结构体实现m与工作线程的绑定
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;curg&lt;/span&gt;       &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;g&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// 指向正在运行的goroutine对象
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;          &lt;span class=&#34;nx&#34;&gt;puintptr&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 当前工作线程绑定的P
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;preemptoff&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;// 该字段不等于空字符串时，保存curg始终在这个m上运行
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;spinning&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// 为true表示当前m处于自旋状态，正在从其他线程偷任务
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;blocked&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// m正阻塞在note上
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;park&lt;/span&gt;       &lt;span class=&#34;nx&#34;&gt;note&lt;/span&gt;       &lt;span class=&#34;c1&#34;&gt;// 没有goroutine需要运行时，工作线程sleep在这个park成员上，其他线程通过这个park唤醒该工作线程
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;alllink&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// 记录所有工作线程的链表
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;locks&lt;/span&gt;      &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// 锁的计数器，非0表示对m上锁，禁止被抢占
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;p&#34;&gt;P&lt;/h3&gt;
&lt;p&gt;为M的执行提供上下文，保存M执行G的一些资源，一个M只有绑定了P才能执行goroutine&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;id&lt;/span&gt;          &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// 在allp中的索引
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;schedtick&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;uint32&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 每次调用schedule时会加一
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;syscalltick&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint32&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 每次系统调用时会加一
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;sysmontick&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;sysmontick&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 用于sysmon线程记录被监控p的系统调用时间和运行时间
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;           &lt;span class=&#34;nx&#34;&gt;muintptr&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// 执行绑定的m，如果p是idle的话，这个指针是nil
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;runqhead&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;uint32&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 本地运行队列的队头
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;runqtail&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;uint32&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 本地运行队列的队尾
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;runq&lt;/span&gt;        &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;256&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;guintptr&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 本地运行队列，一个256长度的数组
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// runnext非空，表示有一个G在执行，状态是runnable
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 这个G被当前G修改为ready状态时，相比runq中的G有更高的优先级
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 如果当前G还有剩余的可用时间，那就运行这个G
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 运行之后，该G会记串当前G的剩余时间
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;runnext&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;guintptr&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 空闲g链表
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;gFree&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;gList&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;基本&#34;&gt;基本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;GPM模型 - M：N调度模型&lt;/p&gt;
&lt;p&gt;模型分类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;N：1 即 N个协程绑定1个线程&lt;/p&gt;
&lt;p&gt;优点：协程在用户态线程即可完成切换，由协程调度器调度，不涉及内核态，无需CPU调度，轻量快速；&lt;/p&gt;
&lt;p&gt;缺点：无法使用多核加速，一旦某协程阻塞，会导致线程阻塞，此时并行变成串行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1：1 即 1个协程绑定1个线程&lt;/p&gt;
&lt;p&gt;优点：解决N：1模型的缺点；&lt;/p&gt;
&lt;p&gt;缺点：调度均有协程调度器和CPU调度，代价较大，无法并行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;M：N 即 M个协程绑定N个线程，由协程调度器调度，线程在内核态通过CPU抢占式调用，协程在用户态通过协作式调度&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般线程会占有1Mb以上的内存空间，每次对线程进行切换时会消耗较多内存，恢复寄存器中的内容还需要向操作系统申请或销毁对应的资源，每一次上下文切换都需要消耗~1us左右的时间，而Go调度器对 G 的上下文切换为~0.2us，减少了80%的额外开销。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;协程本质是一个数据结构，封装了要运行的函数和运行的进度，交由go调度器进行调度，不断切换的过程。由go调度器决定协程是运行，还是切换出调度队列(阻塞)，去执行其他满足条件的协程。&lt;/p&gt;
&lt;p&gt;go的调度器在用户态实现调度，调度的是一种名叫协程的执行流结构体，也有需要保存和恢复上下文的函数，运行队列。&lt;/p&gt;
&lt;p&gt;协程同步造成的阻塞，只是调度器切换到别的协程去执行了，线程本身并不阻塞。&lt;/p&gt;
&lt;p&gt;抢占：在协程中，要等到一个协程主动让出CPU才能执行下一个协程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Go的调度器通过&lt;strong&gt;使用与CPU数量相等的线程&lt;/strong&gt;减少线程频繁切换的内存开销，同时&lt;strong&gt;在每一个线程上执行额外开销更低的Goroutine&lt;/strong&gt;来降低操作系统和软件的负载。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1.2~1.3版本使用&lt;strong&gt;基于协作的抢占式调度器&lt;/strong&gt;（通过编译器在函数调用时(函数头或尾)插入抢占式检查指令，比如栈扩容检查，在函数调用时检查当前G是否发起抢占式请求），但 G 可能会因为垃圾回收和循环时间太长，占用资源导致没有让出CPU，造成其他goroutine饿死，甚至让程序暂停；&lt;/p&gt;
&lt;p&gt;从1.14版本开始使用&lt;strong&gt;基于信号的抢占式调度&lt;/strong&gt;，会给需要处理的函数绑上signhandler，处理SIGURG信号，当线程M接收到信号后，会从用户栈 G 切换到gsingal执行信号处理逻辑，实现调度，比如垃圾回收在扫描栈时会触发抢占式调度，sysmon是其中一种实现，sysmon会定时进行监控，触发调度；&lt;/p&gt;
&lt;p&gt;之所以要使用信号抢占式的，是因为如果是 G 主动让出CPU资源才能触发调度，可能会导致某个 G 长时间占用线程，造成其他 G 饿死；另外，垃圾回收需要暂停整个程序，在STW时，整个程序无法工作。&lt;/p&gt;
&lt;p&gt;关于抢占和协作，go本身的调度模型既包含了抢占，也包含了协作；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;协作式：各个任务相互合作，程序主动在需要等待的时候让出控制权，比如golang是由编译器隐式插入yield节点，所以程序可以知道各个任务挂起和恢复时需要哪些信息，而OS的线程调度器不知道，也不需要知道，交由任务自己决定；&lt;/li&gt;
&lt;li&gt;抢占式：各个程序不协作，相互抢占，由外部的调度器决定运行哪一个任务，所以程序不需要关心用户代码和处理协作的细节，也不知道各个任务挂起和恢复时的信息，而是由OS直接把整个调用栈的状态进行保存和恢复；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;早期调度模型-mg模型&#34;&gt;早期调度模型-MG模型&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go%e6%97%a9%e6%9c%9f%e8%b0%83%e5%ba%a6%e6%a8%a1%e5%9e%8b.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go%e6%97%a9%e6%9c%9f%e8%b0%83%e5%ba%a6%e6%a8%a1%e5%9e%8b.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;goroutine early schedule&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;goroutine early schedule&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;线程M想要处理协程G，都必须访问全局队列GRQ，当多个M访问同一资源时需要加锁保证并发安全，因此M对G的创建，销毁，调度都需要上锁，造成激烈的锁竞争，导致性能较差。&lt;/p&gt;
&lt;p&gt;另外，当M0执行G0，但G0又产生了G1，此时为了继续执行G0，需要将G1移给M1，造成较差的局部性，因为一般情况下这两个G是有一定的关联性的，如果放在不同的M会增加系统开销；CPU在多个M之间切换也增加了系统开销。&lt;/p&gt;
&lt;p&gt;为了解决早期调度器模型的缺点，采用了GMP模型。&lt;/p&gt;
&lt;h2 id=&#34;调度器的gpm模型&#34;&gt;调度器的GPM模型&lt;/h2&gt;
&lt;p&gt;goroutine完全运行在用户态，借鉴M：N线程映射关系，采用GPM模型管理goroutine。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;G：即goroutine，代码中的&lt;code&gt;go func{}&lt;/code&gt;，代表一个待执行的任务&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一个G最多占有CPU 10ms&lt;/strong&gt;，防止其他G饿死。&lt;/li&gt;
&lt;li&gt;每个Goroutine都有自己独立的栈存放当前的运行内存及状态，当G被调离CPU时，调度器会负责把CPU寄存器的值保存在G对象的成员变量中，当G被调度运行起来时，调度器又会负责把G对象的成员变量所保存的寄存器的值恢复到CPU的寄存器中。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;栈扩张：每一个G都有自己的栈空间，为了避免G过多导致使用过多的内存，一开始只会分配给G一块很小的栈空间，比如2k，当函数发现栈空间不足时，就会申请一块新的栈空间并把原来的栈内容复制过去，这就是G中_Gcopystack状态，64位机器最大是1GB，32位为256MB。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;M：即machine，操作系统的线程，与一个内核线程绑定，由操作系统的调度器调度和管理。每个线程有一个TLS（Thread-Local Storage），用于保存线程中的本地数据，比如栈的起止位置、当前正在执行的G、M本身是否空闲等信息、通过指针维持与P结构体实例对象的绑定关系、获取系统线程中当前的G和G所属的M实例等；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;M的数量不一定和P匹配，可以设置多个M，M和P绑定后才可运行，多余的M会处于休眠状态；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调度器最多可创建10k个M，但最多只有GOMAXPROCS个活跃线程能够正常运行，或者自旋；&lt;/p&gt;
&lt;p&gt;所以一般情况下，会设置与P一样数量的M，让所有的调度都发生在用户态，减少额外的调度和上下文切换开销；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;M被创建的时机：当没有足够的M来关联P，并运行P中LRQ的G，或者所有的M都被阻塞住时，就会去空闲M链表中查找M，如果还没有，就会创建新的M；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;P：即processor，处理器的抽象，运行在线程上的本地调度器，用来管理和执行goroutine，使得goroutine在一个线程上跑，提供了线程M需要的上下文（局部计算资源，用于在同一线程写多个goroutine的切换）；&lt;/p&gt;
&lt;p&gt;之所以LRQ是放在P不是放在M，是因为当M发生阻塞时，才能将和它绑定的P上的G转移给其他线程；&lt;/p&gt;
&lt;p&gt;P的意义在于工作窃取算法，高效利用M，同时也是为了保证在发生系统调用时，M阻塞，释放P，MP分离，此时P就可以交给其他M继续执行，即hand off策略，是实现从N：1到N：M映射的关键。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;P的个数取决于&lt;strong&gt;GOMAXPROCS&lt;/strong&gt;，默认使用CPU的个数，这些P会绑定到不同内核线程，尽量提升性能，让每个核都有代码在跑。在确定了P的最大数量n后，当程序运行时，创建n个P，P代表代表并发度；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;P包含一个LRQ（Local Run Queue本地运行队列），保存P需要执行的goroutine的队列。&lt;strong&gt;LRQ是一个长度为256的环形数组&lt;/strong&gt;，有head和tail两个序号，当数量达到256时，新创建的goroutine会保存在GRQ中，LRQ中前一半G打乱顺序后也放到GRQ中；&lt;/p&gt;
&lt;p&gt;当在G0中产生G1，此时会G1会优先加入当前的LRQ队列，保证其在同一个M上执行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;P本身还会维护一个&lt;code&gt;local freelist G&lt;/code&gt;用于复用G，类似复用池，在短时间内大量创建G且执行完成的时间很短时用处比较大；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全局运行队列GRQ（Global Run Queue）：由调度器本身持有，保存所有未分配的goroutine，保存在全局遍历sched中。GRQ是一个链表，有head，tail两个指针。&lt;/p&gt;
&lt;p&gt;在没有P的情况下，所有G只能放在一个GRQ(全局队列)中，当M执行完G，且没有G可执行时，必须锁住该全局队列才能取G。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空闲的M链表：主要用于保存无G可运行时而进入休眠的M，也保存在全局变量sched中，进入休眠的M会等待信号量m.park的唤醒。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空闲的P链表：当无G可运行时，拥有P的M会释放P并进入休眠状态，释放的P会变成空闲状态，加入到空闲的P链表中，也保存在全局变量sched中，当M被唤醒时，其持有的P也会重新进入运行状态。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GRQ、空闲M链表、空闲P链表、复用G列表等都存放在schedt结构体中，该结构体在整个go程序中只有一个实例对象，是一个全局变量。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;go中还有特殊的M和G, 它们是M0和G0.&lt;/p&gt;
&lt;p&gt;M0是启动程序后的主线程, 这个M对应的实例会在全局变量M0中, 不需要在heap上分配；&lt;/p&gt;
&lt;p&gt;M0负责执行初始化操作和启动第一个G， 在之后M0就和其他的M一样了；&lt;/p&gt;
&lt;p&gt;G0是仅用于负责调度的G，G0不指向任何可执行的函数，&lt;strong&gt;每个M都会有一个自己的G0&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;G0的栈大小是固定的，为8MB，不能动态伸缩，而普通G是2KB，可动态伸缩；&lt;/p&gt;
&lt;p&gt;在调度或系统调用时会使用G0的栈空间, 全局变量的G0是M0的G0，其他G的栈扩容也是由G0来执行；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;gpm三者的关系&#34;&gt;GPM三者的关系&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;持有P的M会执行G，执行完G后会&lt;strong&gt;先判断是否满足61次调用&lt;/strong&gt;，如果是，则先从GRQ中获取，否则继续从P的LRQ中继续获取G进行消费；之所以先有次数判断，是为了&lt;strong&gt;防止GRQ里的G被饿死&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;当发现P的LRQ中没有其他G可执行时，则会从&lt;strong&gt;GRQ的队首里获取G&lt;/strong&gt;放入自己的LRQ，获取数量&lt;code&gt;n = min(len(GQ)/GOMAXPROCS + 1, len(GQ/2))&lt;/code&gt;，一次不会获取太多（一次不超过128个），保证其他M在GRQ中有G可拿，&lt;strong&gt;获取时会加锁&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;当P发现自己的LRQ、GRQ都没有G了，会从netpoller(网络轮询器)上获取G来执行；&lt;/p&gt;
&lt;p&gt;如果当前P的LRQ、GRQ、netpoller上都没有G时，则会随机从&lt;strong&gt;其他P的LRQ队尾窃取一半+1个的G&lt;/strong&gt;放到自己的LRQ，通过CAS获取G；（&lt;strong&gt;work stealing 工作窃取&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;获取到的G都会先放到P的runnext队列(该队列的长度是1)，然后再交由M执行；&lt;/p&gt;
&lt;p&gt;以上过程由M执行 runtime.schedule 函数来执行调度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;当P的LRQ满时，会把当前P的LRQ前一半的G打乱顺序后转移到GRQ&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;如果此时runnext也有G，则新创建的G会替换runnext中的G，原来runnext中的G跟着LRQ中挑出来的那些G一起加入GRQ；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当P的LRQ和调度器的GRQ都没有可执行的G时，M进入自旋状态；&lt;/p&gt;
&lt;p&gt;M进入自旋，是为了避免频繁的休眠和唤醒产生大量的开销，当其他G准备就绪时，首先被调度到自旋的M上，其次才是去创建新的M；&lt;/p&gt;
&lt;p&gt;自旋只会持续一段时间，如果自旋期间没有G需要调度，则之后会进入休眠状态，加入空闲M链表，等待被唤醒；&lt;/p&gt;
&lt;p&gt;M自旋时会调用G0协程，G0协程 主要负责调度时协程的切换；&lt;/p&gt;
&lt;p&gt;M是否新建取决于正在自旋的M或者休眠的M的数量；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当M执行的G发生阻塞时，将挂起当前M和G，从当前P中摘除，从空闲M链中唤醒一个M服务这个P，执行这个P的LRQ上的其他G；（挂起时，M的现场信息保存在G上，如果G还没执行完，M也可以被复用，再次执行时，就可以从G上恢复M的现场，继续执行）&lt;/p&gt;
&lt;p&gt;如果当前P的LRQ、调度器的GRQ上没有G，则P加入空闲P链表，等待M来获取可用的P；&lt;/p&gt;
&lt;p&gt;阻塞结束后，该M和G会尝试找回原来的P（有利于数据局部性），如果原来的P没空，则获取其他空闲的P，放入其LRQ，等待执行；如果没有空闲的P，则G放入GRQ，M继续休眠；（&lt;strong&gt;hand off策略&lt;/strong&gt;）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;G被调用运行时，会尝试唤醒其他空闲的M和P进行组合，由于M和P由于刚被唤醒，进入自旋状态，G0发现P的LRQ队列没有G，则先去GRQ里获取，如果GRQ里没有，则去其他P的LRQ里working stealing；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;如果是网络IO&lt;/strong&gt;，比如通过netpoller进行网络系统调用，调度器可以防止G在进行这些系统调用时阻塞M，使得M可以执行P的LRQ中的其他G，而不需要使用新的M，该G在netpoller执行完后，会重新回到之前P的LRQ中（或者被放到GRQ），等待调用。执行网络系统调用不需要额外的M，netpoller使用系统线程时刻处理一个有效的事件循环（通过linux上的epoll实现，网络相关fd与G绑定），即在这种场景下，G会和M、P分离，G挂在了netpoller下。（&lt;strong&gt;网络调用导致G阻塞，会由netpoller接管，M不阻塞，此时M可以继续执行下一个G&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果是系统调用&lt;/strong&gt;，如读取文件导致G被阻塞，此时不关netpoller什么事，这种阻塞使得G阻塞M，调度器会使得GM与P分离，而P使用新的M继续执行。（&lt;strong&gt;G阻塞导致M阻塞，P寻找新M来执行G&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果是channel、sync包中的方法、time.Sleep&lt;/strong&gt;，比如让G执行一个sleep、原子操作、锁或者chan操作，导致M被阻塞，则由sysmon监控线程来监控那些长时间运行的G，然后设置可以抢占的标识符，别的G就可以抢占来执行。（&lt;strong&gt;阻塞的G被切换出去，M不阻塞，转而执行其他空闲的G&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;这些不同类型阻塞的G都是由sysmon来调度的。&lt;/p&gt;
&lt;p&gt;这里有一个有趣的例子&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;runtime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;GOMAXPROCS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 输出的数是 9、0、1、2、3、4、5、6、7、8
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;原因是此时P&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;且只有10个G&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;不涉及GRQ&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;for循环中产生的协程都会进到这个p里&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;由于此时还没发生调度&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;每次新产生的协程都会被M持有&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;这时就会把老的协程放到p的LRQ中&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;当i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;时&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;M持有i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;的协程&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;此时p的LRQ队列因为先进先出的缘故&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;持有的协程顺序是0&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;此时执行到读chan的语句&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;调度发生&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;goroutine挂起&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m运行持有的协程i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;之后继续消费LRQ里的协程&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;因此输出顺序是&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;、&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;、&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;、&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;、&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;、&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;、&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;、&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;、&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;、&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;调度过程中存在的阻塞&#34;&gt;调度过程中存在的阻塞&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;网络IO（M可以执行其他G）&lt;/li&gt;
&lt;li&gt;系统调用syscall（M与G绑定阻塞，释放P，此时M无法执行其他G）&lt;/li&gt;
&lt;li&gt;channel，select，锁等待（M可以执行其他G）&lt;/li&gt;
&lt;li&gt;runtime.Gosched()运行时调度&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;调度器的策略&#34;&gt;调度器的策略&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;复用线程，避免线程频繁的创建和销毁，使用work stealing机制和hand off机制&lt;/li&gt;
&lt;li&gt;并行：&lt;code&gt;GOMAXPROCS&lt;/code&gt;设置P的数量，最多有&lt;code&gt;GOMAXPROCS&lt;/code&gt;个线程在CPU上同时运行或自旋&lt;/li&gt;
&lt;li&gt;抢占：一个G最多运行10ms，还有sysmon协程协助式抢占，防止其他G被饿死&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;调度抢占的时机&#34;&gt;调度(抢占)的时机&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;go调度器，本质是为需要执行的G寻找M以及P，不是一个实体，调度是需要发生调度时由M执行&lt;code&gt;runtime.schedule函数&lt;/code&gt;进行；&lt;/li&gt;
&lt;li&gt;函数调用期间，如G需要栈扩容，就会调度另一个G&lt;/li&gt;
&lt;li&gt;调度器初始化时，会依次调用mcommoninit：初始化M资源池、procresize：初始化P资源池、newproc：G的运行现场和调度队列；&lt;/li&gt;
&lt;li&gt;channel、mutex等sync操作发生协程阻塞；&lt;/li&gt;
&lt;li&gt;time.sleep，go1.13以前的版本，会创建一个goroutine，专门用来唤醒挂载timer上的时间未到期的goroutine，但在1.14之后不会创建goroutine来做这件事，而是在调度循环的各个地方、sysmon中都有唤醒timer的代码，使得timer的唤醒更加及时；&lt;/li&gt;
&lt;li&gt;IO&lt;/li&gt;
&lt;li&gt;GC，如STW期间、P上执行safe point、GC栈扫描；&lt;/li&gt;
&lt;li&gt;sysmon后台监控，当G运行过久时会触发，比如G每次只执行10ms，或系统调度过久，此时会把G放到GRQ；&lt;/li&gt;
&lt;li&gt;panic崩溃期间；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;调度器的生命周期&#34;&gt;调度器的生命周期&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_%e8%b0%83%e5%ba%a6%e5%99%a8%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_%e8%b0%83%e5%ba%a6%e5%99%a8%e7%9a%84%e7%94%9f%e5%91%bd%e5%91%a8%e6%9c%9f.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;go调度器的生命周期&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;go调度器的生命周期&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;总的调度流程&#34;&gt;总的调度流程&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/GMP%e6%a8%a1%e5%9e%8b%e6%95%b4%e4%bd%93%e8%b0%83%e5%ba%a6.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/GMP%e6%a8%a1%e5%9e%8b%e6%95%b4%e4%bd%93%e8%b0%83%e5%ba%a6.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;goroutine schedule&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;goroutine schedule&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;5.1 当M执行某个G时发生syscall或其他阻塞操作，M会阻塞，如果当前有一些G在执行，runtime会把这个线程M从P中摘除，然后再创建一个新的M（操作系统线程或者复用其他空闲线程）来服务这个P，即此时的M会直接管理阻塞的G，之前跟它绑定的P转移到其他M，执行其他G。&lt;/p&gt;
&lt;p&gt;当原阻塞的M系统调用或阻塞结束时，其绑定的这个G要继续往下执行，会优先尝试获取之前的P，若之前的P已经跟其他M绑定，则尝试从空闲的P链表获取P，将G放入这个P的本地队列，继续执行。如果获取不到P，则该M进入休眠，加入休眠队列，G则放入全局队列，等其他P消费它。&lt;/p&gt;
&lt;h2 id=&#34;sysmon协程&#34;&gt;sysmon协程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;切换M和G的操作由sysmon协程进行处理，即sysmon协程进行协作式抢占&lt;/strong&gt;，对goroutine进行标记，执行goroutine时如果有标记就会让出CPU，对于syscall过久的P，会进行M和P的分配，防止P被占用过久影响调度。&lt;/p&gt;
&lt;p&gt;sysmon协程运行在M上，且不需要P，它会每隔一段时间检查runtime，确保没有出现异常状态，也会触发调度、GC、检查死锁、获取下一个需要被触发的计时器、定时从netpoll中获取ready的G、打印调度和内存信息。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_sysmon_goroutine.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_sysmon_goroutine.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;go sysmon goroutine&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;go sysmon goroutine&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;mmachine&#34;&gt;M：Machine&lt;/h2&gt;
&lt;p&gt;M本质是一个循环调度，不断的执行schedule函数，查找可运行的G。会在自旋与休眠的状态间转换。&lt;/p&gt;
&lt;p&gt;没有状态标记，只是会处于以下几个场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;自旋：M正在从LRQ中获取G，此时M会拥有一个P&lt;/li&gt;
&lt;li&gt;拥有一个P，执行G中的代码&lt;/li&gt;
&lt;li&gt;进行系统调用或者G的阻塞操作，此时M会释放P&lt;/li&gt;
&lt;li&gt;休眠，无G可执行，不拥有P，此时存在空闲线程队列&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ggoroutine的状态&#34;&gt;G：Goroutine的状态&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_goroutine_state.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_goroutine_state.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;go goroutine state&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;go goroutine state&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;goroutine的状态不止以下几种，只是这几种比较常用&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;G状态&lt;/th&gt;
&lt;th&gt;值&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;_Gidle&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;刚刚被分配，还没被初始化&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;_Grunnable&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;表示在runqueue上，即LRQ，还没有被执行，此时的G才能被M执行，进入Grunning状态&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;_Grunning&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;执行中，不在runqueue上，与M、P绑定&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;_Gsyscall&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;在执行系统调用，没有执行go代码，没在runqueue上，只与M绑定，此时P转移到其他M中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;_Gwaiting&lt;/strong&gt;&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;&lt;strong&gt;被阻塞（如IO、GC、chan阻塞、锁）不在runqueue，但一定在某个地方，比如channel中，锁排队中等&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;_Gdead&lt;/td&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;现在没有在使用，也许执行完，或者在free list中，或者正在被初始化，可能有stack&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;_Gcopystack&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;栈正在复制，此时没有go代码，也不在runqueue上，G正在获取一个新的栈的空间，并把原来的内容复制过去，防止GC扫描&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;_Gscan&lt;/td&gt;
&lt;td&gt;0x1000&lt;/td&gt;
&lt;td&gt;与runnable、running、syscall、waiting等状态结合，表示GC正在扫描这个G的栈&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;pprocessor的状态&#34;&gt;P：Processor的状态&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_processor_state.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_processor_state.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;go processor state&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;go processor state&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;状态&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;_Pidle&lt;/td&gt;
&lt;td&gt;空闲，无可运行的G，这时M拥有的P会加入空闲P队列中，LRQ为空&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;_Prunning&lt;/td&gt;
&lt;td&gt;被线程 M 持有，并且正在执行G或者G0（即用户代码或者调度器逻辑）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;_Psyscall&lt;/td&gt;
&lt;td&gt;用户代码触发了系统调用，此时P没有执行用户代码&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;_Pgcstop&lt;/td&gt;
&lt;td&gt;被线程 M 持有，且因gc触发了STW而停止&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;_Pdead&lt;/td&gt;
&lt;td&gt;当运行时改变了P的数量时，多余的P会变成此状态&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;泄露与排查&#34;&gt;泄露与排查&lt;/h2&gt;
&lt;p&gt;goroutine的泄露一般会导致内存的泄露，最终导致OOM，原因一般是该运行完成的goroutine一直在运行，没有结束，可能的原因是goroutine内阻塞，死循环。&lt;/p&gt;
&lt;p&gt;检查工具：pprof，请求&lt;code&gt;/debug/pprof/goroutine接口或者heap接口&lt;/code&gt;，判断内存占用走势，分析内存使用情况。一般的走势是整体向上递增，伴随一个一个的峰谷。&lt;/p&gt;
&lt;h1 id=&#34;内存模型&#34;&gt;内存模型&lt;/h1&gt;
&lt;p&gt;当程序开始启动，runtime的页分配器向操作系统申请内存，并预留内存驻留在runtime中，一旦用户程序需要进行内存分配，就可以从runtime的对象分配器分配新的内存进行使用；当用户程序不在使用这些所申请的内存后，runtime的垃圾回收器将这些内存进行标记，并重新在runtime进行管理和再分配；对于某些长期不再使用的内存，拾荒器会负责将这部分内存归还给操作系统，减轻整个应用程序的总内存消耗。&lt;/p&gt;
&lt;p&gt;Go的runtime就是传统意义上的栈，不开放给用户态代码；而传统意义上的堆，被Go的runtime划分为两部分：一个是Go runtime自身所需的堆内存（也是堆外内存，例如mheap、mcentral、mcache），另一部分用于Go用户态所使用的堆内存，也叫Go堆，Go堆负责用户态对象的存放，以及goroutine的执行栈。&lt;/p&gt;
&lt;p&gt;Go 的内存分配器基于tcmalloc的内存分配算法，它是一个带内存池的分配器，底层直接调用操作系统的mmap函数实现内存分配，减少内存碎片，提升内存利用率。tcmalloc的核心思想是为每个线程实现一个线程局部缓存，并同时区分了小对象（小于32KB）和大对象分配两种类型，管理的内存单元是跨度，对应go里的mspan。&lt;/p&gt;
&lt;p&gt;所以Go的分配思路是，runtime为每个系统线程分配一个本地的mcache，少量的内存分配就直接从mcache中分配，并且定期做垃圾回收，将线程的mcache中的空闲内存返回给全局控制堆；当线程的本地mcache不够用时，就向堆中申请。&lt;/p&gt;
&lt;p&gt;内存浪费有两种，一种是内存对齐产生的浪费，一种是每次需要分配内存时，每个大小等级都设计了自己的页数，当需要该大小等级的新对象时，会选择给定大小最多12.5%的浪费。&lt;/p&gt;
&lt;p&gt;基于这两种浪费的控制，设计了大约67种内存块类别，每一类别都有自己对象的空闲链表。小于32K的内存分配被向上取整到对应的尺寸类别，从相应的空闲链表中分配。一页内存只可以被分裂成同一种尺寸类别的对象，然后由空闲链表分配器管理。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_%e5%88%86%e9%85%8d%e5%99%a8%e7%bb%93%e6%9e%84.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_%e5%88%86%e9%85%8d%e5%99%a8%e7%bb%93%e6%9e%84.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Go内存管理可以看成一个两级的内存管理结构，mheap和mcache。上面一级管理的基本单位是页，用于分配大对象，每次分配都是若干连续的页，也就是若干个4KB的大小，使用的数据结构是mheap和mspan，用BestFit算法做分配，用位示图做回收。下面一级管理的基本单位是不同类型的固定大小的对象，更像一个对象池而不是内存池，用引用计数做回收，使用的数据结构是mcache。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mspan：是mheap管理内存最基本的结构，由一连串的页(连续8KB)组成的双向链表，每个节点保存起始页地址，span大小，span中页的数量，是Go堆内存单元的基本大小；&lt;/li&gt;
&lt;li&gt;mcache：局部缓存，&lt;strong&gt;是M中的内存缓存&lt;/strong&gt;，是堆的一部分，每个尺寸对应一个空闲的单链表。一次对象分配时，总是会先从这样的线程局部缓存中获取内存（比如 用于小对象（&amp;lt;=32KB）的内存分配），当mcache中的mspan不够用时，才会去向堆外内存mcentral中获取新的mspan；&lt;/li&gt;
&lt;li&gt;mcentral：从mheap中申请mspan，将mspan划分成各种小尺寸对象，将相同大小的span聚合起来，每个mcentral保存一种特定大小的全局mspan列表，提供给mcache使用；&lt;/li&gt;
&lt;li&gt;mheap：用于大对象（&amp;gt;32KB）的内存分配，GC的主要地方；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果mcache有空闲的空间，那直接在mcache分配，如果没有，则尝试去mcentral中获取一个空闲的mspan，如果mcentral中也没有可用的mspan，则去mheap向操作系统申请可用的mspan。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_mem_alloc_summary.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_mem_alloc_summary.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;根据对象中是否含有指针以及对象大小，内存分配过程分为 3 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;tiny：小于16 byte 并且 没有指针的对象，分配最复杂，容易产生内存碎片，Go会把这些tiny都嵌入到一个16K的对象中；&lt;/li&gt;
&lt;li&gt;small：有指针 或者 大小大于等于16 byte 并且小于等于 32 KB 的对象；小于32K的为小对象，小对象从本地内存链表mcache中分配；如果不够，就会向其上级mcentral获取新mspan链表，不够再继续向上级获取；&lt;/li&gt;
&lt;li&gt;large：大于 32KB 的对象，属于大对象，直接从全局控制堆（中心内存堆）上以页（4K）为单位进行分配，大对象总是以页对齐的，一个页可以存入一些相同大小的小对象；&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;我们可以将内存分配的路径与 CPU 的多级缓存作类比，这里 mcache 内部的 tiny 可以类比为 L1 cache，而 alloc 数组中的元素可以类比为 L2 cache，全局的 mheap.mcentral 结构为 L3 cache，mheap.arena 是 L4，L4 是以页为单位将内存向下派发的，由 pageAlloc 来管理 arena 中的空闲内存。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;L1&lt;/th&gt;
&lt;th&gt;L2&lt;/th&gt;
&lt;th&gt;L3&lt;/th&gt;
&lt;th&gt;L4&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;mcache.tiny&lt;/td&gt;
&lt;td&gt;mcache.alloc[]&lt;/td&gt;
&lt;td&gt;mheap.central&lt;/td&gt;
&lt;td&gt;mheap.arenas&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;若 L4 也没法满足我们的内存分配需求，便需要向操作系统去要内存了。&lt;/p&gt;
&lt;p&gt;和 tiny 的四级分配路径相比，small 类型的内存没有本地的 mcache.tiny 缓存，其余与 tiny 分配路径完全一致。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;L1&lt;/th&gt;
&lt;th&gt;L2&lt;/th&gt;
&lt;th&gt;L3&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;mcache.alloc[]&lt;/td&gt;
&lt;td&gt;mheap.central&lt;/td&gt;
&lt;td&gt;mheap.arenas&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;large 内存分配稍微特殊一些，没有上面复杂的缓存流程，而是直接从 mheap.arenas 中要内存，直接走 pageAlloc 页分配器。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;逃逸分析&#34;&gt;逃逸分析&lt;/h1&gt;
&lt;p&gt;之所以需要逃逸分析，是因为GC只清理堆内存，函数执行时内存分配在栈上，函数结束时栈内存会被回收，无需GC。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;go通过逃逸分析决定变量在堆上分配还是在栈上分配&lt;/p&gt;
&lt;p&gt;如果变量只在函数内被引用，则优先分配在栈上&lt;/p&gt;
&lt;p&gt;如果变量还在函数外被引用，则优先分配在堆上&lt;/p&gt;
&lt;p&gt;申请了大对象，栈不够放，也会分配到堆上&lt;/p&gt;
&lt;p&gt;所以，用new创建的变量不一定在堆上，要看逃逸分析的结果，如果该变量一直只是在函数内被引用，会被优先分配在栈上；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;go中逃逸分析是在编译期完成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;go中逃逸分析只针对指针，一个值引用变量如果没有被取址，那它永远不可能逃逸&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;go run -gcflags &amp;quot;-m -l&amp;quot;&lt;/code&gt;命令runtime加入参数，-m表示打印逃逸分析信息，-l 表示禁止内联编译&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;逃逸场景&#34;&gt;逃逸场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在函数内new出来或使用字面量创建的变量，其值作为函数的返回值，该变量一定发生逃逸；&lt;/li&gt;
&lt;li&gt;被已经逃逸的变量引用的指针，也发生了逃逸；&lt;/li&gt;
&lt;li&gt;被指针类型的slice、map和chan引用的指针一定发生了逃逸；&lt;/li&gt;
&lt;li&gt;返回值为interface{}类型，由于编译期间无法判断是具体类型，也会发生逃逸；&lt;/li&gt;
&lt;li&gt;栈空间不足时也会发生逃逸，对于64位机器，栈空间是8MB，使用&lt;code&gt;ulimit -a&lt;/code&gt;命令查看机器上栈允许占用的内存大小；&lt;/li&gt;
&lt;li&gt;闭包函数直接访问外部的变量；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;gc&#34;&gt;GC&lt;/h1&gt;
&lt;h2 id=&#34;基本-1&#34;&gt;基本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用&lt;strong&gt;可达性分析&lt;/strong&gt;判断对象是否被回收&lt;/li&gt;
&lt;li&gt;三色标记法进行GC，本质是标记-清除算法，三色标记法是其改进版，主要是为了减少STW的时间&lt;/li&gt;
&lt;li&gt;Go 语言为了实现高性能的并发垃圾收集器，使用三色抽象、并发增量回收、混合写屏障、调步算法以及用户程序协助等机制将垃圾收集的暂停时间优化至毫秒级以下&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;并行垃圾回收&lt;/strong&gt;：多核场景下，多个核同时进入STW，进行GC，将原本一个线程要执行的认为，分给多个核的不同线程去执行，需要考虑执行的负载均衡，但会增加线程间的同步开销，复制垃圾回收时，还得避免数据对象被不同线程重复复制；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;并发垃圾回收&lt;/strong&gt;：多核场景下，用户程序和垃圾回收程序并行执行，一些核STW执行GC，另一些核继续运行用户程序，所以在此场景下，用户程序和垃圾回收程序会同时使用写屏障记录集；&lt;/p&gt;
&lt;p&gt;go的GC，采用的就是&lt;strong&gt;主体并发增量式垃圾回收&lt;/strong&gt;，采用插入写屏障和删除写屏障组合而成的&lt;strong&gt;混合写屏障&lt;/strong&gt;；（主体 增量 指的是将STW拆分成多份，与用户程序交替在不同的核中运行，使得可以在垃圾回收开始时，消息能及时准确的通知到所有线程，避免某些线程开启写屏障的动作有所延迟而发生错误）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%b9%b6%e5%8f%91GC%e6%a8%a1%e5%bc%8f.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%b9%b6%e5%8f%91GC%e6%a8%a1%e5%bc%8f.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;使用三色标记法的原因&#34;&gt;使用三色标记法的原因&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Go运行时的内存分配算法基于 tcmalloc，基本没有碎片问题，对对象进行整理不会带来实质性的性能提升，所以并不需要像Java一样对内存进行分代，另外Java作为面向对象语言，存在大量的对象分配，对内存进行分代有利于对不同的分代采取不同的GC算法，也能及时回收生命周期较短的对象，减少STW影响，提升GC效率；&lt;/p&gt;
&lt;p&gt;关于tcmalloc内存分配算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;线程级别的内存管理模式；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;速度快，减少锁竞争，对于小对象，只有在对应线程分配的空闲块不足时，才会用到锁；对于大对象，会尝试使用自旋锁，最大化内存使用效率，最小化分配时间；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对内存碎片的处理：&lt;/p&gt;
&lt;p&gt;tcmalloc会提前分配多种size的内存：8、16、32、48、64&amp;hellip;产生最多12.5%的内存碎片，分配并不是按照2的幂级数分配，比如如果申请65字节，2次幂就会分配128，但实际上tcmalloc只会分配80，以减少内存碎片的产生；&lt;/p&gt;
&lt;p&gt;如果小内存块不够用，才会分配大内存块，申请内存时以Page为单位进行申请，为了使得内存碎片率最多12.5%，就会申请多个page来解决，合并相邻的page，减少外部碎片；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Go的编译器会通过&lt;strong&gt;逃逸分析&lt;/strong&gt;将大部分新生对象存储在栈上，而栈在方法结束后即可被回收，只有那些需要长期存在的对象才会被分配到堆中，goroutine死亡后，栈也可被直接回收，不需要GC参与，因此无需分代、频繁检查对象；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Go的垃圾收集器与用户代码并发执行，使得STW的时间变短，STW的时间与对象的代际、对象的大小没有关系；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;垃圾收集器标记过程中最先检查的对象即gcroot&#34;&gt;垃圾收集器标记过程中最先检查的对象，即GCRoot&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;全局变量，静态数据：程序在编译期就能确定的存在于整个生命周期的变量，这些变量会被分配在数据段；&lt;/li&gt;
&lt;li&gt;执行栈：每个goroutine包含自己的执行栈，这些执行栈上包含栈上的变量以及指向分配的堆内存的指针；&lt;/li&gt;
&lt;li&gt;寄存器：寄存器的值可能表示一个指针，这些指针可能指向某些赋值器分配的&lt;strong&gt;堆内存区块&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;三色标记---标记清除&#34;&gt;三色标记 - 标记清除&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;白色：潜在垃圾，其内存可能会被垃圾收集器回收；&lt;/li&gt;
&lt;li&gt;灰色：活跃对象，因为存在指向白色对象的外部指针，垃圾收集器只会对对象进行扫描，&lt;strong&gt;通过引入灰色标记这一中间状态，使得用户代码和标记代码可以并发执行，无需STW，减少停顿时间&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;黑色：活跃对象，包括不存在任何引用外部指针对象以及从根对象可达的对象；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_gc.gif&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_gc.gif&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;go gc简化过程&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;go gc简化过程&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始对象都是白色，首先把所有对象都放到白色集合中&lt;/li&gt;
&lt;li&gt;从根节点开始遍历对象，遍历到的对象标记为灰色，并从白色集合放入到灰色集合&lt;/li&gt;
&lt;li&gt;遍历灰色对象，把自己标记为黑色，放入黑色集合，将其引用的对象标记为灰色，放入灰色集合&lt;/li&gt;
&lt;li&gt;重复第3步，直到灰色集合为空，此时所有可达对象都被标记，标记阶段完成&lt;/li&gt;
&lt;li&gt;清除阶段开始，白色集合里的对象为不可达对象，即垃圾，对内存进行迭代清扫，回收白色对象&lt;/li&gt;
&lt;li&gt;重置GC状态，将所有的对象放入白色集合中&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;实际上并没有对应颜色的集合，对象被内存分配器分配在span中，span里有个gcmarkBits字段，每个bit代表一个slot被标记，白色对象该bit为0，灰色或黑色为1。&lt;/p&gt;
&lt;p&gt;每个p中都有wbBuf和gcw gcWork, 以及全局的workbuf标记队列, 实现生产者-消费者模型, 在这些队列中的指针为灰色对象, 表示已标记, 待扫描.&lt;/p&gt;
&lt;p&gt;从队列中取出来并把其引用对象入队的为黑色对象, 表示已标记, 已扫描. (runtime.scanobject).&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;写屏障&#34;&gt;写屏障&lt;/h2&gt;
&lt;p&gt;传统标记清除算法，是用户程序运行一段时间，就STW一段时间，但是长时间的STW性能太差，因此改成了用户程序和STW短时间内交替运行（也称为增量式GC），以此减少STW带来的影响。&lt;/p&gt;
&lt;p&gt;在go的早期版本中，在标记阶段时，因为用户程序可能会修改对象的指针，导致标记错误，对象被错误回收，因此在标记阶段需要STW，&lt;strong&gt;为了减少STW时间和提升标记的准确性，需要进行并发标记，便通过写屏障配合三色标记来保证标记的正确性&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;内存屏障是一种屏障指令，使得CPU或编译器对该屏障指令的前后发出的内存操作强制执行排序约束，在内存屏障前执行的操作一定先于内存屏障后执行的操作，防止指令重排引发的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;想要在并发或增量的标记算法中保证正确性，需要达成&lt;strong&gt;任意&lt;/strong&gt;一种三色不变性&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强三色不变性：黑色对象不会指向白色对象，只会指向灰色对象或黑色对象&lt;/li&gt;
&lt;li&gt;弱三色不变性：黑色对象可以指向白色对象，但是被指向的白色对象，必须有被其他灰色对象直接或间接引用&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;go中使用了写屏障是在写入指针前执行的一小段代码，在数据对象修改时，通知垃圾回收器，用以防止并发标记时指针丢失，这一小段代码Go是在编译时加入的。&lt;/p&gt;
&lt;p&gt;写屏障通常是一个记录集，需要考虑是采用 顺序存储还是哈希表存储、记录精确到被修改的对象还是只记录被修改对象所在的页等问题、用户程序和垃圾回收程序之间的竞争问题；&lt;/p&gt;
&lt;p&gt;题外话：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;关于读屏障&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;对于复制算法，对象所引用的对象从from区复制到to区，且自身也从from区复制到to区后，仍然引用的是from区的对象，这样，当from区空间被回收后，会发生引用错误；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;读屏障一般是用在复制算法里&lt;/strong&gt;，确保用户程序不会访问到已经复制到to区（新）的from区对象（旧），当访问出现这种情况时，就会将当前对象复制到to区，并更新引用的对象指向to区的新对象；&lt;/p&gt;
&lt;h3 id=&#34;dijkstra的插入写屏障---灰色赋值器&#34;&gt;Dijkstra的插入写屏障 - 灰色赋值器&lt;/h3&gt;
&lt;p&gt;插入写屏障，保证达成强三色不变性，即不允许出现黑色对象到白色对象的引用，可以把白色指针改成灰色，也可以把黑色对象退回到灰色对象；&lt;/p&gt;
&lt;p&gt;在标记阶段，在对对象所引用的指针进行修改时触发，比如A引用了B，在标记阶段，A将对B的引用改成了C，C会被标记为灰色，即 &lt;strong&gt;指针修改时，指向的新对象要标记成灰色，go会在堆区使用插入写屏障&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;灰色赋值器：尚未被回收器扫描过，或者已经扫描过但仍然需要重新扫描。如果重新扫描过程中发现了新的灰色对象或白色对象，回收器需要对这些对象遍历扫描追踪，由于此时赋值器还没停止，仍然可以插入新的非黑色引用，因此回收器仍然需要往复扫描，直到重新扫描过程中没有发现新的白色或灰色对象，so最坏情况下，回收器只能将所有赋值器线程都停止才能对根对象进行完整扫描，此时就会STW。&lt;/p&gt;
&lt;p&gt;优点：可以立即开始并发标记&lt;/p&gt;
&lt;p&gt;缺点：相对保守，将有存活可能的对象都标记为灰色，保证强三色不变性，部分残留对象只能留在下一次进行回收；另外，插入写屏障有两种实现方式：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;在标记阶段，如果每次有指针赋值操作都需要引入写屏障，性能开销比较大；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因此在&lt;strong&gt;标记阶段，go只会对堆区中修改指针的操作启用写屏障，栈区中则不触发&lt;/strong&gt;，在标记阶段结束时，需要&lt;strong&gt;STW重新扫描一遍栈区&lt;/strong&gt;，直至没有灰色节点（避免黑指向白，因此新对象被黑指向之前，会变成灰色），停止STW，进行GC，所以可能导致整个进程的赋值器卡顿；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_dijkstra_%e6%8f%92%e5%85%a5%e5%86%99%e5%b1%8f%e9%9a%9c.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_dijkstra_%e6%8f%92%e5%85%a5%e5%86%99%e5%b1%8f%e9%9a%9c.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;go dijkstra插入写屏障&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;go dijkstra插入写屏障&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Dijkstra写屏障是对被写入的指针进行grey操作, 不能防止指针从heap被隐藏到黑色的栈中, 需要STW重扫描栈.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;yuasa的删除写屏障---黑色赋值器&#34;&gt;Yuasa的删除写屏障 - 黑色赋值器&lt;/h3&gt;
&lt;p&gt;删除写屏障，保证达成弱三色不变性，即关注对白色对象的路径破坏行为，比如删除灰色对象到白色对象的引用时，会把白色对象改成灰色；&lt;/p&gt;
&lt;p&gt;在标记阶段，对对象所引用的指针进行删除时触发，保证灰色-白色链路不会断开，比如A引用了B，标记阶段，A取消了对B的引用，B会被标记为灰色，即一个对象即使被删除了最后一个指向它的指针，也依旧可以活过这一轮，在下一轮的GC中才会被清理掉。&lt;strong&gt;即 指针修改时，修改前指向的对象要标记成灰色，go会在栈区和堆区都使用删除写屏障&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;黑色赋值器：已经被回收器扫描过，不会再次对其进行扫描。&lt;/p&gt;
&lt;p&gt;优点：标记结束时不需要STW；&lt;/p&gt;
&lt;p&gt;缺点：已经被垃圾回收器扫描过，不会再次对其进行扫描，回收精度低；标记开始前开启STW扫描栈来记录初始快照，这个过程会保护开始时刻的所有存活对象，用于把原来指向的对象标记为灰色，完了之后后续不需要STW；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Yuasa写屏障是对将被覆盖的指针进行grey操作, 不能防止指针从栈被隐藏到黑色的heap对象中, 需要在GC开始时保存栈的快照.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_yuasa_%e5%88%a0%e9%99%a4%e5%86%99%e5%b1%8f%e9%9a%9c.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_yuasa_%e5%88%a0%e9%99%a4%e5%86%99%e5%b1%8f%e9%9a%9c.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;go yuasa删除写屏障&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;go yuasa删除写屏障&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;混合屏障&#34;&gt;混合屏障&lt;/h2&gt;
&lt;p&gt;如果所有对象都在堆上分配，理论上只需要选择插入写屏障 或者 删除写屏障即可满足强/弱三色不变性，但在Go中，栈上对象操作比较频繁，对栈上对象开启写屏障的成本比较高，颜色判断比较复杂，如果只使用其中一种写屏障，都会有对象丢失的问题，需要对栈进行重新扫描标记，导致STW的时间过长，官方为了简单实现，使用混合写屏障，避免二次扫描栈。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GC 开始将栈上的对象全部并发扫描并标记为黑色（之后不再对栈进行第二次重复扫描，无需STW）；&lt;/li&gt;
&lt;li&gt;GC 期间，任何在栈上创建的新对象，均为黑色，扫描过一次就不需要再扫描了，这样就消除了插入写屏障时期最后STW的重新扫描栈；&lt;/li&gt;
&lt;li&gt;被删除的堆对象标记为灰色；&lt;/li&gt;
&lt;li&gt;被添加的堆对象标记为灰色；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;混合屏障结合了删除写屏障和插入写屏障的优点，&lt;strong&gt;满足弱三色不变式&lt;/strong&gt;，只需要在开始时并发扫描各个goroutine的栈，使其变黑并一直保持，这个过程不需要STW，而标记结束后，因为栈在扫描后始终是黑色的，也无需再进行重新扫描，减少了STW的时间。虽然扫描栈时没有STW，但是扫描具体某一个具体的栈时，还是要停止这个G的赋值器的工作，要么对象全灰，要么全黑。&lt;/p&gt;
&lt;h2 id=&#34;gc触发条件&#34;&gt;GC触发条件&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;内存大小阈值， 内存达到上次GC后的2倍&lt;/li&gt;
&lt;li&gt;达到定时时间触发 ，默认2min，由sysmon强制触发GC&lt;/li&gt;
&lt;li&gt;用户代码中调用 &lt;code&gt;runtime.GC&lt;/code&gt; 主动触发&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;阈值是由一个gc percent的变量控制的，当新分配的内存占已在使用中的内存的比例超过gcprecent时就会触发。比如一次回收完毕后，内存的使用量为5M，那么下次回收的时机则是内存分配达到10M的时候。也就是说，并不是内存分配越多，垃圾回收频率越高。 如果一直达不到内存大小的阈值呢？这个时候GC就会被定时时间触发，比如一直达不到10M，那就定时（默认2min触发一次）触发一次GC保证资源的回收。&lt;/p&gt;
&lt;p&gt;当内存分配速度超过标记清除的速度时：&lt;/p&gt;
&lt;p&gt;触发GC后，进入并发标记阶段，并发标记会设置一个标志，并在内存分配mallocgc调用时进行检查，当存在新的内存分配时，会暂停分配内存过快的goroutine，并将其转去执行一些辅助标记工作，从而达到放缓继续分配，辅助GC的标记工作的目的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;垃圾收集过程&#34;&gt;垃圾收集过程&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;清理终止阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;暂停程序&lt;/strong&gt;STW，所有的goroutine在这时会进入安全点（Safe point）；&lt;/li&gt;
&lt;li&gt;如果当前垃圾收集循环是强制触发的，我们还需要处理还未被清理的内存管理单元；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标记阶段：&lt;/p&gt;
&lt;p&gt;标记过程是一个广度优先遍历的过程，扫描节点，将节点的子节点推到任务队列中，然后递归扫描子节点的节点，直到所有工作队列都被排空为止，这个阶段进行三色标记。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;将写屏障状态切换至 &lt;code&gt;_GCmark&lt;/code&gt;、开启写屏障、辅助GC程序（Mutator Assiste）并将根对象入队；占用25%CPU。&lt;/p&gt;
&lt;p&gt;辅助GC程序是为了防止堆heap的增速太快，在GC执行过程中如果同时运行的G分配了内存，那么这个G会被要求作为辅助GC做一部分的工作，辅助GC的G有两种类型，一种是标记，一种是清扫。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;恢复程序&lt;/strong&gt;，开始进行三色标记，标记进程和用于辅助GC程序会开始并发标记内存中的对象，写屏障会将被覆盖的指针和新指针都标记成灰色，而所有新创建的对象都会被直接标记成黑色；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开始扫描根对象，包括所有 Goroutine 的栈、全局对象以及不在堆中的运行时数据结构，扫描 Goroutine 栈期间会暂停当前处理器；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;依次处理灰色队列中的对象，将对象标记成黑色并将它们指向的对象标记成灰色；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用分布式的终止算法检查剩余的工作，发现标记阶段完成后进入标记终止阶段；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标记终止阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;暂停程序STW&lt;/strong&gt;、将写屏障状态切换至 &lt;code&gt;_GCmarktermination&lt;/code&gt; 并停止写屏障，关闭辅助标记的用户程序；&lt;/li&gt;
&lt;li&gt;清理处理器上的线程缓存；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;清理阶段；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将写屏障状态切换至 &lt;code&gt;_GCoff&lt;/code&gt; 开始清理阶段，初始化清理状态并关闭写屏障；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;恢复程序&lt;/strong&gt;，所有新创建的对象会标记成白色；&lt;/li&gt;
&lt;li&gt;后台并发清理所有的内存管理单元，当 Goroutine 申请新的内存管理单元时就会触发清理；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;并发垃圾回收是先STW找到所有的Root对象，开启写屏障，然后结束STW，让垃圾标记线程和用户线程并发执行，垃圾标记完成后，再次开启STW，停止写屏障，统计GC信息，结束STW，清理内存。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/GC%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/GC%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;go GC执行流程&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;go GC执行流程&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关注的指标&#34;&gt;关注的指标&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;CPU利用率&lt;/li&gt;
&lt;li&gt;GC停顿时间&lt;/li&gt;
&lt;li&gt;GC停顿频率&lt;/li&gt;
&lt;li&gt;GC可扩展性&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;gc性能优化技巧&#34;&gt;GC性能优化技巧&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;slice或map提前预分配&lt;/p&gt;
&lt;p&gt;slice预先分配内存，因为slice扩容时会返回新的slice，如果频繁扩容会增加GC压力；&lt;/p&gt;
&lt;p&gt;map同理；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;slice的缩容，比如一个 &lt;code&gt;arr = make([]*obj, 6)&lt;/code&gt; 缩容时，当&lt;code&gt;arr = arr[:3]&lt;/code&gt;时，底层数组后面 3 个元素已经无法访问了，但是其关联的堆上内存依然无法释放，触发把对应下标的元素置为nil；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;map的key和value使用值类型，而不是指针类型，利用map中extra中的特性；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;go中，string底层也是指针，如果string不可变，可以在转成 byte数组，这样就不会生成原有变量的副本，新的变量共享底层的数据指针。此特性也可用在把字符串转成[]byte，再作为map的key或value；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于占用空间少，频繁分配的函数，函数返回值使用值类型，不使用指针类型，因为返回指针类型会带来指针逃逸，使得原来可以分配在栈上的内存分配在堆上。在栈上进行小对象拷贝的性能会比对象在堆上分配好得多；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将多个小对象合并成一个大对象，减少对象分配，比如在局部变量逃逸时，聚集起来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// copy for capturing by the goroutine
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
       &lt;span class=&#34;c1&#34;&gt;// use k and v
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可以修改为下面这种，修改后，逃逸的对象变为了 x，将 k，v2 个对象减少为 1 个对象。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// copy for capturing by the goroutine
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
       &lt;span class=&#34;c1&#34;&gt;// use x.k and x.v
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对象如果包含了指针，则需要递归进行扫描，大量使用对象指针会使垃圾回收耗时变长；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;减少频繁创建goroutine，可以的话是一批一批的创建，或进行goroutine复用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;sync.Pool&lt;/code&gt;来缓存常用对象；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽可能使用字节数少的类型，比如当我们知道某些数字的使用只会在一定范围内，直接使用int8类型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Go 中存在数量极少的与 GC 相关的 API：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;runtime.GC：手动触发 GC&lt;/li&gt;
&lt;li&gt;runtime.ReadMemStats：读取内存相关的统计信息，其中包含部分 GC 相关的统计信息&lt;/li&gt;
&lt;li&gt;debug.FreeOSMemory：手动将内存归还给操作系统&lt;/li&gt;
&lt;li&gt;debug.ReadGCStats：读取关于 GC 的相关统计信息&lt;/li&gt;
&lt;li&gt;debug.SetGCPercent：设置 GOGC 调步变量&lt;/li&gt;
&lt;li&gt;debug.SetMaxHeap（尚未发布[10]）：设置 Go 程序堆的上限值&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/secondtonone1/p/11803961.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;图解Go协程调度原理，小白都能理解 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zboya.github.io/post/go_scheduler&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入golang runtime的调度&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.lanzous.com/i7lj0he&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gopher meetup-深入浅出Golang Runtime-yifhao&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://studygolang.com/articles/27069?fr=sidebar&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Golang调度器GMP原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000023869478&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;【golang】GMP调度详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://qcrao91.gitbook.io/go/gc/gc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://liangyaopei.github.io/2021/01/02/golang-gc-intro/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Golang垃圾回收(GC)介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.kancloud.cn/aceld/golang/1958308&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Golang三色标记+混合写屏障模式全分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://go.xargin.com/docs/runtime/memory_management/garbage_collection/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;垃圾回收&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://yousec995.github.io/2021/07/25/Goroutine%E5%8E%9F%E7%90%86/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;goroutine原理|YouSec&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.luozhiyun.com/archives/448&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;详解Go语言调度循环源码实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://mp.weixin.qq.com/s?__biz=MzAxMTA4Njc0OQ==&amp;amp;mid=2651439356&amp;amp;idx=2&amp;amp;sn=264a3141ea9a4b29fe67ec06a17aeb99&amp;amp;chksm=80bb1e0eb7cc97181b81ae731d0d425dda1e9a8d503ff75f217a0d77bd9d0eb451555cb584a0&amp;amp;scene=21#wechat_redirect&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;GC模式图文全分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://jishuin.proginn.com/p/763bfbd5f194&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Golang 系统调用与阻塞处理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/373874739&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;go pprof 实战&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1hv411x7we/?p=19&amp;amp;vd_source=a870d050aec1403366ebea0f42b4cdaf&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;[幼麟实现室]golang合辑&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go Context和Channel</title>
        <link>http://nixum.cc/p/go-context%E5%92%8Cchannel/</link>
        <pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/go-context%E5%92%8Cchannel/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;context&#34;&gt;Context&lt;/h1&gt;
&lt;p&gt;一个接口，包含如下方法，主要用于实现主协程对子协程的控制，作用包括取消执行、设置超时时间、携带键值对等&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 获取到期时间，如果没有，ok则返回false
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nf&#34;&gt;Deadline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;deadline&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 返回一个chan，表示取消信号，如果通道关闭则代表该 Context 已经被取消；如果返回的为 nil，则代表该 Context 是一个永远不会被取消的 Context。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 返回该 Context 被取消的原因。如果只使用 Context 包的 Context 类型的话，那么只可能返回 Canceled （代表被明确取消）或者 DeadlineExceeded （因超时而取消）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;Err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 获取Context中的键值对
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nf&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;一个demo，引用：&lt;a class=&#34;link&#34; href=&#34;https://strikefreedom.top/goroutine-concurrency-control-and-communication&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;通知多个子goroutine退出运行&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt; &lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;
 
 &lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
 	&lt;span class=&#34;s&#34;&gt;&amp;#34;context&amp;#34;&lt;/span&gt;
 	&lt;span class=&#34;s&#34;&gt;&amp;#34;crypto/md5&amp;#34;&lt;/span&gt;
 	&lt;span class=&#34;s&#34;&gt;&amp;#34;fmt&amp;#34;&lt;/span&gt;
 	&lt;span class=&#34;s&#34;&gt;&amp;#34;io/ioutil&amp;#34;&lt;/span&gt;
 	&lt;span class=&#34;s&#34;&gt;&amp;#34;net/http&amp;#34;&lt;/span&gt;
 	&lt;span class=&#34;s&#34;&gt;&amp;#34;sync&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;s&#34;&gt;&amp;#34;time&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;favContextKey&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;values&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;https://www.baidu.com/&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;https://www.zhihu.com/&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cancel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WithCancel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Background&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;

	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;url&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;values&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;subCtx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WithValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;favContextKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;url&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;reqURL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;subCtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;cancel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;

	&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;exit main goroutine&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;reqURL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;favContextKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;url&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)).(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 调用Done方法检测是否有父节点调用cancel方法通知子节点退出运行, chan被close时触发
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;stop getting url:%s\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;StatusCode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;StatusOK&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ioutil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ReadAll&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;subCtx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WithValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;favContextKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;resp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%s%x&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;url&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;md5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;showResp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;subCtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
			&lt;span class=&#34;c1&#34;&gt;//启动子goroutine是为了不阻塞当前goroutine，这里在实际场景中可以去执行其他逻辑，这里为了方便直接sleep一秒
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;c1&#34;&gt;// doSometing()
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;showResp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;stop showing resp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
			&lt;span class=&#34;c1&#34;&gt;//子goroutine里一般会处理一些IO任务，如读写数据库或者rpc调用，这里为了方便直接把数据打印
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;printing: &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;favContextKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;resp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;emptyctx&#34;&gt;emptyCtx&lt;/h2&gt;
&lt;p&gt;go提供了两个基本的context创建，emptyCtx是&lt;code&gt;int&lt;/code&gt;类型的重新定义，emptyCtx没有过期时间，不能被取消，不能设置value，作用仅作为context树的根节点。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;background&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;emptyCtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;todo&lt;/span&gt;       &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;emptyCtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Background&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;background&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;TODO&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;todo&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;cancelctx&#34;&gt;cancelCtx&lt;/h2&gt;
&lt;p&gt;通过根context，比如emptyCtx之后，调用&lt;code&gt;withCancel()&lt;/code&gt;方法可以创建cancelCtx用于取消操作。&lt;/p&gt;
&lt;p&gt;有两种方式可触发取消：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;返回的CancelFunc被调用，此时会取消当前context和其所有的子context&lt;/li&gt;
&lt;li&gt;Done这个chan被close了，此时会取消当前context和其所有的子context&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;CancelFunc&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 创建一个可被取消的context
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;WithCancel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cancel&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;CancelFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;cannot create context from nil parent&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;newCancelCtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 构建树形的cancel
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nf&#34;&gt;propagateCancel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;cancel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Canceled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// canceled是一个error实现
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;newCancelCtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cancelCtx&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cancelCtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 主要是将child ctx与parent ctx绑定，放到parent的children属性中
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;propagateCancel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;child&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;canceler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// parent is never canceled
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// parent is already canceled
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;child&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;cancel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 获取parent的cancelCtx，ok是用来判断父context是不是CancelCtx类型的
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;parentCancelCtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;c1&#34;&gt;// parent已经被取消，触发child的取消
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nx&#34;&gt;child&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;cancel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// parent没有被取消，把当前context作为parent的child
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;children&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;children&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;canceler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;children&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;child&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}{}&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;p&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 表示parent的ctx不是一个cancelCtx，没有children属性，无法构建成树，只能通过parent的done来向下传播
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AddInt32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;goroutines&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;child&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;cancel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;child&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;可被取消的context实现了canceler接口，具体实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;canceler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nf&#34;&gt;cancel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;removeFromParent&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cancelCtx&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 存储父context的指针
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;       &lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt;     &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 作为取消信号的channel，子协程监听该channel判断是否要cancel
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;children&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;canceler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 被关联的可被取消的context
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;      &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;                &lt;span class=&#34;c1&#34;&gt;// 第一次取消时被设置
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cancelCtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
   &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt;
   &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt;
   &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
   &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cancelCtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;cancel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;removeFromParent&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 在向下传播cancel时, 必须带上原始的error
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;context: internal error: missing cancel error&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// already canceled
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;closedchan&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;child&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;children&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// 取消所有子context
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;child&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;cancel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;children&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 从父context的children中移除当前context
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;removeFromParent&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;removeChild&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;timerctx&#34;&gt;timerCtx&lt;/h2&gt;
&lt;p&gt;可超时自动取消的context，内部使用cancelCtx + timer实现，调用&lt;code&gt;WithDeadline()&lt;/code&gt;方法可以创建timerCtx用于超时取消操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WithTimeout()方法&lt;/code&gt;和&lt;code&gt;WithDeadline()方法&lt;/code&gt;，效果是一样的，只是时间的含义不一样。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;WithTimeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;timeout&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Duration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;CancelFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;WithDeadline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;关于withTimeout()方法，返回的cancel函数，即使不主动调用，也不影响资源的最终释放，它到时间了也会自动调用，建议是提前主动调用，尽快释放，避免等待时间过长导致浪费。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;WithDeadline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;deadline&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;CancelFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cur&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Deadline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cur&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Before&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;deadline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 如果parent可以更早结束, 那么返回一个包装parent的cancelCtx
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;WithCancel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;timerCtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 组合一个新的cancelCtx
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;cancelCtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;newCancelCtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;deadline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;deadline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;nf&#34;&gt;propagateCancel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;parent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 组织树形结构
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Until&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;deadline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 如果时间已经到了, 直接触发取消
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;cancel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;DeadlineExceeded&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;cancel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Canceled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 新建定时器, 到期触发取消
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;timer&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;AfterFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;cancel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;DeadlineExceeded&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;// 返回值还有用于直接取消的CancelFunc
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;cancel&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Canceled&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    
&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;timerCtx&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;cancelCtx&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;timer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Timer&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// Under cancelCtx.mu.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;deadline&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Time&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;valuectx&#34;&gt;valueCtx&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;valueCtx&lt;/code&gt;内部仍然使用&lt;code&gt;Context&lt;/code&gt;存储父&lt;code&gt;Context&lt;/code&gt;的指针，并用&lt;code&gt;interface{}&lt;/code&gt;存储键值；&lt;/p&gt;
&lt;p&gt;如果当前&lt;code&gt;valueCtx&lt;/code&gt;找不到需要的&lt;code&gt;key&lt;/code&gt;，会沿着树向上一直查找直到根节点，类似链表的搜索；&lt;/p&gt;
&lt;p&gt;使用&lt;code&gt;WithValue&lt;/code&gt;创建时，会判断&lt;code&gt;key&lt;/code&gt;是否实现&lt;code&gt;Comparable&lt;/code&gt;接口。如果没有实现，会触发&lt;code&gt;panic&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;key的类类型不应该是内置类型，以避免冲突。使用的时候应该自定义类型；&lt;/p&gt;
&lt;h1 id=&#34;channel&#34;&gt;Channel&lt;/h1&gt;
&lt;p&gt;Channel的设计基于CSP模型。&lt;/p&gt;
&lt;p&gt;CSP模型（Communicating Sequential Process，通信顺序进程），允许使用进程组来描述系统，独立运行，并且只通过消息传递的方式通信。&lt;/p&gt;
&lt;p&gt;本质上就是，在使用协程执行函数时，不通过内存共享(会用到锁)的方式通信，而是通过Channel通信传递数据。&lt;/p&gt;
&lt;p&gt;动画参考：https://go.xargin.com/docs/data_structure/channel/&lt;/p&gt;
&lt;h2 id=&#34;基本&#34;&gt;基本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;chan是引用类型，使用make关键字创建，未初始化时的零值是nil，如&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ch := make(chan string, 10)&lt;/code&gt;，创建一个能处理string的缓冲区大小为10的channel，效果相当于异步队列，除非缓冲区用完，否则不会阻塞；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ch := make(chan string)&lt;/code&gt;，则创建了一个不存在缓冲区的channel，效果相当于同步阻塞队列，len永远返回0。&lt;/p&gt;
&lt;p&gt;即 假如没有接收者，同一个方法内，连续发送两次数据，第一次如果没有被接收的话，此时就阻塞了，轮不到第二次发送，但如果size = 1，第一次发送的数据就会进入buf数组，不阻塞，到了第二次发送才阻塞；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;var ch chan int&lt;/code&gt;表示创建了一个nil channel；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;channel作为通道，负责在多个goroutine间传递数据，解决多线程下共享数据竞争问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;len()&lt;/code&gt;方法获取buff中未被读取的数量，即qcount的值；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;cap()&lt;/code&gt;方法获取buff数组的长度&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;带有 &amp;lt;- 的chan是有方向的，不带 &amp;lt;- 的chan是双向的，比如&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;  &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 双向chan，可以发送和接收string  chan&amp;lt;- struct{}    // 只能发送struct到chan中  &amp;lt;-chan int         // 只能从chan中接收int
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;chan可以是任何类型的，比如可以是 chan&amp;lt;- 类型，&amp;lt;-总是尽量和左边的chan结合，比如&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 等价于 chan&amp;lt;- (chan int)chan&amp;lt;- &amp;lt;-chan int  // 等价于 chan&amp;lt;- (&amp;lt;-chan int)&amp;lt;-chan &amp;lt;-chan int  // 等价于 &amp;lt;-chan (&amp;lt;-chan int)chan (&amp;lt;-chan int)  // 等价于 chan (&amp;lt;-chan int)
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;接收数据时可以有两个返回值，第一个是返回的元素，第二个是bool类型，表示是否成功地从chan中读取到一个值。如果是false，说明chan已经被close并且chan中没有缓存的数据，此时第一个元素是零值。所以，如果接收时第一个元素是零值，可能是sender真的发送了零值，也可能是closed并且没有元素导致的，所以最好通过第二个返回值来确定。&lt;/li&gt;
&lt;li&gt;双向chan可以赋值给单向chan，但反过来不可以；&lt;/li&gt;
&lt;li&gt;给一个nil channel发送数据，会造成永久阻塞，从一个nil channel接收数据，会造成永久阻塞；&lt;/li&gt;
&lt;li&gt;给一个已经关闭的channel发送数据，会引起panic；&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 因为是无缓冲区的，只有当存在receiver的时候才能send成功，否则就一直阻塞，所以当close的时候，就会panic
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// panic: send on closed channel
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从一个已经关闭的channel接收数据，如果缓冲区为空，则返回一个零值；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;已关闭的channel再次关闭，会panic；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于一个不关闭的channel，在方法结束后，只要channel没有被引用，会被GC自动回收；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭channel的原则：不要向已关闭的channel发送数据或者再次关闭，关闭的动作尽量在sender做，主要还是分场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一个sender一个receiver的场景：在sender处关闭。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个sender多个recevier的场景：在sender处关闭。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多个sender一个receiver的场景：增加一个传递关闭信号的 channel，receiver 通过信号 channel 下达关闭数据 channel 指令。senders 监听到关闭信号后，停止发送数据。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;dataCh&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;stopCh&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// senders
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;NumSenders&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;stopCh&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
                    &lt;span class=&#34;c1&#34;&gt;// 接收关闭信号退出
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;dataCh&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Intn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// the receiver
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;dataCh&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Max&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;send stop signal to senders.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 直接关闭
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;nb&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;stopCh&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

            &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多个sender多个receiver的场景：再增加一个中间的channel，用来接收标识关闭的数据，收到后直接close传递关闭的信号channel即可。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;dataCh&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;stopCh&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 当使用select发送数据到toStop时，一定要有buffer，防止中间channel没准备好而错失关闭时机的问题
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;toStop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;stoppedBy&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 中间channel，用于接收标识关闭的数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;stoppedBy&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;toStop&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;stopCh&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// senders
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;NumSenders&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;id&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Intn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Max&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
                &lt;span class=&#34;c1&#34;&gt;// 发送者也可以关闭
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;nx&#34;&gt;toStop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;sender#&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;id&lt;/span&gt;
                    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

                &lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;stopCh&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 真正的停止
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;dataCh&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;strconv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Itoa&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// receivers
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;NumReceivers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;id&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;stopCh&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 真正的停止
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dataCh&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
                    &lt;span class=&#34;c1&#34;&gt;// 接收者也能进行关闭
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Max&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                        &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;toStop&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;receiver#&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
                        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
                    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

                    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;strconv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Itoa&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;channel在关闭时会自动退出循环；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;注意channel不提供跨goroutine的数据保护，如果多个channel传递一份数据的指针，使得每个goroutine可以操作同一份数据，也会出现并发安全问题；&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;nil&lt;/th&gt;
&lt;th&gt;empty&lt;/th&gt;
&lt;th&gt;full&lt;/th&gt;
&lt;th&gt;not full &amp;amp; empty&lt;/th&gt;
&lt;th&gt;closed&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;receive&lt;/td&gt;
&lt;td&gt;block&lt;/td&gt;
&lt;td&gt;block&lt;/td&gt;
&lt;td&gt;read value&lt;/td&gt;
&lt;td&gt;read value&lt;/td&gt;
&lt;td&gt;返回未读的元素，读完后返回零值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;send&lt;/td&gt;
&lt;td&gt;block&lt;/td&gt;
&lt;td&gt;write value&lt;/td&gt;
&lt;td&gt;block&lt;/td&gt;
&lt;td&gt;writed value&lt;/td&gt;
&lt;td&gt;panic&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;close&lt;/td&gt;
&lt;td&gt;panic&lt;/td&gt;
&lt;td&gt;closed，没有未读元素&lt;/td&gt;
&lt;td&gt;closed，保留未读元素&lt;/td&gt;
&lt;td&gt;closed，保留未读元素&lt;/td&gt;
&lt;td&gt;panic&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;hchan&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;qcount&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;uint&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 已经接收但还没被取走的元素个数，即channel中的循环数组的元素个数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;dataqsiz&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// channel中的循环数组的长度, ch:=make(chan int, 10), 就是这个10
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// channel中缓冲区数据指针，buf是一个循环数组，buf的总大小是elemsize的整数倍
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;elemsize&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint16&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 当前channel能够收发的元素大小
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;closed&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;uint32&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;elemtype&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;_type&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 当前channel能够收发的元素类型
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;sendx&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;uint&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 指向底层循环数组buf，表示当前可发送的元素位置的索引值，当sendx=dataqsiz时，会回到buf数组的起点，一旦接收新数据，指针就会加上elemsize，移向下个位置
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;recvx&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;uint&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 指向底层循环数组buf，表示当前可接收的元素位置的索引值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;recvq&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;waitq&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 等待接收队列，存储当前channel因缓冲区空间不足而阻塞的goroutine列表，双向链表
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;sendq&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;waitq&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 等待发送队列，存储当前channel因缓冲区空间不足而阻塞的goroutine列表，双向链表
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mutex&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 互斥锁，保证每个读channel或写channel的操作都是原子的，保护hchan和sudog上的字段。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 持有lock时，禁止更改另一个G的状态(比如不要把状态改成ready)，防止死锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 双向链表
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// sudog表示goroutine，是对goroutine的一层封装，代表一个在等待队列中的G
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 一个G可以出现在多个等待队列上，因此一个G可以有多个sudog
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;waitq&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;first&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sudog&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;last&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sudog&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sudog&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;g&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;g&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sudog&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;prev&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sudog&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;初始化&#34;&gt;初始化&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;makechan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;chantype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hchan&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 略去检查代码，检查数据项大小是否超过64KB，是否有错误的内存对齐，缓冲区大小是否溢出
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hchan&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;switch&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mem&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// chan的size或者元素的size是0，不必创建buf
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hchan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;mallocgc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hchanSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;raceaddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ptrdata&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 元素不是指针，分配一块连续的内存给hchan数据结构和buf
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hchan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;mallocgc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hchanSize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// hchan数据结构后面紧接着就是buf
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;hchanSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 元素包含指针，那么单独分配buf
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hchan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mallocgc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  
    &lt;span class=&#34;c1&#34;&gt;// 元素大小、类型、容量都记录下来
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elemsize&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uint16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elemtype&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dataqsiz&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nf&#34;&gt;lockInit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lockRankHchan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;发送数据&#34;&gt;发送数据&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt;ch &amp;lt;- &amp;quot;test&amp;quot;&lt;/code&gt;发送数据，最终会调用&lt;code&gt;chansend()&lt;/code&gt;函数发送数据，该函数设置了阻塞参数为true；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果chan是nil，则把发送者的goroutine park（阻塞休眠），此时发送者将被永久阻塞；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果chan没有被close，但是chan满了，则直接返回false，但是由于阻塞参数为true，这部分不会被执行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;上锁&lt;/strong&gt;，保证线程安全，再次检查chan是否被close，&lt;strong&gt;如果被close，再往里发数据会触发 解锁，panic&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步发送 - &lt;strong&gt;优先发送给等待接收的G&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果&lt;strong&gt;没被close，当recvq存在等待的接收者时&lt;/strong&gt;，通过&lt;code&gt;send()&lt;/code&gt;函数，取出第一个等待的goroutine，直接发送数据，不需要先放到buf中；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;send()&lt;/code&gt;函数将因为等待数据的接收而阻塞的goroutine的状态从Gwaiting或者Gscanwaiting改为Grunnable，把goroutine绑定到P的LRQ中，&lt;strong&gt;等待下一轮调度&lt;/strong&gt;时会立即执行这个等待发送数据的goroutine；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步发送 - &lt;strong&gt;其次是发送到buf区&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当recvq中没有等待的接收者，且buf区存在空余空间时&lt;/strong&gt;，会使用&lt;code&gt;chanbuf()&lt;/code&gt;函数获取&lt;strong&gt;sendx索引值&lt;/strong&gt;，计算出下一个可以存储数据的位置，然后调用&lt;code&gt;typedmemmove()&lt;/code&gt;函数将要发送的数据拷贝到buff区，增加sendx索引和qcount计数器，完成之后解锁，返回成功；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻塞发送 - &lt;strong&gt;最后才保存在待发送队列，阻塞（阻塞只发生在这里，此时G和M分离）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当recvq中没有等待的接收者，且buf区已满或不存在buf区时&lt;/strong&gt;，会先调用&lt;code&gt;getg()&lt;/code&gt;函数获取正在发送者的goroutine，执行&lt;code&gt;acquireSudog()&lt;/code&gt;函数获取sudoG对象，设置此次阻塞发送的相关信息（如发送的channel、是否在select控制结构中和待发送数据的内存地址、发送数据的goroutine）&lt;/p&gt;
&lt;p&gt;然后将该sudoG对象加入sendq队列，调用&lt;code&gt;goparkunlock()&lt;/code&gt;函数让当前发送者的goroutine进入等待状态，表示当前goroutine正在等待其他goroutine从channel中接收数据，等待调度器唤醒；&lt;/p&gt;
&lt;p&gt;此时len()返回值为0，数据的发送是阻塞在方法中的。&lt;/p&gt;
&lt;p&gt;调度器唤醒后，将一些属性值设置为零，并释放sudog对象，表示向channel发送数据结束；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;channel发送数据时涉及两次goroutine的调度&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当接收队列里存在sudoG可以直接发送数据时，执行&lt;code&gt;goready()&lt;/code&gt;函数，将G从Gwaiting或GScanwaiting转为Grunnable，等待下次调度触发，交由M执行；&lt;/li&gt;
&lt;li&gt;当没有等待接收数据的G，并且没有缓冲区，或者缓冲区已满时，执行&lt;code&gt;gopark()&lt;/code&gt;函数挂起当前G，将G阻塞，此时状态为Gwaiting，让出CPU等待调度器调度；&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;  1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 95
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 96
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 97
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 98
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 99
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;100
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;101
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;102
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;103
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;104
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;105
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;106
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;107
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;108
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;109
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;110
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;111
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;112
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;113
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// ep指的是用来发送数据的内存指针，数据类型与hchan中的类型一致
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 返回值表示带发送的数据是否 send 成功，即是否被接受，比如进buff或者被接收者接收；
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// ch &amp;lt;- [val] 时，block=true; select时，block=false
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;chansend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hchan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;block&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;callerpc&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 如果chan是nil，则把发送者的goroutine park（阻塞休眠），此时发送者将被永久阻塞
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;block&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;gopark&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;waitReasonChanSendNilChan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;traceEvGoStop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;throw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;unreachable&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;raceenabled&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;racereadpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;raceaddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;callerpc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;funcPC&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;chansend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 下面代码进针对select场景
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 当chan不为null，且没被close，full方法判断chan发送是否阻塞，是则直接返回true
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// full方法有两种情况判断是否可发送
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 1. 如果hchan.dataqsiz=0，说明是阻塞队列，如果此时hchan.recvq.first==nil，说明没有接收者，发送阻塞
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 2. 比较hchan.qcount是否等于hchan.dataqsiz，如果是说明chan已满，发送阻塞
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;block&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;closed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;full&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    
    &lt;span class=&#34;c1&#34;&gt;// 上锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nf&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 如果chan被关闭，再往里发送数据就会解锁，然后panic
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;closed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;plainError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;send on closed channel&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 如果chan没关闭，获取接收者等待队列中的第一个G开始发送数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;recvq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;dequeue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// G存在，调用send函数，send函数主要完成两件事
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 1. 调用sendDirect()函数将数据拷贝到接收变量的内存地址上
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 2. 调用goready()函数将等待接收的阻塞G的状态从Gwaiting或者Gscanwaiting改为Grunnable，把G绑定到P的LRQ中，下一轮调度时会唤醒这个等待接收数据的G立即执行。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nf&#34;&gt;send&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 当recvq中没有等待接收数据的G，且chan的缓冲区还有空间时
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;qcount&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dataqsiz&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 调用chanbuf获取sendx索引的元素的指针，；
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;qp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;chanbuf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sendx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;raceenabled&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;raceacquire&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;qp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;racerelease&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;qp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 调用typedmemmove()将要发送的数据拷贝到缓冲区buf
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nf&#34;&gt;typedmemmove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elemtype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;qp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 然后增加sendx索引和qcount计数器的值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sendx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sendx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dataqsiz&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 因为buf缓冲区是环形，如果索引到了队尾，则置0重新回到队头
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sendx&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;qcount&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 完成后就解锁，返回成功
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nf&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 能过到这边，说明没有等待接收数据的G，并且没有缓冲区，或者缓冲区已满，此时进入阻塞发送
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;block&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;c1&#34;&gt;// 获取当前goroutine
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 获取一个sudo G；acquireSudog()方法主要是获取可复用的sudoG对象，会优先从本地缓存获取，获取不到就会从全局缓存中获取，追加到本地缓存，如果全局缓存也没有，则新创建一个sudoG
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;acquireSudog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;releasetime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;releasetime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 为sudo G设置好要发送的数据和状态，比如发送的Channel、是否在select中和待发送的数据的内存地址等
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;waitlink&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;g&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;isSelect&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;waiting&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;param&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 将sudo G加入待发送队列
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sendq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;enqueue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 调用gopark方法挂起当前goroutine，状态为waitReasonChanSend，阻塞等待channel
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nf&#34;&gt;gopark&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;chanparkcommit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;waitReasonChanSend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;traceEvGoBlockSend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 确保发送的值保存活动状态，直到接收者将其复制出来。因为sudoG具有指向堆栈对象的指针，但其不能作为GC时的root对象。发送的数据是分配在堆上的，避免被GC。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nf&#34;&gt;KeepAlive&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

	&lt;span class=&#34;c1&#34;&gt;// 当goroutine被唤醒后，解除阻塞状态，完成channel阻塞数据的发送
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;waiting&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;throw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;G waiting list is corrupted&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;waiting&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;activeStackChans&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;param&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;closed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;throw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;chansend: spurious wakeup&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;plainError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;send on closed channel&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;param&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;releasetime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;blockevent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;releasetime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 发送完成之后，解除channel的绑定，重置sudoG状态，释放sudoG，释放时，如果本地缓存已满，会转移一部分到全局缓存，否则放到本地缓存等待被复用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nf&#34;&gt;releaseSudog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;接收数据&#34;&gt;接收数据&lt;/h2&gt;
&lt;p&gt;使用&lt;code&gt; str &amp;lt;- ch 或 str, ok &amp;lt;- ch (ok用于判断ch是否关闭，如果没有ok，可能会无法分辨str接收到的零值是发送者发的还是ch关闭)&lt;/code&gt;接收数据，会转化为调用&lt;code&gt;chanrecv1和chanrecv2函数&lt;/code&gt;，但最终会调用&lt;code&gt;chanrecv函数&lt;/code&gt;接收数据。chanrecv1和chanrecv2函数都是设置阻塞参数为true。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果chan是nil，则把接收者的goroutine park（阻塞休眠），接收者被永久阻塞；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不上锁检查 buf 区大小：如果chan的buf区大小为0 或者 没有数据可接收，检查是否被关闭，被关闭则返回；如果没被关闭，则再次检查buf区大小是否为0 或者 没有数据可接收，如果是，则清除ep指针中的数据并返回selected为true，received为false；&lt;/p&gt;
&lt;p&gt;这里两次empty检查，因为第一次检查，chan可能还没关闭，但是第二次检查时关闭了，由于可能在两次检查之间有待接收的数据达到了，所以需要两次empty检查；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;上锁&lt;/strong&gt;检查buf区大小：上锁，如果chan已经被close，且buf区没有数据，清除ep指针中的数据，解锁，返回selected为true，received为false；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步接收 - &lt;strong&gt;如果无buf，消费发送等待队列中G的数据，如果buf满，先拿buf区的，发送的再加入&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当chan的sendq队列存在等待状态的goroutine时&lt;/strong&gt;（能拿到就说明要不就是buf区为0，要不就是buf区已满）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果是无buf区的chan&lt;/strong&gt;，直接使用&lt;code&gt;recv()&lt;/code&gt;函数从阻塞的发送者中获取数据；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;如果是有buf区的chan&lt;/strong&gt;，说明此时buf区已满，则先从buf区中获取可接收的数据（从buf区中copy到接收者的内存），然后从sendq队列的队首中读取待发送的数据，加入到buf区中（将发送者的数据copy到buf区，替换刚刚buf区copy出去的位置），更新可接收和可发送的下标chan.recvx和sendx的值；&lt;/p&gt;
&lt;p&gt;最后调用&lt;code&gt;goready()&lt;/code&gt;函数将等待发送数据而阻塞gorouotine的状态从Gwaiting 或者 Gscanwaiting 改变成 Grunnable，把goroutine绑定到P的LRQ中，&lt;strong&gt;等待下一轮调度时&lt;/strong&gt;立即释放这个等待发送数据的goroutine；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步接收 - &lt;strong&gt;其次是消费buf区中的数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当channel的sendq队列没有等待状态的goroutine，且buf区存在数据时&lt;/strong&gt;，从channel的buf区中的recvx的索引位置接收数据，如果接收数据的内存地址不为空，会直接将缓冲区里的数据拷贝到内存中，清除buf区中的数据，递增recvx，递减qcount，完成数据接收；&lt;/p&gt;
&lt;p&gt;这个和chansend共用一把锁，所以不会有并发问题；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻塞接收 - &lt;strong&gt;最后才是保存在接收等待队列，阻塞（阻塞只发生在这里，此时G和M分离）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当channel的sendq队列没有等待状态的goroutine，且buf区不存在数据时&lt;/strong&gt;，执行&lt;code&gt;acquireSudog()&lt;/code&gt;函数获取sudoG对象，设置此次阻塞发送的相关信息（如发送的channel、是否在select控制结构中和待发送数据的内存地址、发送数据的goroutine）&lt;/p&gt;
&lt;p&gt;然后将该sudoG对象加入待发送recvq队列，调用&lt;code&gt;goparkunlock()&lt;/code&gt;函数让当前接收者的goroutine进入等待状态，表示当前goroutine正在等待其他goroutine从channel中发送数据，等待调度器唤醒；&lt;/p&gt;
&lt;p&gt;此时方法会阻塞在ch的接收中，len()返回值为0；&lt;/p&gt;
&lt;p&gt;goroutine被唤醒后，chan完成阻塞数据的接收，接收完成后进行基本的参数检查，解除chan的绑定，释放sudoG，表示接收数据完成；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;channel 接收过程中包含 2 次有关 goroutine 调度过程&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当发送队列中存在 sudoG 时，调用&lt;code&gt;goready()&lt;/code&gt;，G 的状态从 Gwaiting 或者 Gscanwaiting 改变成 Grunnable，等待下次调度便立即运行；&lt;/li&gt;
&lt;li&gt;当 buf 区为空，且没有发送者时，调用 &lt;code&gt;gopark()&lt;/code&gt;挂起当前G，此时状态为Gwaiting，让出 cpu 的使用权并等待调度器的调度；&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;  1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 95
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 96
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 97
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 98
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 99
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;100
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;101
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;102
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;103
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;104
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;105
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;106
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;107
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;108
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;109
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;110
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;111
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;112
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;113
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;114
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;115
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;116
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;117
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;118
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;119
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;120
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;121
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;122
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;123
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;124
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;125
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;126
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;127
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;128
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;129
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;130
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;131
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;132
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;133
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;134
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;135
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;136
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;137
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;138
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;139
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;140
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;141
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;142
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;143
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;144
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;145
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;146
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;147
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;148
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;149
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;150
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;151
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;152
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;153
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// ep指的是用来接收数据的内存指针，数据类型与hchan中的类型一致
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// [val] &amp;lt;- ch 时，block=true; select时，block=false
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;chanrecv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hchan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;block&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;selected&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;received&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;debugChan&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;chanrecv: chan=&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 如果chan是nil，接收者会被阻塞，gopark会引起waitReasonChanReceiveNilChan原因的休眠，并抛出unreachable的错误
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;block&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;gopark&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;waitReasonChanReceiveNilChan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;traceEvGoStop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;throw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;unreachable&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 这段代码仅针对select的场景
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 当chan不为nil，在没有获取锁的情况下，检查chan的buf区大小和是否存在可接收数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// empty方法是原子检查，检查chan.dataqsiz、chan.qcount是否为0，发送队列是否为空
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;block&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;atomic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Load&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;closed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 这里两次empty检查，因为第一次检查，chan可能还没关闭，但是第二次检查时关闭了，由于可能在两次检查时有待接收的数据达到了，所以需要两次empty检查
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;raceenabled&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nf&#34;&gt;raceacquire&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;raceaddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 如果chan的buf区大小和是否存在可接收数据，此时会清除ep指针中的数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nf&#34;&gt;typedmemclr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elemtype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	
	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t0&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;blockprofilerate&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;t0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;cputicks&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 获取锁后，再检查一遍
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nf&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 如果chan已经关闭且buf区不存在数据了，则清理ep指针中的数据并返回
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 这里也是从已经关闭的chan中读数据，读出来的是该类型零值的原因
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;closed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;qcount&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;raceenabled&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;raceacquire&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;raceaddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;typedmemclr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elemtype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 从发送队列队首中找到等待发送的goroutine（能拿到就说明要不就是buf区为0，要不就是buf区已满）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果buf区大小为0，则直接接收数据；
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 否则，说明buf区已满，先从buf区中获取要发送的数据，再将sender的数据加入到buf区中，更新可接收和可发送的下标chan.recvx和sendx的值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sendq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;dequeue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;recv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 当chan的buf区存在数据时，直接从buf区中获取数据，进行接收，更新接收数据的下标值，解锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;qcount&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;qp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;chanbuf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;recvx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;raceenabled&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;raceacquire&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;qp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;racerelease&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;qp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;typedmemmove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elemtype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;qp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;typedmemclr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elemtype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;qp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;recvx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;recvx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dataqsiz&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;recvx&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;qcount&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;block&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;c1&#34;&gt;// 到了这里，说明sendq里没有待发送的goroutine，且buf区也没有数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;acquireSudog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;releasetime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;releasetime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;waitlink&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;waiting&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;g&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;isSelect&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;param&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 设置好待接收的sudoG后，加入待发送的等待队列
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;recvq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;enqueue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 挂起当前goroutine，状态设置为waitReasonChanReceive，阻塞等待chan
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nf&#34;&gt;gopark&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;chanparkcommit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;waitReasonChanReceive&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;traceEvGoBlockRecv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// goroutine被唤醒后，完成chan阻塞数据的接收，解除chan的绑定释放sudoG
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;waiting&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;throw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;G waiting list is corrupted&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;waiting&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;activeStackChans&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;releasetime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;blockevent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;releasetime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;closed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;param&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;param&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
	&lt;span class=&#34;nf&#34;&gt;releaseSudog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mysg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;closed&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;


&lt;span class=&#34;c1&#34;&gt;// 这里sg指的是等待发送队列中的G，ep指其携带的数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;recv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hchan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sudog&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unlockf&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;skip&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dataqsiz&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;c1&#34;&gt;// 从 sender 里面拷贝数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nf&#34;&gt;recvDirect&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elemtype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	    &lt;span class=&#34;c1&#34;&gt;// 这里对应 buf 满的情况
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;qp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;chanbuf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;recvx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// 将数据从 buf 中拷贝到接收者内存地址中
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;typedmemmove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elemtype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;qp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// 将数据从 sender 中拷贝到 buf 中
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nf&#34;&gt;typedmemmove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elemtype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;qp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;recvx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;recvx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;dataqsiz&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;recvx&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sendx&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;recvx&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// c.sendx = (c.sendx+1) % c.dataqsiz
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;g&lt;/span&gt;
	&lt;span class=&#34;nf&#34;&gt;unlockf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;param&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;success&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;releasetime&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;releasetime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;cputicks&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nf&#34;&gt;goready&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;skip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;关闭&#34;&gt;关闭&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果 chan 为 nil，close 会 panic；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上锁：&lt;/p&gt;
&lt;p&gt;如果 chan 已经 closed，再次 close 也会 panic；&lt;/p&gt;
&lt;p&gt;否则的话，如果 chan 不为 nil，chan 也没有 closed，设置chan的标记为closed；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;优先释放所有的接收者&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;将接收者等待队列中的sudoG对象加入到待清除队列glist中，这里会优先回收接收者，这样即使从close中的chan读取数据，也不会panic，最多读到默认值；&lt;/p&gt;
&lt;p&gt;这样第6步执行的时候，才会先执行接收者，接收后面发送者的数据（接收buff数组里的数据，因为sender里的会被panic掉），否则发送者发送的数据无法被先接收。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;其次是释放所有发送者&lt;/strong&gt;：
将发送者等待队列中的sudoG对象加入到待清除队列glist中，这里可能会发生panic，因为往一个close的chan中发送数据会panic；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进行最后的调度，遍历glist中的sudoG，调用&lt;code&gt;goready()&lt;/code&gt;触发调度，将每个goroutine状态从 Gwaiting 转为 Grunnable状态，等待调度器调度；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;closechan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hchan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;plainError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;close of nil channel&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

	&lt;span class=&#34;nf&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;closed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;plainError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;close of closed channel&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;closed&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;glist&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gList&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 释放所有接收者：将所有接收者的sudoG等待队列加入到待清除的队列glist中
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;recvq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;dequeue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 销毁资源
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;typedmemclr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elemtype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;releasetime&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;releasetime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;cputicks&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;g&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;param&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;raceenabled&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;raceacquireg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;raceaddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;glist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 释放所有发送者：将所有发送者的sudoG等待队列加入到待清除的队列glist中
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果发送者队列存在发送者，那这些发送者所在的goroutine会产生panic
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sendq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;dequeue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 销毁资源
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;releasetime&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;releasetime&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;cputicks&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;g&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;param&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;raceenabled&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;raceacquireg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;raceaddr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;glist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nf&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

	&lt;span class=&#34;c1&#34;&gt;// 为所有被阻塞的 goroutine 调用 goready 触发调度。将所有 glist 中的 goroutine 状态从 _Gwaiting 设置为 _Grunnable 状态，等待调度器的调度
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;glist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;empty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;glist&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;pop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;schedlink&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;goready&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gp&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;实现生产者 - 消费组模型，数据传递，比如&lt;a class=&#34;link&#34; href=&#34;http://marcio.io/2015/07/handling-1-million-requests-per-minute-with-golang/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;worker池的实现&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;consumer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;taskChan&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;id&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;nx&#34;&gt;task&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;taskChan&lt;/span&gt;
                &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 模拟耗时
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;taskCh&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;consumer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;taskCh&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 生产者
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;taskCh&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// wait...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号通知：利用 如果chan为空，那receiver接收数据的时候就会阻塞等待，直到chan被关闭或有新数据进来 的特点，将一个协程将信号(closing、closed、data ready等)传递给另一个或者另一组协程，比如 wait/notify的模式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;协程池，把要操作的逻辑封装成task，通过chan传输实现协程复用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任务编排：让一组协程按照一定的顺序并发或串行执行，比如实现waitGroup的功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制并发量，可以配合WaitGroup进行控制goroutine的数量&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 这个放在外层和放在里层的效果不同，都可以控制并发量，但是前者会阻塞for循环，后者不会
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 放满三个后就会阻塞循环，此时最多存在3个goroutine
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
          &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// do something...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;          &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
          &lt;span class=&#34;c1&#34;&gt;// 防止泄露
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;          &lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
              &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;
          &lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 配合WaitGroup控制goroutine的数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;WaitGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// ch如果放在里层就达不到控制goroutine的效果了
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// ch&amp;lt;- 1, ch如果放在这，那就只阻塞goroutine里的逻辑，goroutine还是会创建多个
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;          &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// do something...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;          &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 防止泄露
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;          &lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
              &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;
          &lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;wg&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Wait&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任务定时&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;worker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;ticker&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Tick&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ticker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 执行定时任务
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;            &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;执行 1s 定时任务&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 或者
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;worker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
          &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;After&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Millisecond&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
          &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;stopc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
              &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现互斥锁的机制，比如，容量为 1 的chan，放入chan的元素代表锁，谁先取得这个元素，就代表谁先获取了锁&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Locker&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewLocker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Locker&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;locker&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Locker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)}&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;locker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;locker&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;locker&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Locker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;locker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;locker&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Locker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;UnLock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;locker&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}{}:&lt;/span&gt; 
      &lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; 
          &lt;span class=&#34;nb&#34;&gt;panic&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34; unlock of unlocked mutex&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; 
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;共享资源的并发访问使用传统并发原语；&lt;/p&gt;
&lt;p&gt;复杂的任务编排和消息传递使用 Channel；&lt;/p&gt;
&lt;p&gt;消息通知机制使用 Channel，除非只想 signal 一个 goroutine，才使用 Cond；&lt;/p&gt;
&lt;p&gt;简单等待所有任务的完成用 WaitGroup，也有 Channel 的推崇者用 Channel，都可以；&lt;/p&gt;
&lt;p&gt;需要和 Select 语句结合，使用 Channel；需要和超时配合时，使用 Channel 和 Context。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意点：使用chan要注意panic和goroutine泄露，另外，只要一个 chan 还有未读的数据，即使把它 close 掉，你还是可以继续把这些未读的数据消费完，之后才是读取零值数据。&lt;/p&gt;
&lt;p&gt;在使用chan和select配合时要注意会出现goroutine泄漏的情况：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;timeout&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Duration&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 模拟处理耗时的业务
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;timeout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// block
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;exit goroutine&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 如果上面的协程任务处理的时间过长，触发下面select的超时机制，此时process函数返回，之后当上面的协程任务执行完之后，由于process已经执行完，下面result接收chan的值被回收，所以没有接收者，导致上面的协程任务一直卡在 ch &amp;lt;- true，进而导致goroutine泄漏。解决方案就是使用容量为1的ch即可。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;After&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;):&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;select&#34;&gt;select&lt;/h1&gt;
&lt;h2 id=&#34;结构&#34;&gt;结构&lt;/h2&gt;
&lt;p&gt;select在runtime中不存在结构体表示，但是case倒是有&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// scase.kind，到时select就是轮询判断这些类型的
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// send 或者 recv 发生在一个 nil channel 上，就有可能出现这种情况
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;caseNil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;iota&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;caseRecv&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;caseSend&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;caseDefault&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// select 中每一个 case 的数据结构定义
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;scase&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 接收 或 发送数据的变量地址
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hchan&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// 存储正在使用的chan
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;kind&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint16&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// case的种类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;releasetime&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;pc&lt;/span&gt;          &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// return pc (for race detector / msan)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;基本-1&#34;&gt;基本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;非阻塞收发：当chan中存在可接收数据，直接处理那个chan，否则执行default语句&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;default&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;随机执行：select遇到多个case就绪，会进行随机选择&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;ch1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;ch2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
        &lt;span class=&#34;nb&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;编译器会对select中的case进行优化，总共有四种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不包含任何case，即空select，此时会阻塞当前的goroutine&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;只包含一个case，此时select会被优化成 if ，当chan没有数据可接收时，就会把阻塞当前goroutine，直到有数据到来；如果chan是nil，就会永远阻塞当前goroutine&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// ...    
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 会被优化成
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nf&#34;&gt;block&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;
&lt;p&gt;存在两个case，其中一个是default：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送，这种情况下，发送是不阻塞的：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;chan&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 一定要1及以上，才先会走case，如果是0会死锁，直接走default，
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 底层调用的是chansend(c, elem, false, getcallerpc())，这里的阻塞参数是false， 表示这次发送不会阻塞
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;selectnbsend&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;接收，这种情况下，chan有值就走case，否则走default&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;  &lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// case v, received &amp;lt;- ch:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;selectnbrecv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// if selectnbrecv2(&amp;amp;v, &amp;amp;received, ch) {
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;通用的select条件：比如select里包含多个case，会编译成通过&lt;code&gt;runtime的selectgo方法&lt;/code&gt;处理case，&lt;code&gt;selectgo&lt;/code&gt;会返回 case的序号 还有 是否被接收的标识，然后被编译成多个if，用于判断选中哪个case。&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;selv&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;scase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;order&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint16&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cas&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cases&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;scase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;kind&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;elem&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
      &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;chosen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;revcOK&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;selectgo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;selv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;order&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;chosen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;chosen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;chosen&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;
  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;selectgo的流程&#34;&gt;selectgo的流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;获取case数组，随机打乱，确定打乱后的轮询顺序数组pollorder和加锁顺序数组lockorder，数组里存放的元素是chan&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按加锁顺序数组，调用chan的锁，依次进行锁定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进入主循环，遍历 轮询顺序数组pollorder&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;第一阶段&lt;/strong&gt;，查找是否已经存在准备就绪的chan（此时的chan可以执行收发操作）此时需要处理四种类型的case：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当case不包含chan时，直接跳过；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当case会从chan中接收数据时：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如果当前chan的&lt;code&gt;sendq队列&lt;/code&gt;上有等待的goroutine，就会跳到 &lt;code&gt;recv标签&lt;/code&gt;，如果没有buf区，则从&lt;code&gt;sendq队列&lt;/code&gt;上获取数据，否则，从chan的buf区读取数据后，将&lt;code&gt;sendq队列&lt;/code&gt;中等待的goroutine中的数据放入到buf区中相同的位置；&lt;/li&gt;
&lt;li&gt;如果当前chan的buf区不为空，就跳到&lt;code&gt;bufrecv标签&lt;/code&gt;，从chan的buf区中获取数据&lt;/li&gt;
&lt;li&gt;如果当前chan已经被关闭，就会跳到 &lt;code&gt;rclose标签&lt;/code&gt; 做一些清除的收尾工作；&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;当case会从chan中发送数据时：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;如果当前chan已经被关闭，会直接跳到 &lt;code&gt;sclose标签&lt;/code&gt;，触发panic；&lt;/li&gt;
&lt;li&gt;如果当前chan的&lt;code&gt;recvq队列&lt;/code&gt;上有等待的goroutine，就跳到 &lt;code&gt;send标签&lt;/code&gt; 向chan发送数据；&lt;/li&gt;
&lt;li&gt;如果当前chan的缓冲区存在空闲位置，就会将等待发送的数据存入缓冲区中，因为select相当于有接收者了，不会出现发送阻塞的情况；&lt;/li&gt;
&lt;/ul&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;当case是default时，表示前面的所有case都没有被执行，此时会解锁所有的chan并返回（意味着当前select结构的收发都是非阻塞的），直接执行default内容；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;第一阶段只是查找所有case中是否有可以立即被处理的chan，无论是数据是在等待的goroutine上，还是buf区中，只要存在数据满足条件就会立即处理，然后返回；如果不能立刻找到活跃的chan，就会进入下一循环；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二阶段&lt;/strong&gt;，将当前goroutine加入到chan对应的收发队列上并等待其他goroutine的唤醒:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将当前goroutine，包装成sudogo，遍历case，加入到case的chan的&lt;code&gt;sendq队列&lt;/code&gt;或者&lt;code&gt;recvq队列&lt;/code&gt;中（同时，这个sudog会关联当前case的chan，然后将这些sudog组成链表，挂在当前goroutine下，用于唤醒之后的查找）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_selectgo.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_selectgo.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用&lt;code&gt;gopark函数&lt;/code&gt;挂起当前goroutine，等待被调度器唤醒；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;第三阶段&lt;/strong&gt;，当前goroutine被唤醒后，找到满足条件的chan并进行处理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;等到select对应的chan准备好后，当前goroutine会被调度器唤醒，被唤醒后，获取当前goroutine的sudog，依次对比所有case里chan对应的sudog结构，找到被唤醒的case，并释放其他未被使用的sudog结构；&lt;/li&gt;
&lt;li&gt;由于当前的select结构已经被挑选了其中一个case执行，剩下的case中没有被用到的sudog会被直接忽略并释放掉，为了不影响chan的正常使用，还需要将这些废弃的sudog从chan中出队；&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;selectgo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cas0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;scase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;order0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ncases&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;cas1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;scase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cas0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;order1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;17&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;order0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;

    &lt;span class=&#34;nx&#34;&gt;scases&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cas1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ncases&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ncases&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 轮询顺序数组
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;pollorder&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;order1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ncases&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ncases&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 加锁顺序数组
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;lockorder&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;order1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ncases&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:][:&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ncases&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ncases&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;scases&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;cas&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;scases&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cas&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;kind&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;caseDefault&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cas&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;scase&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 根据chan的地址排序
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ncases&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 随机轮询，避免chan饿死
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fastrandn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;uint32&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;pollorder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pollorder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;pollorder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uint16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 按照之前生成的加锁顺序锁定 select 语句中包含所有的 Channel
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;sellock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;scases&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lockorder&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// ...后面太长就不贴了
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;timer&#34;&gt;Timer&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cyhone.com/articles/analysis-of-golang-timer/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cyhone.com/articles/analysis-of-golang-timer/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;时间轮&#34;&gt;时间轮&lt;/h1&gt;
&lt;p&gt;概念理解：&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/121483218&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;一张图理解Kafka时间轮&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://lk668.github.io/2021/04/05/2021-04-05-%E6%89%8B%E6%8A%8A%E6%89%8B%E6%95%99%E4%BD%A0%E5%A6%82%E4%BD%95%E7%94%A8golang%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAtimewheel/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;手把手教你如何用golang实现一个timewheel时间轮&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.luozhiyun.com/archives/444&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go语言中时间轮的实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Kafka%e6%97%b6%e9%97%b4%e8%bd%ae%e7%ae%80%e5%8d%95%e5%ae%9e%e7%8e%b0.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Kafka%e6%97%b6%e9%97%b4%e8%bd%ae%e7%ae%80%e5%8d%95%e5%ae%9e%e7%8e%b0.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;p&gt;通过DelayQueue（优先级队列实现，队列里的每个元素，都是某一个具体时间的list） + 环形数组（数组的每个元素是个list，索引代表时间格）&lt;/p&gt;
&lt;p&gt;DelayQueue会根据环形数组中的每个元素进行排序；&lt;/p&gt;
&lt;p&gt;添加任务时，判断任务执行时间，加入环形数组中，对应的环形数组的元素（list），加入DelayQueue中。，&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Go</title>
        <link>http://nixum.cc/p/go/</link>
        <pubDate>Sat, 07 Nov 2020 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/go/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下基于go.1.14&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&#34;函数内联优化&#34;&gt;函数内联优化&lt;/h1&gt;
&lt;p&gt;函数内联优化：在A函数中调用了B函数，内联后，B函数的代码直接在A函数内原地展开，代替这个函数实现，当有多次调用时，就会多次展开&lt;/p&gt;
&lt;p&gt;go在编译时会自动判断函数是否可以内联，当函数内包含以下内容时不会被内联：闭包调用，select，for，defer，go关键字创建的协程等。&lt;/p&gt;
&lt;p&gt;内联的好处：因为函数调用被内联了，可以减少栈帧的创建，减少读写寄存器的读取，减少参数和函数的拷贝，提升性能&lt;/p&gt;
&lt;p&gt;缺点：堆栈panic显示的行数可能不准确、增加编译出来的包的大小&lt;/p&gt;
&lt;p&gt;编译时使用&lt;code&gt;go build -gcflags=&amp;quot;-m -m&amp;quot; main.go&lt;/code&gt;可以知道编译器的内联优化策略，&lt;/p&gt;
&lt;p&gt;go编译时默认会使用内联优化，使用&lt;code&gt;go build --gcflags=&amp;quot;-l&amp;quot; main.go&lt;/code&gt;可禁掉全局内联，如果传递两个或以上-l，则会打开内联；&lt;/p&gt;
&lt;h1 id=&#34;defer&#34;&gt;defer&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多个defer是栈的关系，以链表的形式挂在G上，先进后出&lt;/strong&gt;，即在一个函数中，写在前面的defer会比写在后面的defer调用得晚，先进后出的原因是后面定义的函数可能会依赖前面的资源，如果前面的先执行导致依赖没了，会影响后面的执行，导致出错；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;defer和return同时出现时，先return后defer，defer可以修改到return里的变量；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;return 是非原子性的，需要两步，执行前首先要为返回值赋值，然后 return 将返回值返回调用处。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;defer 和 return 的执行顺序是：1. 先为返回值赋值；2. 然后执行 defer；3. 然后 return 到函数调用处&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;要注意defer + 函数 的场景，如果是函数调用，并且使用的变量是传参进去的，那得看入参类型；如果是闭包调用，引用了外边的变量（不管是不是指针），那就是引用&lt;/p&gt;
&lt;p&gt;当返回值没有声明变量时，会内置一个隐式的变量来接收return的赋值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;panic被触发时，控制权就交给了defer&lt;/p&gt;
&lt;p&gt;遇到panic时，会先遍历此协程内的defer链表，并执行defer，如果在执行过程中遇到recover，则停止panic，返回recover处继续往下执行，如果没遇到recover，则遍历完本协程的defer链表后，向stderr抛出panic信息；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行defer过程中出现panic，此时的panic会覆盖它之前的panic，直至被捕获或抛出；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;test1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 0 0
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;test2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 3 3
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;test21&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 0 3
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;test3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 0 4
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;test4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 0 5
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 注意返回值是否已经声明了变量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;test5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 1 0
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;test51&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 1 1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;test1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 0
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;test2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 3
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// test2 和 test21 的差异在于闭包
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;test21&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 相当于调用fmt.Print方法，然后把v传值进去，此时 v=0，v已经赋值给了fmt.Print方法的入参了
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 类似 test4()
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 0
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;test3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 0
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;test4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 0
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;}(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 区分 test51, 区别在于返回值是否声明了变量名，当返回值没有声明变量时，return会把值赋值给一个隐式的变量，之后随便i怎么改，都不影响其返回值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;test5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;test51&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Print&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34; &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;}()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;内存对齐&#34;&gt;内存对齐&lt;/h1&gt;
&lt;p&gt;CPU读取数据时不会一个字节一个字节去读取，而是一块一块，块的大小可以是2、4、6、8、16字节，块大小称为内存访问粒度。32位CPU一次读取4个字节，64位CPU一次读取8个字节。&lt;/p&gt;
&lt;p&gt;如果未进行内存对齐，会导致CPU进行两次内存访问，并且需要花费额外的时钟周期来处理对齐及运算，如果对齐了内存，一次读取就能访问完成，内存对齐可能会耗费额外的空间，但是可以加快读取效率，标准的空间换时间做法。&lt;/p&gt;
&lt;p&gt;以32位CPU对齐为例：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Part1&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int8&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 乍一看按每个类型所占字节数去算，算出来的内存占用是15个字节，但实际上是32字节
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;对齐规则：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为编译器默认对齐长度（&lt;code&gt;#pragma pack(n)&lt;/code&gt;）或当前成员变量类型的长度（&lt;code&gt;unsafe.Sizeof&lt;/code&gt;），取最小值作为当前类型的对齐值。其偏移量必须为对齐值的整数倍&lt;/li&gt;
&lt;li&gt;结构体本身，对齐值必须为编译器默认对齐长度（&lt;code&gt;#pragma pack(n)&lt;/code&gt;）或结构体的所有成员变量类型中的最大长度，取最大数的最小整数倍作为对齐值&lt;/li&gt;
&lt;li&gt;结合以上两点，可得知若编译器默认对齐长度（&lt;code&gt;#pragma pack(n)&lt;/code&gt;）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;对齐过程：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成员变量&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;偏移量&lt;/th&gt;
&lt;th&gt;自身占用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字节对齐&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;int32&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;int8&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字节对齐&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;int64&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;24&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字节对齐&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;25&lt;/td&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;总占用大小&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;内存布局：axxx|bbbb|cxxx|xxxx|dddd|dddd|e，之后要保证整个结构体进行字节对齐，发现它不是2^n，可得出最近一个数是32。&lt;/p&gt;
&lt;p&gt;对结构体内字段顺序进行调整后，可以发现算出来的大小会不一样&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Part2&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int8&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int32&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 调整字段顺序后，算出来的大小是16，原因是整个结构体本身不需要额外对齐
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;成员变量&lt;/th&gt;
&lt;th&gt;类型&lt;/th&gt;
&lt;th&gt;偏移量&lt;/th&gt;
&lt;th&gt;自身占用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;byte&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;c&lt;/td&gt;
&lt;td&gt;int8&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;a&lt;/td&gt;
&lt;td&gt;bool&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字节对齐&lt;/td&gt;
&lt;td&gt;无&lt;/td&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;int32&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;d&lt;/td&gt;
&lt;td&gt;int64&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;总占用大小&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;内存布局：ecax|bbbb|dddd|dddd&lt;/p&gt;
&lt;h1 id=&#34;数组&#34;&gt;数组&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;声明时必须指定固定长度，因为编译时需要知道数组长度以便分配内存，如&lt;code&gt;var arr1 [5]int&lt;/code&gt;，或者&lt;code&gt;var arr2 = [5]int{1,2,3}, 其余数字为0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;数组&lt;strong&gt;长度最大是2Gb&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当数组类型是整形时，所有元素都会被自动初始化为0，即声明完数组，&lt;strong&gt;数组会被设置类型的默认值&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;可以使用new()来创建，如&lt;code&gt;var arr3 = new([3]int)&lt;/code&gt;，arr3的类型是&lt;code&gt;*[3]int&lt;/code&gt;，arr1、arr2的类型是&lt;code&gt;[5]int&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;函数的参数可以是[5]int, 表明入参是数组，如果是[]int，表明入参是slice。类型[3]int和[5]int是两种不同的类型。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;数组是值类型&lt;/strong&gt;，赋值和传参会进行拷贝，函数内部的修改不会影响原始数组。&lt;/li&gt;
&lt;li&gt;如果数组中的元素个数小于或等于4个，所有变量会直接在栈上初始化；当数组元素大于4个，变量就会在静态存储区初始化然后拷贝到栈上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;切片slice&#34;&gt;切片Slice&lt;/h1&gt;
&lt;h2 id=&#34;数据结构&#34;&gt;数据结构&lt;/h2&gt;
&lt;p&gt;slice本质是一个结构体，所以它是值类型是不难理解的，它仅仅只是对数组的一种包装，且该结构体不包含任何函数，任何对slice的处理都是go的内置函数来处理的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Slice&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;ptr&lt;/span&gt;   &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt; 	&lt;span class=&#34;c1&#34;&gt;// 指向数组的指针
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;len&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;               &lt;span class=&#34;c1&#34;&gt;// 切片长度
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;cap&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;               &lt;span class=&#34;c1&#34;&gt;// 切片容量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;基本&#34;&gt;基本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建时无需指定长度，如 &lt;code&gt;slice1 := []int{1,2,3}, 此时长度和容量均为3&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从数组上截取&lt;code&gt;arr1 := [5]int; var slice2 []int = arr1[1:3], 此时长度2，容量5，且对slice2的修改会影响arr1&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以使用make([]type, len, cap)来创建，len必填，cap非必填，如果cap不填，初始cap=len。如&lt;code&gt;slice4 := make(int[], 5, 10)，长度5，容量10&lt;/code&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以使用new来创建，比如 &lt;code&gt;new([100]int)[0:50]&lt;/code&gt; 效果等同于 &lt;code&gt;make([]int, 50, 100)&lt;/code&gt;，或者 &lt;code&gt;slice := *new([]int) 为空切片&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空切片：&lt;code&gt;slice := make([]int, 0) 或 slice := []int{}&lt;/code&gt;，nil切片：&lt;code&gt;var slice *[]int 或 slice := *new([]int)&lt;/code&gt;；两者的区别在于，空切片会指向一个内存地址，但它没有分配任何的内存空间；nil切片是直接指向nil。&lt;/p&gt;
&lt;p&gt;打印时，两者的结果均为&lt;code&gt;[], len=0， cap=0&lt;/code&gt;，但nil切片与nil比较的结果为true，空切片与nil的比较结果为false。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切片是对数组的一个连续片段的引用，对于&lt;strong&gt;切片底层数组是引用类型&lt;/strong&gt;，作为函数参数时，虽然是传切片的值，但是底层数组传递指针，函数内部的修改会影响原始数组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个数组可以创建多个slice，一个slice也可以创建多个slice，但是新老slice会共用底层数组，新老slice的修改都会互相影响。但是如果新slice经过append，使得slice底层数组扩容了，此时slice引用了新的数组，此时新老slice就不会互相影响了。&lt;/p&gt;
&lt;p&gt;语法：&lt;code&gt;ns = slice1[起始下标:结束下标(不包括):cap容量]&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;slice&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;slice&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// s = [1]
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;slice&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// s = [1, 2], len=2, cap=2
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;slice&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// s = [1, 2], len=2, cap=5
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;slice&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// s=[], len=0, cap=0
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用new()和make()的区别&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;看起来二者没有什么区别，都在堆上分配内存，但是它们的行为不同，适用于不同的类型。&lt;/p&gt;
&lt;p&gt;new (T) 为每个新的类型 T 分配一片内存，初始化为 0 并且返回类型为 *T 的内存地址：这种函数 返回一个指向类型为 T，值为 0 的地址的指针，它&lt;strong&gt;适用于值类型，如数组和结构体&lt;/strong&gt;；它相当于 &amp;amp;T{}。
make(T) 返回一个类型为 T 的初始值，它只&lt;strong&gt;适用于 3 种内建的引用类型：切片、map 和 channel&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;range遍历的注意点：将slice的每个元素赋值给v时，发生了一次拷贝，无法通过修改v来修改slice。如果是slice是指针结构体类型，还是能修改的。也就是说如果slice是指针类型，通过range遍历append时要注意&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;	&lt;span class=&#34;nx&#34;&gt;arr2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;newArr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;arr2&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;newArr&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;newArr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;newArr&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%v &amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 打印3 3 3，因为是v指向了同一个指针
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;扩容&#34;&gt;扩容&lt;/h2&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;当使用append()函数向slice追加元素，会根据slice的容量判断是否需要扩容。另外，因为slice是值传递，append()函数不会修改传入的slice，返回是重新对底层数组、长度、容量做包装，返回新slice。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果slice容量够用，则直接把新元素追加进去，长度 + 1，返回原slice&lt;/li&gt;
&lt;li&gt;原slice容量不够，将slice扩容，得到新的slice&lt;/li&gt;
&lt;li&gt;将新元素追加到新slice，长度 + 1，返回新slice&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，&lt;strong&gt;copy函数拷贝&lt;/strong&gt;两个slice时，会将源slice拷贝到目标slice，&lt;strong&gt;如果目标slice的长度&amp;lt;源slice，不会发生扩容&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Demo：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;slice&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;slice&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;slice&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// slice=? data=?
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;slice&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;slice&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;11&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// slice=? data=?
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;结果&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 第一次append后结果
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;slice&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 第二次append后结果
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;slice&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;11&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;  &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;   &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;扩容策略&#34;&gt;扩容策略&lt;/h3&gt;
&lt;p&gt;扩容实际上包括两部分：计算容量的规则 和 内存对齐&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;如果&lt;strong&gt;期望容量大于当前容量的两倍&lt;/strong&gt;就会使用期望容量，期望容量指的是把元素加进去后的容量，一般发生在append 多个的时候，如 append(arr, 1, 2, 3, 4)。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果当前切片的长度小于 1024，扩容两倍。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果当前切片的长度大于 1024 就会每次增加 25% 的容量，即扩容1.25倍，直到新容量大于期望容量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此时只是确定切片的大致容量，之后会判断切片中元素所占字节大小，如果字节大小是1、2、8的倍数时，会进行内存对齐，这个操作之后，扩容后的容量可能会 &amp;gt; 原容量的两倍 或 1.25倍。&lt;/p&gt;
&lt;p&gt;内存对齐主要是为了提高内存分配效率，减少内存碎片。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;PS：go 18以前还是用 1024 来判断要扩容的大小，18之后使用256，长度小于256，扩容两倍；长度大于256时，规则为 &lt;code&gt;原长度 += (原长度 + 3*256) / 4&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 此时期望容量是2 + 3 = 5 &amp;gt; 旧容量的两倍 2 * 2 = 4，期望容量为5，占40个字节，不是2^n次，so触发内存对齐，向上取整为48字节，此时新容量为 48 / 8 = 6。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;s1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;len=%d, cap=%d\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;cap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// len=5, cap=6
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 第一次append，扩容，拷贝旧数据到新数组，容量增长两倍；
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 第二次append，没有产生新数组，只将元素进行追加；
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 第三次append，扩容，拷贝旧数据到新数组，容量增长两倍；
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;len=%d, cap=%d\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;cap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// len=3, cap=4
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;len=%d, cap=%d\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;cap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// len=4, cap=4
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Printf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;len=%d, cap=%d\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;cap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// len=5, cap=8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;map&#34;&gt;Map&lt;/h1&gt;
&lt;h2 id=&#34;数据结构-1&#34;&gt;数据结构&lt;/h2&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;87
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;hmap&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 哈希表中元素的数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// flags枚举：1: 可能有迭代器使用buckets，2: 可能有迭代器使用oldbuckets，4: 有协程正在向map中写入key，8:等量扩容
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;flags&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;uint8&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 记录map的状态
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;         &lt;span class=&#34;kt&#34;&gt;uint8&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// buckets的数量，len(buckets) = 2^B
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;noverflow&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint16&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 溢出的bucket的个数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;hash0&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;uint32&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 哈希种子，为哈希函数的结果引入随机性。该值在创建哈希表时确定，在构造方法中传入
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;buckets&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 桶的地址，指向一个bmap数组，即指向很多个桶
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;oldbuckets&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 扩容时用于保存之前buckets的字段，大小是当前buckets的一半或0.75，非扩容状态下为null
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;nevacuate&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 扩容迁移的进度，小于nevacuate的buckets表示已迁移完成，同时也用来计算下一个要迁移的桶在oldbuckets中的位置
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;extra&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mapextra&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 存储单个桶装满时溢出的数据，溢出桶和正常桶在内存上是连续的, 即 hmap.buckets[i].overflow会关联hmap.extra.overflow
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mapextra&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 下面这两个字段是为了优化GC扫描而设计的。在map的key和value都不是指针，并且size都小于128字节时使用（即可以被inline），所有hmap.buckets的溢出桶都用这两个字段进行管理，避免gc时扫描整个hmap。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    
    &lt;span class=&#34;c1&#34;&gt;// 因为 bmap.overflow 是个指针，指向溢出的bucket，而GC时必定会扫描指针，那就会扫描所有bmap，
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 当map的key和value都是非指针类型时，为了避免扫描所有buckets，就可以使用extra.overflow来存储溢出的bucket，并把bmap结构体里的overflow指针类型变成unitptr类型（编译期干的），那整个bmap就完全没指针了。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 这样就可以通过extra直接标记整个map的颜色，避免扫描每个bmap的overflow指针；
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 另一方面，当 GC 在扫描 hmap 时，通过 extra.overflow 这条路径（指针）就可以将 overflow 的 bucket 正常标记成黑色，从而不会被 GC 错误地回收。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;overflow&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bmap&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 包含hmap.buckets的overflow的buckets，即保存了所有溢出桶，便于GC扫描
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;oldoverflow&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bmap&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 包含扩容时的hmap.oldbuckets的overflow的bucket，用于扩容
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 指向空闲的 overflow bucket 的指针，用于预分配
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;nextOverflow&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bmap&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 即桶bucket的结构
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bmap&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 表示一个桶，实际上为len为8的数组，每个桶只能存8个键值对，包含此桶中每个key的哈希值的高8位
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果tophash[0] &amp;lt; minTopHash，说明前minTopHash个已经被搬迁过
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// tophash的最低位代表桶的搬迁evacuation状态，最低位0表示在X part，1表示在Y part。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;tophash&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucketCnt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint8&lt;/span&gt; 
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 但由于go没有泛型，哈希表中又可能存储不同类型的键值对，所以键值对所占的内存空间大小只能在编译时推导，
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 无法先设置在结构体中，这些字段是在运行时通过计算内存地址的方式直接访问，这些额外的字段都是编译时动态创建
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bmap&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;topbits&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint8&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 通过tophash找到对应键值对在keys和values数组中的下标，即有8个cell
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;keys&lt;/span&gt;     &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;keytype&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;values&lt;/span&gt;   &lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;valuetype&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;pad&lt;/span&gt;      &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;overflow&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 每个桶只能存8个元素，超过8个时会存入溢出桶，溢出桶只是临时方案，溢出过多时会进行扩容
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 重要的常量标志
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 一个桶中最多能装载的键值对（key-value）的个数为8
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;bucketCntBits&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;bucketCnt&lt;/span&gt;     &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bucketCntBits&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 触发扩容的装载因子为13/2=6.5
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;loadFactorNum&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;13&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;loadFactorDen&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 键和值超过128个字节，就会被转换为指针
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;maxKeySize&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;128&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;maxElemSize&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;128&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 数据偏移量应该是bmap结构体的大小，它需要正确地对齐。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 对于amd64p32而言，这意味着：即使指针是32位的，也是64位对齐。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;dataOffset&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Offsetof&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bmap&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}{}.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;


    &lt;span class=&#34;c1&#34;&gt;// 每个桶（如果有溢出，则包含它的overflow的链接桶）在搬迁完成状态下，要么会包含它所有的键值对，要么一个都不包含（但不包括调用evacuate()方法阶段，该方法调用只会在对map发起write时发生，在该阶段其他goroutine是无法查看该map的）。简单的说，桶里的数据要么一起搬走，要么一个都还未搬。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 当tophash值小于minTopHash时，表示存的是迁移状态，大于minTopHash时，表示的是计算的值。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;emptyRest&lt;/span&gt;      &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 表示cell为空，并且之后的位置也为空，包括overflow，初始化bucket时，就是该状态
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;emptyOne&lt;/span&gt;       &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 表示当前是空的cell，但曾经有值，已经被搬迁到新的bucket
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;evacuatedX&lt;/span&gt;     &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 键值对已经搬迁完毕，key在新buckets数组的前半部分
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;evacuatedY&lt;/span&gt;     &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 键值对已经搬迁完毕，key在新buckets数组的后半部分
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;evacuatedEmpty&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// cell为空，整个bucket已经搬迁完毕
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;minTopHash&lt;/span&gt;     &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// tophash的最小正常值，如果计算出来的tophash小于该值，则加上它避免跟前面几个状态枚举冲突
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// flags
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;iterator&lt;/span&gt;     &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 可能有迭代器在使用buckets
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;oldIterator&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 可能有迭代器在使用oldbuckets
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;hashWriting&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 有协程正在向map写人key
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;sameSizeGrow&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 等量扩容
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 用于迭代器检查的bucket ID
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;noCheck&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PtrSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_map_struct.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_map_struct.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;go map 结构图&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;go map 结构图&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;注：一个bmap里key和value是各自存的，而key/value一对对存储，这样的好处是省掉padding字段，节省内存空间，方便内存对齐。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;例如，有这样一个类型的 map：&lt;code&gt;map[int64]int8&lt;/code&gt;，如果按照 &lt;code&gt;key/value...&lt;/code&gt; 这样的模式存储，那在每一个 key/value 对之后都要额外 padding 7 个字节；而将所有的 key，value 分别绑定到一起，这种形式 &lt;code&gt;key/key/.../value/value/...&lt;/code&gt;，则只需要在最后添加 padding，每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个 bucket ，通过 &lt;code&gt;overflow&lt;/code&gt; 指针连接起来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;基本-1&#34;&gt;基本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建：&lt;code&gt;m := map[string]int{&amp;quot;1&amp;quot;: 11, &amp;quot;2&amp;quot;: 22}&lt;/code&gt;或者 &lt;code&gt;m := make(map[string]int, 10)&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当使用字面量的方式创建哈希表时，如果{}中元素少于或等于25时，编译器会转成make的方式创建，再进行赋值；如果超过了25个，编译时会转成make的方式创建，同时为key和value分别创建两个数组，最后进行循环赋值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接声明 &lt;code&gt;var m map[string]int&lt;/code&gt;会创建了一个&lt;strong&gt;nil的map&lt;/strong&gt;，此时不能被赋值，但可以取值，虽然不会panic，但会得到零值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;key不允许为slice、map、func；允许bool、numeric、string、指针、channel、interface、struct及其类型对应的数组；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;即key必须支持 == 或 != 运算的类型，如果是结构体，则他们的所有字段都相等，才被认为是相同的key&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;另外，float比较特殊，因为float作为key时，会被转成unit64，再插入key中，可能会有精度问题，导致有时候查询不到，或者查询出来的key不一样；&lt;/p&gt;
&lt;p&gt;有个特殊的key值&lt;code&gt;math.NaN&lt;/code&gt;，它每次生成的哈希值是不一样的，这会造成m[&lt;code&gt;math.NaN&lt;/code&gt;]是拿不到值的，而且多次对它赋值，会让map中存在多个&lt;code&gt;math.NaN&lt;/code&gt;的key。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;map容量最多为 6.5 * 2^B 个元素，6.5是装载因子阈值常量，装载因子 = 哈希表中的元素 / 哈希表总长度，装载因子越大，冲突越多。B最大值是63。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拉链法解决哈希冲突（指8个正常位和溢出桶），除留余数法得到桶的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;key的哈希值的低B位计算获得桶的位置，高8位计算得到tophash的位置，进而找到key的位置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;溢出桶也是一个bmap，bmap的overflow会指向下一个溢出桶，所以&lt;strong&gt;溢出桶的结构是链表，但是它们跟正常桶是在一片连续内存上，都在buckets数组里，前2^B个当成正常桶，后2^(B-4)个当作溢出桶&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个桶存了8个tophash + 8对键值对。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;扩容判断发生在插入，扩容迁移发生在插入和删除&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;map是非线程安全的，扩容不是一个原子操作，通过hmap里的flags字段在并发读写时进行fast-fail。&lt;/p&gt;
&lt;p&gt;当 map 对象同时进行加锁的 write 和不加锁的read（比如打印，序列化等）时，会发生panic，因为相当于并发读写。&lt;/p&gt;
&lt;p&gt;当map出现并发读写时，不是抛出panic错误，而是fatal错误，fatal错误不可被recover，程序会直接退出；原因是当存在并发读写时，如果被recover了，会导致其他协程出现读取错误的情况。&lt;/p&gt;
&lt;p&gt;但在同一个协程里，边遍历边增删，并不会触发并发检测，但是可能会导致漏遍历；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;map的遍历是无序的，每次遍历出来的结果的顺序都不一样。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;无法直接对map的value直接取地址：&lt;code&gt;&amp;amp;m[&amp;quot;key&amp;quot;]&lt;/code&gt;会无法通过编译，虽然可以使用&lt;code&gt;unsafe.Pointer&lt;/code&gt;取地址，但是因为map会扩容，拿到的地址也不一定是之后的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;创建初始化&#34;&gt;创建初始化&lt;/h2&gt;
&lt;p&gt;通过&lt;code&gt;make(map[type]type)&lt;/code&gt;，或者&lt;code&gt;make(map[type]type, hint), hint &amp;lt;= 8&lt;/code&gt;创建的map，底层会调用&lt;code&gt;makemap_small函数&lt;/code&gt;，并直接从堆上进行分配，此时只分配内存空间，不初始化桶，懒加载，只有在第一次插入时才会初始化桶，此时B=0，桶的数量为1。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;makemap_small&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hmap&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hash0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fastrand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当hint &amp;gt; 8时，则会在运行时调用&lt;code&gt;makemap函数&lt;/code&gt;进行创建和初始化，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;计算哈希表占用的内存是否溢出或者超出能分配的最大值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用fastrand()获取随机哈希种子&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据hint来计算需要的桶的数量来计算B的值（hint是make的第二个参数），用于初始化桶的数量 = 2^B；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用&lt;code&gt;makeBucketArray()&lt;/code&gt;分配连续的空间，创建用于保存桶的数组&lt;/p&gt;
&lt;p&gt;当桶的数量小于2^4时，由于数据较少，哈希冲突的可能性较小，此时不会创建溢出桶。&lt;/p&gt;
&lt;p&gt;当桶的数量大于2^4时，就会额外创建2^(B-4)个溢出桶，溢出桶与普通桶在内存空间上是连续的，使用extra的nextOveflow来做溢出桶，预分配。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;makemap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;maptype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;hint&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hmap&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hash0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fastrand&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 函数内，计算桶的数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uint8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;//计算得到合适的B
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;overLoadFactor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hint&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 如果 B == 0时，就会懒加载
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;nextOverflow&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bmap&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buckets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;nextOverflow&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;makeBucketArray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;nextOverflow&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;extra&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mapextra&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;extra&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nextOverflow&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;nextOverflow&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;overLoadFactor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 常量loadFactorNum=13 ，loadFactorDen=2，bucketCnt=8，bucketShift()函数返回2^B
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bucketCnt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;loadFactorNum&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;bucketShift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;loadFactorDen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;makeBucketArray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;maptype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;dirtyalloc&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buckets&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;nextOverflow&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;base&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bucketShift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// base = 2 ^ B
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;nbuckets&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;base&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// B &amp;lt; 4时，即桶的数量小于16，认为哈希冲突几率较小，因此不会创建溢出桶
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// B &amp;gt;= 4时，创建2^(B-4)个溢出桶
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;nbuckets&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bucketShift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;sz&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;nbuckets&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;up&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;roundupsize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sz&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;up&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sz&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;nbuckets&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;up&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;dirtyalloc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 为null, 会分配一个新的底层数组
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;buckets&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;newarray&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nbuckets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 不为null，则它指向的是曾经分配过的底层数组，该底层数组是由之前同样的t和b参数通过makeBucketArray分配的，如果数组不为空，需要把该数组之前的数据清空并复用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;buckets&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;dirtyalloc&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;nbuckets&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ptrdata&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;memclrHasPointers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buckets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nf&#34;&gt;memclrNoHeapPointers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buckets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 如果多申请了桶，将多申请的桶放在nextOverflow里备用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;base&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;nbuckets&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 先计算出多申请出来的内存地址 nextOverflow
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;nextOverflow&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buckets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;base&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucketsize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 计算出申请的最后一块bucket的地址
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;last&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buckets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nbuckets&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucketsize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 将最后一个bucket桶的位置指向non-nil值，这样在获取溢出桶时，可以通过nextOverflow指针判断自己是否是最后一个溢出桶，nil说明还有桶，non-nil说明是最后一个桶
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;last&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;setoverflow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buckets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;buckets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;nextOverflow&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;查找与插入&#34;&gt;查找与插入&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;v := m[key]&lt;/code&gt;使用函数&lt;code&gt;mapaccess1()&lt;/code&gt;进行查找， &lt;code&gt;v, ok := m[key]&lt;/code&gt;使用函数&lt;code&gt;mapaccess2()&lt;/code&gt;进行查找&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mapaccess2()&lt;/code&gt;也会调用&lt;code&gt;mapaccess1()&lt;/code&gt;，只是返回的时候会返回多一个用于表示当前键值对是否存在的布尔值。&lt;/p&gt;
&lt;h3 id=&#34;key的定位&#34;&gt;key的定位&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;找buckets数组中的bucket的位置：key经过哈希计算得到哈希值，取出hmap的B值，取哈希值的后B位个bit位，计算后面的B位的值得到桶的位置（实际上这一步就是除留余数法的取余操作）。&lt;/p&gt;
&lt;p&gt;比如：一个key经过哈希计算之后，得到的结果是：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;10010111 | 000011110110110010001111001010100010010110010101010 │ 00110&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;长度为64位，B等于5，取后5位，即拿到00110，值为6，也就是6号桶，buckets[6]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;确定使用buckets数组还是oldbuckets数组：判断oldbuckets数组中是否为空，不为空说明正处于扩容中，还没完成迁移，则重新计算桶的位置，并在oldbuckets数组找到对应的桶；如果为空，则在buckets数组中找到对应的桶。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在桶中找tophash的位置：用key哈希计算得到的哈希值，取高8个bit位 + minTopshash(小于minTopshash值时才需要加)，计算得到此bucket桶中的tophash，即key在桶中的编号，之后在桶中的正常位遍历比较。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个桶是一整片连续的内存空间，先遍历bucket桶中的正常位，与桶中的tophash进行比较，当找到对应的tophash时，根据tophash进行计算得到key，根据key的大小计算得到value的地址，找到value。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果bucket桶中的正常位没找到tophash，且overflow不为空，则继续遍历溢出桶overflow bucket，直到找到对应的tophash，再根据key的大小计算得到value的地址，找到value。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 计算得到bucket桶在buckets数组中的位置
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucket&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;hash&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;bucketMask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;buckets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bucket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucketsize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 计算得到tophash，miniTopHash用于表示迁移进度，当tophash值小于minTopHash时，表示存的是迁移状态，大于minTopHash时，表示的是计算的哈希值，因此根据hash计算出的结果需要加上minTopHash才表示真正的值。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;tophash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hash&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint8&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;top&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uint8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hash&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PtrSize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;top&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;minTopHash&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;top&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;minTopHash&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;top&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 计算key和value，dataoffset是tophash[8]所占用的大小，所以key的地址就是：bmap的地址 + dataOffset的偏移 + 对应的索引i * key的大小；
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 而value是在所有key之后的，第i个value的递增在加上所有key的偏移即可得出。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;dataOffset&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;keysize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;dataOffset&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucketCnt&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;keysize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;valuesize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_map_get.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_map_get.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;go map 结构图&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;go map 结构图&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;插入&#34;&gt;插入&lt;/h3&gt;
&lt;p&gt;插入也需要先定位到key的位置后才能进行插入，定位key的操作跟上面是类似的，调用mapassign函数，mapassign入参不用传value，而是通过方法返回key对应的value的指针来进行赋值。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先判断hmap是否为空，是否是并发写入，如果是直接抛错误；修改当前hamp的状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据key计算出哈希；还有就是判断bucket桶是否为空，为空则分配bmap数组，。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;判断 hmap的oldbuckets是否为空，不为空说明当前处于扩容搬迁，则进行搬迁工作（一次最多迁移两个bucket桶），完了再进行之后的流程。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据key的哈希值的低B个bit位，计算得到桶的位置；根据key的哈希值的高8个bit位，计算出tophash。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先遍历正常位，从第一个cell开始，比较桶上的每个tophash是否等于计算得到的tophash，如果不等，再判断该tophash是否为空，如果为空，计算key和value的内存地址，进行插入。如果不为空，则遍历下一个cell进行tophash的判断。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下一个cell上的tophash与计算的tophash相等，说明发生了哈希冲突，先计算key的地址，找到key，判断key是否相等，如果相等，计算key对应的value地址，将value的值进行更新。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果key不相等，遍历下一个cell的tophash，直到正常位遍历完成，如果此时还不能插入，继续遍历溢出桶，如果溢出桶为空，退出循环。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在已有桶和溢出桶都未找到合适的cell插入时，会有两种情况进行判断：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;判断当前map的装载因子是否达到默认的6.5，或者当前map的溢出桶数量是否过多，如果是这两种情况之一，则进行扩容，扩容 + 迁移后，继续步骤5上的逻辑（使用了goto关键字）。如果不满足扩容条件，则进行下一种情况的判断&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;此时key还没插入，且正常位已满，还不需要扩容，此时会调用&lt;code&gt;newoverflow()函数&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;newoverflow()函数&lt;/code&gt;使用hmap在&lt;code&gt;extra.nextOverflow&lt;/code&gt;中创建好的桶，如果有，遍历这个创建好的桶链表，直到可以放入新的键值对；如果没有，则创建一个桶，增加noverflow计数，将新键值对放入这个桶中，然后将新桶挂载到当前桶overflow字段，成为溢出桶。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;newoverflow()函数&lt;/code&gt;会在一开始判断hmap的&lt;code&gt;extra.nextOverflow&lt;/code&gt;是否为空，如果为空会先预分配，不为空则直接将其设置为当前要使用的溢出桶，并把原来的nextOverflow设置为空，目的是充分利用已分配的内存，减少分配次数。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Nixum/Java-Note/raw/master/source_with_note/go_map_mapassign.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mapassign函数&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;mapassign&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;maptype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Pointer&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// ... 一些例行检查，如判空、竞态检查、内存探测、并发读写检查，设置当前hmap的状态flags
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;asign&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    	&lt;span class=&#34;c1&#34;&gt;// 先判断当前是否处于扩容时的搬迁，即h.oldbuckets不为空，先进行搬迁工作
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 完了之后，计算出桶的位置，拿到对应的桶；计算tophash
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;bucketloop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    	&lt;span class=&#34;c1&#34;&gt;// 遍历桶，找到适合插入的位置
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;done&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
    	&lt;span class=&#34;c1&#34;&gt;// ... 竞态检查，并发读写检查
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Nixum/Java-Note/raw/master/source_with_note/go_map_newoverflow.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;newoverflow函数&lt;/a&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// bmap的overflow(t)方法是返回当前桶的overflow桶的地址
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// bmap的setoverflow方法是为bmap的overflow桶赋值下一个桶的地址
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// hmap的incrnoverflow()方法是增加hmap的noverflow值，表示溢出桶的数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// hmap的createOverflow()方法是为hmap的extra.overflow创建新桶
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;newoverflow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;maptype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bmap&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ovf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bmap&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;extra&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;extra&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nextOverflow&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;ovf&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;extra&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nextOverflow&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 如果hmap的extra.nextOverflow桶的没有溢出桶，则进行初始化
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ovf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;overflow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;extra&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nextOverflow&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unsafe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pointer&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ovf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucketsize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)))&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;c1&#34;&gt;// 预分配当前桶的溢出桶
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nx&#34;&gt;ovf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;setoverflow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;extra&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nextOverflow&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;ovf&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;newobject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;incrnoverflow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucket&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ptrdata&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;createOverflow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;extra&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;overflow&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;extra&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;overflow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ovf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;setoverflow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ovf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ovf&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;扩容-1&#34;&gt;扩容&lt;/h2&gt;
&lt;h3 id=&#34;扩容条件&#34;&gt;扩容条件&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;!h.growing() &amp;amp;&amp;amp; (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B))&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;即 在没有正在进行扩容 的情况下，负载因子 &amp;gt; 6.5 或 溢出桶的数量 &amp;gt;= buckets数组的数量&lt;/p&gt;
&lt;p&gt;扩容条件的判断发生在&lt;code&gt;mapassign函数&lt;/code&gt;，即对map使用put的时候。&lt;/p&gt;
&lt;h3 id=&#34;扩容策略-1&#34;&gt;扩容策略&lt;/h3&gt;
&lt;h4 id=&#34;增量扩容---降低哈希冲突&#34;&gt;增量扩容 - 降低哈希冲突&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;overLoadFactor函数&lt;/code&gt;，该函数返回true，表示哈希表内的元素过多，哈希冲突的概率变大，可能在找到桶，遍历完桶内的元素，还要继续遍历溢出桶链表，此时需要**增量扩容，扩容为原来的两倍 **，降低哈希冲突的概率。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// count是key的数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;overLoadFactor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// loadFactorNum = 13, loadFactorDen = 2, 即count &amp;gt; 8 &amp;amp;&amp;amp; count / (2^B) &amp;gt; 6.5
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bucketCnt&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;loadFactorNum&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;bucketShift&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;loadFactorDen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;等量扩容---提高桶的利用率防止内存泄漏加快查询效率&#34;&gt;等量扩容 - 提高桶的利用率，防止内存泄漏，加快查询效率&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;tooManyOverflowBuckets函数&lt;/code&gt;，该函数返回true，表示由于某一个桶满后，开始使用溢出桶，不断的插入数据到溢出桶，又不断的删除正常桶上的正常位，但此时哈希表的数量又没超阈值，但是空桶太多，溢出桶的数量太多，而每次查找又得先遍历正常位，查找效率变低，此时需要&lt;strong&gt;等量扩容，容量不变，重新迁移键值对&lt;/strong&gt;。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;tooManyOverflowBuckets&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;noverflow&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 如果负载因子太低, 不操作。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果负载因子太高，maps的扩容和缩容会使用大量未使用的内存
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 太多指的是溢出桶的数量 大于等于 buckets数组的数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// The compiler doesn&amp;#39;t see here that B &amp;lt; 16; mask B to generate shorter shift code.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;noverflow&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uint16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;触发扩容&#34;&gt;触发扩容&lt;/h3&gt;
&lt;p&gt;触发扩容条件时，会执行&lt;code&gt;hashGrow函数&lt;/code&gt;，&lt;strong&gt;进行新桶的分配，但还未迁移数据&lt;/strong&gt;，真正迁移数据在&lt;code&gt;growWork函数&lt;/code&gt;中。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先会判断是增量扩容还是等量扩容，如果是增量扩容，B + 1，即扩容到原来的两倍，如果是等量扩容，B + 0，容量不变&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将当前buckets数组挂在hmap的oldbuckets字段，当前extra里的溢出桶挂在&lt;code&gt;hmap.extra.oldoverflow&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建新的buckets数组，容量为新的B值，预创建溢出桶（溢出桶的数量看上面创建初始化逻辑），然后将新的buckets数组挂在buckets字段，新的溢出桶挂在&lt;code&gt;hmap.mapextra.nextOverflow&lt;/code&gt;字段上&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;触发扩容条件，对新桶进行内存分配，只是创建了新的桶，旧数据还在旧桶上，之后还需要完成数据迁移。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Nixum/Java-Note/raw/master/source_with_note/go_map_hashGrow.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;hashGrow函数&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;扩容迁移&#34;&gt;扩容迁移&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;扩容迁移发生在 mapassign 和 mapdelete 函数中，即进行插入、修改、删除时&lt;/strong&gt;，才会调用&lt;code&gt;growWork函数&lt;/code&gt;和&lt;code&gt;evacuate函数&lt;/code&gt;，完成真正的迁移工作后，才会进行插入、修改或删除。&lt;/p&gt;
&lt;p&gt;迁移时是渐进式迁移，一次最多迁移两个bucket桶。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在插入、修改或删除中，如果发现oldbuckets数组不为空，表示此时正在扩容中，需要进行扩容迁移，调用&lt;code&gt;growWork函数&lt;/code&gt;，&lt;code&gt;growWork函数&lt;/code&gt;调用一次&lt;code&gt;evacuate函数&lt;/code&gt;，如果调用完成后，hmap的oldbuckets还是非空，则再调用一次&lt;code&gt;evacuate函数&lt;/code&gt;，加快迁移进程。&lt;/li&gt;
&lt;/ol&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;growWork&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;maptype&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hmap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bucket&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uintptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 确认搬迁老的 bucket 对应正在使用的 如果当前key映射到老的bucket1，那就搬迁该bucket1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nf&#34;&gt;evacuate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bucket&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;oldbucketmask&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 再搬迁一个 bucket，以加快搬迁进程
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;growing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nf&#34;&gt;evacuate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nevacuate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start=&#34;2&#34;&gt;
&lt;li&gt;进入&lt;code&gt;evacuate函数&lt;/code&gt;：&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果是&lt;strong&gt;等量扩容&lt;/strong&gt;，B值不变，老bucket桶上的键值计算出来的桶的序号不变，tophash不变，此时会将老桶上的键值对依次地一个个转移到新桶上，使这些键值对在新桶上排列更加紧凑；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是&lt;strong&gt;增量扩容&lt;/strong&gt;，容量变为原来的两倍，B值+1，老bucket桶上的键值计算出来的桶的序号改变，这些键值对计算后的bucket桶的序号可能跟之前一样，也可能是相比原来加上2^B，取决于key哈希值后 老B+1 位的值是0还是1。比如：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;10010111 | 000011110110110010001111001010100010010110010101010 │ 01010&lt;/code&gt;，B=5，bucket的序号是10，增量扩容后为&lt;/p&gt;
&lt;p&gt;&lt;code&gt;10010111 | 00001111011011001000111100101010001001011001010101 | 001010&lt;/code&gt;，B=6，bucket的序号还是10，&lt;/p&gt;
&lt;p&gt;另一种情况是&lt;/p&gt;
&lt;p&gt;&lt;code&gt;10010111 | 000011110110110010001111001010100010010110010101011 │ 01010&lt;/code&gt;，B=5，bucket的序号是10，增量扩容后为&lt;/p&gt;
&lt;p&gt;&lt;code&gt;10010111 | 00001111011011001000111100101010001001011001010101 │ 101010&lt;/code&gt;，B=6，bucket的序号是42（10 + 32，即10 + 2 ^5）&lt;/p&gt;
&lt;p&gt;tophash不变，原来老bucket桶上的键值对会重新分流到两个新bucket桶上。将老bucket桶上的键值对和其指向的溢出桶上的键值对进行迁移，依次转移到新桶上，每迁移完一个，key在老buckect的tophash设置为evacuatedX或者evacuatedY（tophash的最低位表示迁移到新桶的哪一part，0为x，1为y），hmap的nevacuate计数+1，直到老bucket桶上的键值对迁移完成，最后清空oldbuckets和oldoverflow字段。&lt;/p&gt;
&lt;p&gt;这里两个新的桶对应源码里的X part, Y part，因为扩容到原来的 2 倍，桶的数量是原来的 2 倍，前一半桶被称为 X part，后一半桶被称为 Y part。一个 bucket 中的所有key 可能会分流到 2 个桶中，一个位于 X part，一个位于 Y part。所以在搬迁一个 cell 之前，需要计算这个cell要落入到哪一part。&lt;/p&gt;
&lt;p&gt;X part 与 Y part的关系：X part + 2 ^ 老B = Y part，之所以要确定key落在哪个区间，是为了方便计算key要插入的内存地址。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;扩容前，B = 2，共有 4 个 buckets，lowbits 表示 hash 值的低位。假设我们不关注其他 buckets 情况，专注在 2 号 bucket。并且假设 overflow 太多，触发了等量扩容。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e6%89%a9%e5%ae%b9.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e6%89%a9%e5%ae%b9.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;go map 触发扩容&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;go map 触发扩容&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;扩容完成后，overflow bucket 消失了，key 都集中到了一个 bucket，更为紧凑了，提高了查找的效率。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e7%ad%89%e9%87%8f%e6%89%a9%e5%ae%b9.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e7%ad%89%e9%87%8f%e6%89%a9%e5%ae%b9.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;go map 等量扩容&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;go map 等量扩容&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;假设触发了 2 倍的扩容，那么扩容完成后，老 buckets 中的 key 分裂到了 2 个 新的 bucket。一个在 x part，一个在 y 的 part。依据是 hash 的 lowbits。新 map 中 &lt;code&gt;0-3&lt;/code&gt; 称为 x part，&lt;code&gt;4-7&lt;/code&gt; 称为 y part。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e5%a2%9e%e9%87%8f%e6%89%a9%e5%ae%b9.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e5%a2%9e%e9%87%8f%e6%89%a9%e5%ae%b9.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;go map 增量扩容&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;go map 增量扩容&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Nixum/Java-Note/raw/master/source_with_note/go_map_evacuate.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;evacuate函数&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;删除&#34;&gt;删除&lt;/h2&gt;
&lt;p&gt;调用delete函数，无论要删除的key是否存在，delete都不会返回任何结果。删除实际上也是一个key的定位 + 删除的操作，定位到key后，将其键值对置空，hmap的count - 1，tophash置为empty。&lt;strong&gt;删除过程也会检查是否处于扩容状态，如果是，则会触发搬迁&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&#34;遍历&#34;&gt;遍历&lt;/h2&gt;
&lt;p&gt;对go中的map是无序的，每次遍历出来的顺序都是不一样的，go在每次遍历map时，并不是固定地从0号bucket桶开始遍历，每次都是从一个随机值序号的bucket桶开始遍历，并且是从这个bucket桶的一个随机序号的 正常位开始遍历。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;首先从buckets数组中，随机确定一个索引，作为startBucket，然后确定offset偏移量，得到桶中的正常位的位置，作为起始key的地址。&lt;/li&gt;
&lt;li&gt;遍历当前bucket及bucket.overflow，判断当前bucket是否正在扩容中，如果是则跳转到3，否则跳转到4。&lt;/li&gt;
&lt;li&gt;如果是在扩容中，遍历时会先到当前bucket扩容前的老的bucket桶中遍历那些能迁移到当前桶的key。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假如原先的buckets为0，1，那么扩容后的新的buckets为0，1，2，3，此时我们遍历到了buckets[0]， 发现这个bucket正在扩容，那么找到bucket[0]所对应的oldbuckets[0]，遍历里面的key，这时候仅仅遍历那些key经过hash后，可以散列到bucket[0]里面的部分key；同理，当遍历到bucket[2]的时候，发现bucket正在扩容，找到oldbuckets[0]，然后遍历里面可以散列到bucket[2]的那些key。&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;遍历当前这个bucket即可。&lt;/li&gt;
&lt;li&gt;继续遍历bucket下面的overflow链表。&lt;/li&gt;
&lt;li&gt;如果遍历到了startBucket，说明遍历完了，结束遍历。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;假设我们有下图所示的一个 map，起始时 B = 1，有两个 bucket，后来触发了扩容（这里不要深究扩容条件，只是一个设定），B 变成 2。并且， 1 号 bucket 中的内容搬迁到了新的 bucket，&lt;code&gt;1 号&lt;/code&gt;裂变成 &lt;code&gt;1 号&lt;/code&gt;和 &lt;code&gt;3 号&lt;/code&gt;；&lt;code&gt;0 号&lt;/code&gt; bucket 暂未搬迁。老的 bucket 挂在在 &lt;code&gt;*oldbuckets&lt;/code&gt; 指针上面，新的 bucket 则挂在 &lt;code&gt;*buckets&lt;/code&gt; 指针上面。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e9%81%8d%e5%8e%861.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e9%81%8d%e5%8e%861.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这时，我们对此 map 进行遍历。假设经过初始化后，startBucket = 3，offset = 2。于是，遍历的起点将是 3 号 bucket 的 2 号 cell，下面这张图就是开始遍历时的状态：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e9%81%8d%e5%8e%862.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e9%81%8d%e5%8e%862.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;标红的表示起始位置，bucket 遍历顺序为：3 -&amp;gt; 0 -&amp;gt; 1 -&amp;gt; 2，遍历到0号桶时，虽然0号桶此时还没搬迁，但只会遍历0号桶搬迁过后仍然在0号桶的key，即遍历时如果遇到正在扩容，会按照将来扩容完成后新bucket的顺序进行遍历&lt;/p&gt;
&lt;p&gt;最终遍历的顺序为:&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e9%81%8d%e5%8e%863.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e9%81%8d%e5%8e%863.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/1859042&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;从 map 的 extra 字段谈起&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://learnku.com/docs/the-way-to-go/chapter-description/3611&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go入门指南&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/61121325&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入理解Slice底层实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go 语言设计与实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://studygolang.com/articles/27421&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Golang源码-Map实现原理分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000020616487&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Go map原理剖析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000023879178&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;年度最佳【golangmap】详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://juejin.cn/post/7079964047893856293&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;逐行拆解 Go map 源码&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/74613114&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深度解密Go语言之channel&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Gin框架原理</title>
        <link>http://nixum.cc/p/gin%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/</link>
        <pubDate>Mon, 22 Mar 2021 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/gin%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;标准库nethttp&#34;&gt;标准库net/http&lt;/h1&gt;
&lt;p&gt;demo:&lt;/p&gt;
&lt;p&gt;定义了一个路由 &lt;code&gt;/hello&lt;/code&gt;，绑定了一个handler，输出当前path，ListenAndServe方法启动web服务，第一个参数表示监听的端口，第二个参数代表 处理所有的HTTP请求 的实例，等于nil时会使用默认的&lt;code&gt;DefaultServeMux&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;该demo是基于标准库实现的Web框架入口。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;HandleFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/hello&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;URL.Path = %q\n&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;URL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;:8080&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// http.ListenAndServe()方法第二个参数的实现：
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Handler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nf&#34;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 注册handler默认使用DefaultServeMux，与ListenAndServe第二个参数使用的处理器一致。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 将path和对应的handler方法保存在DefaultServeMux的map中，等请求进来进行匹配处理。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;HandleFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pattern&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;DefaultServeMux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;HandleFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pattern&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;&lt;code&gt;http.ListenAndServe&lt;/code&gt;是整个web的总流程，本质上还是走socket那一套，bind -》 listen -》 accept -》 read、write -》 close。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;  1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 95
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 96
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 97
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 98
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 99
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;100
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;101
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;102
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;103
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;104
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;105
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;106
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;107
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;108
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;109
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;110
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;111
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;112
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;113
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;114
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;115
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;116
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;117
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;118
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;119
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;120
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;121
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;122
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;123
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;124
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;125
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;126
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;127
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;128
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;129
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;130
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;131
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;132
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;133
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;134
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;135
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;136
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;137
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;138
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;139
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;140
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;addr&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handler&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;server&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;srv&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;ln&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Listen&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;tcp&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;srv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Serve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ln&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;srv&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Serve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Listener&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 将listener封装进server
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WithValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;baseCtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ServerContextKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;srv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 无限循环，accept接收客户端的请求
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;l&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Accept&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;-&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;srv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;getDoneChan&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;():&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ErrServerClosed&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ne&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ne&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Temporary&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 设置默认超时时间
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;				&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tempDelay&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;continue&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 封装accept到的连接，起一个goroutine来处理这个连接，之后继续等待accept的返回
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;connCtx&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;srv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ConnContext&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;connCtx&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;cc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;connCtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
			&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;tempDelay&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;srv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;newConn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rw&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;setState&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rwc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;StateNew&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// before Serve can return
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 每次有连接进来都会起一个协程来处理
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;serve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;connCtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;serve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ctx&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
 	&lt;span class=&#34;c1&#34;&gt;// 处理连接、tls处理之类的，从连接中读取数据，封装成request、response，交给serverHandler处理
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;requestBodyRemains&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nf&#34;&gt;registerOnHitEOF&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;startBackgroundRead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 该方法会起一个新协程在后台读取连接，就靠它来实现请求还没处理完就能进行取消的功能
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// 实际上，取消后，只是连接被中断了，业务代码该执行还是在执行，执行完才能收到cancel信号
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;startBackgroundRead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 默认的serverHandler.ServeHTTP方法会进行判断:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果handler为空就会使用默认的DefaultServeMux，否则就用用户定义的ServeHTTP来处理请求
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;serverHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 请求结束之后cancel掉context
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;cancelCtx&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 处理连接时，处理会把连接交给serverHandler，还会起一个协程监控连接的状态
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;connReader&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;startBackgroundRead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;cr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;cr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;inRead&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;cr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rwc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;SetReadDeadline&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;backgroundRead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 如果连接有问题，就会cancel掉
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;connReader&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;backgroundRead&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;conn&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rwc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Read&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;byteBuf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[:])&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;cr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;cr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hasByte&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 如果连接超时了，就会收到EOF的错误
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ne&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;aborted&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ne&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Timeout&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 出错时就会触发cancel，从而结束掉请求
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;cr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;handleReadError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// handleReadError方法内就是下面这两句
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;c1&#34;&gt;// cr.conn.cancelCtx()
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	    &lt;span class=&#34;c1&#34;&gt;// cr.closeNotify()
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;cr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;aborted&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;cr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;inRead&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;cr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;cr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cond&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Broadcast&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// DefaultServeMux的ServeHTTP方法，对请求进行路由匹配，用的就是http.HandleFunc里的map
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 根据path找到对应的handler，执行
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mux&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ServeMux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RequestURI&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;*&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ProtoAtLeast&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Header&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Set&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Connection&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;close&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WriteHeader&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;StatusBadRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 获取注册的路由handler
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;r&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 路由handler的逻辑非常简单，就是直接根据path在map里匹配找到处理的handler
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mux&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ServeMux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;host&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pattern&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;RLock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;RUnlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;hosts&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pattern&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;host&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pattern&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pattern&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NotFoundHandler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 只是做简单的路由匹配
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;mux&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ServeMux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pattern&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pattern&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mux&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;es&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;HasPrefix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;path&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pattern&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pattern&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;gin对nethttp的封装&#34;&gt;Gin对net/http的封装&lt;/h1&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// http.ListenAndServe()方法第二个参数的实现：
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Handler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nf&#34;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Gin做的，就是实现这个Handler接口，掌管所有HTTP请求，提供丰富的能力：如路由分发、请求上下文的复用、中间件调用链等功能。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;github.com/gin-gonic/gin&amp;#34;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;handlePing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;JSON&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;200&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;H&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;s&#34;&gt;&amp;#34;message&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;pong&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
   &lt;span class=&#34;p&#34;&gt;})&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// gin.Default还会默认包含两个中间件Logger和Recovery，还有对404、405处理的handler
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;routerEngine&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Default&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 三种注册路由的方式
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;routerEngine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;GET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/ping&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handlePing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;routerEngine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Handle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;MethodGet&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;/ping2&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handlePing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 分组
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;v1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;routerEngine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/v1&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;GET&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;/ping3&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handlePing&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// run的底层仍然是http.ListenAndServe
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;routerEngine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Run&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 默认监听 0.0.0.0:8080
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// -----
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 也可以用下面这种方法启动，本质还是调用gin.Default()的ServeHTTP方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;server&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    	&lt;span class=&#34;nx&#34;&gt;Addr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;    &lt;span class=&#34;s&#34;&gt;&amp;#34;:8080&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;Handler&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;routerEngine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;log&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fatal&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;ListenAndServe&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;())&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;so，本质上也可以说gin是一个http router，主要看gin.Default()方法返回的engin，由gin的engin来进行请求封装、路由匹配、转发到对应的handler处理。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;engine&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ServeHTTP&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ResponseWriter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// gin.Context对象复用池
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 重置gin.context对象
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;writermem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;reset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;w&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;req&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;reset&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 交给engine处理请求，进入路由树匹配
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;handleHTTPRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 处理完成把context放回复用池
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Put&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;路由&#34;&gt;路由&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;在 Gin 框架中，路由规则被分成了最多 9 棵前缀树，每一个 HTTP Method对应一棵「前缀树」，树的节点按照 URL 中的 / 符号进行层级划分，URL 支持 :name 形式的名称匹配，还支持&lt;code&gt; *subpath&lt;/code&gt; 形式的路径通配符。&lt;/p&gt;
&lt;p&gt;每个节点都会挂一系列的handler组成的处理链来处理匹配到的请求。&lt;/p&gt;
&lt;p&gt;之所以要使用前缀树，是为了支持如&lt;code&gt;/hello/:name&lt;/code&gt;这种动态路由，路径上的每一段&lt;code&gt;/{名字}&lt;/code&gt;作为前缀树的一个节点，通过树结构查询，如果中间某一层节点不匹配，则直接结束查询。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;81
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// engine与Route人Group相互持有的目的是为了实现分组路由时，注册到同一棵路由前缀树
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 并且可以使得中间件既可以注册在全路径上，也可以注册在分组上
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Engine&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;RouterGroup&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;RouterGroup&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;engine&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Engine&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;...&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 上面那三种路由注册方式，最终调用的还是RouterGroup的handle方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 由这个方法生成前缀树
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;group&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RouterGroup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;handle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;httpMethod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;relativePath&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;HandlersChain&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;IRoutes&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 解析路径
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;absolutePath&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;calculateAbsolutePath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;relativePath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 组装成handlers chain
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;combineHandlers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 构建路由前缀树
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;addRoute&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;httpMethod&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;absolutePath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;returnObj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 当收到客户端请求时，在前缀树种找到对应的路由handler，处理请求
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;engine&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;handleHTTPRequest&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;httpMethod&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Method&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;rPath&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;URL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Path&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;unescape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;UseRawPath&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;URL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RawPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;rPath&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Request&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;URL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RawPath&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;unescape&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;UnescapePathValues&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;rPath&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;cleanPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

	&lt;span class=&#34;c1&#34;&gt;// 遍历所有http method树，找到对应http method的前缀树，进行路由前缀匹配，找到对应的handler
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;trees&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tl&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tl&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;httpMethod&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;continue&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;root&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;root&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;// 获取对应的handler
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;getValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Params&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unescape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Params&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;params&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fullPath&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fullPath&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 执行handler方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;			&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;writermem&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;WriteHeaderNow&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;httpMethod&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;CONNECT&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;rPath&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;/&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tsr&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RedirectTrailingSlash&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nf&#34;&gt;redirectTrailingSlash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RedirectFixedPath&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;redirectFixedPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RedirectFixedPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 找不到http method对应的前缀树，使用默认的405Handler
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;HandleMethodNotAllowed&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tree&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;trees&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;method&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;httpMethod&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;continue&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tree&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;root&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;getValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rPath&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;unescape&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;allNoMethod&lt;/span&gt;
				&lt;span class=&#34;nf&#34;&gt;serveError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;StatusMethodNotAllowed&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;default405Body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 即找不到http method对应的前缀树或path，使用默认的404handler
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;engine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;allNoRoute&lt;/span&gt;
	&lt;span class=&#34;nf&#34;&gt;serveError&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;http&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;StatusNotFound&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;default404Body&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;中间件&#34;&gt;中间件&lt;/h1&gt;
&lt;p&gt;gin的中间件指的是handler方法，所有的中间件包括请求处理的handler都要满足这种方法签名:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;HandlerFunc&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;跟着路由一起注册后，调用&lt;code&gt;RouterGroup&lt;/code&gt;的&lt;code&gt;combineHandlers&lt;/code&gt;方法，将这些handler组成一个&lt;code&gt;HandlersChain&lt;/code&gt;，本质上是&lt;code&gt;[]HandlerFunc&lt;/code&gt;，当请求进来时，通过路径找到对应的&lt;code&gt;HandlersChain&lt;/code&gt;，注入到context中，调用Next方法处理请求。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 执行HandlersChain
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Context&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;int8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;handlers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;](&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;在gin中，context的&lt;code&gt;Next方法&lt;/code&gt;是会增加&lt;code&gt;HandlersChain&lt;/code&gt;索引值，执行下一个方法，而&lt;code&gt;Abort方法&lt;/code&gt;是直接更新&lt;code&gt;HandlersChain&lt;/code&gt;索引值到一个比较大的数字，使得循环调用结束， Abort() 方法并不是通过 panic 的方式中断执行流，执行 Abort() 方法之后，当前函数内后面的代码逻辑还会继续执行。&lt;/p&gt;
&lt;p&gt;gin就是通过context的Next方法和Abort方法，使得执行&lt;code&gt;HandlersChain&lt;/code&gt;方法时可以嵌套执行：先从前往后顺序执行&lt;code&gt;HandlersChain&lt;/code&gt;中在Next方法前的逻辑，直到最后一个，然后再从后往前执行Next方法后的逻辑。&lt;/p&gt;
&lt;h1 id=&#34;gincontext&#34;&gt;gin.Context&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;主要是包装请求&lt;code&gt;*http.Request&lt;/code&gt;、响应&lt;code&gt;http.ResponseWriter&lt;/code&gt;，让用户无需知道太多细节，比如消息头、消息体、状态码，消息类型等，直接提供现成包装好的方法比如&lt;code&gt;context.Json()&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;Context 会随着每一个请求的出现而产生，请求的结束而销毁，和当前请求强相关的信息都应由 Context 承载，比如动态路由&lt;code&gt;/hello/:name&lt;/code&gt;中的name参数；&lt;/li&gt;
&lt;li&gt;为处理请求的handler方法提供统一的入参，使得context可以持有处理请求的一系列handler方法，实现中间件处理逻辑；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://geektutu.com/post/gee.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;极客兔兔 - Web框架 - Gee&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/1404356&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;轻量级 Web 框架 Gin 结构分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/1877653?from=article.detail.1885821&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gun源码阅读&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>MySQL</title>
        <link>http://nixum.cc/p/mysql/</link>
        <pubDate>Thu, 09 Jul 2020 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/mysql/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;基础架构&#34;&gt;基础架构&lt;/h1&gt;
&lt;h2 id=&#34;mysql逻辑架构图&#34;&gt;MySQL逻辑架构图&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/MySQL%e9%80%bb%e8%be%91%e7%bb%93%e6%9e%84%e5%9b%be.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/MySQL%e9%80%bb%e8%be%91%e7%bb%93%e6%9e%84%e5%9b%be.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;连接器：负责跟客户端建立连接、获取权限、维持和管理连接。登录进去后修改权限，默认是将在下一次登录后生效&lt;/li&gt;
&lt;li&gt;查询缓存：MySQL接收到查询请求后会先查询缓存，key是查询语句，value是查询结果，之后经过执行器的权限判断再返回，如果查不到则往后走。不建议使用，因为若有更新操作，会删除对应表的缓存，可能导致缓存命中低，可以设置&lt;code&gt;query_cache_type=demand&lt;/code&gt;，默认不使用缓存，需要在查询时显示指定。MySQL8.0删除此功能&lt;/li&gt;
&lt;li&gt;分析器：对SQL语句进行分析，词法分析判断各个字符串代表的含义（包括列是否存在），语法分析判断SQL的语法是否正确，这一层操作之后，MySQL就知道你要做什么了&lt;/li&gt;
&lt;li&gt;优化器：决定是否要使用索引，使用哪个索引，决定表的连接顺序&lt;/li&gt;
&lt;li&gt;执行器：先判断是否有对该表的操作权限，之后判断要使用哪个引擎提供的接口&lt;/li&gt;
&lt;li&gt;引擎：对数据进行具体操作的执行者，事务和索引都是在这层做的，但具体需要引擎支持，例如MyISAM不支持事务，InnoDB支持&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;日志系统&#34;&gt;日志系统&lt;/h2&gt;
&lt;p&gt;关于物理日志和逻辑日志：物理日志记录每一个page具体存储的值，在这个数据页上做了什么修改，比如redo log；而逻辑日志记录每一个page中数据的变动过程，比如undo log、bin log、relay log；&lt;/p&gt;
&lt;p&gt;比如一个page页中一个数据从 1 改到 2 ，再改到 3，物理日志记录最后一个值是 3 ，逻辑日志记录 1 -&amp;gt; 2, 2-&amp;gt;3 的过程。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;undo log回滚日志&lt;/strong&gt;：InnoDB独有，逻辑日志，&lt;strong&gt;主要用于事务失败时的回滚，以及MVCC中的版本数据查看&lt;/strong&gt;。当事务被提交后，并不会马上被删除，而是放到待清理链中，等到没有事务用到该版本信息时才可以清理。&lt;/p&gt;
&lt;p&gt;undo log和数据页的刷盘策略是一样的，都需要通过redo log保证持久化，Buffer Pool中也有undo 页，对undo页的修改会记录到redo log中，跟着redo log刷盘一起刷盘；&lt;/p&gt;
&lt;p&gt;同时，如果在内存中修改undo页，需要更新记录对应的redo log。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;redo log重做日志&lt;/strong&gt;：InnoDB独有，物理日志，&lt;strong&gt;记录这个页做了什么改动&lt;/strong&gt;，本质上记录了对某个表空间的某个数据页的某个偏移量修改了哪几个字节的值，具体修改的值是什么，一条redo log也就几个字节到十几个字节，格式是 &lt;code&gt;日志类型，表空间ID，数据页号，数据页偏移量，具体修改的数据&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;二阶段提交&lt;/strong&gt;保证两份日志逻辑一致。当有日志要写入时，先写到redo log buffer后状态是prepare，开始写bin log cache，bin log 写完后，事务提交，redo log 改为commit状态，redo log写完，此时事务就算完成；这里描述的写redo log和bin log都只写在了缓冲区，何时写进磁盘，是根据&lt;code&gt;innodb_flush_log_at_trx_commit&lt;/code&gt;和&lt;code&gt;sync_binlog&lt;/code&gt;配置决定，&lt;strong&gt;用于实现数据持久化，以及宕机恢复数据。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;之所以要使用二阶段提交，是为了保证redo log和bin log的数据一致性，&lt;strong&gt;对于处于 prepare 阶段的 redo log，即可以提交事务，也可以回滚事务，这取决于是否能在 binlog 中查找到与 redo log 相同的 XID&lt;/strong&gt;，如果有就提交事务，如果没有就回滚事务，这样就可以保证 redo log 和 binlog 这两份日志的一致性。&lt;/p&gt;
&lt;p&gt;二阶段提交虽然保证了redo log和bin log的数据一致性，但是会提升磁盘IO的次数，每次事务提交都要刷两次盘，一次redo log，一次bin log；此外，为了保证在多事务场景下，两个日志提交顺序一致，还需要锁来保证事务的顺序，可能导致锁竞争激烈。&lt;/p&gt;
&lt;p&gt;后面引入了组提交机制解决这两个问题，组提交将commit阶段拆分成三个阶段，并使用三个队列，当有多个事务提交时，会将多个bin log 刷盘操作合并成一个，从而减少磁盘IO，该机制只针对commit阶段。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WAL机制&lt;/strong&gt;：执行事务时，将表数据写入内存和日志(redo log)，事务就完成了，此时表数据可能还没写入磁盘，InnoDB会在合适的时机将内存里的数据（Buffer Pool里的脏页）刷入磁盘。&lt;strong&gt;WAL机制主要是解决表数据写入时，CPU和磁盘速度的差异问题&lt;/strong&gt;，也因为是先把数据写进内存，再写入磁盘，才需要redo log + 二阶段提交来解决崩溃数据丢失的问题。&lt;/p&gt;
&lt;p&gt;在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;bin log归档日志&lt;/strong&gt;：属于server层的日志，逻辑日志，&lt;strong&gt;记录所有逻辑操作&lt;/strong&gt;，追加写入，不会覆盖以前的日志。bin log有两种模式：statement 格式的话是记sql语句； row格式会记录行的内容，一般使用row，记录行变化前和变化后的数据，缺点是日志变大。&lt;strong&gt;用于主从复制和数据备份恢复&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;redo log prepare、commit 的XID与bin log的XID实现关联，通过XID的关联，就能知道两份日志是否完整，从而实现crash-safe。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;执行一条更新语句的执行流程&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;执行器负责具体执行， 调用存储引擎的接口，通过主键索引找到那一行的记录，如果这条记录在Buffer Pool中，返回给执行器，如果不在Buffer Pool中，就从磁盘读入到Buffer Pool中，返回给执行器；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行器拿到记录后，判断更新前后是否一致，如果一致，就不进行后续流程直接返回了；如果不一致，就把更新前和更新后的数据传给InnoDB，由存储引擎执行真正的更新操作；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开启事务，数据修改前，先把老版本的数据写入undo log，undo log也会写入 Buffer Pool 的undo页中，当在内存中修改该 undo 页，需要更新记录对应的redo log；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InnoDB开始更新记录，更新Buffer Pool里该行的数据，同时标记成脏页，然后把新数据先写进redo log buffer，状态是prepare，然后是写入 bin log cache，事务提交，redo log更新为commit状态，整个更新操作就算完成。数据写入Buffer Pool时，一条记录就算更新完成了，事务提交，一条更新语句才算执行完成；（二阶段提交）&lt;/p&gt;
&lt;p&gt;redo log 和 bin log 都是先写进对应的cache，再刷盘，所以，写入到对应的log文件，并不意味着写入了磁盘，此时可能只写入到了操作系统内核的Page Cache，操作系统再在合适的时机写入磁盘。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当&lt;code&gt;innodb_flush_log_at_trx_commit=1&lt;/code&gt;和&lt;code&gt;sync_binlog=1&lt;/code&gt;时，事务完整提交前，需要刷两次盘，一次 redo log，一次 bin log。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;innodb_flush_log_at_trx_commit&lt;/code&gt;在不同值的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;=1&lt;/code&gt;：表示每次事务完成后，立即调一次 fsync 方法将 redo log buffer 中的数据持久化到Page Cache，再调用一次flush 方法持久化到硬盘。（建议）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=0&lt;/code&gt;：表示每秒调用 fsync 方法将 redo log buffer 中的数据持久化到Page Cache，再调用 flush 刷盘，机器停电或崩溃可能会丢失一秒的数据；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=2&lt;/code&gt;：表示每次事务完成后，立即调一次 fsync 方法将 redo log buffer 中的数据写到Page Cache，然后每秒调一次 flush 方法持久化到硬盘，机器停电或操作系统崩溃可能会丢失一秒的数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;redo log buffer默认是16MB&lt;/strong&gt;，redo log 数据内容是记在 redo log block 里的，写满一个就存到redo log buffer里，然后写下一个，直到 buffer 满了，此时会强制刷盘。&lt;/p&gt;
&lt;p&gt;redo log  是固定大小的，比如有一组4个文件组成的“环形队列”，环形写入，一个文件写完就写下一个，4个轮转，作用是redo log刷盘完成之后这部分内存就能重新利用；首位指针表示当前记录的位置和当前擦除位置。当前擦除位置是一个叫 LSN（log sequence number）的检查点，表示在LSN之前的数据（缓冲池里的数据页、索引页）都已经持久化到磁盘了，redo log文件里在LSN检查点之前的内容才允许被覆盖，擦除或覆盖之前一定会刷到磁盘。&lt;/p&gt;
&lt;p&gt;redo log buffer 除此之外还有几种场景会强制写磁盘：redo log buffer满了、正常关闭服务器、redo log环形写入到达check point时。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sync_binlog&lt;/code&gt; 在不同值的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;=1&lt;/code&gt;：表示每次事务提交后bin log都会持久化到磁盘；(建议)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=0&lt;/code&gt;：表示由系统判断何时刷盘；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;=N&lt;/code&gt;，表示每次事务提交都会写入到Page Cahce，但是会累计提交 N 个事务后才把bin log的数据持久化到磁盘，一般设置范围是100~1000，对应的风险是，如果机器宕机，会丢失最近 N 个事务的bin log日志；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InnoDB在空闲的时候才真正的将Buffer Pool中已更新的&lt;strong&gt;表数据&lt;/strong&gt;刷新到对应的page页，写入磁盘中，此时数据才真正落盘。（WAL机制）&lt;/p&gt;
&lt;p&gt;因为redo log格式固定，可以通过redo log buffer实现顺序写入磁盘，顺序IO写入速度快，而将表数据写入磁盘，需要更新redo log日志中的内容到表数据对应的page页，涉及到分页或合并等操作，属于随机IO写入，比较费时，所以才先写redo log日志，再把表数据写入磁盘。虽然WAL机制也实现了顺序写，但是因为它是先写在内存，存在丢失风险，才需要redo log一起配合；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;关于奔溃恢复&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;可以&lt;strong&gt;只使用redo log来实现崩溃恢复&lt;/strong&gt;，保证恢复后不会出现主从不一致的情况，由MySQL内部实现，但无法只使用bin log，原因是 InnoDB使用WAL机制，如果此时数据库崩溃，要依赖日志来恢复数据页，但是bin log并没有记录数据页的更新细节，而redo log因为环形写入的问题，无法对所有记录进行归档，仅仅只能实现崩溃恢复；&lt;/p&gt;
&lt;p&gt;崩溃重启后，扫描redo log文件，如果碰到prepare状态的redo log，就会拿着它的 XID，去bin log里查询，如果bin log里能找到，就提交事务，如果找不到，就回滚事务，从而保证 redo log 和 binlog 这两份日志的一致性；&lt;/p&gt;
&lt;p&gt;只有当&lt;code&gt;innodb_flush_log_at_trx_commit=1&lt;/code&gt;和&lt;code&gt;sync_binlog=1&lt;/code&gt;，数据库才具备crash-safe的能力。&lt;/p&gt;
&lt;p&gt;备份时间的长短会影响日志文件的大小，文件的完整性，从而影响到恢复速度和恢复效果；&lt;/p&gt;
&lt;p&gt;参考：&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/133994414&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL中的日志机制&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;常用sql&#34;&gt;常用SQL&lt;/h1&gt;
&lt;h2 id=&#34;更新&#34;&gt;更新&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;update 表名 set 列名1=值1, 列名2=值2... where 列名3=值3 &lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;插入&#34;&gt;插入&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;insert into 表名 (列名1, 列名2, ...) values (值1, 值2, ...)&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;countcount1count列区别&#34;&gt;Count(*)、Count(1)、Count([列])区别&lt;/h2&gt;
&lt;p&gt;在count(*)不带条件在MyISAM里查询比较快，因为MyISAM会存储总条数，不带条件查询的时候直接用就行，而InnoDB带了事务，支持MVCC，因此每次count(*)时都会扫表&lt;/p&gt;
&lt;p&gt;以下归纳基于InnoDB，count会返回满足条件的结果集的总行数，它会使用存储引擎进行全表扫描获取结果，比如count(1)会直接返回1，count(主键)会获取主键，返回给server层，由server层进行计数，因此按效率排序是：&lt;code&gt;count(字段) &amp;lt; count(主键id) &amp;lt; count(1) ≈ count(*)&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;count（列）会计算列或这列的组合不为空的计数；&lt;/li&gt;
&lt;li&gt;count(*) 跟 count(1) 的结果一样，都包括对NULL的统计，而count([列名]) 是不包括NULL的统计；&lt;/li&gt;
&lt;li&gt;对于计数，也可以通过创建列为表名、total的表进行计数，利用事务能力，一般是先insert再update，理由是并发进行total值的更新时，是会上行锁的，如果先update total值可能会导致事务处理时间过长；&lt;/li&gt;
&lt;li&gt;对于大表count，可以使用近似值，比如使用 &lt;code&gt;show table status&lt;/code&gt; 或 &lt;code&gt;explain select语句&lt;/code&gt;来查询近似值；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;having的使用&#34;&gt;having的使用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;having一般需要搭配 group by 使用，在group by之后，order by之前&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;having一般配合聚合函数使用，而where后面不能加聚合函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;where是对&lt;strong&gt;表的字段&lt;/strong&gt;进行条件过滤，having是对&lt;strong&gt;select出来的字段&lt;/strong&gt;进行条件过滤&lt;/p&gt;
&lt;p&gt;可以想成 查询一些字段，先通过where进行一次过滤，group by进行一次分组，having对分组后的结果再过滤一次，having后的字段必须出现在select中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常见一点的sql，比如有如下表，这里为了方便理解以中文的形式表示字段&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;-----+--------Log------+------------+
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;网站名称&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;点击数&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;date&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;        &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;-----+---------+-------+------------+
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2016&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;05&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2016&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;05&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;230&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2016&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;05&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;14&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;45&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2016&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;05&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;14&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;545&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2016&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;05&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;14&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;6&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;D&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;13&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2016&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;05&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;105&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2016&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;05&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;660&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2016&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;05&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;9&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;       &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;C&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;301&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2016&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;05&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;17&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;|&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;-----+---------+-------+------------+
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;查询 除了D网站外 各个网站的点击数 大于100 的 网站名称 和 点击数 并 降序 表示&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;网站名称&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SUM&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;点击数&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Log&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;where&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;网站名称&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;D&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;   
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;by&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;网站名称&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;having&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SUM&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;点击数&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;order&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;by&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SUM&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;点击数&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;order-by&#34;&gt;order by&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;全字段排序&lt;/strong&gt;：查询条件是索引，但是order by 条件不是，会先遍历索引，再回表取值，每次取到数据就丢sort_buffer，完了之后在sort_buffer里根据order by条件排序 （利用sort_buffer + 临时表），会根据数据量采用内存排序或者外部归并排序；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;rowId排序&lt;/strong&gt;：如果select的字段太多，超过设置的最大长度&lt;code&gt;max_length_for_sort_data&lt;/code&gt;，就会只取主键和order by的条件丢进去sort_buffer里进行排序，最后再回表根据主键取出其他select的字段；&lt;/li&gt;
&lt;li&gt;如果order by的条件正好是索引顺序，就不需要使用sort_buffer进行排序了，直接使用索引顺序即可；&lt;/li&gt;
&lt;li&gt;order by rand()，随机排序，使用内存临时表，使用rowId + 随机数进行排序；&lt;/li&gt;
&lt;li&gt;不带查询条件进行order by，就算order by条件是索引，是不一定会走索引进行排序，原因是如果MySQL优化器判断走索引后要去回表数量太大，就不会走；&lt;/li&gt;
&lt;li&gt;带limit的order by，mysql会采用堆排；&lt;/li&gt;
&lt;li&gt;默认的临时内存表是16M，由&lt;code&gt;tmp_table_size&lt;/code&gt;设置；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;group-by&#34;&gt;group by&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;group by一般是使用在select + 聚合函数的情况，如果select 没有聚合函数，语义（即按照group by后的字段进行分组，相同的分组只返回一行）与distinct是类似的，性能也一样&lt;/li&gt;
&lt;li&gt;SQL语句的执行顺序是 from &amp;gt; where &amp;gt; group by ＞ having &amp;gt; order by &amp;gt; limit，join 和on和and的组合属于from范围&lt;/li&gt;
&lt;li&gt;group by实际上会进行排序操作的，先根据group by后的字段进行排序，再聚合，最后select出需要的字段返回，这个过程会用到内存临时表(可能会退化为磁盘临时表)&lt;/li&gt;
&lt;li&gt;无法这样使用select * from table group by column&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;distinct&#34;&gt;distinct&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;select distinct 列1, 列2 from 【表名】&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;distinct 接多个列，会对多个列的不同组合都列出来&lt;/li&gt;
&lt;li&gt;无法这样使用&lt;code&gt;select 列1, distinct 列2 from 【表名】&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;join&#34;&gt;join&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;由于有时优化器会选择错误的驱动表，使用 &lt;strong&gt;straight_join&lt;/strong&gt; 则可以让MySQL&lt;strong&gt;默认使用左边的表作为驱动表&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NLJ算法进行join操作&lt;/strong&gt;：当有A、B两表，是一个1对1的关系，逻辑外键在B表带有索引，使用join进行关联查询，小表驱动大表(这样扫描的行数较少)，每扫一行B，通过外键索引，在另一个表A找对应的行数据，合并，返回，总共执行1条语句，扫描len(A) + len(B) 行。但是如果不使用join查，而是先查出B表所有数据，再根据B的id查回A的数据，虽然扫描的行数一样，但是却执行了len(B) + 1条SQL语句，显然是使用了join的方式性能强，前提是B上带了索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;BNL算法进行join操作&lt;/strong&gt;：如果B上关联键没有使用索引，则算法是这样的，先对B表进行全表扫描存进内存，再对A表进行全表扫描，每扫一行A，就在内存（join buffer）里的B进行匹配，返回；如果内存太小，则分块对表B进行加载，全表扫描A，匹配后将结果集返回，清空内存，再分块加载剩下的B，再次全表扫描A，匹配返回，循环处理，直至表B加载完成。分块加载会导致重复扫描表A。&lt;/p&gt;
&lt;p&gt;对BNL的优化，一种是在业务端查回两张表的数据，在通过hash匹配组合，另一种是查join查询前，先创建临时表，创建索引，查询被驱动表的数据，插入临时表中，与临时表进行join操作，将BNL转为NLJ；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;驱动表走全表扫描，被驱动表最好走索引扫描，使用NLJ算法，如果被驱动表是全表扫描，则使用(S)BNL算法；即&lt;strong&gt;被驱动表有索引，使用NLJ，被驱动表没索引，使用BNL，都是为了扫描更少的行数&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;select * from a join b on a.id=b.id&lt;/code&gt;，A是驱动表，B是被驱动表；如果是 &lt;code&gt;select * from a, b on a.id=b.id&lt;/code&gt;，则驱动表和被驱动表由MySQL自己决定。&lt;/p&gt;
&lt;p&gt;小表驱动，小表指的是行数相对少，或者select时表的数据量相对少的表；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;所以，NLJ算法是从表B每查一行就根据索引去表A匹配一行，MRR优化就是在NLJ基础上，回表的时候根据有序的索引一批一批查，这样就快一点；而BNL算法是同时去查表A和表B的所有行，再进行匹配关联&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;left join，使用left join时，左边的表不一定是驱动表，如果要使用left join语义，不能把被驱动表的字段放在where条件里做等值和不等值判断，必须放在on里，原因是MySQL会先用on作为条件进行过滤，完了才使用where进行过滤，放在on里能让过滤出来的条数少，要注意两者表达的语义还是有些不同的；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;dropdelete与truncate&#34;&gt;drop、delete与truncate&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;delete和truncate只删除表数据不删除表结构&lt;/li&gt;
&lt;li&gt;速度上 drop &amp;gt; truncate &amp;gt; delete&lt;/li&gt;
&lt;li&gt;drop和truncate是ddl语句，操作是立即生效，原数据不放到rollback segment中，不能回滚，而delete是dml语句，该操作会放在rollback segment中，事务提交后才生效&lt;/li&gt;
&lt;li&gt;不需要表时使用drop，删除某些行时使用delete，保留表但清空表的数据时使用truncate&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;limit&#34;&gt;Limit&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;limt M [offset N]&lt;/code&gt;，从第N条记录开始，返回M条记录，比如&lt;code&gt;limit 5, 10&lt;/code&gt;，表示返回6-15行&lt;/li&gt;
&lt;li&gt;当limit后面只跟一个参数时，表示返回最大的记录行数目，比如&lt;code&gt;limit 5&lt;/code&gt;，表示只返回前5行&lt;/li&gt;
&lt;li&gt;初始偏移量是0&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;日期类查询&#34;&gt;日期类查询&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;curdate()函数：得到今天的日期，格式： 年-月-日&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;now()函数：得到今天的日期和时间，格式：年-月-日 时:分:秒&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;两个datetime类型的字段相减，得到的单位跟日期的格式有关，如果格式有到秒，那减出来就是多少秒，如果格式只到日，那减出来就是多少日&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;UNIX_TIMESTAMP(datetime类型的字段) 将datetime类型的字段转换为时间戳，要注意时间戳是以1970 年 1 月 1 日开始算的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DATE_SUB(date, INTERVAL expr type) 函数：从日期减去指定的时间间隔&lt;/p&gt;
&lt;p&gt;date_format(date字段, ‘%Y%m%d %H:%i:%s&#39;) 函数：日期格式化函数，&lt;/p&gt;
&lt;p&gt;可以利用这些来查询最近多少天的数据如&lt;/p&gt;
&lt;p&gt;查询 近一小时的数据 where date字段 &amp;gt;= DATE_SUB(now(), INTERVAL 1 Hour) and date字段 &amp;lt; now()&lt;/p&gt;
&lt;p&gt;查询 昨天的数据 where date字段 &amp;gt;= DATE_SUB(CURDATE(), INTERVAL 1 Day) and date字段 &amp;lt; CURDATE()&lt;/p&gt;
&lt;p&gt;查询 近7天的数据 where date字段 &amp;gt;= DATE_SUB(CURDATE(), INTERVAL 7 Day)&lt;/p&gt;
&lt;p&gt;查询 本月的数据 where date_format(date字段, ‘%Y%m&#39;) = date_format(curdate() , ‘%Y%m&#39;)&lt;/p&gt;
&lt;p&gt;查询 上个月的数据 where period_diff(date_format(now() , ‘%Y%m&#39;) , date_format(date字段, ‘%Y%m&#39;)) =1&lt;/p&gt;
&lt;p&gt;查询 今年的数据 where YEAR(date字段)=YEAR(NOW())&lt;/p&gt;
&lt;p&gt;查询 去年的数据  where YEAR(date字段)=year(date_sub(now(),interval 1 year))&lt;/p&gt;
&lt;p&gt;查询本季和上一季的跟 查年的差不多 ，把 YEAR函数 换成 QUARTER函数 即可&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;数据类型&#34;&gt;数据类型&lt;/h1&gt;
&lt;h2 id=&#34;varchar和char&#34;&gt;varchar和char&lt;/h2&gt;
&lt;p&gt;char是固定长度，varchar是可变长度，varchar(50)和varchar(200)存储字符串 “hello” 所占空间一样，但后者在排序时会消耗更多内存，因为order by采用fixed_length计算字段长度。&lt;/p&gt;
&lt;p&gt;MySQL中除了TEXT、BLOBs外，其他所有列占用的字节长度加起来不能超过65535个字节，即一行的长度不会超过65535字节，64kb；公式：&lt;code&gt;如果有多个字段的话，要保证所有字段的长度 + 变长字段字节数列表所占用的字节数 + NULL值列表所占用的字节数 &amp;lt;= 65535字节&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;varchar(n)中的n代表最多能存储的字符数量，并不是字节大小，所以还要看数据库的字符集用的是上面编码&lt;/p&gt;
&lt;h2 id=&#34;int和int20&#34;&gt;int和int(20)&lt;/h2&gt;
&lt;p&gt;有符号的整型范围是-2147483648~2147483647；无符号的整型范围是0~4294967295；&lt;/p&gt;
&lt;p&gt;int(20)表示能显示的宽度是20，比如id的值是10，那MySQL就会在前面加0，自动补全到20位，仍然占4个字节存储，存储范围也不变。&lt;/p&gt;
&lt;h2 id=&#34;datetime&#34;&gt;Datetime&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间&lt;/li&gt;
&lt;li&gt;与时区无关&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;timestamp&#34;&gt;TimeStamp&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;它和时区有关，每个时间戳在不同时区所代表的具体时间不同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，&lt;/p&gt;
&lt;p&gt;提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;null&#34;&gt;NULL&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;NULL跟任何值执行等值判断和不等值判断的结果都是NULL&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;存储结构&#34;&gt;存储结构&lt;/h1&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/MySQL%e8%a1%a8%e7%a9%ba%e9%97%b4%e7%bb%93%e6%9e%84.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/MySQL%e8%a1%a8%e7%a9%ba%e9%97%b4%e7%bb%93%e6%9e%84.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;记录是按照行来存储的，但是数据库的读取并不以行为单位，否则一次读取（也就是一次I/O操作）只能处理一行数据，效率会非常低。因此InnoDB将数据划分为若干个页面，不论读一行，还是读多行，都是将这些行所在的页进行加载。即 数据库管理存储空间的基本单位是页（Page）。&lt;/p&gt;
&lt;p&gt;B+树叶子节点，双向链表，叶子节点，以及数据页的格式，User Records从Free Space里转换而来，当Free Space用完，就会创建下一页；&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e6%95%b0%e6%8d%ae%e9%a1%b5%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e6%95%b0%e6%8d%ae%e9%a1%b5%e5%ad%98%e5%82%a8%e7%bb%93%e6%9e%84.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;索引页，即非叶子节点也是类似上面的结构，只是行记录那里存的是指向下一层页的指针，而不是具体的行数据。&lt;/p&gt;
&lt;p&gt;一个页中可以存储多个行记录（Row），同时在数据库中，还存在着区（Extent）、段（Segment）和表空间（Tablespace）。大小排序与包含关系：行 -&amp;gt; 页 -&amp;gt; 区 -&amp;gt; 段 -&amp;gt; 表空间。&lt;/p&gt;
&lt;p&gt;页（Page）是基本的存储单位，按类型分可分为 数据页（B+树节点，链表结构，逻辑上连续）、系统页、Undo页和事务数据页等，每个页默认大小是16KB。意味着数据块每次读写都是以16KB为单位。&lt;/p&gt;
&lt;p&gt;区（Extent）是比页大一级的存储结构，在InnoDB存储引擎中，一个区会分配64个连续的页。因为InnoDB中的页大小默认是16KB，所以一个区的大小是64*16KB=1MB。传统链表每个相邻节点的物理位置并不一定是连续的，MySQL为了能够顺序IO，就通过区来实现，当表中数据量大的时候，为某个索引分配空间不再以页为单位分配，而是按照区，每个区大小为1MB，对于16KB的页来说，连续的64个页会被划分为一个区，使得链表中相邻的页的物理位置页相邻，即B+树叶子节点链表相邻的页的物理位置相邻，能够顺序IO；&lt;/p&gt;
&lt;p&gt;段（Segment）由一个或多个区组成，区在文件系统是一个连续分配的空间（在InnoDB中是连续的64个页），不过在段中不要求区与区之间是相邻的。段是数据库中的分配单位，不同类型的数据库对象以不同的段形式存在。索引段，存放B+树的非叶子节点的区集合；数据段，存放B+树叶子节点的区集合；回滚段，存放回滚数据的区集合；&lt;/p&gt;
&lt;p&gt;表空间（Tablespace）是一个逻辑容器，表空间存储的对象是段，在一个表空间中可以有一个或多个段，但是一个段只能属于一个表空间。数据库由一个或多个表空间组成，表空间从管理上可以划分为系统表空间、用户表空间、撤销表空间、临时表空间等。对应的文件是 [表名].ibd 的文件，在这个文件里，会被分成很多数据页，每一份是16K。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;行格式&#34;&gt;行格式&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/MySQL%e8%a1%8c%e6%a0%bc%e5%bc%8fCompact%e6%a0%bc%e5%bc%8f.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/MySQL%e8%a1%8c%e6%a0%bc%e5%bc%8fCompact%e6%a0%bc%e5%bc%8f.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;记录的额外信息&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;变长字段长度列表：存储数据的时候，也要把数据占用的大小存起来，存到「变长字段长度列表」里面，读取数据的时候才能根据这个「变长字段长度列表」去读取对应长度的数据，按照列的顺序逆序将列的长度存储到这个字段里；字段如果是NULL值不会存在这；&lt;/p&gt;
&lt;p&gt;之所以要逆序存放，可以使得位置靠前的记录的真实数据和数据对应的字段长度信息可以同时放到CPU Cache Line里，提高CPU Cache 的命中率；&lt;/p&gt;
&lt;p&gt;当数据表的字段没有变长字段时，行格式里就不会记录 变长字段长度列表 了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;NULL值列表：至少一个字节，跟列的数量有关，比如如果是9个列，那就是两个字节；该字段会记录该行所有列是否是NULL值，以二进制位按列的顺序逆序排列，二进制位=1，表示NULL，=0表示不为NULL，列的数量不足的，高位补零。&lt;/p&gt;
&lt;p&gt;当数据表的字段都定义成NOT NULL时，行格式里就不会记录 NULL值列表 了；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录头信息：只列举重要的，比如 delete_mask，标识此条记录是否被删除；next_record，指向下一条记录的指针（记录与记录之间是链表，下一条记录的「记录头信息」和「真实数据」之间的位置）；record_type，当前记录的类型，0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;记录的真实数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;row_id：当表没指定主键时，且也没有不包含NULL值得唯一列，就会用到这个作为隐藏主键&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;trx_id：事务id，表示这个数据由哪个事务产生，用于MVCC&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;roll_ptr：记录上个版本的指针，用于回滚，MVCC&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;MySQL 中磁盘和内存交互的基本单位是页，一个页的大小一般是 &lt;code&gt;16KB&lt;/code&gt;，也就是 &lt;code&gt;16384字节&lt;/code&gt;，而一个 varchar(n) 类型的列最多可以存储 &lt;code&gt;65532字节&lt;/code&gt;，一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会&lt;strong&gt;发生行溢出，多的数据就会存到另外的「溢出页」中&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;buffer-pool&#34;&gt;Buffer Pool&lt;/h2&gt;
&lt;p&gt;InnoDB使用了Buffer Pool来提高数据库读写性能；MySQL启动时，&lt;strong&gt;InnoDB 会为 Buffer Pool 申请一片连续的内存空间，然后按照默认的&lt;code&gt;16KB&lt;/code&gt;的大小划分出一个个的页， Buffer Pool 中的页就叫做缓存页&lt;/strong&gt;，默认配置下 Buffer Pool 只有 &lt;code&gt;128MB&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;Buffer Pool会缓存索引页、数据页、undo页、插入缓存、自适应哈希索引、锁信息等；&lt;/p&gt;
&lt;p&gt;使用三种链表来管理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Free list链表：关联空闲的页，以便快速找到空闲页；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Flush list链表：关联脏页，以便将脏页刷盘；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LRU List链表：管理脏页和干净页；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。&lt;/p&gt;
&lt;p&gt;查询一条数据时，会把这个页的数据都加载到Buffer Pool中，因为通过索引只能定位到磁盘中的页，而不能定位到页中的一条数据，将页加载到Buffer Pool后，再通过页里的页目录去定位到具体的行记录；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MySQL加载数据时，会进行预读，但是这些提前被加载进来的数据页，可能并不会被访问到，造成预读失效；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用LRU算法提升缓存命中率，将LRU链表划分为两个区域，前半段是young区，后半段是old区，比例大概是64：37，预读的页会先加入到old区的头部，当页被真正访问时，才会插入young区的头部，如果预读的页一直没有被访问到，就会从old区移除，这样就不会影响young区的热点数据，解决预读失效导致缓存命中率低的问题；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一个SQL语句需要扫描大量的数据，在Buffer Pool空间比较有限的情况下，把所有页都替换出去了，导致大量热点数据被淘汰，造成缓存污染，等到这些热点数据被访问时，由于缓存未命中，就会产生大量磁盘IO。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据加入young区条件增加门槛，只有同时满足「被访问」与「在 old 区域停留时间超过 1 秒」两个条件，才会被插入到 young 区域头部，解决 缓存污染的问题；&lt;/p&gt;
&lt;p&gt;另外，为了防止young区节点并频繁移动到头部，前1/4被访问不会移动，后3/4被访问才会移动；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当修改数据时，首先是修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页，最后由后台线程将脏页写入到磁盘，触发脏页刷盘的时机：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;redo log日志满时，主动触发脏页刷盘；&lt;/li&gt;
&lt;li&gt;Buffer Pool空间不足，此时需要淘汰一部分数据页 ，如果淘汰的是脏页，就要刷盘；&lt;/li&gt;
&lt;li&gt;MySQL 空闲时，定期适量将脏页刷盘；&lt;/li&gt;
&lt;li&gt;MySQL正常关闭，会把所有脏页刷盘；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;索引&#34;&gt;索引&lt;/h1&gt;
&lt;h2 id=&#34;1常见索引及概念&#34;&gt;1.常见索引及概念&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;聚簇索引：InnoDB中的主键索引，每张表的主键构造一棵B+树，同时叶子节点中存放的即为整张表的行记录数据。一个表只能包含一个聚簇索引，聚簇索引通常提供更快的数据访问速度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为表的数据都是存放在聚集索引的叶子节点里，所以 InnoDB 存储引擎一定会为表创建一个聚簇索引，且由于数据在物理上只会保存一份，所以聚簇索引只能有一个，而二级索引可以创建多个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非聚簇索引：表中行的物理顺序与键值的逻辑顺序不匹配，查到记录对应的主键值 ，再使用主键的值通过聚簇索引查找到需要的数据，这个过程也称为回表；即先通过普通索引找到主键，在通过主键找到数据。&lt;/p&gt;
&lt;p&gt;要细分的话可以分为普通索引，唯一索引，组合索引，全文索引这些。&lt;/p&gt;
&lt;p&gt;注：MyISAM无论主键索引还是二级索引都是非聚簇索引，而InnoDB的主键索引是聚簇索引，二级索引是非聚簇索引。我们自己建的索引基本都是非聚簇索引。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;稠密索引：每个索引对应一个值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;稀疏索引：每个索引对应一个存储块&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;覆盖索引：要查询的字段只需要去查询索引表就可以&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;组合索引（联合索引）：最左匹配，建立一个组合索引等于建立多个索引，能达到覆盖索引的目的，效率高；例如有组合索引(a，b，c)，则同时得到了索引（a），(a，b)，（a，b，c）&lt;/p&gt;
&lt;p&gt;MySQL5.6 后有个&lt;strong&gt;索引下推&lt;/strong&gt;，当查询条件带a，b的时候，会先查找索引树匹配a，再判断b，然后才回表找数据，从而减少回表次数，如果没有索引下推，MySQL是先查找索引树匹配a，拿到id回表查数据，判断是否匹配b，这样回表次数就太多了。&lt;/p&gt;
&lt;p&gt;组合索引之所以是最左匹配跟B+树有关，也是类似Order by的过滤，根据索引依次排列数据的，如Order by a,b,c 则先排a，a相同再排b，b相同再排c&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;联合索引的最左匹配原则，在遇到范围查询（如 &amp;gt;、&amp;lt;）的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引，比如 a &amp;gt; 1 AND b = 2，这种只会用到联合索引的（a）。注意，对于 &amp;gt;=、&amp;lt;=、BETWEEN、like 前缀匹配 的范围查询，并不会停止匹配，比如 a &amp;gt;= 1 AND b = 2，会用到索引（a，b），因为此时在进行扫描时，可以是以 a=1 AND b=2 为条件找到第一条数据，再继续往下匹配的；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自适应哈希索引，由InnoDB自行决定是否建立，自适应哈希索引只保存热点数据，不会保存全表数据，所以数据量不会很大，使用的 InnoDB Buffer Pool进行缓存；相当于 索引的索引，降低对二级索引树的频繁访问，快速定位到叶子节点；无法进行范围查询；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;索引可能因为删除，或者页分裂等原因，导致数据页有空洞，重建索引的过程会创建一个新的索引，把数据按顺序插入，这样页面的利用率最高，也就是索引更紧凑、更省空间，&lt;strong&gt;但主键索引的重建会导致整个表重建，一般可以使用alter table T engine=InnoDB来达到重建主键索引的效果&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;2特点&#34;&gt;2.特点&lt;/h2&gt;
&lt;p&gt;需要建立的列：经常需要搜索的列、主键列、外键列、排序的列、经常在where后面出现的列&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;避免进行数据库全表的扫描，大多数情况，只需要扫描较少的索引页和数据页，而不是查询所有数据页。而且对于非聚簇索引，有时不需要访问数据页即可得到数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;聚簇索引可以避免数据插入操作，集中于表的最后一个数据页面。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在某些情况下，索引可以避免排序操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加速表与表之间的连接&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;增，删，改会带来不小性能开销&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于普通索引和唯一索引&lt;/p&gt;
&lt;p&gt;在查询上，唯一索引和普通索引的区别是，唯一索引在查找到结果后就不会继续往下查了，但其实性能跟普通索引差别不会很大，但是更新的时候唯一索引由于用不上change buffer机制，更新的性能比较差。&lt;/p&gt;
&lt;p&gt;在更新上，InnoDB会先判断更新的数据是否在Buffer Pool，如果在就直接更新，如果不在，就先把更新操作写到change buffer，等之后数据加载到Buffer Pool后，合并这两部分Buffer，更新Buffer Pool里的数据。&lt;/p&gt;
&lt;p&gt;change buffer只适用普通索引上的更新操作，因为唯一索引需要先读取所有数据，判断索引是否重复后再插入，如果此时数据没有被读进Buffer Pool，需要磁盘随机IO读取，最终导致更新变慢。&lt;/p&gt;
&lt;p&gt;另外，为了保证更新操作的稳定性，实际上在写change buffer的过程中还会把相关操作记录按顺序写进redo log（redo log也会刷盘），才算真正完成更新操作。查询的时候其实可以直接查Buffer Pool里的数据，或者先把磁盘里的数据读到内存，再配合change buffer就能得到更新后的数据了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3原理&#34;&gt;3.原理&lt;/h2&gt;
&lt;p&gt;B类树都是为了磁盘或其他辅助存储设备而设计的一种数据结构，目的是为了在查找数据的过程中减少磁盘I/O次数，&lt;strong&gt;树存储在磁盘中，树的高度等于每次查询数据时磁盘的IO操作次数&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B+树&lt;/strong&gt;：表的数据为叶子节点，非叶子节点为索引，有两条路径，一条是树，一条是各叶子相连&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;N叉树的N在MySQL5.6后可以通过page大小来间接控制，叶子节点是数据页(page)，页与页之间组成&lt;strong&gt;双向链表&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;一个数据页(page)可以包含多个行(记录)，行按(记录)照主键顺序，行与行之间组成单向链表；每一个数据页中有一个页目录，方便按照主键查询行；&lt;/li&gt;
&lt;li&gt;页目录中通过槽把行(记录)分成不同小组，每个小组内包含多条行(记录)，按照主键搜索页中行(记录)时，使用二分法查找，从槽开始依次往下找；&lt;/li&gt;
&lt;li&gt;B+树的插入可能会引起数据页的分裂，删除可能会引起数据页的合并，二者都是比较重的IO消耗，所以比较好的方式是顺序插入数据，这也是我们一般使用自增主键的原因之一；&lt;/li&gt;
&lt;li&gt;每个结点就算一个page，数据以Page为单位在内存和磁盘间进行调度，每个Page的大小决定了相应结点的分支数量，每条索引记录会包含一个数据指针，指向一条数据记录所在文件的偏移量；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/B&amp;#43;%e6%a0%91.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/B&amp;#43;%e6%a0%91.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;B&amp;#43;树&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;B+树&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;B-树&lt;/strong&gt;：也称B树，不限制出度的个数，所有节点为表的数据，只有一条路，从根节点开始&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/B%e6%a0%91.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/B%e6%a0%91.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;B树&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;B树&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;为什么说b树比b树更适合mysql数据库索引&#34;&gt;为什么说B+树比B树更适合MySQL数据库索引&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;B+树的磁盘读写代价更低：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，比B树更矮胖，相对IO读写次数就降低了，而且，在没定位到要找的记录时，加载别的数据行进内存并没有什么用，因为只需要索引来判断查找得对不对。&lt;/p&gt;
&lt;p&gt;B+树的查询效率更加稳定：B+树深度比较平均，由于非叶子点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引，任何关键字的查找必须走一条从根结点到叶子结点的路，即所有关键字查询的路径长度相同，因此每一个数据的查询效率相当。而B树查询的深度比较随机，比较适合定点查询，单次查询效率高。&lt;/p&gt;
&lt;p&gt;由于B+树的数据都存储在叶子结点中，分支结点均为索引，方便扫库，顺序IO，只需要扫一遍叶子结点即可；但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，带来更多的随机IO。所以B+树更加适合在区间查询的情况。&lt;/p&gt;
&lt;p&gt;B树不适合遍历数据，B树比较合适查询单一记录，常用与NoSQL的索引结构，NoSQL一般是Key-value形式的存储，文档性一般是Json存储。&lt;/p&gt;
&lt;p&gt;插入和删除时，B树会导致平衡发生改变，节点会上移或下沉，B+树因为存在冗余节点，删除时不会发生复杂的树变形，插入时虽然也可能存在页分裂，但也只涉及到树的一条路径，因此在插入和删除时，B+树效率更高；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;与二叉查找树avl树的比较&#34;&gt;与二叉查找树、AVL树的比较&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;AVL树的出度为2，而且AVL树要严格保持平衡，但旋转保持平衡比较耗时，适合用于插入删除次数比较少，但查找多的情况&lt;/li&gt;
&lt;li&gt;二叉查找树在查找最大值或最小值的时候，二叉查找树就完全退化成了线性结构了&lt;/li&gt;
&lt;li&gt;其他缺点同下面&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;与红黑树的比较&#34;&gt;与红黑树的比较&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;红黑树出度为2，B+树出度不止2，因此红黑树的高度会比B+树高，查找的次数也多了。（红黑树不是严格的平衡二叉树，旋转次数相对少，高度比平衡二叉树的低些）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;B+树在降低磁盘I/O操作数方面占优势&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了减少磁盘 I/O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，速度会非常快。&lt;/p&gt;
&lt;p&gt;操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;红黑树的特性&lt;/strong&gt;:
（1）每个节点要么是黑色，要么是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点）
（4）如果一个节点是红色的，则它的子节点必须是黑色的。
（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。&lt;/p&gt;
&lt;p&gt;参考&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/aspirant/p/9214485.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;一步步分析为什么B+树适合作为索引的结构&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;4失效情况&#34;&gt;4.失效情况&lt;/h2&gt;
&lt;p&gt;失效的本质是MySQL判断查询时走什么路径所花费的随机I/O和顺序I/O更多，比如需要扫描超过表的30%数据，就有可能失效。&lt;/p&gt;
&lt;p&gt;在使用到索引列的情况下&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对索引列作运算如 + - * / !&lt;/li&gt;
&lt;li&gt;索引类型出错，比如该索引列是字符串，但是写时候没有加``号，&lt;strong&gt;字符串和数字比较，MySQL会把字符串转为数字，无法转成数字的字符串都会被转换成0&lt;/strong&gt;；或者是字段的字符编码格式不同，比如有两张表，它们有外键关系，但是由于一张表是UTF-8另一张表是UTF-8mb4，也会导致索引失效；它们的原因都是MySQL在进行比较的时候，会使用函数对字段进行转换&lt;/li&gt;
&lt;li&gt;模糊查询 like ‘%keyword%` 查询不能有前置的%，如果是 like ‘keyword%’ 这样还是可以用到索引的&lt;/li&gt;
&lt;li&gt;索引列里有字段为null，null值不会加入到索引中&lt;/li&gt;
&lt;li&gt;使用or连接条件，如果or连接的条件中有一个不是索引，会失效，可以改成使用union all来连接两条sql语句&lt;/li&gt;
&lt;li&gt;组合索引没有体现最左匹配&lt;/li&gt;
&lt;li&gt;is null / is not null 对索引作判断&lt;/li&gt;
&lt;li&gt;索引上使用  != 或者 &amp;lt;&amp;gt; 还有not in&lt;/li&gt;
&lt;li&gt;索引的值只有几种情况，如性别只有男和女，这种情况虽然也会用索引，只是意义不大&lt;/li&gt;
&lt;li&gt;表的量级较小，存储引擎判定使用全表扫描更快&lt;/li&gt;
&lt;li&gt;有一case：1.select * from T where k in(1,2,3,4,5)；2.select * from T where k between 1 and 5，k为索引，但是推荐使用方法2，因为方法1会导致树查5次，而2是1次&lt;/li&gt;
&lt;li&gt;对索引字段使用了函数进行计算，可能会导致MySQL不使用该索引，或者进行了全索引扫描，无法用到索引进行快速定位&lt;/li&gt;
&lt;li&gt;如果查询的值的长度是否大于索引定义的长度，如果大于，&lt;strong&gt;虽然也会走索引&lt;/strong&gt;，因为MySQL是先把查询值的长度截断成跟索引定义的长度一致去遍历索引，但是它还要再回表得到数据进行比较，所以查询会很慢&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;5优化&#34;&gt;5.优化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;注意区分度，计算索引最优长度，使用这个计算 &lt;code&gt;select count(distinct left(列名, 索引长度)) / count(*) from {table名}&lt;/code&gt;，&lt;strong&gt;区分度越高越好&lt;/strong&gt;，另外使用前缀索引虽然会减少索引存储空间，但是可能会增加扫描次数或者覆盖索引不生效&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当表的字符集编码或者属性不同时，需要想办法把函数加再索引对应的值上，而不是索引字段上，或者去掉函数，使用其他方法替代&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当要充当索引的字段在某些长度的区分度太小时，可以增加一个字段，采用索引字段的倒序存储或者hash的方法来充当索引，缺点是无法使用索引进行范围查询，而hash更是只能支持等值查询，查询时需要进行额外的计算，也是一种性能消耗&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于MySQL在选择索引的时候会根据 索引区分度 和 索引对应的预估扫描行数（包括回表），但是有可能预估的结果是不准的，如果通过explain命令发现rows的值与想象中的偏差较大，可以执行&lt;code&gt;analyze table [tableName]&lt;/code&gt;来重新统计索引信息，或者使用&lt;code&gt;force index([索引名称])&lt;/code&gt;来强制使用索引，或者重写SQL，引导MySQL使用正确的索引&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意索引的最左前缀原则，如果在设置联合索引时，可以通过调整顺序来达到少维护一个索引，拿这个顺序就可以优先考虑，另外一个要考虑的就是索引的大小&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那么只需要修改原来的索引即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;启用MRR优化&lt;/strong&gt;：在MySQL 5.6之后，使用MRR进行优化，需要设置&lt;code&gt;set optimizer_switch =&#39; mrr = on, mrr_cost_based = off, batched_key_access = on&#39;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在没使用MRR优化前，通过索引回表是一行一行去查的，每次通过普通索引查到后的主键id是无序的，多次回表查性能不太好，而MRR优化指的是，如果主键索引有序，记录递增插入，则会先根据索引找到所有的id，再对id进行排序，再回表查。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用临时表，如果是InnoDB引擎，那创建的临时表是写磁盘的，如果是Memory引擎，则是写内存的。创建语句是 &lt;code&gt;create temporary table ···engine=xxx&lt;/code&gt;，用法跟普通表类似，但仅在当前线程可见，show tables不显示临时表，当当前线程处理完成后，临时表会被清空，但会保留表结构，允许在不同线程间重名，如果bin log格式是statement或mix，操作临时表的记录也会记录在bin log，备库也会跟着操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;内部临时表常用于不带索引的 join、分库分表时的联合查询、union查询(对两个查询结果求并集并去重，union all则不去重)、group by查询(order by和group by子句不一样时也会)、distinct查询时加上order by、from 中的子句查询，explain查询指向计划结果的extra列&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;当查询的数据量比较大时，默认会先使用内存临时表，发现太大后才转成磁盘表，因此如果数据量太大，可以使用&lt;strong&gt;SQL_BIG_RESULT&lt;/strong&gt;（ &lt;code&gt;select SQL_BIG_RESULT 字段 from 表 group by xxx&lt;/code&gt;）告诉MySQL强制使用磁盘临时表&lt;/p&gt;
&lt;p&gt;一般情况下还是使用内存表快些，通过调大&lt;code&gt;tmp_table_size&lt;/code&gt;来加大内存临时表的大小，默认是16M，这种临时表是由MySQL查询算法决定使用的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;group by 或order by多个字段时，需要为这多个字段建组合索引，不然也是全表扫，注意 order by 无法使用前缀匹配索引；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;索引最好设置为 NOT NULL，NULL值的存在会导致优化器做索引选择更复杂，索引统计时，count会省略值为NULL的行，另外，NULL值无意义，但会占物理空间，至少1字节存储 NULL值列表；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于大数据量时的分页，优化的思路也是尽可能的使用索引，比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;select * from table where id &amp;gt; (页数*页面大小) order by id limit M&lt;/code&gt;， &lt;code&gt;order by&lt;/code&gt; 使得结果稳定；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select * from table where id &amp;gt; (select ID from table order by id limit M, 1) order by id limit n&lt;/code&gt;，先利用子查询把id查出来，依靠id上的顺序，外层效果跟上面的类似&lt;/li&gt;
&lt;li&gt;&lt;code&gt;select * from table where id in (select id from table limit M, N)&lt;/code&gt;，同样也是利用id上的索引，覆盖索引，只查主键时，效率很高。&lt;/li&gt;
&lt;li&gt;普通查询返回是会等整个结果集都查询完毕才会返回，可能会导致客户端直接OOM，so 可以采用流式返回，边查边返回，客户端可以根据查到的结果先进行业务处理，及时回收内存，避免OOM；但是流式查询返回有个问题就是MySQL并不清楚客户端什么时候会关闭，所以MySQL会持续占用这条连接和使用额外的内存或磁盘来存储流式查询的结果，持续的查询也可能导致CPU消耗，消耗较大；两者在查询上的耗时是一样的，只是对客户端友不友好而已；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;6分析&#34;&gt;6.分析&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;explain + SQL语句&lt;/code&gt;，给出该SQL语句的分析结果，看看查询的类型，有没有用到索引，是不是全表扫描&lt;/p&gt;
&lt;p&gt;比较重要的字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;select_type&lt;/strong&gt;：查询类型，如 SIMPLE（简单查询）、PRIMARY（当存在子查询时，最外面的查询被标记为主查询）、UNION（联合查询，当一个查询在UNION关键字后就会出现）、SUBQUERY（子查询）、DERVIED（构造表，一个查询语句形成的结果集）等；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;type&lt;/strong&gt;：访问类型， 从左到右，查询性能依次减弱，一个好的SQL起码得达到range级；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NULL &amp;gt; system &amp;gt; const &amp;gt; eq_ref &amp;gt; ref &amp;gt; ref_or_null &amp;gt; index_merge &amp;gt; range &amp;gt; index &amp;gt; ALL&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;NULL&lt;/strong&gt;：MySQL在优化阶段分解查询语句，在执行阶段用不着再访问表和索引，比如&lt;code&gt;explain SELECT 5*7&lt;/code&gt;这种&lt;strong&gt;单纯做计算&lt;/strong&gt;的，一般用在已建立索引的情况下，查找索引的最大值和最小值，因为MySQL直接查找B+树最边上的叶子节点就能知道了，比如&lt;code&gt;EXPLAIN SELECT MAX(id) FROM student&lt;/code&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;const&lt;/strong&gt;：表示通过索引一次就找到了，一般是查询条件是&lt;strong&gt;主键或者唯一索引&lt;/strong&gt;的场景下；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;eq_ref&lt;/strong&gt;：联表查询，按&lt;strong&gt;连表的主键或唯一键联合查询&lt;/strong&gt;，当主键或唯一非&lt;code&gt;NULL&lt;/code&gt;索引的所有字段都被用作&lt;code&gt;join&lt;/code&gt;联接时会使用此类型；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ref&lt;/strong&gt;：表示单表扫描或者表间的连接匹配条件时用到&lt;strong&gt;普通索引或者唯一索引的前缀匹配&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;index_merge&lt;/strong&gt;：&lt;strong&gt;索引合并， 表示查询使用了两个以上的索引&lt;/strong&gt;，最后取交集或者并集，常见&lt;code&gt;and &lt;/code&gt;，&lt;code&gt;or&lt;/code&gt;的条件使用了不同的索引；&lt;/p&gt;
&lt;p&gt;5.0后才有的功能，使得MySQL可以在一次查询种使用多个索引，但是使用场景比较局限，多发生在查询条件涉及多个and和or的场景&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;range&lt;/strong&gt;：&lt;strong&gt;索引范围查询&lt;/strong&gt;，常见于使用 =, &amp;lt;&amp;gt;, &amp;gt;, &amp;gt;=, &amp;lt;, &amp;lt;=, IS NULL, &amp;lt;=&amp;gt;, BETWEEN, IN()或者like等运算符的查询中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;index&lt;/strong&gt;： &lt;strong&gt;索引表全表扫描&lt;/strong&gt;，通常比 All 快。因为索引文件通常比数据文件小，即 all 和 index 都是读全表，但 index 是从索引中读取的，而 all 是从硬盘读的，比如 count 查询；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;all&lt;/strong&gt;：&lt;strong&gt;全表扫描&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;possible_keys&lt;/strong&gt;：能使用哪个索引找到行，查询涉及到字段上若存在索引，则该索引将被列出，但不一定被查询使用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;key&lt;/strong&gt;：索引列的名称，如果没有使用索引，显示为NULL；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;key_len&lt;/strong&gt;：使用到索引的长度，可以看出索引是否使用得充分，比如虽然用到了联合索引，但是只用到了第一个字段作为索引，说明没有使用到所以索引，索引使用不充分；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ref&lt;/strong&gt;：表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;rows&lt;/strong&gt;：扫描的行数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;filtered&lt;/strong&gt;：查询出的行数占表的百分比&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;extra&lt;/strong&gt;：额外信息说明&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;using index：使用到了覆盖索引；&lt;/li&gt;
&lt;li&gt;using temporary：对查询结果排序时使用了临时表，查询效率比filesort还低，常见于order by和group by，查询效率不高；&lt;/li&gt;
&lt;li&gt;using filesort：当查询语句包含 group by，且无法利用索引完成排序操作时，会使用外部排序，通过磁盘和内存交换数据来排序，查询效率不高；&lt;/li&gt;
&lt;li&gt;using index condition：使用了索引下推；&lt;/li&gt;
&lt;li&gt;using join buffer（block nested loop）：使用join连表，并使用了缓冲区；&lt;/li&gt;
&lt;li&gt;using union：使用索引并取并集；&lt;/li&gt;
&lt;li&gt;using sort_union ：先对取出的数据按rowid排序，然后再取并集；&lt;/li&gt;
&lt;li&gt;using intersect ：索引取交集；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;show processlist&lt;/code&gt;，此命令用于查看目前执行的sql语句执行的状态，比如当CPU使用率飙升时，可通过该命令查看哪些SQL语句在执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;show status&lt;/code&gt;，查看数据库运行的实时状态，比如查询运行期间SQL的执行次数、连接数、缓存内的线程数量、连接数等，具体看 &lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/836f07dd89ec&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;mysql SHOW STATUS 变量&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;show variables&lt;/code&gt;，查看系统参数，一些静态参数，比如开启慢查询，设置索引缓冲区大小，具体参考：&lt;a class=&#34;link&#34; href=&#34;https://baike.xsoftlab.net/view/218.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Mysql show variables命令详解&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;performance_schema和sys系统库&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MySQL启动前需要设置&lt;code&gt;performance_schema=on&lt;/code&gt;，但是性能会比off少10%；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询&lt;code&gt;sys.schema_table_lock_waits&lt;/code&gt;、&lt;code&gt;sys.innodb_lock_waits表&lt;/code&gt;可以知道那条语句在占用锁；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查看 &lt;code&gt;information_schema.innodb_trx表&lt;/code&gt;可以看到事务具体的状态；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;show engine innodb status&lt;/code&gt;查看数据库请求情况&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;show status like &#39;innodb_row_lock%&#39;;&lt;/code&gt;查询行锁竞争情况&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;show status like &#39;table%&#39;;&lt;/code&gt;查询表锁竞争情况&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;select trx_id,trx_state,trx_started,trx_wait_started,trx_operation_state,trx_tables_in_use,trx_rows_locked,trx_rows_modified,trx_query from information_schema.innodb_trx;&lt;/code&gt;查询当前事务情况&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;select * from information_schema.innodb_lock_waits;&lt;/code&gt;查看锁等待对应关系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;select * from information_schema.innodb_locks;&lt;/code&gt;查看当前出现的锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当有语句执行过久或有语句一直被阻塞时，可以kill掉它&lt;/p&gt;
&lt;p&gt;使用kill query/connection + 线程id终止语句或连接，但kill不是直接终止线程，只是告诉该线程这条语句不用继续执行了，MySQL会在执行逻辑上打上断点标记，线程执行到该位置，才会判断状态是否是处于被kill状态，然后进行收尾工作，比如释放掉之前持有的锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;慢查询分析&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;打开：&lt;code&gt;set global slow_query_log=&#39;ON&#39;&lt;/code&gt;，临时开启，无需重启，永久开启则在my.cnf文件里设置&lt;/p&gt;
&lt;p&gt;设置日志存放位置：&lt;code&gt;set global slow_query_log_file=&#39;/usr/local/mysql/data/slow.log&#39;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设置超过x秒就会记录到慢查询日志中：&lt;code&gt;set global long_query_time=x;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;查看慢查询相关设置：&lt;code&gt;show variables like &#39;slow_query%&#39;;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;慢查询日志分析工具：mysqlsla、mysqldumpslow&lt;/p&gt;
&lt;p&gt;慢查询日志中，&lt;strong&gt;rows_examined&lt;/strong&gt;字段，表示某个语句执行过程中扫描了多少行&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tech.meituan.com/2014/06/30/mysql-index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL索引原理及慢查询优化&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;存储引擎&#34;&gt;存储引擎&lt;/h1&gt;
&lt;h2 id=&#34;1myisam&#34;&gt;1.MyISAM&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供了大量的特性，包括压缩表、空间数据索引等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持事务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果指定了 &lt;code&gt;DELAY_KEY_WRITE&lt;/code&gt;选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。&lt;/p&gt;
&lt;h2 id=&#34;2innodb&#34;&gt;2.InnoDB&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻读。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;关于有时更新或者查询时突然变慢的原因&lt;/strong&gt;：首先，InnoDB更新采用WAL机制，更新redo log和表数据时都是先写到buffer，再flush到磁盘，原因就是出在flush磁盘上，当redo log满了，或者内存满了，脏页太多，都会将内存里的数据flush到磁盘，以腾出空间，如果要刷的数据特别多，那消耗的时间就长。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置到 &lt;code&gt;innodb_io_capacity&lt;/code&gt; 参数，该参数会告诉InnoDB机器的磁盘能力，可以使用fio工具测出 ；&lt;/li&gt;
&lt;li&gt;控制脏页的比例，设置 &lt;code&gt;innodb_max_dirty_pages_pct&lt;/code&gt; 的值，默认是75%，达到了就会刷；&lt;/li&gt;
&lt;li&gt;. 刷新脏页时是否会递归检测隔壁数据页是否也是脏页，如果是会连着一起刷，通过 &lt;code&gt;innodb_flush_neighbors=1&lt;/code&gt;表示采用这种机制，=0表示只会刷自己，这个机制对机械硬盘关系比较大，SSD则不会；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;关于InnoDB的删除&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;innodb_file_per_table=OFF&lt;/code&gt;：表示表数据放在系统共享表空间，=on表示各个表空间放在独立文件下，后缀名是 .ibd ，一般设置=on，便于管理。&lt;/p&gt;
&lt;p&gt;当我们使用delete删除数据时，InnoDB实际上是把数据页上的该数据标记为删除，表示该位置可以进行复用，此时磁盘上的文件并不会变小，当数据随机插入时会因为页分裂，分裂后的页可能存不满数据，就会标记某些位可复用，导致页的利用率不高，当有大量的增删时，会导致数据页存在大量空洞，为了压缩空间，此时的解决办法是重建表，一般使用&lt;code&gt;alter table [tableName] enging=InnoDB&lt;/code&gt;达到重建的目的，MySQL会自动创建临时表，进行数据转存，交换表名，删除旧表，此时会阻塞，阻止增删改，&lt;strong&gt;5.56版本后使用onlineDDL机制&lt;/strong&gt;，解决了这个问题，解决方法是使用redo log记录新插入的数据 + MDL读锁(写锁会退化) + IO + CPU&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四大特性&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;插入缓冲：使用change buffer，对insert、delete、update、purge都有提升；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;双写机制：InnoDB在将Buffer Pool中的dirty Page脏页刷到磁盘时，会先将dirty page刷到InnoDB tablespace中的一个区域，这个区域称为 Double Write Buffer，该区域大小 2MB ，每次写入 1MB，128个页，每个页16k，其中120个页为后台线程批量刷Dirty Page，还有8个也是为了前台起的single page flash线程，用户可以主动请求使用，迅速提升空余的空间，在向Double Write Buffer写入成功后，第二步是将数据分别刷到一个共享空间和真正应该存在的位置；&lt;/p&gt;
&lt;p&gt;Buffer Pool：解决查询性能问题，作为磁盘的缓存，避免每次查询都从磁盘里读取，提升读写性能；MySQL启动时，InnoDB会为Buffer Pool申请一片连续的内存空间，按照默认的16KB大小划分出一个个页作为缓存页；&lt;/p&gt;
&lt;p&gt;读取数据时，先读Buffer Pool，没有才去读磁盘；写数据时，先修改Buffer Pool中数据所在的页，设置为脏页，由后台线程将脏页写入磁盘（或配合使用change buffer机制）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自适应哈希索引：InnoDB会监控对表上辅助索引页的查询，如果发现建立hash索引可以提升性能，就会在缓冲池建立hash索引，提升查询性能；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;预读：用异步将磁盘中的页读取到Buffer Pool中，预读请求的所有页集中在一个范围内；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;3memory&#34;&gt;3.Memory&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;menory引擎的内存表不同于InnoDB的内部临时表，内存表是库内全局可见，写内存的，而innodb的内部临时表是写磁盘的，同一线程内可见，线程结束就会清空&lt;/li&gt;
&lt;li&gt;默认是hash索引，数据单独存放，索引上保存数据的位置，这种形式称为推组织表，而InnoDB那种 B+树 数结构的则是索引组织表&lt;/li&gt;
&lt;li&gt;InnoDB数据存放是有顺序的，因此有可能会产生空洞，而memory则是有空位就可以存放，因此当数据位置发生变化时，innoDB只需要修改主键索引，而内存表需要修改所有索引（哈希表扩容导致）&lt;/li&gt;
&lt;li&gt;内存表不支持变长数据类型，只能固定字符串长度，即varchar(N)会退化为char(N)&lt;/li&gt;
&lt;li&gt;内存表的索引地位是相等的，而Innodb表分成了主键索引和普通索引&lt;/li&gt;
&lt;li&gt;由于hash索引并不适合索引范围查询，范围查询实际上是全表扫描，如果要支持索引范围查询，需要建立B+树索引&lt;/li&gt;
&lt;li&gt;内存表仅支持表级锁，粒度较大，并发度低&lt;/li&gt;
&lt;li&gt;重启会清空内存表的特性会影响主备复制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;4myisam与innodb引擎区别&#34;&gt;4.MyISAM与InnoDB引擎区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MyISAM是非事务安全；InnoDB是事务安全型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MyISAM的锁是表锁；InnoDB支持行锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MyISAM支持全文索引；InnoDB 5.6版本后才支持&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MyISAM适合 &lt;code&gt;SELECT&lt;/code&gt; 密集型的表；InnoDB适合 &lt;code&gt;INSERT&lt;/code&gt; 和 &lt;code&gt;UPDATE&lt;/code&gt; 密集型的表；MyISM可以直接定位到数据所在的内存地址，直接找到数据，而InnoDB需要维护数据缓存，查询过程中先定位到行所在的数据块，在从数据块中定位到要查找的行，所以查询性能上差于MyISM&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MyISAM表是保存成文件形式，跨平台转移方便&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;InnoDB表比MyISAM表安全&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MyISAM对于不会进行修改的表，支持压缩表，极大减少磁盘空间占用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢；InnoDB因为有redo log，支持安全恢复&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MyISAM不支持外键；InnoDB 支持外键，InnoDB 支持在线热备份&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MyISAM是非聚集索引，使用 B+树 作为索引结构，索引和数据文件是分离的，索引保存的是数据文件的指针（数据的物理地址），所以还要再查一次才能得到数据；&lt;/p&gt;
&lt;p&gt;InnoDB是聚集索引，数据文件是和（主键）索引绑在一起的，即索引 + 数据（数据本身，不是指针） = 整个表数据文件，通过主键索引到整个记录，必须要有主键；辅助索引是以建索引的字段为关键字索引到主键，查询时先查到主键，再通过主键查询到数据；&lt;/p&gt;
&lt;p&gt;即MyISAM的B+树主键索引和辅助索引的叶子节点都是数据文件的地址指针；InnoDB的B+树主键索引的叶子节点就是数据文件，辅助索引的叶子节点是主键的值；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;事务&#34;&gt;事务&lt;/h1&gt;
&lt;h2 id=&#34;1acid原则&#34;&gt;1.ACID原则&lt;/h2&gt;
&lt;p&gt;原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durability）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原子性：事务中的所有操作要么全部提交成功，要么全部失败回滚（undo log保证）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一致性：数据库总是从一个一致性的状态转换到另一个一致性的状态（由AID原则保证）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;隔离性：一个事务所做的修改在最终提交以前，对其他事务是不可见的（MVCC + 锁机制保证）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;持久性：一旦事务提交，则其所做的修改将永久保存到数据库（redo log保证）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2并发情况下带来的问题&#34;&gt;2.并发情况下带来的问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;脏读：如有事务A和B，A读取了B未提交的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;丢失更新：如有事务A和B，AB均写入数据，A写入的数据被B覆盖&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不可重复读：如有事务A和B，A负责读取，B负责写入，A连续读的过程中B写入了一次，A前后两次读出来的数据不一样&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;幻读：如有事务A和B，A修改表内数据的过程中，B向表内插入了一条数据，A修改完后发现数据并没有被全部修改完，或者是在RR隔离级别下，事务A内前后两条相同的SQL带“当前读”查询查回来的数据数不一致；&lt;/p&gt;
&lt;p&gt;另外一种理解是，在RR隔离级别下，事务A，快照读查到数据1不存在，此时事务B插入数据1，事务A继续插入数据1失败，但是查询数据1又不存在，此时也可以说事务A出现幻读；&lt;/p&gt;
&lt;p&gt;还有一种理解是，在RR隔离级别下，事务A，先快照读查询得到两条数据，此时事务B插入数据后，事务A使用当前读，就会读到3条数据了，此时也可以说事务A出现幻读；&lt;/p&gt;
&lt;p&gt;原因是事务A一开始查询时没有带 当前读 导致，因为如果事务A一开始就使用范围当前读，事务B是插不进去的数据1的；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;不可重复读和幻读的区别&lt;/strong&gt;：不可重复读侧重于update，而幻读侧重于insert和delete。不可重复读是在一个事务内前后两次读取的数据不一致，此时数据数量没有变化，重复读取得到的数据不一致，所以叫不可重复读；而幻读是在一个事务内前后两次读取的数据不一致，读的数据量变多或者变少了，这些多了的数据或少了的数据就像幻觉，所以叫幻读&lt;/p&gt;
&lt;h2 id=&#34;3事务隔离级别&#34;&gt;3.事务隔离级别&lt;/h2&gt;
&lt;p&gt;隔离级别就是为了解决上述并发时候带来的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;DEFAULT&lt;/strong&gt;：默认隔离级别，即使用底层数据库默认的隔离级别；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;READ_UNCOMMITTED&lt;/strong&gt;：未提交读，一个事务未提交时，它的变更可以被其他事务看到；&lt;/p&gt;
&lt;p&gt;可能出现 脏读、不可重复读、丢失更新、幻读；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;READ_COMMITTED&lt;/strong&gt;：提交读，一个事务提交之后，它做的变更才会被其他事务看到，保证了一个事务不会 读 到另一个并行事务已修改但未提交的数据；每次select语句都会生成一个新的Read View；&lt;/p&gt;
&lt;p&gt;避免了“脏读”，可能出现不可重复读、丢失更新；&lt;/p&gt;
&lt;p&gt;Oracle默认隔离级别；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;REPEATABLE_READ&lt;/strong&gt;：可重复读，一个事务在执行中看到的数据，总是跟这个事务在启动时看到的数据一致，保证了一个事务不会 修改 已经由另一个事务读取但未提交（回滚）的数据；事务开始时生成一个Read View，整个事务期间都是用整个Read View；&lt;/p&gt;
&lt;p&gt;避免了脏读、不可重复读取、丢失更新，可能存在幻读；&lt;/p&gt;
&lt;p&gt;MySQL默认是此隔离级别；&lt;/p&gt;
&lt;p&gt;针对快照读，即普通的select语句，MySQL通过MVCC解决幻读问题；&lt;/p&gt;
&lt;p&gt;针对当前读，即带for update的select语句，MySQL通过next-key lock解决幻读问题；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SERIALIZABLE&lt;/strong&gt;：序列化,最严格的级别，事务串行执行,即一个事务要等待另一个事务完成才可进行&lt;/p&gt;
&lt;p&gt;效率最差，但也解决了并发带来的那4种问题；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事务A&lt;/th&gt;
&lt;th&gt;事务B&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;启动事务，查询得到值1&lt;/td&gt;
&lt;td&gt;启动事务&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;查询得到值1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;将1改为2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;查询得到的值v1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;提交事务B&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;查询得到的值v2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;提交事务A&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;查询得到值v3&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在不同隔离级别下的答案&lt;/p&gt;
&lt;p&gt;未提交读：v1=2，v2=2，v3=2&lt;/p&gt;
&lt;p&gt;提交读：v1=1，v2=2，v3=2&lt;/p&gt;
&lt;p&gt;可重复读：v1=1，v2=1，v3=2&lt;/p&gt;
&lt;p&gt;串行：v1=1，v2=1，v3=2，且直到事务A提交后，事务B才可以继续执行&lt;/p&gt;
&lt;p&gt;一般避免使用长事务，即在一个事务里做过多操作，长事务会导致回滚日志变大，也会占用锁资源&lt;/p&gt;
&lt;h2 id=&#34;4事务相关命令&#34;&gt;4.事务相关命令&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;显式启动事务，使用begin或strart transaction启动事务，commit提交事务，rollback回滚；&lt;/li&gt;
&lt;li&gt;set autocommit=0，关掉自动提交，任何语句执行都需要显式的提交(主动commit或rollback)才算执行完成；&lt;/li&gt;
&lt;li&gt;set autocommit=1，执行任意一条语句都会默认开启单次事务执行完成后隐式提交，事务也可以显式开启，直到显示使用commit、rollback或断开连接。一般是使用set autocommit=1，开启事务，再commit提交事务，执行commit work and chain则提交事务并开启下一次事务；&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;锁&#34;&gt;锁&lt;/h1&gt;
&lt;h2 id=&#34;锁的分类&#34;&gt;锁的分类&lt;/h2&gt;
&lt;p&gt;根据范围，可以分为全局锁、表级锁、行锁，当多种锁同时出现时，必须得所有锁不互斥，才能并行，否则就得等。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;全局锁&lt;/strong&gt;：对整个数据库实例加锁，命令：&lt;code&gt; Flush tables with read lock&lt;/code&gt;，让整个数据库变成只读，禁止任何ddl、dml语句&lt;/p&gt;
&lt;p&gt;一般用于全库逻辑备份，但有可能造成主从库数据延迟或者业务停摆，不用的话又会导致数据不一致问题，一般这种方式是给不支持 可重复读 事务的引擎使用的，像InnoDB可以在可重复读隔离级别下开启事务读数据，利用MVCC来保证在此期间数据一致，可以不用这种锁；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;表级锁&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一种需要显示启动，比如&lt;code&gt;lock tables t1 read, t2 write;&lt;/code&gt; 表示线程在执行&lt;code&gt;unlock tables&lt;/code&gt;之前，只能读t1，读写t2，其他操作做不了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另一种是 MDL(metadata lock)，不需要显示使用，在访问一个表时自动加上，作用是保证读写正确性，当对一个表内数据做CRUD时，加MDL读锁，当对一个表做结构变更时，加MDL写锁；&lt;/p&gt;
&lt;p&gt;主要用于保护表的元数据，比如字段名等，比如查询和修改表字段的语句同时出现，如果没有MDL锁，就会导致查出来的数据列名有问题。&lt;/p&gt;
&lt;p&gt;MDL锁和表锁时可以同时出现的，比如MyISAM表上更新一行，会加上MDL读锁和表锁；&lt;/p&gt;
&lt;p&gt;读锁间不互斥，读写、写写间互斥，MDL会在事务提交后释放。当需要对热点表做结构变更时，最好在变更语句上加等待时间，避免出现死锁导致整个表无法读写，或者确定没有长事务执行后，再上MDL写锁；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;意向共享锁&lt;/strong&gt; - IS锁：表级锁，表示事务持有表中行的共享锁或者打算获取行的共享锁，仅表示意图，不阻塞其他操作，当事务在获取表中的共享行锁时，需要先获取表中的意向共享锁；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;意向排他锁&lt;/strong&gt; - IX锁：表级锁，表示事务持有表中行的排他锁或者打算获取行的排他锁，仅表示意图，不阻塞其他操作，当事务在获取表中的排他行锁时，需要先获取表中的意向排他锁；&lt;/p&gt;
&lt;p&gt;意向锁的作用主要为了解决遍历整个表来寻找行锁的情况，快速判断表里释放有记录被加锁，比如在alert语句修改表结构的时候使用：&lt;/p&gt;
&lt;p&gt;事务A想修改表T的行R，A获得行R的排他锁，锁住了行R，事务B使用Alter Table语句修改表T的结构，此时需要获取表T的共享锁，由于它不知道表T是否存在行锁，只能去遍历，当表有行锁时，只能等行锁释放才能修改表结构，因为遍历很耗性能，所以需要意向锁来解决这个问题，事务A在获得行R的排他锁时，需要先上表T的共享排他锁，事务B在Alter 表T时就可以直接判断该表是否被上行锁了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;行锁&lt;/strong&gt;：在InnoDB事务中，采用二阶段锁协议，行锁是在事务结束后才释放，在事务过程中，即使一开始用了后面没用到也不会被释放，因此，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放，减少锁的影响时间；&lt;strong&gt;行锁是统称，主要可以细分为共享锁和排他锁这些&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;记录锁&lt;/strong&gt;：行锁，对索引进行锁定，如果是主键索引就会锁一条，但如果是二级索引，就会锁所有匹配的记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;共享锁&lt;/strong&gt; - S锁（SQL + lock in share mode）：行锁，事务T对数据A加上共享锁，其他事务只能对A添加共享锁，不能加排他锁，获取共享锁的事务只能读不能写。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;排他锁&lt;/strong&gt; - X锁（SQL + for update）：行锁，事务T对数据A加上排他锁，则其他事务不能再对A加任何类型的锁。获得排它锁的事务即能读数据又能修改数据。&lt;/p&gt;
&lt;p&gt;与乐观锁和悲观锁的差别：&lt;strong&gt;乐观锁和悲观锁是针对数据操作的一种思想&lt;/strong&gt;，并不是数据库实际存在的锁，只是可以用上面的锁进行实现，乐观锁适合读多写少的场景，悲观锁适合写多读少的场景；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;间隙锁&lt;/strong&gt;：当我们用范围条件而不是相等条件检索数据，并请求共享或排他锁时，InnoDB会给符合条件的已有数据记录的索引项加锁，对于键值在条件范围内但并不存在的记录，叫做间隙锁。&lt;/p&gt;
&lt;p&gt;主要是为了解决幻读问题，只在&lt;strong&gt;可重复读隔离级别下有效&lt;/strong&gt;，一般与行锁一同出现。&lt;/p&gt;
&lt;p&gt;间隙锁也会导致死锁，比如两个事务同时在一段范围内的数据加入间隙锁（&lt;strong&gt;事务间的间隙锁不会冲突&lt;/strong&gt;，可以加成功），又insert或update在这个范围内的数据，就会导致死锁。&lt;/p&gt;
&lt;p&gt;比如有数据 (1, a)(3, c)(4, d)(5,e)，事务A更新c，间隙锁范围为(a, d)，事务B更新e，间隙锁范围为(d, 正无穷)，如果此时事务A插入f，事务B插入b，就会导致死锁。&lt;/p&gt;
&lt;p&gt;另外，&amp;ldquo;间隙&amp;rdquo; 是 由这个间隙右边的记录定义的，也就是说，如果 有索引 c 的值为0，5，10，15，先有事务A查询&lt;code&gt;select c from t where c &amp;gt; 5 lock in share mode&lt;/code&gt;，加锁范围是(5, 10], (10, 15], (15, max]，然后有事务B更新&lt;code&gt;update t set c = 1 where c = 5&lt;/code&gt;，执行成功，此时c的值有 0，1，10，15，再执行&lt;code&gt;update t set c=5 where c=1;&lt;/code&gt;会执行不成功，被blocked住，原因是间隙锁的间隙变成了 [1, 10]，更新失败。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Next-Key 锁&lt;/strong&gt; = 间隙锁(gap lock) + 行锁(record lock)，在可重复读隔离级别下，InnoDB在查找和扫描索引时，都会使用Next-Key锁来防止幻读的发生。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Auto-Inc 锁&lt;/strong&gt;：自增锁，表级锁，比较特殊，当设置键为自增时使用，比如自增主键，在生成自增id时，会先获取相关表的 Auto-Inc 锁，阻塞其他事务的插入操作，保证自增的唯一性。不遵循二阶段锁协议，因为它并不是在事务提交时释放，而是在inset语句执行后释放，即使是在回滚时，自增值也不会减一。&lt;/p&gt;
&lt;p&gt;涉及的参数是 &lt;code&gt;innodb_autoinc_lock_mode&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;=1&lt;/code&gt;时，普通insert语句会执行完之后释放，批量insert时会等到所有批量insert的SQL都结束的时候才释放锁，原因是如果bin log不是row，备库在复制时产生的行的id可能跟主库的不一致问题；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;=2&lt;/code&gt;时，自增id锁每次获取完就会释放，不必等待插入语句执行完，所以如果此时bin log的格式不是row，就会出现主从不一致。&lt;/p&gt;
&lt;p&gt;如果选择=1，在批量insert时性能就会很差，MySQL的优化是让insert的语句不使用连续的自增id，不过这样就会让自增id不连续了，所以一般的操作是选择=2，每条insert就释放，且bin log格式要=row；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;多版本并发控制（MVCC）&lt;/strong&gt;：用来解决读-写冲突的无锁并发控制，为事务分配一个单向增长的时间戳，为每个修改保存一个版本，版本与事务时间戳关联，读操作只读该事务开始前的数据库的快照。MVCC 在语境中倾向于 “对多行数据打快照造平行宇宙”，而 CAS 一般只是保护单行数据而已&lt;/p&gt;
&lt;p&gt;MVCC只在 &lt;strong&gt;提交读 和 可重复读隔离级别下有效&lt;/strong&gt;，保证在读操作不用阻塞写操作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。 对于可重复读，查询只承认在事务启动前就已经提交完成的数据； 对于提交读，查询只承认在语句启动前就已经提交完成的数据;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;MVCC的版本快照，指的是什么呢，而且它是基于整个库的，总不能保存多个版本的库的所有数据吧？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;实际上MVCC得到的快照是逻辑上的数据，是推测出来的，通过当前值，利用事务id和undo log日志，根据日志&amp;quot;回滚&amp;quot;得到各个版本的数据，事务id可以简单理解为对该行数据进行更改时产生的id，当然一个事务内可以对多条数据进行操作，这多条数据的事务id都是相同的&lt;/p&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;p&gt;假如一个值1被按顺序改为2、3、4，每一次更改都会记录在回滚日志(undo log)里，如：将2改为1 -&amp;gt; 将3改为2 -&amp;gt; 将4改为3，当前的值是4，在查询这条记录的时候，不同时刻启动的事务会有不同的视图，比如有视图A（将2改成1）里看到的值是1，即同一条记录在数据库中存在多个版本&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;插入意向锁&lt;/strong&gt;（II Gap）：特殊间隙锁，只有在插入时使用，表示插入的意向，属于行级锁，但不与行级锁冲突，而是&lt;strong&gt;与 间隙锁 和 Next-Key锁 冲突&lt;/strong&gt;，当插入前需要获取插入意向锁，此时会与 Next-Key 锁冲突而阻塞，从而防止幻读。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;可重复读-隔离级别时的加锁规则&#34;&gt;可重复读 隔离级别时的加锁规则&lt;/h2&gt;
&lt;p&gt;唯一索引（主键）的索引树:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;id&lt;/th&gt;
&lt;th&gt;1&lt;/th&gt;
&lt;th&gt;5&lt;/th&gt;
&lt;th&gt;10&lt;/th&gt;
&lt;th&gt;15&lt;/th&gt;
&lt;th&gt;20&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;index&lt;/td&gt;
&lt;td&gt;19&lt;/td&gt;
&lt;td&gt;21&lt;/td&gt;
&lt;td&gt;22&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;td&gt;39&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;非唯一索引的索引树：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;index&lt;/th&gt;
&lt;th&gt;19&lt;/th&gt;
&lt;th&gt;20&lt;/th&gt;
&lt;th&gt;21&lt;/th&gt;
&lt;th&gt;22&lt;/th&gt;
&lt;th&gt;39&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;id&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;15&lt;/td&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;20&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;查询过程中扫描到的行才会加锁，&lt;strong&gt;锁的基本单位是next-key lock（左开右闭），间隙锁是左开右开&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;唯一索引（主键）等值查询&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;记录存在，退化成行锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;记录不存在，会在找到该等值的 前后 遇到的第一个存在的数据的这段范围加上间隙锁（左开右开）；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;唯一索引（主键）范围查询：会对每个扫描到的索引加next-key锁，遇到下面情况会退化成间隙锁或者行锁；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;大于，对扫描到的索引加next-key锁（左开右闭）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如有记录id：1，5，10，15，20，查询id&amp;gt;15，记录存在，加锁区间是 (15, 20], (20, +∞]&lt;/p&gt;
&lt;p&gt;记录不存在，查询 id &amp;gt; 14，加锁区间是 (10, 15], (15, 20], (20, +∞]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;大于等于（此时不管条件里有没有小于），等值的记录加行锁，大于该值的记录会进行扫描，扫描到第一个不满足条件的值（也是对应存在的行，不管小于），加next-key lock（左开右闭）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如有记录 id：1，5，10，15，20，查询 id&amp;gt;=10 and id &amp;lt;11，加锁区间是 [10], (10, 15]&lt;/p&gt;
&lt;p&gt;记录存在，查询 id &amp;gt;= 15，加锁区间是 [15], (15, 20], (20,  +∞)&lt;/p&gt;
&lt;p&gt;记录不存在，查询 id &amp;gt;= 14，加锁区间是 (10, 15], (15, 20], (20, +∞]&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;小于或小于等于，且记录不存在，先扫描到的记录，还是加next-key锁，扫描到终止范围查询的记录时，该记录的索引的next-key锁会退化成间隙锁（左开右开）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如有记录 id：1，5，10，15，20，查询 id&amp;lt;6，锁的区间是 (-∞, 1], (1, 5], (5, 10)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;小于，且当记录存在时，next-key lock会退化成间隙锁（左开右开）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如有记录 id：1，5，10，15，20，查询 id&amp;lt;5，锁的区间是 (-∞, 1], (1, 5)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;小于等于，且记录存在时，扫描到终止范围查询的记录时，加next-key锁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如有记录 id：1，5，10，15，20，查询 id&amp;lt;=5，锁的区间是 (-∞, 1], (1, 5]&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非唯一索引等值查询&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;记录存在，需要访问该等值的左边到右边第一个不满足条件的值，这个范围加上间隙锁（左开右开，中间包含该等值）；然后还要对这些扫描到的非唯一索引记录对应的主键索引加锁；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如有非唯一索引：19，20，21，22，39，查询 index=22的，锁的区间是 (21, 22], (22, 39)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;记录不存在，需要访问该等值的左边到右边第一个不满足条件的值，这个范围加上间隙锁（左开右开），因为不存在满足查询条件的记录，所以不用对主键索引加锁；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;虽然主键索引没加锁，但是，左右两边的值，还是会存在插入失败的情况，因为插入语句在插入一条记录之前，需要定位到该记录在B+树的位置，如果插入的位置的下一条记录的索引上有间隙锁，会发生阻塞；&lt;/p&gt;
&lt;p&gt;此时对应区间左右两边的值，虽然是开区间，但是在插入时，要判断插入的主键索引，是否在非唯一索引间隙锁对应的主键的范围内；&lt;/p&gt;
&lt;p&gt;比如有非唯一索引：19，20，21，22，39，查询 index=25，锁的区间是 (22, 39)，假如index=22对应的主键索引为10，index=39对应的主键索引为20，此时如果要插入index=22，id=3的记录，会插入失败，因为id=3的下一条是id=10，同理，插入index=22，id=12的也会失败，因为下一条id=20&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非唯一索引范围查询&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;范围查询都需要访问到第一个不满足条件的值为止，在这个范围加next-key锁（左开右闭），然后还要对这些扫描到的非唯一索引记录对应的主键索引加锁；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;比如有非唯一索引：19，20，21，22，39，查询 index&amp;gt;=22，锁的区间是 (21, 22], (22, 39], (39, +∞]，同时，会对index=22，39的记录加行锁；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;锁是加在索引上的，先对where条件上的用到的索引加锁，再对该行上存在的索引依次加锁&lt;/strong&gt;。比如有表A，索引为id、a、b，当update时的条件是where a=xx时，会对索引a、id、b的顺序加锁；&lt;strong&gt;间隙锁只会加在where条件中的索引上&lt;/strong&gt;，对于该索引定位到的行加的是行锁，但对于主键索引加锁的时候，只有满足查询条件的记录才会对它的主键索引加锁；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;select加的锁，如果查询的列刚好是满足覆盖索引，且覆盖索引不包括其他索引，则只会锁where条件上的索引；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以上规则需要组合起来使用，&lt;strong&gt;InnoDB会对扫描过的行都加上行锁和间隙锁，所以如果查询条件不是索引，就会全表扫描，并对扫到的行主键上锁，表现出来就是锁表了&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在InnoDB中，一般设置&lt;code&gt;innodb_thread_concurrency&lt;/code&gt;的值在64~128之间，=0表示不限制并发线程数量，这里的并发线程数量指的是并发查询数量，并发连接数量可以有上千个，但是并发查询数量不能太多，否则太耗CPU资源，另外，在查询进入锁等待时，并发查询数量会减一，不计入并发查询数量里，select sleep(秒)则会计入。&lt;/p&gt;
&lt;p&gt;对于update或delete语句，可以设置参数 &lt;code&gt;sql_safe_updates=1&lt;/code&gt; 此时，语句只有使用了where，且where条件中必须包含索引列，或者使用了limit，或者同时使用where和limit（此时where不要求有索引条件），才允许执行，如果优化器最终还是选择扫描全表，就需要使用&lt;code&gt;fore index([index名称])&lt;/code&gt;强制使用索引了。&lt;/p&gt;
&lt;h2 id=&#34;关于死锁&#34;&gt;关于死锁&lt;/h2&gt;
&lt;p&gt;当线程出现循环资源依赖，导致多个线程互相等待的状态称为死锁，解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置超时时间 &lt;code&gt;innodb_lock_wait_timeout&lt;/code&gt;，在InnoDB中默认是50s&lt;/li&gt;
&lt;li&gt;死锁检测，当发现死锁后，主动回滚死锁链条中的某一个事务，设置&lt;code&gt;innodb_deadlock_detect=on&lt;/code&gt;，默认值是on&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般使用第二种，但死锁检测会消耗大量CPU资源，主要发生在对同一行进行更新的检测上，其算法是O(n)，虽然在同一行更新不会造成死锁，但是当并发很高时进行检测时就会消耗大量CPU资源，解决方案有两种，一种是在中间件或者MySQL server层上，增加对同一行更新的判断，进行排队，或者将那一行改为逻辑上的多行，来分散压力，因此对同一组资源，尽量以相同的顺序访问。&lt;/p&gt;
&lt;h2 id=&#34;关于对表进行ddl语句加字段索引时是否锁表&#34;&gt;关于对表进行DDL语句（加字段、索引）时是否锁表&lt;/h2&gt;
&lt;p&gt;加字段：&lt;code&gt;alter table {表名} add column {列名} {类型} default {默认值} comment {注释} after {排在哪个字段后}&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;加索引：&lt;code&gt;alter table {表名} add index {索引类型，比如unique、primary} {索引名} (字段1, 字段2)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;以加字段为例子：&lt;/p&gt;
&lt;p&gt;MySQL5.6以前的给表加字段时会锁表，在此期间只能读，加字段的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对原始表加MDL写锁，&lt;strong&gt;禁止读写&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;按照原始表和执行语句的定义，重新创建一个空的临时表；&lt;/li&gt;
&lt;li&gt;为临时表添加索引；&lt;/li&gt;
&lt;li&gt;将原始表种的数据逐条copy到临时表中；&lt;/li&gt;
&lt;li&gt;当原始表的所有数据都被copy到临时表后，将原始表删除，临时表更名为原始表表名，&lt;strong&gt;允许读写&lt;/strong&gt;；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果5.6之前的版本要加字段，可以使用pt-osc来实现，本质上也是创建临时表，然后copy数据的过程中通过触发器触发临时表上数据的修改，最后删除原始表并更名而已。&lt;/p&gt;
&lt;p&gt;MySQL5.6之后新增Online DDL功能，使得表不可用的时间减少，或者说让表在被修改时仍然能正常操作，加字段时的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对原始表加MDL写锁，&lt;strong&gt;禁止读写&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;按照原始表和执行语句的定义，重新创建一个空的临时表，并申请rowlog空间，然后便&lt;strong&gt;允许读写&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;拷贝原始表的数据到临时表，此时表数据的CUD操作都会放在rowlog中，此时客户端仍然可以进行操作；&lt;/li&gt;
&lt;li&gt;原始表数据全部拷贝完成后，会将rowlog中的改动同步到临时表中，此时客户端不可操作；&lt;/li&gt;
&lt;li&gt;当原始表中的数据都被copy到临时表后，并且copy期间客户端的所有CUD操作都同步到临时表后（&lt;strong&gt;同步copy期间的操作禁止读写&lt;/strong&gt;），原始表删除，临时表更名为原始表表名；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以其实Online DDL也会锁表的，只是锁表的时间特别短，几乎可以全程允许读写。&lt;/p&gt;
&lt;p&gt;要注意当表的数据量比较大时，不要设置default值，如果字段带有default值，MySQL会在执行完Online DDL后，对整个表该新增字段更新默认值，导致锁表。&lt;/p&gt;
&lt;p&gt;在对索引进行添加和删除时也是类似的步骤，只是不是使用copy的方式，而是改成了in-place方式，不需要复制数据，而是将copy的操作改成按照聚簇索引的顺序查询数据，找到需要的索引列数据，排序后插入新的索引页中。&lt;/p&gt;
&lt;p&gt;5.6版本之后copy和in-place就都对增删字段、索引时都可用。&lt;/p&gt;
&lt;p&gt;参考：https://segmentfault.com/a/1190000041149544&lt;/p&gt;
&lt;h2 id=&#34;关于事务可见性的疑问&#34;&gt;关于事务可见性的疑问&lt;/h2&gt;
&lt;p&gt;在可重复读的隔离级别下，事务A开启，操作数据D，此时会创建一个当前数据D的视图(MVCC)，但此时又刚好有事务B，已经操作到这条数据，并给这条数据加了行锁，对这条数据进行操作，事务B操作完成后，释放数据D的行锁，那之前的事务A在最终修改操作数据D时，数据D的值是什么呢？&lt;/p&gt;
&lt;p&gt;假如一开始k的值是1，autocommit=1，即单独一条SQL执行本身就是一个事务，会自动提交&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;另外，事务中的begin / start transaction命令，是以执行它们之后的第一个sql语句为启动开始事务，而start with consisten snapshot是以这条命令为起点开启事务&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;事务A&lt;/th&gt;
&lt;th&gt;事务B&lt;/th&gt;
&lt;th&gt;事务C&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;start transaction with consisten snapshot;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;start transaction with consisten snapshot;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;update t set k = k + 1 where id = D&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;update t set k = k + 1 where id = D;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;select K from t where id = D;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;select k from t where id = D;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;commit;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;commit;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;上面这道题的答案是 事务A查到k的值分别是1，事务B查到k的值是3&lt;/p&gt;
&lt;p&gt;原因：事务A之所以查到的值是1，是因为事务A开启时，事务B和C还没开启，此时的快照k=1，因此得到的值是1。事务B查到k的值是3，虽然事务C是在事务B之后开启的，感觉看不到事务C修改后的值，但是由于更新操作是先读后写的，此时的读是&lt;strong&gt;当前读&lt;/strong&gt;（当前读总是读该已提交的数据的最新版本），而当前读的值是2，因此更新后k的值是3，如果不这么做，就会导致事务C更新丢失，而在同一个事务内读值，是可以读到由当前事务修改的值的，所以事务B读到的值是3。普通select语句，在可重复读情况下，为了实现一致性读，是通过读undo log实现的，如果undo log太长（可能因为更新次数太多），会导致查的很慢&lt;/p&gt;
&lt;p&gt;题外话，如果事务A读的时候加锁，就会变成当前读，例如将事务A的select语句后面加上lock in share mode（共享锁）或者for update（排他锁），那么查到的值就是3了。如果事务B在执行更新前先select了，查到的值也是1。如果事务C是显式启动事务，在事务B select后commit前才执行commit操作，就会触发二阶段锁协议，两条更新语句同时更新一行数据，先执行的语句会对这条数据加行锁，所以事务B需要等到事务C提交后，才能执行更新操作&lt;/p&gt;
&lt;p&gt;这个问题的关键在于要理解 MVCC原理，更新操作前的当前读，事务的隔离级别，一致性读、行锁&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/crazylqy/p/7611069.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Mysql加锁过程详解（1）-基本知识&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/leedaily/p/8378779.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Mysql中的锁机制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tech.meituan.com/2014/08/20/innodb-lock.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Innodb中的事务隔离级别和锁的关系&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;大表优化&#34;&gt;大表优化&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000006158186&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL大表优化方案&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;大表建立索引&#34;&gt;大表建立索引&lt;/h2&gt;
&lt;p&gt;当表的数据量很大，并且TPS也很高时，建立索引或者修改表结构会很慢，甚至出现死锁。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;方案1：创建一张与原表结构相同的新表，在新表上创建索引，将原表改名，新表改成原表的名字，让新表承担业务，然后为老表新增索引，完了之后再交换表名，再将新表产生的数据导入到原表中。&lt;/p&gt;
&lt;p&gt;但是这种方式有个问题是如果要对老表的数据进行删改，会产生数据丢失，此过程可以通过建立触发器解决，有Percona Toolkit工具就可以自动完成上述过程，并且保证数据删改不丢失。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方案2：在业务空闲的时候，在从库上的表建索引，等待主库和从库同步位点一致，切换主从即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;大量数据删除&#34;&gt;大量数据删除&lt;/h2&gt;
&lt;p&gt;大量删除时，会锁表，业务高峰时还会CPU暴涨，导致数据库性能下降&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;方案1：删除大表的多行数据时，会超出InnoDB block table size的限制，要做的就算减少锁表的时间，可以选择不需要删除的数据，存到一张同名的空表里，重新命名原始表，新表使用原表名，删除原始表&lt;/li&gt;
&lt;li&gt;方案2：将批量删除的任务拆分成N个小删除任务，异步执行&lt;/li&gt;
&lt;li&gt;方案3：删除表上的索引，再删除数据，提升删除效率&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cpu或io过高可能的原因&#34;&gt;CPU或IO过高可能的原因&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;慢查询导致CPU飙升，QPS不高，查询效率低，需要扫描大量数据才能出结果导致，这种时候一般是&lt;code&gt;show processlist&lt;/code&gt;查看当前执行的查询，kill掉慢查询对应的id&lt;/li&gt;
&lt;li&gt;慢查询，磁盘故障，不合理的配置+大量增删改导致IO升高，一般结合&lt;code&gt;performance_schema&lt;/code&gt;查看MySQL各项指标，查看刷盘相关的参数配置是否合理，比如&lt;code&gt;sync_binlog&lt;/code&gt;之类的&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分库分表&#34;&gt;分库分表&lt;/h2&gt;
&lt;p&gt;主要是为了解决数据量太大导致查询慢（一般可以分表，主从分离），还有高并发问题（一般是分库）。&lt;/p&gt;
&lt;p&gt;分表时一般分为水平拆分（对行，即数量，比如根据id哈希分散到不同的表）和垂直拆分（对列，即拆字段，或者直接将某些表独立成库）&lt;/p&gt;
&lt;h2 id=&#34;分片算法&#34;&gt;分片算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时间分片、范围分片，但容易产生热点问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哈希分片，针对某一列做哈希取模，平均分配到各个分表中，如果要扩容，由于模会变，导致数据要重新哈希，停机迁移数据，这样是不行的，因此一开始要设计好，例如使用一致性哈希算法，减少迁移的数据量；&lt;/p&gt;
&lt;p&gt;或者分表的时候取2的n次方，这样扩容的时候也以2的n次进行扩容，这样原来的key重新取模是在原来的位置或者原来的2倍；或者换个数据库了，像上面大表优化里面提到的那样。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查表法，先通过分片映射表查到要查询的分片，再到对应的分片进行查询，但是要二次查询，即使上缓存，查询性能也是一般。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;sharding-key选择问题&#34;&gt;Sharding Key选择问题&lt;/h2&gt;
&lt;p&gt;一般是使用最常用的查询条件做分片key；&lt;/p&gt;
&lt;p&gt;当分库分表遇到Sharding Key冲突时，只能选择冗余数据了，或者通过将多个列组合成一个新的列来标识，或者建立映射表；&lt;/p&gt;
&lt;p&gt;分片之后，count之类的计数就只能用一张表单独存或者记录在Redis中了，不然就只能所有分片扫一次；&lt;/p&gt;
&lt;h1 id=&#34;数据部分&#34;&gt;数据部分&lt;/h1&gt;
&lt;p&gt;MySQL一般的集群架构是 有两台MySQL实行双Master部署，进行主备复制，注意要把备用的master的主备复制关闭，避免循环复制，另外会部署一些机子作为从库，以其中一台master为主库进行部署&lt;/p&gt;
&lt;h2 id=&#34;数据存储和恢复&#34;&gt;数据存储和恢复&lt;/h2&gt;
&lt;p&gt;只要redo log 和 bin log能够持久化到磁盘，就能确保MySQL异常重启后，数据就可以恢复&lt;/p&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;bin log的写入机制：事务执行过程中，先把日志写进bin log cache，事务提交时，再把bin log cache写进bin log文件（先写到文件系统的page cache，再进行持久化）中，然后把bin log cache清空。&lt;/p&gt;
&lt;p&gt;bin log cache每个线程自己维护，bin log的写入是一个顺序操作；&lt;/p&gt;
&lt;p&gt;bin log cache的大小通过&lt;code&gt;binlog_cache_size&lt;/code&gt;控制，如果超过就暂存到磁盘；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;redo log写入机制：原理与bin log类似，但是它是二阶段提交，有状态，事务执行过程中，redo log先是prepare状态，写入redo log buffer，再写bin log，提交事务，变为redo log commit状态；&lt;/p&gt;
&lt;p&gt;redo log buffer全局共用，与bin log cache不同；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般会把&lt;code&gt;sync_binlog&lt;/code&gt;和&lt;code&gt;innodb_flush_log_at_trx_commit&lt;/code&gt;都设置为1，即一个事务完整提交前，会刷两次盘。另一种设置是让&lt;code&gt;sync_binlog=1000&lt;/code&gt;和&lt;code&gt;innodb_flush_log_at_trx_commit=2&lt;/code&gt;，一般是在主备复制存在很大延迟时，为了让从库的备份速度跟上主库；&lt;/p&gt;
&lt;p&gt;为了提高刷盘效率，MySQL一般会让多个事务在一段时间内完成，或尽量让page cache里的redo log和bin log组合在一起提交，减少刷盘次数；&lt;/p&gt;
&lt;h2 id=&#34;主从复制&#34;&gt;主从复制&lt;/h2&gt;
&lt;p&gt;一般从库设置为read only，可以避免主从切换过程的双写，实现的是最终一致性。&lt;/p&gt;
&lt;h3 id=&#34;原理-1&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;利用MySQL中的bin-log二进制文件，该文件记录了所有sql信息，主数据库会主动把bin-log文件发送给从数据库，在从数据库的relay-log重放日志文件中利用这些信息进行恢复。&lt;/p&gt;
&lt;p&gt;bin log分为三种格式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;statement：记录每次执行的SQL，但由于索引选择问题或者SQL语句使用聚合函数，有可能会导致主从不一致的问题&lt;/li&gt;
&lt;li&gt;row：记录的是事件，表示每条SQL语句执行后的数据信息，比如delete操作后，会记录delete事件和delete删除的行的所有字段(可设置为记录所有字段或者只记录主键)；update操作会记录行数据前后的记录；insert操作会记录insert的所有字段信息，缺点是占空间，但对数据的恢复有利&lt;/li&gt;
&lt;li&gt;mix（混合上面两种）：由MySQL自己判断，如果会出现主从不一致，就使用row，否则使用statement&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;bin log上会记录每台机子的server id，用于避免循环复制&lt;/p&gt;
&lt;h3 id=&#34;具体步骤&#34;&gt;具体步骤&lt;/h3&gt;
&lt;p&gt;每个MySQL数据库上都有这三个线程，&lt;strong&gt;默认是主服务器写完bin log后就算事务成功，bin log复制是异步执行。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;binlog 线程&lt;/strong&gt; ：负责将主库上的数据更改写入bin log，之后事务线程提交事务，响应成功给客户端。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;I/O 线程&lt;/strong&gt; ：负责从主库上读取bin log，并写入从库的重放日志（relay log）中，主库也会创建一个log dump线程来异步发送bin log给从库；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SQL 线程&lt;/strong&gt; ：在从库里，负责将读取到的relay log日志并重放其中的 SQL 语句。MySQL 5.6前只支持单线程，5.6后改为多线程，SQL线程分为container对事务进行分发，调度不同的worker线程进行执行，分发策略：1、更新同一行的两个事务，必须被分发到同一个worker；2、同一个事务不能被拆开，必须在同一worker中执行&lt;/p&gt;
&lt;p&gt;从库在同步bin log时，必须保证bin log的顺序，才能确保数据一致性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/MySQL%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/MySQL%e4%b8%bb%e4%bb%8e%e5%a4%8d%e5%88%b6.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;MySQL主从复制&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;MySQL主从复制&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;默认情况下，由于是异步复制，无法保证数据第一时间复制到从库上，但如果采用同步复制，即等从库复制完主库的bin log后才响应给客户端，性能就太差了。&lt;/p&gt;
&lt;p&gt;在MySQL 5.7后的版本，增加&lt;strong&gt;半同步复制&lt;/strong&gt;(Semisynchronous Replication)，事务线程不用等到所有都复制成功才响应，只要一部分复制响应回来后即可响应给客户端，比如一主二从，等一从成功即可成功。配置&lt;code&gt;rpl_semi_sync_master_wait_no_slave&lt;/code&gt;表示至少等待多少个从库复制成功才算成功。&lt;code&gt;rpl_semi_sync_master_wait_point&lt;/code&gt;表示主库执行事务的线程是提交事务前等待复制(默认)，还是提交事务之后等待复制&lt;/p&gt;
&lt;h3 id=&#34;主备延迟&#34;&gt;主备延迟&lt;/h3&gt;
&lt;p&gt;当备库重放日志的速度小于主库产生bin log的速度，会出现主备延迟，可能的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主备机器配置不一致，备库机器性能较差&lt;/li&gt;
&lt;li&gt;备库压力大，比如在备库上进行SQL分析、大量查询、大表的DDL，主库上的长事务操作等，消耗大量CPU资源导致&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;默认情况下，异步复制也会带来的读延时问题，可以采取 一主多从，主写从读，分散压力；利用好缓存中间件；持久化层的处理。&lt;/p&gt;
&lt;p&gt;在MySQL 5.6后的版本，可以设置&lt;code&gt;slave_parallel_workers&lt;/code&gt;来决定从库在进行重放时工作的线程数，一般设置在8~16，以通过并行重放的目的加快主从复制速度。&lt;/p&gt;
&lt;p&gt;当MySQL集群搭建采用一主多从时，最好采用GTID模式来实现一主多从的切换。&lt;/p&gt;
&lt;h3 id=&#34;主备切换策略&#34;&gt;主备切换策略&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;可靠性优先：前提，备库是只读的，首先，备库持续判断与主库同步间的延迟时间，如果小于可接受的值，主库改为只读，主库等待备库同步延迟时间降为0，备库改为可读写，业务切换到备库，业务不可写的时间取决于主库等待备库同步数据的延迟时间&lt;/li&gt;
&lt;li&gt;可用性优先：步骤与上面的类似，只是主库改为只读后，不等待备库同步完数据，就切到备库，此时数据会不一致，后面再自己根据bin log手动调整更正&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;MySQL的高可用（通过主库发生故障时切到从库），是依赖主备复制的，主备延迟时间越小，可用性越高&lt;/p&gt;
&lt;h3 id=&#34;库内表的复制&#34;&gt;库内表的复制&lt;/h3&gt;
&lt;p&gt;将一张表里的数据导出到文件，再写回原表，以下两种方式都可以跨引擎&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用mysqldump，将表里的数据转成insert语句&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;mysqldump -h$host -P$port -u$user --add-locks = 0 --no-create-info --single-transaction --set-gtid-purged = OFF db1 t --where =&amp;quot;a&amp;gt;900&amp;quot; --result-file =/client_tmp/t.sql

– single-transaction：，在导出数据的时候不需要对表db1.t加表锁，而是使用STARTTRANSACTIONWITHCONSISTENTSNAPSHOT的方法；
– add-locks：设置为0，表示在输出的文件结果里，不增加&amp;quot;LOCKTABLEStWRITE;&amp;quot;；
– no-create-info：不需要导出表结构；
– set-gtid-purged=off：不输出跟GTID相关的信息；
– result-file：指定了输出文件的路径，其中client表示生成的文件是在客户端机器上的。
- skip-extended-insert：将每行数据输出成一条SQL语句

使用mysql -h$host -P$port -u$user $db -e &amp;quot;source /client_tmp/ t.sql&amp;quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;导成CSV文件，在select语句后面加上&lt;code&gt;into outfile `filepath` &lt;/code&gt;，使用&lt;code&gt;load data infile `filepath/filename` into table $db.$table&lt;/code&gt;，该语句也会被传到备库，如果备库没有该文件就会报错，因此在执行完该语句后，还要再执行&lt;code&gt;load data local infile `filepath/filename` into table $db.$table&lt;/code&gt;，另外，该语句不会导出表结构，表结构需要另外导出&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;读写分离&#34;&gt;读写分离&lt;/h3&gt;
&lt;p&gt;主数据库负责写，从数据库负责读，从而缓解锁的争用、节约系统开销，提高并发量&lt;/p&gt;
&lt;p&gt;读写分离常用代理方式来实现，应用层不需要感知后端的MySQL集群部署结构，直接访问代理层，代理层接收应用层传来的读写请求，然后决定转发到哪个MySQL&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;由于主从库之间可能发生主备延迟，导致在查从库的结果会慢于主库，解决方法&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将查询请求分类，对查询结果严格的请求直接发到主库上&lt;/li&gt;
&lt;li&gt;查询前先进行sleep操作（性能不好）&lt;/li&gt;
&lt;li&gt;等主库位点方案：在从库使用命令 &lt;code&gt;select master_post_wait(file, pos[ , timeout])&lt;/code&gt;，参数file和pos指主库上的文件名和位置，timeout表示等待时间，正常的返回结果是一个正整数M，表示从命令开始执行到应用完file和pos表示的bin log位置，执行了多少事务，即如果M &amp;gt;=0 ，表示从库已与主库同步，可以接受查询，如果等待超过了timeout时间，就去查主库&lt;/li&gt;
&lt;li&gt;GTID方案：与等主库位点方案类似，都是要知道命令执行过程中事务执行的数量，使用命令 &lt;code&gt;select wait_for_executed_gtid_set(gtid_set, 1)&lt;/code&gt;，参数gtid_set表示从库执行的事务是否包含该gtid_set，包含返回0，说明主从已同步过，可以执行查询，超时返回1，超时则查主库。该方案的难点在于gtid_set的获取，需要修改MySQL代码，让其在事务提交后返回gtid值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;分区表&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;建立分区表语句，demo是以范围做分区的，也可以使用hash分区、list分区&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;k&#34;&gt;CREATE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;TABLE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ftime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;datetime&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;NOT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;11&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;DEFAULT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;NULL&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;KEY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ftime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;`&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ENGINE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;InnoDB&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;DEFAULT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CHARSET&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;latin1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RANGE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;YEAR&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ftime&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;	&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p_2017&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LESS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;THAN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2017&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ENGINE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;InnoDB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p_2018&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LESS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;THAN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2018&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ENGINE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;InnoDB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p_2019&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LESS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;THAN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2019&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ENGINE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;InnoDB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PARTITION&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;p_others&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;VALUES&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;LESS&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;THAN&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;MAXVALUE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ENGINE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;InnoDB&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分区表会按分区存储在对应的文件里，第一次访问这张表时，MySQL会对所有分区表的文件进行打开操作，但是打开文件的个数是有限制的，如果分区表太多，会导致SQL语句无法执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分区表对于server层来说是一张表，DDL操作时会对所有分区表上锁，导致后面落到具体分区表的语句阻塞&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分区表对于引擎层来讲是多张表，因此在进行一些DML语句时，只会在对应分区表加间隙锁，不会影响其他分区表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;alter table $tableName drop partition xxx&lt;/code&gt;用于删除分区表，与drop 整张普通表类似，但是速度快，因为只删除了部分数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在跨分区查询数据时，会比普通表慢&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/a8457013/p/7819018.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL主从复制&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;mysql健康状态检测&#34;&gt;MySQL健康状态检测&lt;/h2&gt;
&lt;p&gt;当MySQL的查询并发数满了之后，会导致不可用，后面的操作都会被阻塞&lt;/p&gt;
&lt;h3 id=&#34;检测方法&#34;&gt;检测方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;查询检测：在系统库里建一张表，比如叫health_check，里面只放一个数据，然后定期执行&lt;code&gt; select * from mysql.health_check;&lt;/code&gt; 判断执行的SQL语句是否不可用，当语句超时则表示不可用&lt;/li&gt;
&lt;li&gt;更新判断：由于当磁盘满了之后，MySQL仍然可读，但是bin log却写不进去，导致更新语句和事务 commit会被阻塞，在上面表的基础上，增加一个timestamp字段，每台MySQL的serverId作为主键插入表中，MySQL每次执行把当前时间更新到对应的行上，&lt;code&gt;update mysql.health_check where server_id=xx set t_modified = now(); &lt;/code&gt;主备都需要开启检测。当语句执行超时时表示不可用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于每个执行请求都有可能获得IO资源，所以有时检测请求执行成功了，但是此时系统资源即将被耗尽了，已经可以进行主备切换了，但是仍然要在下次检测才能知道，因此需要判断多每次IO请求的时间，通常是检测(select)performance_schema表的信息&lt;/p&gt;
&lt;h2 id=&#34;高可用方案mha&#34;&gt;高可用方案MHA&lt;/h2&gt;
&lt;p&gt;MHA是一套保证MySQL实现故障切换和主从提升的高可用解决方案，故障切换时能在30s内自动完成，最大程度的保证数据一致，支持跨存储引擎，对原有MySQL库无性能影响，整个故障转移过程对应用程序完全透明。&lt;/p&gt;
&lt;p&gt;MHA里有两个角色一个是MHA Node（数据节点）另一个是MHA Manager（管理节点）。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MHA Manager可以单独部署在一台独立的机器上管理多个master-slave集群，也可以部署在一台slave节点上。&lt;/li&gt;
&lt;li&gt;MHA Node运行在每台MySQL服务器上，MHA Manager会定时探测集群中的master节点，当master出现故障时，它可以自动将最新数据的slave提升为新的master，然后将所有其他的slave重新指向新的master。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/MySQL_MHA_%e6%9e%b6%e6%9e%84.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/MySQL_MHA_%e6%9e%b6%e6%9e%84.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;MHA架构&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;MHA架构&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;MHA方案采用半同步复制的方式，所以MySQL的版本要求至少是5.5，半同步复制机制保证master出问题的时候，至少有一台slave的数据是完整的，但在超时的情况下也会临时切换异步复制，保障业务的正常使用，直到一台slave追上同步进度，再继续切换成半同步复制模式。&lt;/p&gt;
&lt;p&gt;MHA还可以修复多个slave之间的日志差异，使得所有salve的数据保证数据最终一致性，保证至少可以从中选出一个master。&lt;/p&gt;
&lt;h3 id=&#34;故障转移流程&#34;&gt;故障转移流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;MHA验证复制设置以及确认当前master状态&lt;/li&gt;
&lt;li&gt;监控master，检测到master宕机&lt;/li&gt;
&lt;li&gt;再次验证slave的配置&lt;/li&gt;
&lt;li&gt;开始恢复一台新master&lt;/li&gt;
&lt;li&gt;从宕机的master节点上通过SSH保存其bin log到Manager&lt;/li&gt;
&lt;li&gt;根据配置文件来选举出新的master，或者将含有数据同步最新位点的slave提升为master&lt;/li&gt;
&lt;li&gt;根据老master bin log生成差异日志，应用到新master上&lt;/li&gt;
&lt;li&gt;将其他的slave连接到新的master进行复制&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;快速切换master流程&#34;&gt;快速切换master流程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;MHA验证复制设置以及确认当前master状态&lt;/li&gt;
&lt;li&gt;确认新的master&lt;/li&gt;
&lt;li&gt;停止当前master的写操作&lt;/li&gt;
&lt;li&gt;等待其他slave追上当前master，直到数据复制进度无延迟&lt;/li&gt;
&lt;li&gt;确保新master可写&lt;/li&gt;
&lt;li&gt;让其他slave指向新master&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;其他&#34;&gt;其他&lt;/h1&gt;
&lt;h2 id=&#34;自增主键&#34;&gt;自增主键&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;自增id不一定是连续的，可能会产生空洞；比如 插入操作出现唯一键冲突，自增值也会+1；事务回滚时，自增值不会回滚；&lt;/li&gt;
&lt;li&gt;MyISAM自增id的下一个值是存在表结构里的，InnoDB是放内存的，在MySQL 8.0以前，自增值并不会持久化到磁盘，每次重启后，自增值会被清空，在第一次读表的时候会把最大id给读出来+1，达到恢复原来的自增值；8.0后是记录在redo log里，重启后通过持久化的值来恢复；&lt;/li&gt;
&lt;li&gt;自增的两个重要参数&lt;code&gt;auto_increment_offset&lt;/code&gt;和&lt;code&gt;auto_increment_increment&lt;/code&gt;都是系统参数，默认值为1；&lt;/li&gt;
&lt;li&gt;理论上自增id是无限的，但是因为字段的类型已经限定了最大的位数，比如如果id使用unsigned int是4个字节，上限就是2^32 -1，当达到上限后，自增值不变，就会导致报重复主键的错，所以如果表的上限需要比较大，需要设置成unsigned bigint；&lt;/li&gt;
&lt;li&gt;如果没有明确设置主键，innoDB会默认给一个row_id，虽然实际上是一个unsigned bigint，但是只用到了6个字节，所以长度是0 ~ 2^48-1，子增值达到上限后的下一个值是0，此时再insert会覆盖原有的行；&lt;/li&gt;
&lt;li&gt;当产生唯一键冲突时，除了会报错，还会加锁（主键+行锁，普通索引+间隙锁），然后在回滚时才释放，当出现唯一键冲突时，如果有多个事务同时插入，容易造成死锁（双方都在等待对方的间隙锁释放导致）；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;insert into ... on duplicate key update ... &lt;/code&gt;，表示插入一行数据，如果出现唯一键冲突，就执行后面的update语句，该更新语句只会修改跟第一个索引冲突的行；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;xid&#34;&gt;Xid&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Xid是 server层维护，表示一个事务id，存在bin log中，可以作为bin log和redo log中同一事务的关联id，让innoDB事务和server层做关联。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由全局变量global_query_id赋给Query_id，Query_id+1后赋值给Xid，作为事务开始的第一条语句的id。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于global_query_id是内存变量，MySQL重启后会被清零，但是重启后会生成新的bin log，所以同一bin log不会出现两个相同的Xid&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;global_query_id达到上限2^64 - 1后，会从0开始计数，所以同一数据库里可能同时存在相同的Xid&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;trx_id&#34;&gt;trx_id&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;trx_id不同于Xid，trx_id是由InnoDB维护，用在事务可见性方面的，比如MVCC，视图一致性&lt;/li&gt;
&lt;li&gt;普通只读语句不分配trx_id（而是临时算的，会比较大，主要是为了区分读写语句），读写语句才会分配 trx_id，由max_trx_id + 2(至少，比如update，实际上要先当前读在update的，所以是+2)&lt;/li&gt;
&lt;li&gt;max_trx_id会持久化，重启不会变0，上限是2^48-1，然后从0开始计数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;thread_id&#34;&gt;thread_id&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;系统保存全局变量thread_id_counter，每新键一个连接，thread_id_counter + 1后赋给thread_id，作为线程id&lt;/li&gt;
&lt;li&gt;上限是2^32-1，达到上限后重置为0&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;jdbc&#34;&gt;JDBC&lt;/h1&gt;
&lt;p&gt;SUN的 JDBC 是一套接口，而实现是各个数据库厂商的驱动包，因此使用了桥接模式&lt;/p&gt;
&lt;p&gt;DriverManager注册驱动包，com.mysql.jdbc.Driver类中的static块会创建驱动实例，因此只需要把驱动字节码加载到JVM里即可，Class.forName(“com.mysql.jdbc.Driver”);&lt;/p&gt;
&lt;p&gt;Connection conn = DriverManager.getConnection(url, username, password)获取连接&lt;/p&gt;
&lt;p&gt;Statement stmt = con.createStatement(); 之后使用stmt的方法执行SQL语句即可，返回ResultSet&lt;/p&gt;
&lt;p&gt;ResultSet下标从1开始&lt;/p&gt;
&lt;p&gt;使用Connection类的setAutoCommit(false) 方法来实现事务，以这个开始，Connection类的commit()方法提交，Connection类的rollback()方法回滚&lt;/p&gt;
&lt;p&gt;最后关闭ResultSet、Statement和Connection&lt;/p&gt;
&lt;h1 id=&#34;数据库连接池&#34;&gt;数据库连接池&lt;/h1&gt;
&lt;p&gt;链表实现，在使用连接对象之前，先创建好一定数量的连接对象，以链表的形式连接，从端首取，用完回到段尾。&lt;/p&gt;
&lt;p&gt;当池子中没有连接对象可取时，就让其先等待，如果等待超时还没有回获取到连接对象，就新建一个连接对象让其使用，用完后销毁该创建的对象&lt;/p&gt;
&lt;p&gt;连接池负责管理、监控和维护这些连接对象&lt;/p&gt;
&lt;p&gt;连接池单例&lt;/p&gt;
&lt;p&gt;连接池需要保证线程安全&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/xuanzhi201111/p/4103696.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL ACID及四种隔离级别的解释&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/MySQL.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CyC2018/CS-Notes/MySQL&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tech.meituan.com/2014/08/20/innodb-lock.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Innodb中的事务隔离级别和锁的关系&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;&#34; &gt;极客时间 - MySQL实战45讲&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/hapjin/p/11521506.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL中的 redo 日志文件 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/javaanddonet/article/details/112596210&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL的日志 - redo log&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/lemon-flm/p/15307313.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL日志15问&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/mengxinJ/p/14211427.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MySQL 中的WAL机制&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;后记&lt;/p&gt;
&lt;p&gt;极客时间 - MySQL实战45讲真的是质量很高的讲MySQL的课程，非常推荐&lt;/p&gt;
</description>
        </item>
        <item>
        <title>MongoDB</title>
        <link>http://nixum.cc/p/mongodb/</link>
        <pubDate>Sun, 28 Nov 2021 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/mongodb/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;特点&#34;&gt;特点&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;分布式数据库，Json数据模型，面向对象数据模型，不强制表的scheme&lt;/li&gt;
&lt;li&gt;当应用场景不清晰时，可以直接以对象模型直接存储，无需关心字段，表结构灵活，动态增加新字段&lt;/li&gt;
&lt;li&gt;不用太过关注表间的关系，可直接嵌套存储，将多种关系存储在同一张表上，同时也加快查表，因为它可以减少磁盘定位次数，如果是关系型数据库，同时查多张表就需要定位多次&lt;/li&gt;
&lt;li&gt;原生支持高可用，一般的部署方式是部署三个节点replica set，最多50个；多replica set可以实现自恢复（当主节点挂点后会选出从节点），异地容灾，数据库滚动更新&lt;/li&gt;
&lt;li&gt;原生支持横向扩展，通过水平扩展分片实现，外部并不感知有多少个分片，只会当成一个分片使用&lt;/li&gt;
&lt;li&gt;支持字段级加密，针对隐私数据，比如身份证、电话等，在入库时可以进行加密，查询时解密&lt;/li&gt;
&lt;li&gt;支持地理位置经纬度查询&lt;/li&gt;
&lt;li&gt;强大的聚合查询，适合报表、时序数据&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;nosql语句&#34;&gt;NoSQL语句&lt;/h1&gt;
&lt;p&gt;客户端使用驱动时连接的执行流程&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/MongoDB%e5%ae%a2%e6%88%b7%e7%ab%af%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/MongoDB%e5%ae%a2%e6%88%b7%e7%ab%af%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;客户端执行流程&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;客户端执行流程&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;数据库端执行流程&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/MongoDB%e6%95%b0%e6%8d%ae%e5%ba%93%e7%ab%af%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/MongoDB%e6%95%b0%e6%8d%ae%e5%ba%93%e7%ab%af%e6%89%a7%e8%a1%8c%e6%b5%81%e7%a8%8b.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;数据库端执行流程&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;数据库端执行流程&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;要获取ticket是因为MongoDB默认存储引擎wiredtiger的机制，ticket代表着系统资源的数量，ticket数量有限，读写操作都需要先获得ticket才可以进行下一步操作，机制类似信号量。&lt;/p&gt;
&lt;h2 id=&#34;连接&#34;&gt;连接&lt;/h2&gt;
&lt;p&gt;连接mongoDB语句，当有多节点或多分片时，连接也要写上，&lt;code&gt;mongodb://节点1的host:port, 节点2的host:port,.../databaseName?[options: maxPoolSize(java默认是100), maxWaitTime(查询的最大等待事件), writeConcern, readConcern]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;mongoDB驱动里已提供负载均衡，多节点探测&lt;/p&gt;
&lt;h2 id=&#34;聚合&#34;&gt;聚合&lt;/h2&gt;
&lt;p&gt;作用相当与group by，可作用与多个collection，可进行查询和计算。Mongo的聚合操作发生在pipeline中，由多个stage组成，有点像责任链，通过多个state来过滤，聚合数据，每一个{}代表一个state&lt;/p&gt;
&lt;p&gt;demo&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;n&#34;&gt;MySQL中的&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;department&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;as&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;emp_QTY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;User&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WHERE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;gender&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;female&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;GROUP&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;BY&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;department&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; 
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;HAVING&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;等价于&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;mongo中的&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;db&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;user&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;aggregate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;gender&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;female&amp;#39;&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;}}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    	     &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;$DEPARTMENT&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;            &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;emp_qty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;{$&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    	&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;    &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;$&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;match&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;emp_qty&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;{$&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;}}}&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;几个比较特别的运算符&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$unwind&lt;/code&gt;：将查询到的数组展开&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$grouphLookup&lt;/code&gt;：图搜索&lt;/p&gt;
&lt;p&gt;&lt;code&gt;$facet/$bucket&lt;/code&gt;：分面搜索，根据不同范围条件，多个维度一次性进行分组输出&lt;/p&gt;
&lt;h1 id=&#34;文档模型设计原则&#34;&gt;文档模型设计原则&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;传统关系型数据库设计，从概念模型 -》逻辑模型 -》物理模型，关系明确，遵循三范式（1.要有主键，列不可分，2.每列与主键相关，3.不能存在传递依赖(不允许字段冗余)），表现形式上，一对多关系，外键在多那张表上，多对多关系，会有第三张表来做关联&lt;/p&gt;
&lt;p&gt;对于文档模型，一般对应关系型数据库设计的逻辑模型阶段，通过嵌套实体数组，map或者引用字段来处理实体间的关系，字段冗余限制宽松&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实体间的关系，一对一使用嵌套map来表示；一对多使用嵌套数组表示；多对多使用嵌套数组+冗余字段来表示；此外，也可以通过嵌套数组存id + 另一张表来表示实体间的关系，通过id来进行联表（使用&lt;code&gt;aggregate + $lookup&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：嵌套时要注意整个文档大小，限制是16M，读写比例，也要注意数组长度大小，一般会使用id引用模式来解决；&lt;strong&gt;$lookup只支持left outer join&lt;/strong&gt;，不支持分片表&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;模式套用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;场景：时序数据，解决：对于同一个实体，将其变化字段的存储和更新，聚合在内嵌数组中&lt;/li&gt;
&lt;li&gt;场景：大文档、多相似字段、多相似索引，比如sku的多属性，解决：将多个相似字段转成内嵌数组，索引建立在内嵌数组的实体字段中，&lt;/li&gt;
&lt;li&gt;场景：由于schemeless的特性，不同版本存在不一样的字段，需要对字段做校验，解决：增加一个版本字段，通过该字段进行判断&lt;/li&gt;
&lt;li&gt;场景：计数统计，每秒要进行计数更新，不需要准确的计数，解决利用mongo的随机计数器$inc，&lt;/li&gt;
&lt;li&gt;场景：精确统计，排行版，解决：使用预聚合字段，比如增加排名字段，每次更新依赖字段的同时，更新排名字段，进行排行查询时，直接根据排行字段进行排序即可，不用重新聚合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考：&lt;a class=&#34;link&#34; href=&#34;https://www.pdai.tech/md/db/nosql-mongo/mongo-y-doc.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Mongo进阶 - 系统设计：模式构建&lt;/a&gt;，这个更全，也挺实用的&lt;/p&gt;
&lt;h1 id=&#34;调优&#34;&gt;调优&lt;/h1&gt;
&lt;h2 id=&#34;优化&#34;&gt;优化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;查询时，尽量使用索引，为经常做查询的条件添加索引&lt;/li&gt;
&lt;li&gt;查询时，只查询需要的字段，而不是查询全部，减少网络资源的浪费&lt;/li&gt;
&lt;li&gt;更新时，只更新必要的字段，而不是每次更新都把整个json文档发送过去，减少网络资源的浪费&lt;/li&gt;
&lt;li&gt;插入时，尽可能直接批量插入，而不是一条一条插&lt;/li&gt;
&lt;li&gt;通过mongodb提供的TTL索引，可以实现过期自删数据&lt;/li&gt;
&lt;li&gt;建表时，文档嵌套不超过3层&lt;/li&gt;
&lt;li&gt;尽量少用count()来计算总页数，而是使用limit&lt;/li&gt;
&lt;li&gt;尽量少用skip/limit形式分页，而是通过id来定位起始的位置，这点跟aws dynamoDB很像，不过至少有提供这种功能&lt;/li&gt;
&lt;li&gt;尽量少用事务，跨分片事务，避免过大事务，控制更新的文档(行)数量&lt;/li&gt;
&lt;li&gt;使用aggregate时，前一个stage计算得到的数据会传递到下个stage，如果前一个stage没有该数据，则下一个stage无法获取到（尽管表中有该字段）&lt;/li&gt;
&lt;li&gt;使用aggregate时，pipeline最开始时的match sort可以使用到索引，一旦发生过project投射，group分组，lookup表关联，unwind打散等操作后，则无法使用索引。&lt;/li&gt;
&lt;li&gt;创建组合索引时，一般以能够  精确匹配 -》排序 -》范围匹配  的字段顺序进行创建&lt;/li&gt;
&lt;li&gt;可以创建部分索引，比如对id&amp;gt;50的文档才会对id创建索引；对有值的字段才建索引，需要在创建索引时使用partialFilterExpression表达式&lt;/li&gt;
&lt;li&gt;创建索引时使用后台创建索引，&lt;code&gt;{background: true}&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分析&#34;&gt;分析&lt;/h2&gt;
&lt;h3 id=&#34;查看当前执行语句&#34;&gt;查看当前执行语句&lt;/h3&gt;
&lt;p&gt;mongo的 &lt;code&gt;db.currentOp()&lt;/code&gt; 等价于 MySQL的 &lt;code&gt;show full processlist&lt;/code&gt; 可查询当前正在执行的SQL语句，可以通过&lt;code&gt;db.killOp([线程id])&lt;/code&gt;杀掉异常线程。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-json&#34; data-lang=&#34;json&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;opid&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;789193&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;     &lt;span class=&#34;err&#34;&gt;#&lt;/span&gt;  &lt;span class=&#34;err&#34;&gt;此操作id&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;active&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;     &lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;状态(running/sleep)&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;secs_running&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;err&#34;&gt;#操作运行的时间,在active=false时不显示&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;op&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;getmore&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;    &lt;span class=&#34;err&#34;&gt;#操作行为(insert/update/remove)&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;ns&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;local.oplog.rs&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;集合名称&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;query&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{},&lt;/span&gt;             &lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;具体的操作语句&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;client&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;10.0.26.90:55312&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;  &lt;span class=&#34;err&#34;&gt;#连接db的客户端ip&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;desc&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;conn34681&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;     &lt;span class=&#34;err&#34;&gt;#数据库连接描述&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;threadId&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;0x7f24b8793700&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;线程id&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;connectionId&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;34681&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;   &lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;数据库连接id&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;waitingForLock&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;是否正在等待锁&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;numYields&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;          &lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;查询暂停的次数&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;#34;lockStats&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;           &lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;锁的状态&lt;/span&gt;
                &lt;span class=&#34;nt&#34;&gt;&amp;#34;timeLockedMicros&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;     &lt;span class=&#34;err&#34;&gt;#&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;持有锁的时间(ms)&lt;/span&gt;
                        &lt;span class=&#34;nt&#34;&gt;&amp;#34;r&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;NumberLong(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;81&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                        &lt;span class=&#34;nt&#34;&gt;&amp;#34;w&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;NumberLong(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;)&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt;
                &lt;span class=&#34;nt&#34;&gt;&amp;#34;timeAcquiringMicros&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;  &lt;span class=&#34;err&#34;&gt;#等待锁的时间(ms)&lt;/span&gt;
                        &lt;span class=&#34;nt&#34;&gt;&amp;#34;r&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;NumberLong(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
                        &lt;span class=&#34;nt&#34;&gt;&amp;#34;w&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;NumberLong(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;)&lt;/span&gt;
                &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;慢查询&#34;&gt;慢查询&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;开启语句：&lt;code&gt;db.getProfilingLevel(1, 1000)，记录所有超过1000ms的语句&lt;/code&gt;，profile的级别有0(关闭)、1(慢查询)、2(全部)&lt;/li&gt;
&lt;li&gt;查询记录：&lt;code&gt;db.system.profile.find()&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;查询语句上的分析&#34;&gt;查询语句上的分析&lt;/h3&gt;
&lt;p&gt;在查询语句中使用explain()方法分析查询语句，有三种分析模式，通过传参的方式使用，比如：&lt;code&gt;db.getCollection(&amp;quot;表名&amp;quot;).explain(&#39;executionStats&#39;).find({条件})&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;queryPlanner：默认，只会输出被查询优化器选择出来的查询计划winningPlane&lt;/li&gt;
&lt;li&gt;executionStats：除了输出被查询优化器选择出来的查询计划winningPlane，并执行语句（如果是写操作，不会真正操作数据库），给出分析结果，比如扫描的行数，使用什么索引，耗时，返回的条数等&lt;/li&gt;
&lt;li&gt;allPlansExecution：列出所有可能的查询计划并执行，给出所有方案的结果，mongo支持这种分析模式，但aws的documentDB不支持&lt;/li&gt;
&lt;/ul&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 常见的stage枚举：
COLLSCAN：全表扫描
IXSCAN：索引扫描
FETCH：根据前面扫描到的位置抓取完整文档，相当于回表
IDHACK：针对_id进行查询
SHARD_MERGE 合并分片中结果
SHARDING_FILTER 分片中过滤掉孤立文档
SORT：进行内存排序，最终返回结果
SORT_KEY_GENERATOR：获取每一个文档排序所用的键值
LIMIT：使用limit限制返回数
SKIP：使用skip进行跳过
COUNTSCAN：count不使用用Index进行count时的stage返回
COUNT_SCAN：count使用了Index进行count时的stage返回
TEXT：使用全文索引进行查询时候的stage返回
SUBPLA：未使用到索引的$or查询的stage返回
PROJECTION：限定返回字段时候stage的返回

# 一个executionStats例子
{ 
    &amp;quot;queryPlanner&amp;quot; : {
        &amp;quot;plannerVersion&amp;quot; : 1.0, 
        &amp;quot;namespace&amp;quot; : &amp;quot;库名.表名&amp;quot;, 
        &amp;quot;winningPlan&amp;quot; : {
            &amp;quot;stage&amp;quot; : &amp;quot;SORT_AGGREGATE&amp;quot;, 
            &amp;quot;inputStage&amp;quot; : {
                &amp;quot;stage&amp;quot; : &amp;quot;IXONLYSCAN&amp;quot;, 
                &amp;quot;indexName&amp;quot; : &amp;quot;索引名&amp;quot;, 
                &amp;quot;direction&amp;quot; : &amp;quot;forward&amp;quot;
            }
        }
    }, 
    &amp;quot;executionStats&amp;quot; : {
        &amp;quot;executionSuccess&amp;quot; : true, 
        &amp;quot;planningTimeMillis&amp;quot; : &amp;quot;0.276&amp;quot;, 
        &amp;quot;nReturned&amp;quot; : &amp;quot;1&amp;quot;, 
        &amp;quot;executionTimeMillis&amp;quot; : &amp;quot;10517.898&amp;quot;,  # 执行时间
        &amp;quot;totalKeysExamined&amp;quot; : &amp;quot;10519.0&amp;quot;,  # 总扫描数
        &amp;quot;totalDocsExamined&amp;quot; : &amp;quot;567542&amp;quot;,   # 总扫描文档数
        &amp;quot;executionStages&amp;quot; : {
            &amp;quot;stage&amp;quot; : &amp;quot;SORT_AGGREGATE&amp;quot;, 
            &amp;quot;nReturned&amp;quot; : &amp;quot;1&amp;quot;, 
            &amp;quot;executionTimeMillisEstimate&amp;quot; : &amp;quot;10517.497&amp;quot;, 
            &amp;quot;inputStage&amp;quot; : {
                &amp;quot;stage&amp;quot; : &amp;quot;IXONLYSCAN&amp;quot;, # 
                &amp;quot;nReturned&amp;quot; : &amp;quot;567542&amp;quot;, # 返回的文档数
                &amp;quot;executionTimeMillisEstimate&amp;quot; : &amp;quot;9786.122&amp;quot;,  # 执行此阶段的耗时
                &amp;quot;indexName&amp;quot; : &amp;quot;索引名&amp;quot;, 
                &amp;quot;direction&amp;quot; : &amp;quot;forward&amp;quot;
            }
        }
    }, 
    &amp;quot;serverInfo&amp;quot; : {
        &amp;quot;host&amp;quot; : &amp;quot;oms&amp;quot;, 
        &amp;quot;port&amp;quot; : 27017.0, 
        &amp;quot;version&amp;quot; : &amp;quot;4.0.0&amp;quot;
    }, 
    &amp;quot;ok&amp;quot; : 1.0, 
    &amp;quot;operationTime&amp;quot; : Timestamp(1640604817, 1)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;库或集合上的分析&#34;&gt;库或集合上的分析&lt;/h3&gt;
&lt;p&gt;对表的或对库的，使用stats()方法，比如&lt;code&gt;db.getCollection(&amp;quot;order&amp;quot;).stats()，或者db.stats()&lt;/code&gt;，可以查询整张表的信息或整个库的统计信息&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;# 针对库的
{ 
    &amp;quot;db&amp;quot; : &amp;quot;order&amp;quot;,  # 库名
    &amp;quot;collections&amp;quot; : 11.0,  # 集合数
    &amp;quot;objects&amp;quot; : 4938161.0,  # 对象数
    &amp;quot;storageSize&amp;quot; : 4236443648.0,  # 占用磁盘大小
    &amp;quot;indexes&amp;quot; : 32.0,  # 索引数
    &amp;quot;indexSize&amp;quot; : 1424130048.0,  # 索引大小
    &amp;quot;fileSize&amp;quot; : 5660573696.0,   # 文件大小
    &amp;quot;ok&amp;quot; : 1.0, 
    &amp;quot;operationTime&amp;quot; : Timestamp(1640604514, 1)
}
# 针对表的
{ 
    &amp;quot;ns&amp;quot; : &amp;quot;oms.order&amp;quot;, 
    &amp;quot;count&amp;quot; : 749031.0,  # 数量
    &amp;quot;size&amp;quot; : 1479336225.0, # 大小
    &amp;quot;avgObjSize&amp;quot; : 1975.90745, # 每个对象的平均大小
    &amp;quot;storageSize&amp;quot; : 2164432896.0, # 存储大小 
    &amp;quot;capped&amp;quot; : false, 
    &amp;quot;nindexes&amp;quot; : 1.0, # 索引个数
    &amp;quot;totalIndexSize&amp;quot; : 31129600.0, # 总索引大小
    &amp;quot;indexSizes&amp;quot; : {
        &amp;quot;_id_&amp;quot; : 94568448.0, 
        &amp;quot;id&amp;quot; : 77438976.0, 
        &amp;quot;idx_createAt_desc&amp;quot; : 31129600.0,   # 各个索引的大小
    }, 
    &amp;quot;ok&amp;quot; : 1.0, 
    &amp;quot;operationTime&amp;quot; : Timestamp(1640327496, 1)
}
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;存储引擎&#34;&gt;存储引擎&lt;/h1&gt;
&lt;h2 id=&#34;mmapv1&#34;&gt;MMapv1&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;4.0版本开始被弃用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存映射文件，不支持压缩，擅长于大容量插入、读取和就地更新的操作；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每一个数据库由一个.ns文件和一个或多个数据文件组成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.ns文件实际上是一个hash表，用于快速定位某个集合在数据文件中的起始位置；&lt;/li&gt;
&lt;li&gt;每个数据文件会被划分成多个extent，每个extent只包含一个集合的数据，一个extent包含多个文档，同一个extent中的所有文档使用双向链表连接；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了保证连续的存储空间，避免产生磁盘碎片，MMAPv1对数据文件的使用采用预分配策略：数据库创建之后，先创建一个编号为0的文件，大小为64M，当这个文件有一半以上被使用时，再创建一个编号为1的文件，大小是上一个文件的两倍，即128M，依此类推，直到创建文件大小达到2G，以后再创建的文件大小就都是2G了；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MMapv1引擎默认会将所有的redo log记录到硬盘上，每隔60秒写一次数据文件，每隔100毫秒写一次到日志文件，确保所有修改都能持久化到磁盘上；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;锁是集合级别的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MMapv1引擎会最大限度的使用内存，分配给它的内存越大，性能越好；同时，内存由操作系统管理，如果其他进程需要内存，MMapv1会让出自己的空闲内存；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文档按照写入顺序存储在磁盘上，由于文档可能会更新导致长度变长，如果原有存储空间不够，文档就需要进行迁移，导致集合中所有索引都要同步修改文档新的存储位置，影响性能，同时也反映出，如果文档没有索引时，无法保证文档在read中的自然顺序。&lt;/p&gt;
&lt;p&gt;有两种策略来避免文档迁移的情况发生：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;基于paddingFactor（填充因子）的自适应分配方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这种方式会基于每个集合中的文档更新历史计算文档更新的平均增长长度，然后根据平均增长长度设置一个paddingFactor（填充因子，大小大于1）， 以后在新文档插入或旧文档移动时分配的空间=文档实际长度×paddingFactor。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;基于usePowerOf2Sizes的预分配方式&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;　　这种方式则不考虑更新历史，直接为文档分配比文档大小大而又最接近文档大小的2的N次方大小的存储空间（当大小超过2MB时则变为2MB的倍数增长），例如若文档大小为200Bytes则直接分配256Bytes的空间，这种方式也会产生一定的磁盘碎片。&lt;/p&gt;
&lt;p&gt;　　对于第一种策略，由于每个文档大小不一，经过填充后的空间大小也不一样，如果集合上的更新操作很多，那么因为记录移动而导致的空闲空间会因为大小不一而难以重用。而第二种策略就不一样了，它分配的空间大小都是2的N次方，会更容易维护和利用，当那些删除或更新变大而产生的磁盘碎片，比如文档变大，需要迁移到新空间，此时就空间就会被标记为delete，这些被标记为删除的空间可以被insert重用，另外，由于预分配允许文档尺寸有限度的增长，而无需每次更新变大都重新分配空间。&lt;/p&gt;
&lt;p&gt;所以，改进后的MMAPv1便抛弃了第一种策略，只使用较优的第二种策略。&lt;/p&gt;
&lt;p&gt;另外，MongoDB还提供了一个“No Padding Allocation”策略，按照数据的实际尺寸分配空间，如果某个集合上绝大多数情况下执行的都是insert或者in-place update（更新后文档size不会变大），还有极少数的delete，那么可以在这个集合使用这个策略，提高磁盘空间利用率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;inmemory&#34;&gt;InMemory&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;将所有数据都存在内存中，只有少量的元数据和诊断日志、临时数据存储到磁盘文件；&lt;/li&gt;
&lt;li&gt;文档级别的锁，同一时刻多个写操作可以修改同一个集合中的不同文档，修改同一文档时会上锁；&lt;/li&gt;
&lt;li&gt;将数据库的数据、索引和操作日志等内容存储到内存中。可以通过参数&lt;code&gt;--inMemorySizeGB&lt;/code&gt;设置它占用的内存大小，默认为：50% of RAM - 1GB；&lt;/li&gt;
&lt;li&gt;不需要单独的日志文件，不存在记录日志和等待数据持久化的问题。so宕机时，所有存储在内存中的数据都将会丢失；&lt;/li&gt;
&lt;li&gt;数据虽然不会写入磁盘，但是会记录oplog；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;wiredtiger&#34;&gt;WiredTiger&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;3.0版本引入，3.2版本成为默认的存储引擎&lt;/li&gt;
&lt;li&gt;采用插件式的存储引擎架构，既支持B+树，也支持&lt;a class=&#34;link&#34; href=&#34;https://juejin.im/post/6844903688075477000&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LSM树&lt;/a&gt;，默认配置使用B+树；&lt;/li&gt;
&lt;li&gt;设计了一个能充分利用CPU并行计算的内存模型的无锁并行框架，使其在多核CPU上表现优异；&lt;/li&gt;
&lt;li&gt;实现了一套基于BLOCK/Extent的磁盘访问算法，使其在数据压缩和磁盘IO上表现优异；&lt;/li&gt;
&lt;li&gt;实现基于snapshot的ACID事务，简化事务模型，摈弃传统事务锁隔离又能同时保证ACID；&lt;/li&gt;
&lt;li&gt;实现了一种基于Hazard Pointer的LRU cache模型，充分利用内存容量的同时又能拥有很高的事务读写并发；&lt;/li&gt;
&lt;li&gt;支持压缩，占用磁盘空间更小，有两种压缩模式：Snappy和Zlib&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;题外话关于LSM树：&lt;/p&gt;
&lt;p&gt;LSM树，全称：Log-Structured Merge-Tree，是一种数据结构的设计思想，不是一种数据结构，一般基于B树及其变体实现，主要是将随机操作变为顺序操作，提升磁盘写速度，但会牺牲一些读性能；&lt;/p&gt;
&lt;p&gt;LSM树由三部分组成：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MemTable，常驻于内存，用于保存最近更新的数据，按照Key有序组织这些数据，保证有序性通常会使用一些数据结构，比如红黑树，跳表等&lt;/li&gt;
&lt;li&gt;Immutable MemTable，当MemTable达到一定大小后，会转换为Immutable MemTable，处于MemTable和SSTable的中间状态，写操作由新的MemTable处理，在转存过程中不阻塞数据更新操作。&lt;/li&gt;
&lt;li&gt;SSTable，有序键值对集合，是LSM树在磁盘中的结构，为了加速读取，通常是通过建立key的索引 + 布隆过滤器来加快key的查找。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;LSM树在数据插入、修改、删除等操作时，为了保证顺序写，是直接将操作记录追加到内存中（而B+树是直接修改原数据），当达到一定的数据量后，再批量写入磁盘，不断将Immutable MemTable刷盘持久化，变成SSTable，而不用去修改之前的SSTable中的key，保证顺序读写。由于是操作记录的追加写入，在不同的SSTable中，可能存在对相同的Key的记录，而只有最新的记录才是最准确的，因此需要对SSTable进行压缩，通过合并多个SSTable来清除冗余记录，读取时，也是倒序查询。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;LSM树有两种压缩策略：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;size-tiered：保证每层SSTable的大小相近，同时限制每一层SSTable的数量。比如，每层限制SSTable为N，当每层SSTable达到N后，则触发Compact操作合并这些SSTable，并将合并后的结果写入到下一层成为一个更大的sstable。&lt;/p&gt;
&lt;p&gt;由此可以看出，当层数达到一定数量时，最底层的单个SSTable的大小会变得非常大。并且size-tiered策略会导致空间放大比较严重。即使对于同一层的SSTable，每个key的记录是可能存在多份的，只有当该层的SSTable执行compact操作才会消除这些key的冗余记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;leveled：也是采用分层的思想，每一层限制总文件的大小。但是跟size-tiered策略不同的是，leveled会将每一层切分成多个大小相近的SSTable。这些SSTable是这一层是全局有序的，意味着一个key在每一层至多只有1条记录，不存在冗余记录。之所以可以保证全局有序，是因为合并策略和size-tiered不同。&lt;/p&gt;
&lt;p&gt;leveled策略相较于size-tiered策略来说，每层内key是不会重复的，即使是最坏的情况，除开最底层外，其余层都是重复key，按照相邻层大小比例为10来算，冗余占比也很小。因此空间放大问题得到缓解。但是写放大问题会更加突出。举一个最坏场景，如果LevelN层某个SSTable的key的范围跨度非常大，覆盖了LevelN+1层所有key的范围，那么进行Compact时将涉及Level N+1层的全部数据。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;将LSM树存储结构抽象成两种树，比如有C0 tree，常驻在内存，另一个为C1 tree，结构常驻在硬盘，比如B+树，C1所有节点都是100%满的，节点的大小为磁盘块的大小；&lt;/p&gt;
&lt;p&gt;插入新记录时，先在日志文件中以append的方式顺序插入操作日志；新记录的索引插入到C0中，在内存完成，不涉及磁盘IO，当C0大小达到某一阈值或每隔一段时间后，将C0中的记录滚动合并到磁盘C1中，如果C1体量太大就向C2合并，以此类推；合并时从C1中读取未合并叶子节点，从小到大找C0中的节点，合并排序，删除C0，循环执行，直至满了，就写入磁盘，从而达到将随机操作变成顺序操作；&lt;/p&gt;
&lt;p&gt;查找时，先查C0，查不到就查C1，以此类推；&lt;/p&gt;
&lt;p&gt;删除时，查询同查找逻辑，只是找到后只进行标记，等待异步删除；&lt;/p&gt;
&lt;p&gt;参考：https://zhuanlan.zhihu.com/p/103968892、https://zhuanlan.zhihu.com/p/181498475、https://www.51cto.com/article/680775.html&lt;/p&gt;
&lt;h3 id=&#34;数据文件在磁盘上的数据结构&#34;&gt;数据文件在磁盘上的数据结构&lt;/h3&gt;
&lt;p&gt;B+树的leaf page包含一个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;页头(page header)：页的类型、页中实际载荷数据的大小、页中记录条数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;块头(block header)：此页的checksum&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;真正的数据(key/value)：块在磁盘上的寻址位置等信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;WiredTiger有一个块设备管理的模块，用来为page分配block。如果要定位某一行数据（key/value）的位置，可以先通过block的位置找到此page（相对于文件起始位置的偏移量），再通过page找到行数据的相对位置，最后可以得到行数据相对于文件起始位置的偏移量offsets。由于offsets是一个8字节大小的变量，所以WiredTiger磁盘文件的大小，其最大值可以非常大(264bit)。&lt;/p&gt;
&lt;h3 id=&#34;数据在内存上的数据结构&#34;&gt;数据在内存上的数据结构&lt;/h3&gt;
&lt;p&gt;按需将磁盘上的数据以Page为单位加载到内存，一个page树就是一个checkpoint&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内存里面B+Tree包含三种类型的page，即rootpage（根结点）、internal page（非叶子结点）和leaf page（叶子结点），前两者包含指向其子页的page index指针，不包含集合中的真正数据，leaf page包含集合中的真正数据即keys/values和指向父页的home指针；&lt;/p&gt;
&lt;p&gt;leaf page还维护了三个数组：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WT_ROW数组，表示从磁盘加载进来的数据数组，每条记录还有一个cell_offset变量，表示这条记录在page上的偏移量&lt;/li&gt;
&lt;li&gt;WT_UPDATE数组，记录数据加载之后到下一个checkpoint间被修改的数据，每条被修改的记录都有一个数组元素对应，多次修改时，所有修改值以链表的形式保存（MVCC，相当于内存级别的oplog）&lt;/li&gt;
&lt;li&gt;WT_INSERT_HEAD数组，表示数据加载之后到下一个checkpoint间新增的数据，每个插入的数据以跳表的形式组成，提高插入效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;checkpoint机制&#34;&gt;checkpoint机制&lt;/h3&gt;
&lt;p&gt;checkpoint 相当于一个日志，记录上次checkpoint后相关数据文件的变化。&lt;/p&gt;
&lt;h4 id=&#34;作用&#34;&gt;作用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发生写操作时，只是将数据写入内存和journal日志，然后再通过check point机制将内存里面发生修改的数据写到数据文件进行持久化保存，确保数据一致性，同时也通过延迟持久化的方式，提升磁盘效率；&lt;/p&gt;
&lt;p&gt;也就是说，checkpoint开始时，在当前时间点创建快照（同时也有对应的checkpoint文件，但是其读取速度是比数据文件快的），写操作时，先写journal buffer（100ms或buffer到达100M后写入journal日志到磁盘）同时更新内存里的checkpoint数据，等到下一次执行checkpoint前，将checkpoint数据持久化到磁盘，变成数据文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现数据库在某个时刻意外发生故障，再次启动时，直接读取checkpoint文件（会比读数据文件快），配合journal日志恢复数据，缩短数据库的恢复时间；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有点像MySQL中的change buffer + 持久化，优化写操作的速度和数据持久化的保证。&lt;/p&gt;
&lt;h4 id=&#34;触发时机&#34;&gt;触发时机&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;按一定时间周期：默认60s，执行一次checkpoint，所以DB宕机重启后可以快速恢复60s之前的数据，配合journal日志恢复60s之后的数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;按一定日志文件大小：当 journal日志文件大小达到2GB（如果已开启），执行一次checkpoint；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;任何打开的数据文件被修改，关闭时将自动执行一次checkpoint;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;执行流程&#34;&gt;执行流程&lt;/h4&gt;
&lt;p&gt;每个checkpoint包含一个root page、三个指向磁盘具体位置上pages的列表以及磁盘上文件的大小，采用copy on write的方式管理增删改，增删改操作会先缓冲在cache里，持久化时，不会在原来的叶子结点上进行，而是写入新分配的page，每次checkpoint都会产生一个新的root page。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/MongoDB_checkpoint.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/MongoDB_checkpoint.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/MongoDB_checkpoint_process.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/MongoDB_checkpoint_process.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;checkpoint分成两类，一类是已经持久化到磁盘的，另一类是处于内存中的，可能发生改变的live checkpoint。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;上排他锁，打开集合文件，读取最新的checkpoint数据；&lt;/p&gt;
&lt;p&gt;集合文件会按checkponit指定的大小被截取，so如果此时发生系统故障，恢复时可能会丢失checkpoint之后的数据（如果没有开启journal，如果有，就可以通过journal日志来重放）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在内存构造一棵包含root page的live tree，表示当前可修改的checkpoint结构，用来跟踪后面写操作引起的文件变化，其他历史的checkpoint信息只能进行读或删除；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存里的page随着被增删改后，写入磁盘里按需分配的page时，会从live tree中的available列表中选取可用的page供其使用，随后，这个新的page被加入到checkpoint的allocated列表中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果一个checkpoint被删除时，它所包含的allocated和discarded两个列表信息将被合并到最新checkpoint对应的列表上，任何不再需要的磁盘pages，也会将其引用添加到live tree的availabe列表中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;删除旧checkpoint；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;根据此时的live tree生成新的checkpoint，当新的checkpoint生成时，会重新刷新其allocated、available、discard三个列表中的信息，并计算此时集合文件的大小以及root page的位置、大小、check sum等信息；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将新生成的信息作为checkpoint元信息写入磁盘中的文件；&lt;/p&gt;
&lt;p&gt;生成的checkponit默认名为WiredTigerCheckpoint，如果不明确指定其它名称，则新check point将自动取代上一次生成的checkpoint。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;事务实现&#34;&gt;事务实现&lt;/h3&gt;
&lt;p&gt;3.2版本有支持单文档原子操作了，主要是用在单文档嵌套更新上，默认自动的；4.0版本支持复制集多文档事务，4.2版本支持分片事务。&lt;/p&gt;
&lt;p&gt;另外，Spring 5.1.1 / SpringBoot 2.x 以上 @Transactional可以支持Mongo，需要为TransactionManager注入MongoDBFactory&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MVCC：以本次trancsaction_id + 本次修改后的value组成一个结点，每次修改都会追加到链表的头部，每次读取时根据trancsaction_id和本次事务的snapshot来找到对应的历史版本，该链表挂在叶子结点的WT_UPDATE字段中；&lt;/li&gt;
&lt;li&gt;snapshot：拉取当前事务之前的数据快照，确定当前事务哪些数据可见，哪些不可见，确定事务状态；&lt;/li&gt;
&lt;li&gt;operation_array：本次事务中已执行的操作列表，用于事务回滚，类似MySQL的undo log；&lt;/li&gt;
&lt;li&gt;journal日志，相当于redo log，即：记录当前操作，一个mongoDB实例中的所有DB共享journal文件；&lt;/li&gt;
&lt;li&gt;trancsaction_id：全局唯一事务id，通过cas自增生成；&lt;/li&gt;
&lt;li&gt;全局事务管理器：管理系统所有事务，用数组保存所有历史事务对象transaction_array，用于snapshot的创建，扫描transaction_array时使用cas保证并发安全；&lt;/li&gt;
&lt;li&gt;namespace文件：默认大小为16M，主要用于保存集合、索引的属性、命令信息等字段；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;事务执行流程&#34;&gt;事务执行流程&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;事务开启：创建事务对象，加入全局事务管理器，确定事务的隔离级别和redo log的刷盘方式，并将事务状态设置为 执行 ，如果事务隔离级别是snapshot-Isolation，则在本次事务执行前创建一个snapshot。&lt;/li&gt;
&lt;li&gt;事务执行：如果是读操作，则不做任何记录；如果是写操作，生成trancsaction_id，设置当前事务状态为HAS_TXN_ID，记录当前操作，保存到operation_array中；记录修改记录和trancsaction_id，保存mvcc的链表中；写入一条redo log到本地事务对象的redo_log_buf中。&lt;/li&gt;
&lt;li&gt;事务提交：将redo_log_buf中的数据写入redo log file日志文件中，并将redo log file持久化到磁盘，清除提交事务对象的snapshot对象，修改当前提交的事务的transaction_id状态为WT_TNX_NONE，保证其他事务在创建snapshot时看到本次事务的状态是已提交&lt;/li&gt;
&lt;li&gt;事务回滚：遍历operation_array，对每个数组单元对应update的transaction_id状态设置以为WT_TXN_ABORTED，标示mvcc 对应的修改单元值被回滚，在其他读事务进行mvcc读操作的时候，跳过这个放弃的值即可&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;多文档事务错误处理机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写冲突：当一个事务开始后，如果事务要修改的文档在事务外部被修改过，则事务修改这个文档时会触发Abort错误，因为此时的修改存在冲突，这种情况下，事务终止，应用端需要重做事务。&lt;/li&gt;
&lt;li&gt;写等待：如果一个事务已经开始修改一个文档，在事务以外尝试修改同一个文档，则事务以外的修改会等待事务完成才能继续进行。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;事务隔离级别&#34;&gt;事务隔离级别&lt;/h4&gt;
&lt;p&gt;不同于MySQL，MongoDB的Wired Tiger的事务均基于snapshot实现了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Read-Uncommited：未提交读，事务开启时，可以读到别的事务最新修改但还未提交的值，会出现脏读；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Read-Commited：提交读，默认，事务开启时，只能读到别的事务最新修改且已提交的值，这种隔离级别下可能在一个长事务多次读取一个值时前后读取不一致，出现不可重复读现象；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Snapshot-Isolation：快照隔离，事务开启时，只能读到当前事务前最后提交的值，整个事务期间只能看到这个版本的snapshot，不管这个值在此期间被其他事务修改了多少次，防止不可重复读；&lt;/p&gt;
&lt;p&gt;WT引擎会在当前事务下，执行每一个操作前都对系统中的事务做一次snapshot，然后在这个snapshot上读写；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;锁&#34;&gt;锁&lt;/h4&gt;
&lt;p&gt;MongoDB本身提供了三种粒度的锁：Global（锁所有库）、Database（锁库）、Collection（锁集合），Document级别的锁由存储引擎提供，比如WiredTiger有提供，MMapv1则没有；&lt;/p&gt;
&lt;p&gt;当有事务同时对同一文档做修改时还是会加锁，行锁的规则跟MySQL类似，也是分读写锁和意向读写锁，对document写入时，先加排他锁，再加意向锁。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于大多数读写操作，WiredTiger 存储引擎使用乐观并发控制。WiredTiger 仅在全局，数据库和集合级别使用意向锁。当存储引擎检测到两个操作之间的冲突时，会发生写入冲突，导致 MongoDB 透明地重试该操作。一些全局操作 (通常是涉及多个数据库的短期操作) 仍然需要全局 “实例范围” 锁定。其他一些操作（例如删除集合）仍需要独占数据库锁。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;为了解决写写冲突，写操作写入时，会做校验，确保从读开始没有其他写操作修改相应数据。如果有了修改，就重新执行整个写操作。这样就减少了资源被锁住的时间，成本是多个写操作修改相同数据时，有可能会发生多次重试。对于读多写少，写冲突少的情况，这种交换是合适的。这种并发处理机制称为乐观并发控制，即乐观锁。和悲观锁相比，通过增加校验和重试机制，放弃了在整个过程上加锁。&lt;/p&gt;
&lt;p&gt;insert：库级别的意向读锁(r)，表级别的意向读锁(r)，文档级别的读锁(R)&lt;/p&gt;
&lt;p&gt;update：库级别的意向写锁(w)，表级别的意向写锁(w)，文档级别的写锁(W)&lt;/p&gt;
&lt;p&gt;foreground方式创建索引：库级别的写锁(W)&lt;/p&gt;
&lt;p&gt;background方式创建索引：库级别的意向写锁(w)，表级别的意向写锁(w)&lt;/p&gt;
&lt;p&gt;锁是公平锁，所有的请求会排队获取相应的锁。但是mongodb为了优化吞吐量，在执行某个请求时，会同时执行和它相容的其他请求。比如一个请求队列需要的锁如下，执行IS请求的同时，会同时执行和它相容的其他S和IS请求。等这一批请求的S锁释放后，再执行X锁的请求。&lt;/p&gt;
&lt;p&gt;这种处理机制保证了在相对公平的前提下，提高了吞吐量，不会让某一类请求长时间的等待。对于长时间的读或者写操作，某些条件下，mongodb会临时的让渡锁，以防止长时间的阻塞。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;事务日志&#34;&gt;事务日志&lt;/h4&gt;
&lt;p&gt;Wired Tiger引擎在保证事务的持久化可靠性上通过redo log实现，只记录事务过程中对文档的修改，以追加的方式写入wt_transaction对象的redo_log_buf中，等到事务提交时将这个redo_log_buf以同步的方式写入WT的重做日志的磁盘文件中。&lt;/p&gt;
&lt;p&gt;如果数据库程序发生异常或者崩溃，可以通过上一个checkpoint的位置重演磁盘上这个磁盘文件来恢复已经提交的事务来保证事务的持久性。&lt;/p&gt;
&lt;p&gt;WT引擎通过LSN(LogSequence Number日志序列号)来管理redo log，redo log的操作对象叫logrec，对应提交的事务，是一个二进制buffer，事务的每个操作被记录成logop对象，一个logrec包含多个logop，logrec在刷入磁盘之前会进行空间压缩。&lt;/p&gt;
&lt;p&gt;redo log以WAL的方式写入日志，即事务过程中所有的修改在提交前需要将其对应的redo log写入磁盘文件，之后再进行事务提交，事务执行完成。&lt;/p&gt;
&lt;p&gt;为了减少日志刷盘频繁操作IO，其刷盘逻辑类似MySQL，会将同时发生的事务日志合并到一个slotbuffer中，先完成合并的事务线程会同步等待一个完成刷盘信号，最后完成日志数据合并的事务线程将slotbuffer中的所有日志数据sync到磁盘并通知这个slotbuffer中等待其他事务线程刷盘完成。并发事务的logrec合并到slotbuffer通过cas保证并发安全。&lt;/p&gt;
&lt;h4 id=&#34;事务恢复&#34;&gt;事务恢复&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;事务的redo log主要是防止内存中已经提交的事务修改丢失，但如果所有的修改都存在内存中，随着时间和写入的数据越来越多，内存就会不够用，这个时候就需要将内存中的修改数据写入到磁盘上，一般在WT中是将整个BTREE上的page做一次checkpoint并写入磁盘。&lt;/p&gt;
&lt;p&gt;WT中的checkpoint是一个append方式管理的，也就是说WT会保存多个checkpoint版本。不管从哪个版本的checkpoint开始都可以通过重演redo log来恢复内存中已提交的事务修改。整个重演过程就是就是简单的对logrec中各个操作的执行。这里值得提一下的是因为WT保存多个版本的checkpoint，那它会将checkpoint做为一种元数据写入到元数据表中，元数据表也会有自己的checkpoint和redo log，但是保存元数据表的checkpoint是保存在WiredTiger.wt文件中，系统重演普通表的提交事务之前，先会重演元数据事务提交修改。&lt;/p&gt;
&lt;p&gt;WT的redo log是通过配置开启或者关闭的，MongoDB并没有使用WT的redolog来保证事务修改不丢，而是采用了WT的checkpoint和MongoDB复制集的功能结合来保证数据的完整性的。大致的细节是如果某个mongoDB实例宕机了，重启后通过MongoDB的复制协议将自己最新checkpoint后面的修改从其他的MongoDB实例复制过来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;缓存实现&#34;&gt;缓存实现&lt;/h3&gt;
&lt;p&gt;WT引擎内部使用&lt;strong&gt;LRU cache作为缓存模型&lt;/strong&gt;，采用分段扫描和hazardpointer的淘汰机制，充分利用现代计算机超大内存容量的特性来提高事务读写并发。在高速不间断写入内存操作非常快，但是由于内存中的数据最终需要写入磁盘，因为写内存的速度远高于写磁盘，最终可能导致间歇性写挂起的现象出现。&lt;/p&gt;
&lt;p&gt;WT内部将内存划分为3块：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储引擎内部的cache，默认大小是&lt;code&gt;MAX((RAM - 1G)/2, 256M)&lt;/code&gt;，即如果16G，就会有7.5G给WT内部当cache；&lt;/li&gt;
&lt;li&gt;索引cache，默认500M；&lt;/li&gt;
&lt;li&gt;文件系统cache，利用的是操作系统的文件系统缓存，目的是减少内存与磁盘的交互；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当cache空间不足时，会进行淘汰，淘汰的时机由&lt;code&gt;eviction_target：内存使用量&lt;/code&gt;和&lt;code&gt;eviction_dirty_target：内存脏数据量&lt;/code&gt;来控制，超过一定的阈值后触发。&lt;/p&gt;
&lt;p&gt;缓解读写挂起的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WT 2.8版本不再分为预前刷盘和checkpoint刷盘，而是采用逐个对B+树直接做checkpoint刷盘，避免evict page的拥堵，缓解OS cache缓冲太多的文件脏数据问题&lt;/li&gt;
&lt;li&gt;使用direct IO&lt;/li&gt;
&lt;li&gt;多个磁盘存储，redo log文件单独放在一个磁盘上，数据放在另外的磁盘上，避免redo log和checkpoint发生刷盘竞争&lt;/li&gt;
&lt;li&gt;使用SSD&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;复制集读写关注&#34;&gt;复制集读写关注&lt;/h1&gt;
&lt;p&gt;mongo是分布式数据库，通过部署多复制集来实现，单个MongoDB server不支持复制集读写关注，至少需要一主一从两个。&lt;/p&gt;
&lt;h2 id=&#34;分布式下的写操作&#34;&gt;分布式下的写操作&lt;/h2&gt;
&lt;p&gt;对于事务内多文档执行写操作，保证原子性，失败能回滚&lt;/p&gt;
&lt;h3 id=&#34;writeconcern参数&#34;&gt;writeConcern参数&lt;/h3&gt;
&lt;p&gt;通过参数writeConcern来保证写操作到达多少个节点才算成功，写操作会等到写到复制集后才会返回&lt;/p&gt;
&lt;p&gt;使用：nosql语句里包含&lt;code&gt;{writeConcern: {w: 1, timeout: 3000}}&lt;/code&gt;，单位毫秒，超时不意味着都写失败，有可能已经写入了一些节点了，写操作性能会取决于节点的数量，会影响写入的时间，但对集群不会有压力&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认值为1，表示数据被写入到一个节点就算成功&lt;/li&gt;
&lt;li&gt;=[数字x]，表示数据被写入到x个节点就算成功&lt;/li&gt;
&lt;li&gt;=0，表示发出的写操作，不关心是否成功&lt;/li&gt;
&lt;li&gt;=majority（推荐）表示发出的写操作需要写入到多数复制集上才算成功，一般写操作写入主节点，由主节点同步给从节点&lt;/li&gt;
&lt;li&gt;=all，需要全部节点确认，但如果同步时有节点挂了，此时写操作会被阻塞&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;journal参数&#34;&gt;journal参数&lt;/h3&gt;
&lt;p&gt;写操作时，会按操作顺序先写到内存，再写入磁盘（journal日志文件和数据文件），参数journal字段来保证达到哪步操作才算成功，由配置文件里&lt;code&gt;storage.journal.enabled&lt;/code&gt;控制是否开启，&lt;code&gt;storage.journal.commitInternalMs&lt;/code&gt;决定刷盘时间间隔&lt;/p&gt;
&lt;p&gt;使用：nosql语句里包含 &lt;code&gt;{journal: {j: true}}&lt;/code&gt; 会保证每次写入都会进行刷盘&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;=true，表示写操作要落到journal日志文件才算成功&lt;/li&gt;
&lt;li&gt;=false，表示写操作到达内存就算成功&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;journal日志与oplog日志的区别&#34;&gt;journal日志与oplog日志的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;journal日志：即redo log &lt;strong&gt;，由MongoDB引擎层使用，&lt;strong&gt;主要用于控制写操作是否立即持久化&lt;/strong&gt;，因为如果发生写操作，mongo一般是先将写操作写入内存，在&lt;/strong&gt;定时（默认是1分钟）通过check point机制将内存里的数据刷盘持久化&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;如果写操作的成功判定出现在写完内存后，如果此时宕机，将会丢失写操作的记录，如果判定发生在写完journal日志之后，如果宕机可以利用journal日志进行恢复。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;写入journal日志时，也是先写入内存，再根据写入buffer的大小（默认是100M）或者 定时（默认是100ms）写入磁盘。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;oplog日志&lt;/strong&gt;：只用在主从复制集的使用，通过&lt;strong&gt;oplog来实现节点间的数据同步&lt;/strong&gt;，从节点获取主节点的oplog日志后进行重放，同步数据。oplog本身在MongoDB里是一个集合。&lt;/p&gt;
&lt;p&gt;mongo的一次写操作，包括 1.将文档数据写进集合； 2.更新集合的索引信息； 3.写入oplog日志，（此时只是写入内存），这三个步骤是原子性的，要么成功要么失败。一次写操作可以是批量的也可以是单条，一次写操作对应一条journal日志。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;开启journal和writeConcern后的数据写入顺序&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;写操作进来，先将写操作写入journal缓存，将写操作产生的数据写入数据缓存，将journal内存里的写操作日志同步到oplog里，异步响应给客户端；&lt;/li&gt;
&lt;li&gt;后台线程检测到日志变化，将oplog同步给从节点；另外，后台每100ms会将journal缓存里的日志刷盘，每60s将数据缓存里的数据刷盘&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分布式下读操作&#34;&gt;分布式下读操作&lt;/h2&gt;
&lt;h3 id=&#34;readpreference参数&#34;&gt;readPreference参数&lt;/h3&gt;
&lt;p&gt;读操作时，决定使用那一个节点来处理读请求，也可以配合tag使用，来指定节点访问&lt;/p&gt;
&lt;p&gt;使用：可以设置在连接语句里，驱动程序API，nosql语句+.readPref(&amp;ldquo;primary&amp;rdquo;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;=primary（默认，推荐），只选择主节点&lt;/li&gt;
&lt;li&gt;=primaryPreferred：优先选择主节点，不可用时使用从节点&lt;/li&gt;
&lt;li&gt;=secondary：只选择从节点，一般用于历史数据查询，针对时效性低的数据，或者报表服务的操作&lt;/li&gt;
&lt;li&gt;=secondaryPreferred：优先选择从节点，不可用时选择主节点&lt;/li&gt;
&lt;li&gt;=nearest：选择最近节点，根据ping time决定，一般用于异地部署&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;readconcern参数&#34;&gt;readConcern参数&lt;/h3&gt;
&lt;p&gt;读操作时，决定这个节点的数据哪些是可读的，&lt;strong&gt;类似MySQL中的隔离&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;使用：需要在mongo的配置文件的server参数中，增加&lt;code&gt;enableMajorityReadConcern: true&lt;/code&gt;，&lt;/p&gt;
&lt;p&gt;对于值枚举为available、local、majority、linearizable，需要在查询语句后 + .readConcern(&amp;ldquo;local或者其他枚举&amp;rdquo;)开启使用；&lt;/p&gt;
&lt;p&gt;对于snapshot，则是在开启事务时指定，&lt;code&gt;var session = db.getMongo().startSession(); session.startTransaction({readConcern: {level: &amp;quot;snapshot&amp;quot;}, writeConcern: {w: &amp;quot;majority&amp;quot;}});&lt;/code&gt;  session作为事务对象，配合snapshot快照、MVCC、redo log来实现事务。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;=available：读取所有可用数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;=local（默认）：读取所有可用且属于当前分片的数据，类似available，只是限制在分片上，&lt;/p&gt;
&lt;p&gt;mongo为了实现数据均衡，有分片chunk迁移机制，当分片1将数据迁移至分片2，但还没迁移完成时，此时两个分片都存在该chunk数据，但是此时该数据仍属于分片1，=local时不能读到分片2的该数据，=available时则可以&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;=majority：读取在多数节点上提交完成的数据，通过MVCC机制实现，&lt;strong&gt;作用类似MySQL中的提交读隔离级别&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;比如，当读操作指向主节点，且写操作已经同步到多数从节点时，才可以读到该数据；当读操作指向一个从节点，且从节点完成写操作，且通知了主节点并得到主节点的响应时，才能读到该数据。&lt;/p&gt;
&lt;p&gt;作用：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;主要是防止分布式数据库脏读，这里脏读指的是，在一次写操作到达多数节点前读取了这个写操作，又由于故障之类的导致写操作回滚了，此时读到的数据就算脏读。&lt;/li&gt;
&lt;li&gt;配合&lt;code&gt;writeConcern=majority&lt;/code&gt;来实现读写分离，向主节点写入数据，从节点也能读到数据&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;=linearizable：线性读取文档，性能较差，&lt;strong&gt;作用类似MySQL中的serializable(串行化)隔离级别&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;只对读取单个文档时有效，保证在写操作完成后一定可以读到，一次读操作需要所有节点响应&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;=snapshot：读取最近快照中的数据，&lt;strong&gt;作用类似MySQL中的可重复读隔离级别&lt;/strong&gt;，事务默认60s，需要4.2的驱动，会影响chunk迁移，多文档读操作必须使用主节点读&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;全局事务管理器通过自旋创建快照&lt;/li&gt;
&lt;li&gt;实现在同一事务下读取同一数据的一致性，也可以读取同一事务内的写操作；&lt;/li&gt;
&lt;li&gt;当多事务内出现写操作冲突时，排在后面事务的写操作会失败，触发abort错误，此时只能把该事务抛弃，再重新开始事务&lt;/li&gt;
&lt;li&gt;当事务外和事务内的写操作冲突，事务内的写操作早于事务外的写操作，事务外的写操作会进入等待，直到事务内提交，才会执行&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;复制集replica-set机制&#34;&gt;复制集Replica Set机制&lt;/h1&gt;
&lt;p&gt;一般是一主多从，所有实例存储相同数据&lt;/p&gt;
&lt;h2 id=&#34;特点-1&#34;&gt;特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;数据分发，将数据从一个区域复制到另一区域，减少另一区域的读延时&lt;/li&gt;
&lt;li&gt;读写分离&lt;/li&gt;
&lt;li&gt;异地容灾，快速切换可用节点&lt;/li&gt;
&lt;li&gt;复制集主要用于实现高可用，增加复制集的节点数目并不会提升写性能，因为写操作都发生在主节点上，但可以提升读性能。提升性能一般是使用分片的机制&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;节点分类&#34;&gt;节点分类&lt;/h2&gt;
&lt;p&gt;除了常见的主从节点，MongoDB还支持 仲裁节点，只用于选举投票，其作用是在当部署了偶数个节点的复制集时，就算有一台节点宕机，也能选出主节点。仲裁节点本身不存储数据，非常轻量化。&lt;/p&gt;
&lt;p&gt;另外，从节点也可分化出另外两种节点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Priority0从节点：一般作为备用节点，当无法在合理时间内添加新成员节点时，实现替换作为过渡；priority0节点的选举优先级为0，表示不会被选举成主节点；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hidden从节点：隐藏节点不会收到任何写请求，即使设置为复制集读选项，一般用于报表节点、备份节点进行数据备份、离线计算等任务，不影响复制集的其他服务；&lt;/p&gt;
&lt;p&gt;hidden节点的priority也是0，无法被选为主节点，对driver不可见。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;delay从节点：延时节点，同时也是hidden节点，其数据会落后于主节点一段时间，用于帮助我们在人为误操作或其他意外情况下进行数据恢复。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;选举时机&#34;&gt;选举时机&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;往复制集中加入新节点&lt;/li&gt;
&lt;li&gt;初始化复制集&lt;/li&gt;
&lt;li&gt;对复制集进行维护，如&lt;code&gt;rs.stepDown(时间)，在多少时间后将当前主库降级&lt;/code&gt;或&lt;code&gt;rs.reconfig()重新配置现有复制集&lt;/code&gt;操作时&lt;/li&gt;
&lt;li&gt;从节点失联，默认超时时间是10s&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;机制&#34;&gt;机制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;复制集中的数据同步，有两种形式：初始化同步(Initial Sync)，即全量同步；复制(Replication)：增量同步；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般部署奇数个复制集，至少三个，且均要有投票权，一般分为一个主节点，用于接受写入操作和选举时的投票，两个从节点，复制主节点上的数据和选举时的投票&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主节点上所有的写操作，会被记录到oplog日志中，从节点通过在主节点上打开一个tailable游标不断获取新进入主节点的oplog，进行重放，实现与主节点的数据一致。（异步）&lt;/p&gt;
&lt;p&gt;oplog(操作日志)是一个特殊的有上限的集合(老的日志会被overwrite)，它保存所有修改数据库中存储的数据的操作的滚动记录。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过选举实现故障恢复&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每两个节点间 每2s互发心跳，5次心跳未收到时判断为节点失联&lt;/li&gt;
&lt;li&gt;当主节点失联时，从节点发起选举，选出新的主节点，当失联的是从节点，则不会产生选举&lt;/li&gt;
&lt;li&gt;选举算法采用raft算法&lt;/li&gt;
&lt;li&gt;复制集最多可以有50个节点，但具有投票权的节点最多7个&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于从节点有机会成为主节点，所以最好保证多节点的版本，配置上保持一致&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;分片机制&#34;&gt;分片机制&lt;/h1&gt;
&lt;p&gt;分片主要是对同一实例水平的横向扩展，将原本一个实例里的数据拆分出来多分片存储，最多支持1024个分片，所以实际上是所有分片的数据加起来才是完整数据，每一个分片也是一个复制集&lt;/p&gt;
&lt;h2 id=&#34;特点-2&#34;&gt;特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;提升访问性能，降低节点的压力，对外提供同一入口，屏蔽内部集群部署，通过分片路由节点mongos对请求分发到不同的分片，也有负载均衡。分发的规则是通过配置节点configServer决定，配置节点存储了数据与分片的映射。&lt;/p&gt;
&lt;p&gt;mongos、configServer、shard均以复制集为单位，部署多个复制集，实现高可用&lt;/p&gt;
&lt;p&gt;shard：分片，真正的数据存储位置，以chunk为单位存数据，每个分片可部署为一个复制集&lt;/p&gt;
&lt;p&gt;mongos：查询路由，提供客户端和分片集群之间的接口&lt;/p&gt;
&lt;p&gt;configServer：存储元数据和配置数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据存储时会自动均衡，当mongo发现数据存储分布不均衡时，会做chunk迁移，chunk的概念类似MySQL中的页，一个chunk包含多个文档 = 一页中包含多行记录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;chunk的大小默认是64M，如果超过，chunk会进行分裂，如果单位时间存储需求很大，就设置更大的chunk。chunk的大小会影响迁移的速度，小的chunk迁移速度快，数据分配均匀，但是数据分裂频繁，路由节点消耗资源更多；大的chunk分裂少，但是迁移时更耗资源。&lt;/li&gt;
&lt;li&gt;chunk的分裂和迁移非常消耗IO资源；&lt;/li&gt;
&lt;li&gt;chunk在插入和更新时进行分裂，读数据不会分裂&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;支持动态扩容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可基于集合(即表)进行分片&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;设计原则&#34;&gt;设计原则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;分片模式
&lt;ul&gt;
&lt;li&gt;基于范围：根据id或者其他字段按范围进行分片存储，每一个分片的数据上是相邻的，但可能会导致热点数据分布不均&lt;/li&gt;
&lt;li&gt;基于哈希：根据指定字段进行hash，数据分布均匀，但范围查询效率低&lt;/li&gt;
&lt;li&gt;基于地域、时效、tag分区&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;分片键的选择最好选择基数大(比如id，范围大)，分布均匀，在查询条件中可以明确定位&lt;/li&gt;
&lt;li&gt;数据量不超过3TB，尽可能保持2TB一个分片&lt;/li&gt;
&lt;li&gt;分片的数量根据存储容量、集合(即表)和索引的占比、并发量、来决定，&lt;strong&gt;mongodb默认会使用物理机60%的内存来&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;change-stream&#34;&gt;Change Stream&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;类似MySQL中的触发器，但它是异步的，非事务，实现变更追踪，在应用回调中触发，可同时触发多个触发器，故障后会从故障点恢复执行（故障前会拿到id，通过id来恢复）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于oplog实现，在oplog上开启tailable cursor追踪复制集上的变更操作，可追踪的事件包括ddl、dml语句，在ddl、dml语句执行后触发&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用时需要开启readConcern，且设置read/writeConcern：majority，只推送已经在大多数节点上提交的变更操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用：&lt;code&gt;db.[具体的collectionName].watch([...]).操作函数&lt;/code&gt;，当满足watch里的条件时会触发操作方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用场景：跨集群复制、微服务变更数据库时通知其他微服务&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;备份和恢复&#34;&gt;备份和恢复&lt;/h1&gt;
&lt;p&gt;备份主要是为了防止误操作，一个节点的误操作会同步到其他节点，备份同时也可以进行数据回溯&lt;/p&gt;
&lt;h2 id=&#34;备份方案&#34;&gt;备份方案&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;延迟节点备份，通过设置一个延迟节点，比如让其与主节点的存储差距延迟一个小时的数据量，通过oplog + oplog window重放实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;全量备份，数据文件快照(一般是某个时间点) + oplog(该时间点之后操作日志记录)实现&lt;/p&gt;
&lt;p&gt;&lt;code&gt;mongodump -h [需要备份的mongo实例的host:port] -d [数据库名称] -o [备份存放路径]&lt;/code&gt;命令保存数据快照&lt;/p&gt;
&lt;p&gt;恢复：&lt;code&gt;mongorestore -h [目标Mongo实例的host:port] -d [数据库实例名称] [[快照所在的路径]| -dir [快照所在的路径]]&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;监控&#34;&gt;监控&lt;/h1&gt;
&lt;p&gt;一般使用mongodb的ops manager，或者grafana实现&lt;/p&gt;
&lt;h2 id=&#34;监控指标&#34;&gt;监控指标&lt;/h2&gt;
&lt;p&gt;通过&lt;code&gt;db.serverStatus()&lt;/code&gt;方法来获取指标，serverStatus方法记录的是自mongo启动以来的指标数据，常见指标有很多，一般会关注下面几个&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;connections：连接数信息&lt;/li&gt;
&lt;li&gt;locks：mongoDB使用锁的情况&lt;/li&gt;
&lt;li&gt;network：网络使用情况统计&lt;/li&gt;
&lt;li&gt;opconters：CURD执行次数统计&lt;/li&gt;
&lt;li&gt;repl：复制集配置信息&lt;/li&gt;
&lt;li&gt;men：内存使用情况&lt;/li&gt;
&lt;li&gt;scan and order：每秒内存排序操作的平均比例&lt;/li&gt;
&lt;li&gt;oplog window：代表oplog可容纳多长时间的操作，表示从节点可以离线多久后可以追上主节点的数据&lt;/li&gt;
&lt;li&gt;wiredTiger：包含大量WirdTiger引擎执行情况的信息，如block-manager：WT数据块的读写情况，session：session使用量，concurrentTransactions：ticket使用情况&lt;/li&gt;
&lt;li&gt;metrics：一系列指标统计信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;极客时间 - mongodb高手课&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/wujuntian/p/8431674.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MongoDB存储引擎（上）——MMAPv1&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>英语学习总结</title>
        <link>http://nixum.cc/p/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</link>
        <pubDate>Fri, 23 Jun 2023 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;方法论&#34;&gt;方法论&lt;/h1&gt;
&lt;p&gt;整体参考视频：&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1ZM4y1J748&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;自学英语零基础到中高级！超详细学习指南！&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;初学&#34;&gt;初学&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;找核心学习资料（50%），《走进美国》、《每日英语听力》《新概念一册，Leo老师》《欧陆词典》&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;边听边看文本热身&lt;/li&gt;
&lt;li&gt;查词学语法点&lt;/li&gt;
&lt;li&gt;逐句反复跟读&lt;/li&gt;
&lt;li&gt;原速跟读&lt;/li&gt;
&lt;li&gt;遮盖原文原速听&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;背单词（25%）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在语境下背单词&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;听说训练（25%）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发音、音标课《BBC learn all 44 engilsh sounds》
音-词-句，泛听（语音语调、抓单词、重复）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可利用 博树，多邻国，&lt;a class=&#34;link&#34; href=&#34;https://www.usespeak.com/zh-tw&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;speak&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://callannie.ai/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;call annie&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://talkface.ai/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;talkface&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://apps.apple.com/cn/app/ainder-%E5%92%8Cai%E7%BB%83%E9%9B%85%E6%80%9D%E5%8F%A3%E8%AF%AD-%E8%99%9A%E6%8B%9F%E8%B0%88%E6%81%8B%E7%88%B1/id6450455171&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Ainder&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;摸鱼时进行泛听，泡耳朵，平时没事多&lt;strong&gt;听&lt;/strong&gt;或者&lt;strong&gt;跟读&lt;/strong&gt;新概念的音频，主要是用来提升语音、语调、语速、变音，在此过程中要多注意里面的单词，语法的习惯用法&lt;/p&gt;
&lt;p&gt;跟读时，听一句，读一句，尽可能的模仿，直到满意&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要设定目标：长期目标 -&amp;gt; 中期 -&amp;gt; 短期，目的是控制学习量&lt;/p&gt;
&lt;h3 id=&#34;具体计划&#34;&gt;具体计划&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;核心学习资料-30分钟&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;新概念英语一册，一节或半节，搭配leo视频&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;背单词 - 15分钟&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《欧路词典》《新概念一册、二册》词库&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;听书训练 - 15分钟&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;阶段一：英语兔 音标专攻，一天2-4个发音&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阶段二：一集english pod播客，或一集《跟着lucy学英语》&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;语法专攻 - 20分钟&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《剑桥语法》练习及视频&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;口语练习-30分钟&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用《cambly》app 外教课，《语伴》app&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;中级&#34;&gt;中级&lt;/h2&gt;
&lt;p&gt;大量听说读，看视频、有声书、ted等，只看英文字幕&lt;/p&gt;
&lt;h2 id=&#34;单词学习&#34;&gt;单词学习&lt;/h2&gt;
&lt;p&gt;对于单词的学习，尝试去造句&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;学会单词的形态变化，比如对于动词 + 动词的变化，时态的变化&lt;/li&gt;
&lt;li&gt;四句型转换，肯定句，否定句，一般疑问句，特殊疑问句&lt;/li&gt;
&lt;li&gt;方式 / 地点 / 时间&lt;/li&gt;
&lt;li&gt;结合习惯用法&lt;/li&gt;
&lt;li&gt;其他单词 + 词性，根据词性去做组合&lt;/li&gt;
&lt;li&gt;原文摘抄 + 变换&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以 private 为例，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;结合其他单词，比如有 private school、private life、private hospital&lt;/li&gt;
&lt;li&gt;结合短语，比如 go to a private school&lt;/li&gt;
&lt;li&gt;造句，进行四句型转换，比如
&lt;ul&gt;
&lt;li&gt;He goes to a private school.&lt;/li&gt;
&lt;li&gt;Does he go to a private school?&lt;/li&gt;
&lt;li&gt;Why does he go to a private school?&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;简单造句&#34;&gt;简单造句&lt;/h2&gt;
&lt;p&gt;要有主语，有动词（动词要有变化），加形容词/副词，加地点，加时间，语序参考下面的表格&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;时间&lt;!-- raw HTML omitted --&gt;When&lt;/th&gt;
&lt;th&gt;主语&lt;!-- raw HTML omitted --&gt;Who、Which、What&lt;/th&gt;
&lt;th&gt;谓语&lt;!-- raw HTML omitted --&gt;行为，动词+动词变化&lt;/th&gt;
&lt;th&gt;宾语&lt;!-- raw HTML omitted --&gt;Who、Which、What&lt;/th&gt;
&lt;th&gt;方式&lt;!-- raw HTML omitted --&gt;How、副词&lt;/th&gt;
&lt;th&gt;地点&lt;!-- raw HTML omitted --&gt;Where&lt;/th&gt;
&lt;th&gt;时间&lt;!-- raw HTML omitted --&gt;When&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;A cute woman&lt;/td&gt;
&lt;td&gt;is shouting&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;angrily&lt;/td&gt;
&lt;td&gt;in her car&lt;/td&gt;
&lt;td&gt;at midnight&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h1 id=&#34;习惯用法&#34;&gt;习惯用法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;感叹句：what adj + n + (主语 + 谓语) 或者 how adj + (主语 + 谓语)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A be different from B：A 不同与 B&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A is 5 miles from B：A距离B有5英里&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A be full of B：A充满B&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A give B a lift：A给了B搭便车&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A be strict with B：A对B很严格&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A serves as B：A当作B&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A be equipped with B：A装备了B，equip sb with sth：给某人装备某物&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;A be referred to as B：把A称为B，等价于 refer to A as B&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a great number of + 名词复数 等价于 a lot of：大量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a glass of beer：一杯啤酒&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a piece of cheese：一片芝士&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a parcel of diamonds: 一包钻石&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a colony of bee：一群蜜蜂&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a crowd of beggars：一群人乞丐&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a short while age：不久前&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a trail of：一系列，一长串&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a blessing in disguise：因祸得福&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;as it did 引导方式状语从句，eg：Looks the same as it did twenty years ago. 这里it did指的就是Look the same.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;admit doing sth：承认做某事 / sb admin that&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ask (sb) for sth：向某人想要某些东西&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ask sb to do sth：请求某人做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;account for the fact that：解释事实，that后面加一个句子解释这个事实&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;as if : 好像，似乎，就像&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;as 做方式状语的连接词有的含义：1. 像，2. 当&amp;hellip;， 3. 作为&amp;hellip;，4. 按照&amp;hellip;.的方式，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;at large：逍遥法外；在逃；未被捕获的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a few hours earlier：几个小时前&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a pile of：一大堆&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a great deal of + 不可数名词，表示大量的xx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;at five to twelve：差5分钟到12点，即11点55分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;at that moment：在那个瞬间 等价 at present&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;all parts of the country：全国各地&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;admire sb for sth / doing sth：赞美某人某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;apply to sb：适用于某人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;apply for sth：申请某个东西&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;apart from：除了&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;affort this 等价于 affort to pay this，支付得起这个&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;allow用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;be allowd to do sth：被允许做某事&lt;/li&gt;
&lt;li&gt;allow sb to do sth：允许某人做某事&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;as &amp;hellip; as&amp;hellip; ：像什么什么一样什么，eg：as busy as usal 像往常一样忙碌，否定是 not as(也可以用so) &amp;hellip; as &amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;a slip of the tongue：口误&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;attempt to do sth：企图/尝试做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;avoid doing sth：避免做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;base on：基于xxx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be accustomed to doing：习惯做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be armed(被动) with sth 等价于 arm sb/sth with sth：装备某物&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be able to do：能做某事，等价于 be due to do，与 can / could 的区别：两者都表达一种普通能力，只是 was able to do，表示过去的成功事件，&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be always doing sth：be + doing 与 always 连用时，表示频率过高，令说话者心烦，生厌（不绝对）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be base on：基于&amp;hellip;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be busy doing sth：忙于做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be busy with sth：忙于某件事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be confident that + 句子：对xxx有信心&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be eager to do sth：渴望做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be going to do sth：将来要做啥 等价于 be gonna do sth&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be nervous about sth / doing sth：做某事很不安/紧张&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be proud of ：为谁感到自豪&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be aware of ：对什么很清楚，知道什么，意识到什么&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be astonish at sth：对什么感到很惊讶&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be confident that &amp;hellip; + 句子&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be called in to do sth：被叫来做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be dressed in ：穿着了什么（被动）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be dressed up as：打扮成了什么，也可以省略be&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be disappointed to learn that：很沮丧的得知&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be equal to sth：胜任某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be exempted from：从&amp;hellip;被免除&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be fanatical about/doing sth：对某事，做某事很狂热&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be likely to do sth：可能去做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be interested in doing sth：做某事感兴趣&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be instructed to do sth：被指示/命令做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be instructed in doing sth 等价于 instruct sb in sth/doing sth：教某人做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be lined up：排成一排&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be mad at sb：对某人生气&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be keen on sth/doing sth：热衷某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be / get upset about sth：对什么感到沮丧/不安&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be up for sale：待售&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be worth doing：值得去做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be pleased with：对什么感到满意&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be popular with：在xxx之间受欢迎&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be put to shame：等价于 put sb to shame，使某人感到惭愧&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be responsible for：对&amp;hellip;有责任&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be reluctant to do sth：不情愿做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be sensitive about sth：对某事感到敏感&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be tolerant of：容忍某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;get / be tired of sth / doing sth：厌倦做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;begin to do sth：等价于begin doing sth，都是表示 开始做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;belong to sb：属于某人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be confined to xxx：被困在 xxx&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;become / be an expert at doing sth：在做某事上次成为专家&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;bear sth in mind：牢记这sth一点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;borrow sth from sb：从某人那借来某物&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;board the plane：登机&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;black or white：非黑即白，比如see things in balck or white：看待事物非黑即白&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;black out：晕了，昏迷&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;break into cheers：欢呼起来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;burst into tears：爆哭&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cover the distance in &amp;hellip;：覆盖距离&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cause sb/sth to do sth：引起某人做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;call at 等价于 visit 等价于 call on：访问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;clear conscience（良心）：问心无愧&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;claim one&amp;rsquo;s life：夺走某人的性命&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;claim to have done sth：声称已经做过某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cling to sb/sth：附着在&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;charge at sb：冲向某人，有攻击性，等价于 attack&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;catch up with sb：追上某人 / 遇见某人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cover sb/sth with a：用a覆盖sb/sth&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;connect a to b：连接a和b，等价于 a be connected to b&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;complain about sth：抱怨某事 / complain of sth&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;continue doing / to do sth：继续做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;died from：死于环境、事故，died of：死于疾病、衰老&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;despite the fact that&amp;hellip;：除了这样一个事实是&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;devote oneself to sth / doing sth：致力于做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;drive on to sw：继续开向某处&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;died of 后面一般加疾病，表示死于什么疾病&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;drive me mad：把我逼疯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;dream of doing sth：梦想做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;don&amp;rsquo;t have to do 等价于 don&amp;rsquo;t need to do ，不必做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;do anything to do sth：使出浑身解数做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;even if：即使，even though：尽管&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;enter for：参加&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;expect sth to be done：期待某事被做&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;entitle sb to sth / to do sth：给某人有权利做某事，entitle另一个意思是给某个东西起名字&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;enable sb to do sth：确保某人做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;feel obliged to do sth：觉得有义务做某事，obliged to 等价于 bound to，意思是不得不做，一定做&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;fail to do sth：失败做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;far more interesting：有趣得多得多，far 这里表达远超，程度副词&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;forbid sb to do sth：禁止某人做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;feel sorry for sb：觉得某人挺可怜、值得同情，可悲&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;find sb doing sth：发现某人做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;for one cause or another：等价于 for one reason or another，因为诸多原因&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;gaze at / glance at：盯着，凝视着&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;get sth for sb：给某人拿某些东西&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;give up doing sth：放弃做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;give rise to：等价于 lead to 等价于cause，表示导致&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;get into (such) a mess：陷入麻烦 / 弄到一身灰尘&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;get a fright / give me a fright：受到惊吓 / 吓我一跳&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;going througth：翻阅&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;go on a diet 等价于 be on a diet ：表示节食&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;go on doing sth：持续 / 坚持做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;go on strike：罢工&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;go downhill：走下坡路&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;go to church：做礼拜，go to the church：去教堂&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;go to extreme to do sth：走极端做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;help oneself to sth：未经许可拿某人某物，偷某人某物&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;happend to do：碰巧做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hesitate to do sth：犹豫做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hesitate for a moment / second：等价于 wait a moment，表示等一会&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;have sth in common&amp;hellip;：在某事上是相同的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;have difficulty in doing sth：走某事很困难&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;have trouble with sth：做某事情有麻烦或困难&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;have a glimpse of sth/sb：瞥见某人 / 某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;have / make an impact on：在&amp;hellip;上产生影响&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;have a habit of doing sth：有习惯做某事，develop a habit：养成习惯&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;have authority to do：有权力做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;have/get the nerve to do sth：有勇气做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hear / see doing sth：非全程听/看到做某事，hear / see do sth：全程都听 / 看到做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hold up the traffic：阻塞交通，hold up the line：阻碍排队&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;i is/was wondering + 句子：我想知道的是&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;in this way：在路上&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;in sb&amp;rsquo;s honor：向某人致敬&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;in return for xxx：作为xxx的回报&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;in twenty minutes(&#39; time)：12分钟之后 / in six months：6个月后&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;in the front of (内部的前面) / in front of (外部的前面)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;intend to do sth：计划做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;insist on doing sth：坚持做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it seems that + 句子：似乎是&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it is a blessing that &amp;hellip; ：很幸运的是&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it is said that &amp;hellip; 等价于 be said to do sth：表示 据说&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it is disturbing to think that + 句子：很困扰的是&amp;hellip; + 句子&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it occurred to sb that（to do sth）&amp;hellip;：某人突然间想到&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it take sb sometime to do sth：花费某人多长时间做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it is no use pretending that + 句子：假装做&amp;hellip;是没有用的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;it comes as a surprise to learn that + 句子：得知某事很惊讶&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;knock at the door：敲门&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;keep guard：站岗，守卫，守在这里&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;keep in touch with sb：与某人保持联系&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;keep track of：追踪xxx的进展&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;lend sb sth：借给某人某物&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;leave sb a message：给某人留下信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;laugh at sb：嘲笑某人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;look forward to sth / doing sth：盼望做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;look down on sb：看不起某人，等价于 scornfully，轻蔑地&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;look on：旁观&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mind doing sth：介意做某事，格式：do you mind my smoking?为什么要用my，可以理解为smoke是属于&amp;quot;我的&amp;quot;，属于固定搭配，得是 “某人的”，可以省略，也可以用me&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mark the occasion：纪念这个场合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;make a spectacle of oneself：让某人出洋相&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;make no effort to do sth：不努力做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;make a decision：做决定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;make sb do sth：让某人做某事，被动，不能省略to，为 be made to do sth，被迫做某事，等价于 be forced to do sth&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;make up my mind：下定决心&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;manage to do sth：等价于 was able to do sth，含义：过去成功做了某事，设法做成了某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;might / may as well：（没有更好的选择）只能去做了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;mixture of a and b：a和b的混合物&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;move to a house in 地方 / move to 地方：搬到某个地方&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;not know the way to 地方：不知道那个地方的路&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;no sooner &amp;hellip; than &amp;hellip; ：等价于 as soon as，表示 一 &amp;hellip; 就&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;on doing sth, &amp;hellip; 等价于 as soon as，等价于 the moment，都表示 一&amp;hellip;就&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;on the last day：在最后一天&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;on the course：在路上，course还有其他意思，比如课程，过程，经过，球场，of course 当然&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;on this occasion：在这种场合，occasion：n 场合；occasionally：adv 是偶然的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;one way of another：不管怎么样&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;one good turn deserves another：礼尚往来，好人有好报，turn这里表行为&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;once upon a time：很久以前&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;once more：再一次，重新&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pocket money：零钱，零花钱&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;play truant from school：逃学&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pay for sth：支付某如&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pay it back：把他还回来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;pay sb a visit：拜访某人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;persuade sb (not) to do sth：说服某人做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;put forward a plan ：提出一个计划&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;put it behind me：抛之脑后，遗忘掉&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;put my finger on it：引申含义，明确的指出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;point the finger at：引申含义，指责或责备某人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;prevent sb from doing sth：阻止某人做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(would) prefer to do sth 等价于 prefer doing sth，更喜欢做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;prefer A to B：和b比我更喜欢A&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;prefer doing A to doing B ：和做 B 相比我更喜欢做A&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;(would) prefer to do A rather than B：和做B相比，我更喜欢做A&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;protect A from B：保护A免于B的(伤害)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;provide sb with sth：提供给某人某物&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;receive sth from sb：从谁那收到东西&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;refuse to do sth：拒绝做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;remind sb of sth/sb：提醒某人想起某事/人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;remember sb for + sth：想起某人某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;regretted doing sth：后悔做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;run into serious trouble：遇到严重的困难&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;run out of：用尽，耗尽&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;save up for years to buy sth：存了很多年钱买某物&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;should (not) do 或者 ought (not) to do，都是表示应该做&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;should have done 或者 ought to have done，都是表示本应该做某事，但却没有&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sort of 等价于 kind of：各种类型，各种种类，what sort of / what kind of，all sorts of / all kinds of&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;spot sb doing sth：看到某人做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;spend固定用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;spend on：在&amp;hellip;方面花费&lt;/li&gt;
&lt;li&gt;spend money on：花多少钱买某物&lt;/li&gt;
&lt;li&gt;spend time (in) doing：花时间做某事&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;speed it / things / this up：加速做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;stand on sb&amp;rsquo;s head：倒立&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;start doing sth：开始做某事， 等价于 set out to do sth 、intend to do sth、begin to do sth&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;stick to the plan：坚持这个计划&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;step side：站到一边；从重要的职位离开，辞职；撤退&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;stop by：顺便来访&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;set up a new world record：创建新的世界记录 / break the record：打破世界记录&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;seem to be doing：似乎在做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;shout at sb：带情绪的那种喊，shout to sb：使某人能听到的那种喊&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;stick my plan：坚持我的计划&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;stamp out：踩灭、踩出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;so far：到目前为止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;so long as：只要&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;so + adj/adv：表程度，可以是形容词或副词，&lt;/p&gt;
&lt;p&gt;such + adj + n：表程度，但一定是形容词+名词，形容词也可以去掉&lt;/p&gt;
&lt;p&gt;so adj/adv that &amp;hellip; 、 such + (adj) + n + that：如此&amp;hellip;以至于&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;succeed in doing sth：成功做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;suggest that &amp;hellip; does / should do，建议某人做某事，should可省略，可do可does&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sneer at sb 或者 with a sneer：冷笑某人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;sb take a long time to do sth：某人花费很长时间做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;take sth/sb seriously：认真对待某事/某人&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;take it away from me：从我身边抢走&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;take plates of &amp;hellip;：给&amp;hellip;拍片&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;take a lift / ask for a lift / give sb a lift：请求搭便车&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;take charge of ：负责，掌管，承担责任，控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;take off：飞机起飞，touch down：飞机降落&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;too adj to do sth：太 adj 以至于不能做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;to make matters worse：使事情变得更糟糕的是&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;to sb&amp;rsquo;s horror：使某人惊恐&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;think about sth/sb：思考某人/某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;tech sb sth：教给某人某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;try to do sth：尝试做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;turn out to be：结果是，原来是，证明是&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;to sb&amp;rsquo;s surprise：让某人惊讶的是&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;that&amp;rsquo;s neat 等价于 that&amp;rsquo;s cool&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the last day of the year：一年的最后一天&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;threaten sb with sth：威胁某人某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;two minutes past twelve：12点过2分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;the news get around：消息传播开来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wake up with start：惊醒&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;work for xx：给xx工作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;well-konw：著名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;will be away：离开&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wave to sb：向某人招手&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;without doing sth：没有做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;urge sb to do sth：怂恿某人做某事&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;up to now：到目前为止&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;use up：用光&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;use to do sth：过去常常做某事（现在不做了），否定式为 didn&amp;rsquo;t use to do&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;区别 be use to doing：习惯做某事&lt;/li&gt;
&lt;li&gt;区别 be used to do sth：被用来做某事&lt;/li&gt;
&lt;li&gt;与would do的区别，would do指的是过去重复发生的动作、过去经常做某事，use to do指过去的状态 或者 暗含现在不发生了 或者 讨论经常且重要的习惯行为(比较主观，看情况)&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;be use as：被当作，use A as B：把A当成B&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;语法&#34;&gt;语法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;介词 + 地方：at + 小地方，on + 大地方&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ever + 在疑问词后面，比如what、why、who 表示强调，根据语气，可能带有 surprise / astonishment(惊讶) / anger / irritation(激怒) / dismay 等情绪&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;do / does / did 肯定句表强调，一般加在动词后面，后面动词原型，eg：She &lt;strong&gt;did do&lt;/strong&gt; morning exercises this morning; 这里的did是表强调，去掉did也可以，She did morning exercises this morning; 这里的did是do的过去式；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;was / were doing表礼貌，此时可以跟未来的时间一起搭配&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;yet，表示前后句子的表达前后反差很大，yet引导的句子表示很惊喜很惊讶，强转折，表然而但是&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;强调句：it is(was) + 强调部分 + that(who) + 剩余部分&lt;/p&gt;
&lt;p&gt;eg：it was my secretan that sent the bill to Mr.Harding yesterday.&lt;/p&gt;
&lt;p&gt;it was the bill that my secretary sent to Mr.Harding yesterday.  两者强调的部分不一样&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比较级，最高级，一般规则是加 er/ est，其他的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;单音节，元音 + 辅音结尾，双写辅音字母，加 er / est&lt;/li&gt;
&lt;li&gt;双音节，辅音字母 + y结尾，变y为i，加 er / est&lt;/li&gt;
&lt;li&gt;一些另外 或者 多音节(&amp;gt;=3个音节)，是加 more，most 或者 less，lest&lt;/li&gt;
&lt;li&gt;甚至有一些上面的规则皆可&lt;/li&gt;
&lt;li&gt;不规则的，比如 good / well -&amp;gt; better -&amp;gt; best；bad -&amp;gt; worse -&amp;gt; worst；little -&amp;gt; less -&amp;gt; least&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比较级常见用法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主语 + be + adj. er + than + 比较对象&lt;/li&gt;
&lt;li&gt;主语 + be + the + adj. est + n + 范围&lt;/li&gt;
&lt;li&gt;主语 + be + the + adj. est + n + I‘ve ever met/seen/konwn； xxx我所知道的最xxx的xxx&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时间用法，常规用法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;on + 具体的某一天&lt;/li&gt;
&lt;li&gt;in + 年/季/月，早上/下午/晚上&lt;/li&gt;
&lt;li&gt;at + 时间点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;having been done：完成时的被动，可结合 分词作状语 使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;have / get something done：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;含义一：让别人来做某事，自己不做&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;含义二：意外，不幸的遭遇，翻译成 被&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;have gone to：已经去了，人没回来&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;have been to：已经去过，人回来了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;have/has （not） been doing sth：现在完成进行时&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用法一：过去进行的动作(结束)对现有的影响&lt;/li&gt;
&lt;li&gt;用法二：过去进行的动作持续（重复）到现在，也许还会继续&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;have / has done : 现在完成时&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用法一：表示过去的事情对现在产生了影响，等价于 did + do/does（做过了什么，现在怎么样）&lt;/li&gt;
&lt;li&gt;用法二：从过去持续到现在的事情，一般会加时间&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;had done：过去完成时&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用法一：过去的过去，强调的是两个过去是有关联的，不然用一般过去时即可&lt;/li&gt;
&lt;li&gt;用法二：过去时间点A发生，对过去时间点B产生了影响&lt;/li&gt;
&lt;li&gt;用法三：一个动作从过去A持续或重复到过去B&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;will have done：将来完成时，否定：won&amp;rsquo;t have done&lt;/p&gt;
&lt;p&gt;后面常见于接未来时间 &lt;strong&gt;by&lt;/strong&gt; next Monday、&lt;strong&gt;by&lt;/strong&gt; tomorrow&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用法一：一个动作持续或重复到将来&lt;/li&gt;
&lt;li&gt;用法二：一个动作截止到未来某个时间前完成&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;had been doing sth：过去完成进行时&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用法一：过去A进行的v（结束）对过去B产生的影响&lt;/li&gt;
&lt;li&gt;用法二：过去A进行的 v 持续或重复到过去B&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%ae%8c%e6%88%90%e6%97%b6%e6%97%b6%e6%80%81.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%ae%8c%e6%88%90%e6%97%b6%e6%97%b6%e6%80%81.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;被动语句&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;am/is/are + done&lt;/li&gt;
&lt;li&gt;was/were + done&lt;/li&gt;
&lt;li&gt;am/is/are + being + done&lt;/li&gt;
&lt;li&gt;have/has + been + done&lt;/li&gt;
&lt;li&gt;had + been + done&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;how many对可数名词提问，how much对不可数名词提问&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;have to 和 must 的区别，两者都是表达必须，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;must用在一般现在时，但是没办法表达过去；have to可以用时态，表达过去就能用 had to do 了，否定：don&amp;rsquo;t have to；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;must表主观，have to表客观&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;美式英语，直接用 have to，不区分&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;have to 等价于 have got to，have gotta do，都是表示必须（比较少用，口语用的多）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;have got 等价于 have，都是表示 拥有&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;must / can 表推测&lt;/th&gt;
&lt;th&gt;现在&lt;/th&gt;
&lt;th&gt;过去&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;肯定&lt;/td&gt;
&lt;td&gt;must do&lt;!-- raw HTML omitted --&gt;must be adj / n&lt;!-- raw HTML omitted --&gt;must be doing&lt;/td&gt;
&lt;td&gt;must have done&lt;!-- raw HTML omitted --&gt;must have been adj / n&lt;!-- raw HTML omitted --&gt;must have been doing&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;否定&lt;/td&gt;
&lt;td&gt;can&amp;rsquo;t do&lt;!-- raw HTML omitted --&gt;can&amp;rsquo;t be adj / n&lt;!-- raw HTML omitted --&gt;can&amp;rsquo;t be doing&lt;/td&gt;
&lt;td&gt;can&amp;rsquo;t have done&lt;!-- raw HTML omitted --&gt;can&amp;rsquo;t have been adj / n&lt;!-- raw HTML omitted --&gt;can&amp;rsquo;t have been doing&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;may / might 表推测，可能是&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;may / might 表推测&lt;/th&gt;
&lt;th&gt;现在&lt;/th&gt;
&lt;th&gt;过去&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;肯定 / 否定&lt;/td&gt;
&lt;td&gt;may / might (not) do&lt;!-- raw HTML omitted --&gt;may / might (not) be  adj / n&lt;!-- raw HTML omitted --&gt;may / might (not) be doing&lt;/td&gt;
&lt;td&gt;may / might (not) have done &lt;!-- raw HTML omitted --&gt;may / might (not)have been adj / n &lt;!-- raw HTML omitted --&gt;may / might (not) have been doing&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;need&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;动词，含义同want：need to do sth，否定 don&amp;rsquo;t need to do sth（等价于 don&amp;rsquo;t have to do sth，不必做某事）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;情态动词，含义同can，表不必（常出现在否定句/疑问句）：needn&amp;rsquo;t do 等价于 can’t do&lt;/p&gt;
&lt;p&gt;needn&amp;rsquo;t have done：本不必如此，但事情已经发生了，有后悔的语言效果；要区分needn&amp;rsquo;t do，两种意思还是不太一样&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;need doing sth：被动语句，等价于 need to be done&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;should (not) do 或者 ought (not) to do，都是表示应该做&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;should have done 或者 ought to have done，都是表示本应该做某事，但却没有&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;并列连词&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;both A and B ：A 和 B 都&lt;/li&gt;
&lt;li&gt;either A or B：A 或 B，就近原则，看B是不是复数，来决定后面的动词是什么&lt;/li&gt;
&lt;li&gt;neither A nor B：既不是 A 也不是 B ，就近原则，看B是不是复数，来决定后面的动词是什么&lt;/li&gt;
&lt;li&gt;not only &amp;hellip; but also &amp;hellip;：不仅&amp;hellip;而且&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;if 引导的条件从句，主将从现&lt;/strong&gt;，eg：if you don&amp;rsquo;t hurry, you will miss the train.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;if 真实条件句&lt;/strong&gt;：A动作成立关联B动作成立，不符合虚拟语气结构，不与事实相反，比如 if 引导的主将从现句子是一种例子，其他例子：if you didn&amp;rsquo;t study English at school, you won&amp;rsquo;t understand this book. 或者 if jack didn&amp;rsquo;t come to work yesterday, he was probably ill.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;虚拟语气：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;if + did/were, 主语 + would / should / could / might do&lt;/strong&gt;，这里的did并非表示过去，比如有 &lt;code&gt;if i were you, i wouldn&#39;t do that&lt;/code&gt;这句话是对的
&lt;ul&gt;
&lt;li&gt;if 从句中的 动词 与 &lt;strong&gt;现在的事实&lt;/strong&gt; 相反&lt;/li&gt;
&lt;li&gt;说话人认为，if 从句中 动词 发生的机率非常低，所以如果 if 从句里是否定句，那将biao&amp;rsquo;s&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;if + 主语 + had done&amp;hellip;，主语 + would / should / could / might + have done.
&lt;ul&gt;
&lt;li&gt;if 从句中的 动词 与 &lt;strong&gt;过去的事实&lt;/strong&gt; 相反&lt;/li&gt;
&lt;li&gt;变体，if + 主语 + could have done ，比如  if you &lt;strong&gt;could have made&lt;/strong&gt; 等价于 if you &lt;strong&gt;had been able to&lt;/strong&gt; make&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定语从句 与 同位语从句 的区别：&lt;/p&gt;
&lt;p&gt;两者都作补充说明，但定语从句是修饰，而同位语从句是一个完整的句子补充说明一个名词，去掉连接词也是完整的，而定语从句的 that / which / who 是充当句子成分的，比如主语或宾语，不能去掉&lt;/p&gt;
&lt;p&gt;名词性从句，从句一般充当名词，解释名词，常用的连词：that / if or whether / 常用特殊疑问词&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;宾语从句：&lt;/p&gt;
&lt;p&gt;He asked (&lt;strong&gt;if&lt;/strong&gt; Mr. Gilbert&amp;rsquo;s operation had been successful) and the doctor told him (&lt;strong&gt;that&lt;/strong&gt; it had been).&lt;/p&gt;
&lt;p&gt;He then asked (&lt;strong&gt;when&lt;/strong&gt; Mr. Gilbert would be allowed to go home)&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同位语从句：&lt;/p&gt;
&lt;p&gt;No one could account for the fact &lt;strong&gt;that&lt;/strong&gt; one of the boxes was extremely heavy.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表语从句：&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主语从句：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;It&lt;/strong&gt; seem certain &lt;strong&gt;that their plane would crash.&lt;/strong&gt; 这里从句指代的是it&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;形容词从句，从句解释形容词，常用连接词 that / who /which / where / whose / when&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定语从句：&lt;/p&gt;
&lt;p&gt;Jasper White is one of those rare people (&lt;strong&gt;who&lt;/strong&gt; believe in acient myths.)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非限定性定语从句&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;副词性从句，从句解释副词，如 状语从句；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时间状语从句：常用连词：when / while / as / before / after / as soon as / til / until；特殊连词：ever since / since / the moment / no sooner &amp;hellip; than &amp;hellip; / hardly &amp;hellip; when&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;地点状语从句&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原因状语从句：常用连词：because / as / for / since&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目的状语从句：常用连词：so that / in order that / that &amp;hellip;； 特殊连词：in order to / as &amp;hellip; as to&lt;/p&gt;
&lt;p&gt;eg：so that：以便，为了，一般用于连接两个句子，表目的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;结果状语从句：常用连词：so &amp;hellip; that / such &amp;hellip; that &amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;条件状语从句：常用连词：if / unless&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;让步状语从句：常用连词：although / though / even thougt / even if / no matter how / whatever / whoever&amp;hellip;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比较状语从句：as &amp;hellip; as / than&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;方式状语从句：as / like / as if / the way&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分词作定语&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;done作定语&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;被动一般&lt;/p&gt;
&lt;p&gt;The taxi is a small airplane &lt;strong&gt;called&lt;/strong&gt; a &amp;lsquo;Pilatus Porter&amp;rsquo;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;被动完成&lt;/p&gt;
&lt;p&gt;on a &lt;strong&gt;ploughed&lt;/strong&gt; field&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主动完成&lt;/p&gt;
&lt;p&gt;a &lt;strong&gt;retired&lt;/strong&gt; captain = a captain who has retired&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;doing作定语&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主动进行&lt;/p&gt;
&lt;p&gt;the &lt;strong&gt;sleeping&lt;/strong&gt; child = the child who is sleeping.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主动一般&lt;/p&gt;
&lt;p&gt;I like the girl &lt;strong&gt;dancing with that guy&lt;/strong&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分词作状语，简化状语从句&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;一般需要&lt;strong&gt;前后主语一致&lt;/strong&gt;；去掉状语从句的主语，连词可留；从句的动词变成分词；分词有两种，如果从句是主动进行或者主动一般，使用doing，如果从句是被动完成 或 被动一般，使用done；&lt;/p&gt;
&lt;p&gt;原句：When the baby opened his eyes, he began to cry.&lt;/p&gt;
&lt;p&gt;改成分词状语引导：Opening his eyes, the baby began to cry.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果分词要强调从句的动词发生在主句动作前，使用having done&lt;/p&gt;
&lt;p&gt;原句：After he had completed the book, he had a holiday.&lt;/p&gt;
&lt;p&gt;改成分词状语引导：(After) Having completed the book, he had a holiday.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是否定的，使用 not + 分词&lt;/p&gt;
&lt;p&gt;原句：Because i didn&amp;rsquo;t want to wake her, I left the house silently.&lt;/p&gt;
&lt;p&gt;改成分词状语引导：Not wanting to wake her, I left the house silently.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;特殊的，be + 形容词 + 名词&lt;/p&gt;
&lt;p&gt;原句：My girlfriend is a doctor, she knows what medicine you should take;&lt;/p&gt;
&lt;p&gt;改成分词状语引导：（Being）a doctor, my grilfriend knows what medicine you should take.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;限定性定语从句和非限定性定语从句，都是做补充和说明，区别是非限定性定语从句前面有逗号，且去掉这句也无所谓，而限定性定语从句的修饰是指定的，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;He has a daugter who works in a hospital. 表示有一个在医院工作的女儿，可能也有其他女儿，但是这里特指那个在医院工作的&lt;/li&gt;
&lt;li&gt;He has a daugter, who works in a hospital. （= and she works in a hospital）表示有一个女儿，这个女儿是在医院工作&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;only部分倒装&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;only 在句首时，主谓可能颠倒，属于语言习惯，有时和than一起出现，only than&amp;hellip;&lt;/p&gt;
&lt;p&gt;Only on one occasion &lt;strong&gt;have I&lt;/strong&gt; ever felt frightened.&lt;/p&gt;
&lt;p&gt;Onlythen &lt;strong&gt;did I&lt;/strong&gt; understand what she meant.&lt;/p&gt;
&lt;p&gt;Only after her death &lt;strong&gt;was I&lt;/strong&gt; able  to do that.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;only 说明主语，主谓不倒装&lt;/p&gt;
&lt;p&gt;Only policemen can come in.&lt;/p&gt;
&lt;p&gt;Only my mother really understands me.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;not only + 部分倒装（简单理解为将原句改成一般疑问句），起到强调的作用，eg：&lt;/p&gt;
&lt;p&gt;And &lt;strong&gt;you will not only&lt;/strong&gt; have to pay him to do this, far more important, you will have to agree with him. 部分倒装之后：&lt;/p&gt;
&lt;p&gt;And &lt;strong&gt;not only will you&lt;/strong&gt; have  to pay him to do this, far more important, you will have to agree with him.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>Redis</title>
        <link>http://nixum.cc/p/redis/</link>
        <pubDate>Sun, 09 Aug 2020 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/redis/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;数据类型及结构&#34;&gt;数据类型及结构&lt;/h1&gt;
&lt;p&gt;Redis里存的key和value都是二进制数据，即 byte数组，本身是二进制安全的（二进制安全的意思是，存进去怎么样，取出来就是怎么样，程序不会对原始数据进行任意的操作）&lt;/p&gt;
&lt;h2 id=&#34;数据类型&#34;&gt;数据类型&lt;/h2&gt;
&lt;p&gt;具体的分为5种基本类型和3种特殊类型：&lt;/p&gt;
&lt;p&gt;String、List(一般当成队列，尽量少使用随机读写)、Hash、Set、ZSet&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;String&lt;/strong&gt;：简单动态字符串(SDS)&lt;/p&gt;
&lt;p&gt;场景：缓存（可以使用json、protobuf等进行序列化反序列化、也可以通过key来分离缓存对象的属性，实现hash的效果，只是是单字段罢了）、token、限流、分布式id&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;List&lt;/strong&gt;：压缩列表（元素数量小于512，且所有元素的长度都小于64字节） + 双向链表，高版本是快表（其他情况使用）&lt;/p&gt;
&lt;p&gt;场景：用户消息时间线、消息队列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Hash&lt;/strong&gt;：压缩列表（元素数量小于512，且key和value字符串长度都小于64字节） + 哈希表（其他情况使用）&lt;/p&gt;
&lt;p&gt;场景：存储对象缓存（可以更方便get、set对应字段）、根据key进行统计&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Set&lt;/strong&gt;：数组（带有编码类型字段，所以元素可以使用整型表示，少于512个时使用）+ 哈希表（key为set中的元素，value为null，其他情况使用）&lt;/p&gt;
&lt;p&gt;场景：交集、并集、点赞、签到、随机弹出获取元素&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;ZSet&lt;/strong&gt;：压缩列表（元素小于128个，且所有元素的长度小于64字节时使用） + 跳表 （其他情况使用）&lt;/p&gt;
&lt;p&gt;场景：排行榜&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外三种扩展类型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Bitmap&lt;/strong&gt;：位存储，基于String，原理：String类型会保存二进制字节数组，只有0和1两个值，对于这个字节数组的每个bit来表示一个元素的二值状态；&lt;/p&gt;
&lt;p&gt;场景：二值统计，如签到统计、记录每个月签到情况、判断用户登录状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;HyperLogLog&lt;/strong&gt;：基数统计，类似set，不断往里add值，然后判断有总数量；主要作用是使用少量固定的内存（12KB内存即可统计2^64个不同元素）去存储并识别有大量元素的集合中的唯一元素，能快速算出集合内的元素个数，误差率0.81%；版本2.8.9之后才有&lt;/p&gt;
&lt;p&gt;场景：百万级别网络的UV计数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Geo&lt;/strong&gt;：推算地理位置，比如两地之间的距离，方圆几里的人；版本3.2之后才有&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Stream&lt;/strong&gt;：5.0之后的版本才有，Stream会在第一次使用 &lt;code&gt;xadd&lt;/code&gt; 指令追加消息时自动创建。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Consumer Group&lt;/code&gt;：消费组，一个消费组有多个消费者，这些消费者是竞争关系；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Last_delivered_id&lt;/code&gt;：游标，每个消费组的游标，组内任意一个消费者读取了消息都会使游标向前移动；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pending_ids&lt;/code&gt;：消费者的状态变量，用于维护消费者未确认的id，记录当前已经被客户端读取但还没有被ACK的消息。如果客户端没有ACK，这个变量里面的消息ID会越来越多，一旦某个消息被ACK，它就开始减少，用来确保客户端至少消费了消息一次，而不会在网络传输的中途丢失了没处理。&lt;/li&gt;
&lt;li&gt;消息ID：组成方式&lt;code&gt;毫秒级时间戳 - 序号&lt;/code&gt;，消息ID也可以自定义，但必须是整数-整数，且能后面加入的消息ID要大于前面的消息ID。Redis本身会记录 &lt;code&gt;lastest_generated_id&lt;/code&gt;，防止时间回拨导致ID问题；&lt;/li&gt;
&lt;li&gt;消息内容：键值对，类似Hash的结构；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Redis_Stream.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Redis_Stream.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;底层数据结构&#34;&gt;底层数据结构&lt;/h2&gt;
&lt;p&gt;Redis所有类型有一个顶层的数据结构叫RedisObject，这个RedisObject底层对应着具体对象类型和其编码方式。&lt;/p&gt;
&lt;p&gt;之所以有RedisObject对象，是因为每种不同的数据类型有不同的编码方式和结构，Redis必须让每个键都带有类型信息，使得程序可以检查键的类型，还需要根据数据类型的不同编码进行&lt;strong&gt;多态&lt;/strong&gt;处理。&lt;/p&gt;
&lt;p&gt;比如：SADD命令只能用于Set，LPUSH命令只能用于List，而DEL、TTL又能用于所有键，要正确实现这些命令，就需要为不同类型的键设置不同的处理方式；另外，同一种数据类型可能由不同的数据结构实现，比如List，底层可能是压缩列表或者双向链表，因此还需要知道数据类型的编码方式。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-c&#34; data-lang=&#34;c&#34;&gt;&lt;span class=&#34;k&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redisObject&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 类型，如String、List
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;type&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 编码方式：如SDS、压缩列表、跳表等
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;encoding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// LRU - 24位, 记录最后一次访问时间（相对于lru_clock）; 或者 LFU（最少使用的数据：8位频率，16位访问时间）
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;unsigned&lt;/span&gt; &lt;span class=&#34;nl&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LRU_BITS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// LRU_BITS: 24
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 引用计数，新创建对象时值为1，当对该对象进行共享时值+1，使用完一个对象后值-1，=0时被GC回收
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;refcount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 指向底层数据结构实例，具体的实例，由type和encoding决定
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ptr&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;robj&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;当执行一个处理数据类型命令的时候，redis执行以下步骤&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据给定的key，在数据库字典中查找和他相对应的redisObject，如果没找到，就返回NULL；&lt;/li&gt;
&lt;li&gt;检查redisObject的type属性和执行命令所需的类型是否相符，如果不相符，返回类型错误；&lt;/li&gt;
&lt;li&gt;根据redisObject的encoding属性所指定的编码，选择合适的操作函数来处理底层的数据结构；&lt;/li&gt;
&lt;li&gt;返回数据结构的操作结果作为命令的返回值&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;Redis本身还会预分配一些值对象，比如响应结果OK、ERROR，还有包括0在内，所有小于REDIS_SHARED_INTEGERS（默认值是10k，&lt;code&gt;[0 - 9999]&lt;/code&gt;）的所有整数，共享对象只能被字典或双向链表这类带有指针的数据结果使用。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/RedisObject.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/RedisObject.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;简单动态字符串---sds&#34;&gt;简单动态字符串 - SDS&lt;/h3&gt;
&lt;p&gt;Redis的String类型底层有两种保存形式，当保存的是64位有符号整数时，String类型会保存为一个9字节的Long类型整数；当保存的数据包含字符时，String类型就会用简单动态字符串SDS。&lt;/p&gt;
&lt;p&gt;简单动态字符串SDS由三个部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;buf&lt;/code&gt;：是字节数组，保存实际数据，结束标志位是&amp;quot;/0&amp;quot;；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;len&lt;/code&gt;：表示buf已用长度，占4字节；SDS不使用 &amp;ldquo;/0&amp;rdquo; 来判断字符串是否结束，而是通过 &lt;code&gt;len&lt;/code&gt; 来判断；&lt;code&gt;len&lt;/code&gt; 同时也能防止缓冲区溢出；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;alloc&lt;/code&gt;：表示buf的实际分配长度，一般大于len；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;len&lt;/code&gt;和&lt;code&gt;alloc&lt;/code&gt;两个属性，对于修改字符串SDS实现了空间预分配和惰性空间释放两种策略：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;空间预分配：当字符串进行扩展时，扩展的内存会比实际需要的多，减少连续字符串增长带来的内存频繁分配。&lt;/p&gt;
&lt;p&gt;当字符串长度小于 1M 时，扩容时双倍扩容，如果超过 1M，扩容一次只会多扩 1M 的空间，默认的最大长度是 512M，可通过配置文件修改。&lt;/p&gt;
&lt;p&gt;执行Append命令的字符串会带有预分配的空间，这些预分配的空间不会被释放，除非对应的key被删除，或者重启后重新载入，才会删除预分配的空间，如果有存在大量预分配的字符串，可以修改配置使其定时释放预分配的空间，更有效的使用内存。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;惰性空间释放：当字符串进行缩短时，不会使用内存重新分配的方式来回收多余字节，而只是用&lt;code&gt;alloc&lt;/code&gt; 记录这些字节的数量，等待后续使用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RedisObject包含了8个字节的元数据和一个8字节指针，指针指向具体的数据类型的实际数据所在，&lt;/p&gt;
&lt;p&gt;对于String类型的RedisObject：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当保存的是Long类型整数时，RedisObject中的指针直接就是整数数据，不用额外的指针指向整数；&lt;/li&gt;
&lt;li&gt;当保存的是字符串时，如果字符串&amp;lt;=44字节，RedisObject中元数据，指针和SDS是一块连续的内存区域，避免内存碎片；&lt;/li&gt;
&lt;li&gt;当保存的是字符串时，如果字符串&amp;gt;44字节，RedisObject会给SDS分配独立的空间，并用指针指向SDS；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Redis_String_RedisObject.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Redis_String_RedisObject.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;Redis String RedisObject&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Redis String RedisObject&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当使用String类型时，且value的类型是String时，如果value的长度太小，可能会出现元数据的大小比数据本身的大小还大，造成额外的内存开销，如果能替换成Long类型，实际存储的大小会大大降低。&lt;/p&gt;
&lt;h3 id=&#34;哈希表---dict&#34;&gt;哈希表 - Dict&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Redis_%e5%85%a8%e5%b1%80%e5%93%88%e5%b8%8c%e8%a1%a8.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Redis_%e5%85%a8%e5%b1%80%e5%93%88%e5%b8%8c%e8%a1%a8.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;Redis Dict&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Redis Dict&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;无论值是什么类型的，所有的键值对会保存在&lt;strong&gt;全局哈希表&lt;/strong&gt;中，便于快速找到对应的Key，哈希桶只会保存键值对的指针。全局哈希表中的桶每个元素entry由三个8字节指针组成，分别为key、value、next，但实际会占32字节，因为内存分配库jemalloc会分配最接近24的2的幂次数，所以是32，以减少频繁的分配次数。&lt;/p&gt;
&lt;p&gt;因此，即使Redis里存在大量数据，也不影响查找的速度，毕竟都是根据Key进行hash就能找到对应的Value，真正有影响的是哈希表的在解决哈希冲突和rehash时带来的阻塞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Redis的哈希表使用拉链法解决哈希冲突，并通过两个全局哈希表加快rehash的操作。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Redis_Dict.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Redis_Dict.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;Redis Dict&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Redis Dict&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;处理全局哈希表有这种操作，Hash的数据结构也是这样的操作，本质是一样的。&lt;/p&gt;
&lt;h4 id=&#34;rehash触发条件&#34;&gt;rehash触发条件&lt;/h4&gt;
&lt;p&gt;当Redis生成RDB和AOF重写时，哈希表不会进行rehash。&lt;/p&gt;
&lt;p&gt;装载因子：哈希表中所有entry的个数 除以 哈希表的哈希桶个数。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当装载因子&amp;gt;= 1，且哈希表被允许rehash，即此时没有进行RDB和AOF重写，即没有执行或正在执行 &lt;code&gt;BGSAVE&lt;/code&gt; 命令或者 &lt;code&gt;BGREWRITEAOF&lt;/code&gt; 命令&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当装载因子&amp;gt;= 5，因为此时数据量已远远大于哈希桶的个数了，此时会立马进行rehash，不管是否有没有在执行RDB快照或AOF重写，都会强制进行rehash操作；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;rehash过程&#34;&gt;rehash过程&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;默认使用哈希表1，此时哈希表2还没有被分配空间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当数据增多至需要rehash时，为哈希表2分配空间，大小会比哈希表1大，比如&lt;strong&gt;大两倍&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;把哈希表1中的数据重新映射并拷贝到哈希表2中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;渐进式rehash&lt;/strong&gt;：解决大量数据在哈希表1和2之间拷贝，会导致Redis线程阻塞的问题（因为单线程)。&lt;/p&gt;
&lt;p&gt;3.1 拷贝数据时，Redis仍然正常处理客户端请求，每处理一个请求时，从哈希表1中的第一个索引位置开始，顺便将该索引位置上的所有entries拷贝到哈希表2中；&lt;/p&gt;
&lt;p&gt;3.2 等待处理下一个请求时，再顺带拷贝哈希表1中该索引下一个索引位置的entries到哈希表2中；&lt;/p&gt;
&lt;p&gt;通过这两种方式，将一次性的大量拷贝分散到每次请求和等待间隙中。&lt;/p&gt;
&lt;p&gt;3.3 此外Redis本身也有一个&lt;strong&gt;定时任务&lt;/strong&gt;在执行rehash，发生在空闲时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;释放哈希表1的空间，此时哈希表1的空间被回收，原来的哈希表2变成哈希表1，哈希表1变成哈希表2&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;渐进式rehash过程中，如果有新的键值对存进来，Redis会把该键值对放到哈希表2中，确保哈希表1里的键值对只会减少；如果是有查询进来，则会先查询哈希表1，再查询哈希表2。&lt;/p&gt;
&lt;h4 id=&#34;底层的两种实现&#34;&gt;底层的两种实现&lt;/h4&gt;
&lt;p&gt;对于Hash数据类型，底层有压缩列表和哈希表两种实现，当底层使用压缩列表时，存储的时候是以key、value的顺序存储的，新增的键值对保存在表尾；使用压缩列表时，底层是无法利用index查找，只能遍历查找。&lt;/p&gt;
&lt;p&gt;当Hash 集合中写入的元素个数超过了 &lt;code&gt;hash-max-ziplist-entries&lt;/code&gt;，或者写入的单个元素大小超过了 &lt;code&gt;hash-max-ziplist-value&lt;/code&gt;，Redis 就会自动把 Hash 类型的实现结构由压缩列表转为哈希表，且之后不可逆。&lt;/p&gt;
&lt;h3 id=&#34;压缩列表---ziplist&#34;&gt;压缩列表 - ZipList&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/redis_%e5%8e%8b%e7%bc%a9%e5%88%97%e8%a1%a8.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/redis_%e5%8e%8b%e7%bc%a9%e5%88%97%e8%a1%a8.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;Redis Ziplist&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Redis Ziplist&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;本质上是一个数组，数组中每一个元素保存一个数据。压缩列表的结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;表头有三个字段：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;zlbytes&lt;/code&gt;记录整个压缩列表占用的内存字节数，可算出列表长度；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zltail&lt;/code&gt;记录列表最后一个&lt;code&gt;entry&lt;/code&gt;的偏移量，可算出尾节点到列表起始地址的字节数，快速完成pop操作；&lt;/li&gt;
&lt;li&gt;&lt;code&gt;zllen&lt;/code&gt;记录列表中的&lt;code&gt;entry&lt;/code&gt;个数，只占用2bytes，如果压缩列表中&lt;code&gt;entry&lt;/code&gt;的数目小于 65535 ，2的16次方，该字段存储的就是实际的&lt;code&gt;entry&lt;/code&gt;数，如果超过或等于该值，则实际数量要遍历&lt;code&gt;entry&lt;/code&gt;才能得到；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个节点元素&lt;code&gt;entry&lt;/code&gt;有四个字段：&lt;code&gt;previous_entry_length&lt;/code&gt;记录前一个节点的长度；&lt;code&gt;encoding&lt;/code&gt;记录&lt;code&gt;content&lt;/code&gt;的数据类型和长度；&lt;code&gt;content&lt;/code&gt;保存元素的值；&lt;code&gt;len&lt;/code&gt;表示自身长度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;表尾有一字段：&lt;code&gt;zlend&lt;/code&gt;终止字符，用于标记列表末端。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数据类型List、Hash、ZSet都有使用到压缩列表。&lt;/p&gt;
&lt;p&gt;压缩列表可以存储字符串或整数，存储整数时采用整数的二进制而不是字符串形式存储，能在O(1)时间复杂度下完成 list 两端的 push 和 pop 操作，由于每次操作都需要重新分配压缩列表的内存，so实际复杂度跟其内存使用量有关。&lt;/p&gt;
&lt;p&gt;压缩列表的优势在于存储结构，普通数组要求数组的每个元素的大小相同，但是当我们需要在每个元素中存储大小不同的字符串时，就会浪费存储空间，压缩列表就是会把每个元素多余的空间进行压缩，让每个元素紧密相连，再为每个元素增加一个长度，用于计算下一个元素在内存中的位置。&lt;/p&gt;
&lt;p&gt;另外，在内存的地址查找时，在查找第一个和最后一个的时候有优势，可以利用表头的三个字段查到，是O(1)，但是因为存储紧凑的缘故，查找其他元素只能遍历，是O(n)。&lt;/p&gt;
&lt;p&gt;压缩列表或者数组主要因为其数据结构紧凑，节省空间，避免内存碎片，提升内存利用率，线性顺序存储，对CPU高速缓存支持友好。对于查找的时间复杂度的优势提升不大。但是，由于压缩列表比较紧凑，在新增更新删除操作时可能会引发连锁更新，此时最坏为O(n^2)，但触发概率相对较低，利大于弊。&lt;/p&gt;
&lt;h3 id=&#34;快表---quick-list&#34;&gt;快表 - Quick List&lt;/h3&gt;
&lt;p&gt;3.2版本后才添加，之前的版本是双向链表，本质上是一个链表，只是每个节点都是一个压缩列表。&lt;/p&gt;
&lt;p&gt;快表为了解决压缩列表增删元素时的连锁反应导致的性能下降，会控制每个链表节点中的压缩列表的大小或元素个数，来避免这个问题，因为压缩列表越小或元素个数越少，新增或删除时带来的影响就越小。&lt;/p&gt;
&lt;h3 id=&#34;跳表---skip-list&#34;&gt;跳表 - Skip List&lt;/h3&gt;
&lt;p&gt;Redis只有ZSet对象底层使用跳表，ZSet结构体里有两个数据结构，一个是跳表，一个是哈希表，哈希表只在用在获取权重，大部分操作还是通过跳表实现；&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rredis_%e8%b7%b3%e8%a1%a8.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/rredis_%e8%b7%b3%e8%a1%a8.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;Redis Ziplist&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Redis Ziplist&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;先排序分数，分数相同时，再排序元素值，默认是从小到大排。&lt;/p&gt;
&lt;p&gt;跳表本质是为链表增加索引，建立多层索引，查找时从顶层的索引开始逐步往下层找，最终定位到元素，适用于范围查询的场景。跳表的相邻两层的节点数量最理想的比例是 2:1，查找的时间复杂度为O(logN)&lt;/p&gt;
&lt;p&gt;但是，redis在创建跳表时，随机生成每个节点的层数，没有严格维持相邻两层节点2:1的比例，比如在创建节点时，会生成范围为[0-1]的一个随机数，如果这个随机数小于0.25，那么层数加一，然后生成下一个随机数，直到改随机数大于0.25，最终确定改节点的层数；这样做相当于每增加一层的概率不超过25%，层数越高，概率越低，层高最大限制是64；Redis 7.0 定义层高为 32，Redis 5.0 定义为 64，Redis 3.0 定义为 32&lt;/p&gt;
&lt;p&gt;参考：&lt;a class=&#34;link&#34; href=&#34;https://www.pdai.tech/md/db/nosql-redis/db-redis-x-redis-ds.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Redis底层数据结构详解&lt;/a&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Skip List和各种平衡树（如AVL、红黑树等）的元素是有序排列的，而哈希表不是有序的。因此，在哈希表上只能做单个key的查找，不适宜做范围查找。&lt;/p&gt;
&lt;p&gt;在做范围查找的时候，平衡树比Skip List操作要复杂。在平衡树上，我们找到指定范围的小值之后，还需要以中序遍历的顺序继续寻找其它不超过大值的节点。如果不对平衡树进行一定的改造，这里的中序遍历并不容易实现。而在skiplist上进行范围查找就非常简单，只需要在找到小值之后，对第1层链表进行若干步的遍历就可以实现。&lt;/p&gt;
&lt;p&gt;平衡树的插入和删除操作可能引发子树的调整，逻辑复杂，而skiplist的插入和删除只需要修改相邻节点的指针，操作简单又快速。&lt;/p&gt;
&lt;p&gt;从内存占用上来说，Skip List比平衡树更灵活一些。一般来说，平衡树每个节点包含2个指针（分别指向左右子树），而Skip List每个节点包含的指针数目平均为1/(1-p)，具体取决于参数p的大小。如果像Redis里的实现一样，取p=1/4，那么平均每个节点包含1.33个指针，比平衡树更有优势。&lt;/p&gt;
&lt;p&gt;查找单个key，Skip List和平衡树的时间复杂度都为O(log n)，大体相当；而哈希表在保持较低的哈希值冲突概率的前提下，查找时间复杂度接近O(1)，性能更高一些。所以我们平常使用的各种Map或dictionary结构，大都是基于哈希表实现的。&lt;/p&gt;
&lt;p&gt;参考：https://www.jianshu.com/p/8ac45fd01548&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;时间复杂度&#34;&gt;时间复杂度&lt;/h3&gt;
&lt;p&gt;对各种数据类型操作的时间复杂度取决于底层的数据结构，对于Set，虽然名字看起来是集合，但由于底层是哈希表 + 数组，因此在SREM、SADD、SRANDMENBER命令时，时间复杂度都是O(1)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据类型的范围查询，都需要进行遍历操作，一般都是比较耗时的。比如List的LRANGE、ZSet的ZRANGE、Set的SMEMBERS等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据类型的统计查询，比如查看某数据类型的元素个数，时间复杂度是O(1)，因为数据结构本身就有记录了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;与memcached的区别&#34;&gt;与Memcached的区别&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Redis支持存储多种数据类型：string、list、hash、set、zset；而Memcached只支持string；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认情况下，Redis key的最大上限是512M，string类型、list、hash、set、zset每个元素的value上限是512M，可以通过&lt;code&gt;proto_max_bulk_len&lt;/code&gt;的值进行修改；memcached key的上限是50个字符，value最大值是1M；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis支持持久化：RDB快照和AOF日志；Memcached不支持持久化；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis支持事务，使用MULTI 和 EXEC命令，支持流水线式发送命令 ；Memcahced不支持事务，命令只能一条一条的发，当然这里的事务并不满足传统意义上的ACID；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis-Cluster 支持分布式存储，可以多台Redis服务器存储同样的数据；Memcached是以&lt;strong&gt;一致性哈希算法&lt;/strong&gt;实现分布式存储，即多台Memcached服务器，Memcached根据查找的key计算出该数据在哪台服务器上；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在 Redis 中，并不是所有数据都一直存储在内存中，可以将一些很久没用的 value 交换到磁盘；&lt;/p&gt;
&lt;p&gt;Memcached 的数据则会一直在内存中，Memcached使用固定空间分配，将内存分为一组大小不同的slab_class，每个slab_class又分为一组大小相同的slab，每个slab又包含一组大小相同的chunk，根据数据大小，放到不同的chunk里，这种管理方式避免内存碎片管理问题，但是会带来内存浪费，即每个chunk内会放小于这个chunk大小的数据，chunk里有些空间没利用到；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;一致性哈希算法&lt;/strong&gt;，主要解决传统哈希下节点扩容或缩容导致所有key要重新计算迁移的问题。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构造一个长度为2的32次方的整数环，即0 ~ (2^32)-1的数字空间；&lt;/li&gt;
&lt;li&gt;根据节点的唯一名称或者ip作为关键字进行哈希，确定节点在这个Hash环上的位置；&lt;/li&gt;
&lt;li&gt;根据数据的key值计算Hash值，在Hash环上顺时针查找距离这个Key的Hash值最近的节点，完成key到节点的Hash映射查找；&lt;/li&gt;
&lt;li&gt;当一个节点扩容或缩容时，只会影响到其中一个节点上的key，此时需要将该节点上的key重新计算，迁移到离它最近的一个节点，其他节点上的key则不会受影响，避免大量数据迁移，减少服务器压力。&lt;/li&gt;
&lt;li&gt;为了解决负载不均衡问题（比如节点的数量很少，大量的数据就有可能都集中在上面），可以在此基础上增加一个虚拟层，对每个节点的关键字多计算几次哈希，每次计算的结果作为在环中的位置；key算完哈希值后，先在环上找到虚拟节点，再找到物理节点，将数据分散到各个节点，一般一个物理节点对应150个虚拟节点。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/98030096&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;一致性哈希参考&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;redis的线程模型&#34;&gt;Redis的线程模型&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;对于一个 DB 来说，CPU 通常不会是瓶颈，因为大多数请求不会是 CPU 密集型的，而是 I/O 密集型。具体到 Redis 的话，如果不考虑 RDB/AOF 等持久化方案，Redis 是完全的纯内存操作，执行速度是非常快的，因此这部分操作通常不会是性能瓶颈，Redis 真正的性能瓶颈在于网络 I/O，也就是客户端和服务端之间的网络传输延迟，因此 Redis 选择了单线程的 I/O 多路复用来实现它的核心网络模型。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;单线程模型&#34;&gt;单线程模型&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;Redis的单线程，指的是 网络IO 和 键值对读写 由一个线程来完成&lt;/strong&gt;，其他的如持久化、异步删除、集群数据同步都有额外的线程完成。Redis在6.0版本后才支持IO多线程的网络模型。&lt;/p&gt;
&lt;p&gt;Redis单线程之所以能处理得很快，得益于高效的数据结构，且采用了&lt;strong&gt;多路复用机制&lt;/strong&gt;，在网络IO操作中能并发处理大量客户端请求，同时为了支持多种数据结构，保证并发安全，单线程模型下避免加锁解锁带来额外的开销。&lt;/p&gt;
&lt;p&gt;监听 + 事件驱动 + 回调 的方式，处理易阻塞的accept和recv事件，是一个单Reactor模型，利用 epoll / select / kqueue 等多路复用技术，在单线程的事件循环中不断去处理事件（客户端请求）。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/57089960?utm_source=wechat_session&amp;amp;utm_medium=social&amp;amp;utm_oi=632939468966072320&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;一文揭秘单线程的Redis为什么这么快?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://strikefreedom.top/multiple-threaded-network-model-in-redis&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Redis 多线程网络模型全面揭秘&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;总结一下就是：高效的数据结构和数据压缩、纯内存操作、非阻塞IO多路复用，避免频繁的上下文切换、避免同步机制的开销。&lt;/p&gt;
&lt;h2 id=&#34;多线程模型&#34;&gt;多线程模型&lt;/h2&gt;
&lt;p&gt;Redis 4.0之后引入多线程来做一些异步操作，比如以前&lt;code&gt;DEL&lt;/code&gt;命令在删除big key和大量key时是阻塞操作，为了解决这个问题引入多线程使得部分命令支持多线程的异步操作，比如&lt;code&gt;UNLINK&lt;/code&gt;、&lt;code&gt;FLUSHALL ASYNC&lt;/code&gt;、&lt;code&gt;FLUSHDB ASYNC&lt;/code&gt;，此时的网络IO模型仍然是单线程的（单Reactor模型）&lt;/p&gt;
&lt;p&gt;Redis 6.0之后才引入多线程的网络IO模型（多Reactor模型，但不是标准的多Reactor模型），总的流程还是跟单线程模型一样，只是把读取客户端命令和回写响应数据的操作交由I/O线程去执行异步化，&lt;strong&gt;I/O 线程仅仅是读取和解析客户端命令而不会真正去执行命令，客户端命令的执行最终还是要在主线程上完成&lt;/strong&gt;；&lt;/p&gt;
&lt;h2 id=&#34;影响性能的场景&#34;&gt;影响性能的场景&lt;/h2&gt;
&lt;p&gt;关于big key：对于字符串类型，其value的大小超过10KB；集合类类型，其元素的个数超过10k；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对big key的操作，比如创建和删除，big key在分配内存和释放内存会比较耗时。big key意味着value很大，当进行全量查询返回、聚合操作、全量删除(因为要释放内存)时可能会阻塞主线程。&lt;/p&gt;
&lt;p&gt;一般可以配合scan命令以及对应数据类型的scan命令来增量获取或删除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一些命令对应的操作时间复杂度高，比如范围查询、keys命令。&lt;/p&gt;
&lt;p&gt;一般使用scan代替keys命令，scan命令时因为使用高位进位法遍历，所以即使在扩容情况下也不会漏key，但在缩容时可能得到重复的key。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;大量Key集中过期，Redis过期机制也在主线程中执行，大量Key集中过期会导致耗时过长，所以在设置过期时间时要加入随机数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;淘汰策略也是在主线程执行的，发生在执行命令之前，会影响用户命令的执行速度。当内存超过Redis内存上限后，每次写入都需要淘汰Key，也会产生耗时，如果淘汰过程中，内存不足，使用 swap 机制，也会阻塞整个主线程；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主从全量同步生成RDB快照，虽然采用fork子进程生成数据快照的方式，但fork瞬间也会阻塞主线程（因为涉及页表的复制和分配，虽然copy on write能减少部分影响，如果有大量写入就会出现大量复制了）&lt;/p&gt;
&lt;p&gt;另外，从库在接收RDB快照后，会清空所有键值对，如果量大的话也很耗时，如果RDB文件太大，加载也耗时。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AOF日志同步写，因为是需要写磁盘的，比如设置为everysec可能会阻塞主线程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;切片集群，向其他实例传输哈希槽信息，big key数据的迁移，或者分片内存倾斜。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以big key基本上是因为占用内存过大，引发了种种问题，阻塞工作线程，导致客户端超时，造成网络阻塞，内存分布不均等。&lt;/p&gt;
&lt;p&gt;改进的话，就只有删除操作和AOF日志同步写可以放在异步线程去做，Redis4.0以后才提供删除和AOF同步写的异步命令。&lt;/p&gt;
&lt;h2 id=&#34;使用规范和优化&#34;&gt;使用规范和优化&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;String类型的数据不要超过10KB，避免BigKey，value可以使用压缩算法进行压缩来减少大小；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Key的长度尽量短，尽量控制在39字节以内，减少创建RedisObject内存分配次数，提升性能；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当big key真的无法避免时，需要对big key拆分成多个；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定时清理 hash 中无效的数据，Redis &amp;gt;= 4.0 ，可以使用 unlink 命令代替 del 命令删除key，该命令会进行异步删除；Redis &amp;gt;= 6.0 ，可以开启 lazy-free机制，执行del命令时，释放内存的操作放到后台线程执行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果需要频繁操作redis，可以使用pipeline，合并多个命令请求，减少IO次数，也就减少了 CPU上下文切换，当然，pipeline本身组装命令的个数也不能太多&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;key的过期时间加上随机值，避免key的集中过期；&lt;/p&gt;
&lt;p&gt;利用Redis分区功能，将数据分散到各个分区，减轻多个Redis内存淘汰的负载压力；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集合类型的元素个数不超过一万个；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;绑核，绑定在同一个物理核心的多个逻辑核心上，让他们能公用L1/L2 Cache，降低Redis在多个CPU核心之间的上下文切换带来的性能损耗，比如 可以让 主线程、后台线程、后台 RDB 进程、AOF rewrite 进程 绑定在不同的核心上；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis实例容量控制在10GB内；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;禁用Keys、FlushAll、FlushDB命令，慎用全量操作命令、Monitor命令、复杂度过高的命令（如Sort、Sinter、SinterStore、ZUnionStore、ZInterStore）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;监控&#34;&gt;监控&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;redis-cli -h 127.0.0.1 -p 6379 --bigkeys -i 0.01&lt;/code&gt;，每隔0.01秒扫描一次big key，本质是用scan命令遍历所有key，然后针对key的类型，执行&lt;code&gt;STRLEN, LLEN, HLEN, SCARD和ZCARD&lt;/code&gt; 命令，来获取 String 类型的长度，容器类型（List, Hash, Set, ZSet）的元素个数，使用时，要注意对线上的影响；&lt;/li&gt;
&lt;li&gt;使用 redis-rdb-tools 分析 redis rdb文件，因为是离线分析，所以对redis服务没影响&lt;/li&gt;
&lt;li&gt;&lt;code&gt;redis-cli -h 127.0.0.1 -p 6379 --hotkeys&lt;/code&gt;，扫描hotkey，前提是需要开启 &lt;code&gt;allkey-LFU&lt;/code&gt;，这样才能根据key的访问次数知道哪些是hotkey&lt;/li&gt;
&lt;li&gt;&lt;code&gt;INFO memory&lt;/code&gt; 命令查看Redis内存碎片率&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;过期时间和数据淘汰策略&#34;&gt;过期时间和数据淘汰策略&lt;/h1&gt;
&lt;h2 id=&#34;key过期删除原理&#34;&gt;key过期删除原理&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;定期删除策略：Redis起定时器扫描key（默认100ms），判断key是否过期，过期则删除。虽然可以保证过期的key会被删除，但是每次都要扫描会非常消耗CPU资源，且定时器有间距，有可能出现key过期，但是此时定时器还没起，key仍保存在内存中，处理过程中会阻塞主线程；&lt;/p&gt;
&lt;p&gt;抽样检查那些有过期时间的key，每次获取20个（默认），删除其中过期的key，如果占比超过25%，重复此步骤直到低于25%；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;惰性删除策略：每次获取key的时候才判断key是否过期，过期则删除，对CPU消耗较少，只处理当前key，但如果key一直未被使用，则会一直留在内存里，浪费空间，甚至导致内存泄漏；&lt;/p&gt;
&lt;p&gt;注意在Redis3.2以前，主库惰性删除后，从库不会触发数据删除，此时还能读到，3.2以后的版本才改正，返回空值，4.0后从库才会定时校验过期key。另外，expire命令在主库设置key的过期时间，到了从库可能有延迟导致过期时间比实际的长，expire命令表示执行完多久会过期，expireat/pexpireat命令表示在某一时间点会过期。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;所以Redis会将这两种策略整合在一起，定期删除策略不在是每次都扫描全部key，而是随机抽取一部分key进行检查，在配合惰性删除策略，正好可以弥补惰性删除策略的缺点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;淘汰策略&#34;&gt;淘汰策略&lt;/h2&gt;
&lt;p&gt;当内存使用量超出所设置的maxmemory值时，才会执行淘汰策略。默认的淘汰策略是当内存满了之后，新写入操作会报错。maxmemory值一般设置为总数据量的15%-30%。&lt;/p&gt;
&lt;p&gt;其他淘汰策略，分为两种，一种是在所有数据范围内，一种是在设置了过期时间的范围内。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;allkeys-random：在所有key中，随机移除某个key&lt;/li&gt;
&lt;li&gt;allkeys-Lru：在所有key中，移除最近最少使用的key（&lt;strong&gt;优先使用&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;allkeys-Lfu：在所有key中，移除访问次数最少的某个key&lt;/li&gt;
&lt;li&gt;volatile-random：在所有有设置过期时间的key中，随机移除某个key&lt;/li&gt;
&lt;li&gt;volatile-Lru：在所有有设置过期时间的key中，移除最近最少使用的key&lt;/li&gt;
&lt;li&gt;volatile-ttl：在所有有设置过期时间的key中，有更早过期时间的key优先移除&lt;/li&gt;
&lt;li&gt;volatile-Lfu：在所有有设置过期时间的key中，移除访问次数最少的某个key&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;淘汰策略中的lru算法&#34;&gt;淘汰策略中的LRU算法&lt;/h3&gt;
&lt;p&gt;对于LRU算法，如果一些元素被频繁使用，会导致频繁的移动，带来了额外的开销。&lt;/p&gt;
&lt;p&gt;Redis的LRU算法做了简化，其只会在RedisObject中记录每个数据最近以此访问的时间戳，当出现数据淘汰时，第一次会&lt;strong&gt;随机&lt;/strong&gt;选出N个数据，作为一个候选集合，比较N个数据的lru字段，把lru字段最小的元素淘汰。&lt;/p&gt;
&lt;p&gt;再次淘汰时，Redis会挑选那些LRU的值小于候选集合中最小LRU值的数据，进入第一次淘汰时创建的候选集合，可能会把里面最大的换出去或者淘汰里面最小的。准备候选集和淘汰数据是两个解耦操作。&lt;/p&gt;
&lt;p&gt;N的值由&lt;code&gt;maxmemory-samples&lt;/code&gt;决定。&lt;/p&gt;
&lt;h3 id=&#34;淘汰策略中的lfu算法&#34;&gt;淘汰策略中的LFU算法&lt;/h3&gt;
&lt;p&gt;Redis的LRU算法有个问题是对于非热点数据，其访问次数很少，直到触发淘汰策略才会被删除，在被删除之前都会一直留存，造成缓存污染。LFU算法就是为了解决这个问题。&lt;/p&gt;
&lt;p&gt;LFU缓存策略是在LRU策略基础上，为每个数据增加一个计数器，统计数据访问次数。当使用LFU淘汰策略筛选淘汰数据时，首先会根据访问次数进行筛选，把访问次数最低的数据淘汰出缓存，当淘汰次数相同时，才会比较时间。&lt;/p&gt;
&lt;p&gt;LFU在LRU的基础上，将RedisObject中的访问时间戳拆成两半，16bit存时间，8bit存计数，但计数不是线性递增，而是采用一种计算规则，让其增长不那么快到达2^8=255次，同时也有衰减机制，减少次数对时间的影响。&lt;/p&gt;
&lt;h3 id=&#34;淘汰执行时机&#34;&gt;淘汰执行时机&lt;/h3&gt;
&lt;p&gt;淘汰时机和被动删除过期key的时机一样，在用户的命令真正执行之前执行淘汰策略；&lt;/p&gt;
&lt;h1 id=&#34;存储与持久化&#34;&gt;存储与持久化&lt;/h1&gt;
&lt;h2 id=&#34;rdb快照redis-database&#34;&gt;RDB快照（Redis DataBase）&lt;/h2&gt;
&lt;p&gt;RDB快照由于保存的是数据，恢复起来会比AOF快（AOF保存的是命令），而且AOF是文本文件，RDB是二进制文件，所以RDB快照在网络传输、IO效率都比AOF好。&lt;/p&gt;
&lt;h3 id=&#34;相关命令和配置&#34;&gt;相关命令和配置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;bgsave&lt;/code&gt;：会调子进程创建快照写入磁盘，主线程继续处理其他命令请求；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;save&lt;/code&gt;：主线程创建快照写入磁盘，会阻塞其他命令请求，生产环境中比较少用；&lt;/p&gt;
&lt;p&gt;redis.conf 文件里的配置：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;save&lt;/code&gt;：&lt;code&gt;save [时间] [次数]&lt;/code&gt; 表示在[时间]内有[次数]写入/更新，就会触发bgsave命令&lt;/p&gt;
&lt;p&gt;另外，在进行主从复制，主redis发送sync命令给从redis时，如果刚刚没有执行完bgsave，也会进行一次bgsave操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;rdbcompression&lt;/code&gt;：是否启用LZF算法进行压缩，压缩可以使得RDB快照落盘的文件变小，但在压缩时会消耗CPU资源。&lt;/p&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;将Redis中的数据全量保存在文件中，一般会异步使用子进程进行刷盘操作，不阻塞主线程，此时主线程仍然能处理命令。（&lt;strong&gt;先全量&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;此外，会使用&lt;strong&gt;Copy on Write机制（写时复制）&lt;/strong&gt;，解决创建快照的过程中，原有数据被修改对RDB快照的影响。当主线程对原有数据进行修改前，这块数据会被复制一份（复制引用，由bgsave子进程操作），形成副本（此时会消耗两倍内存），由子进程将该副本写入RDB文件中，由于写的是引用，主线程修改后会同步到RDB中。（&lt;strong&gt;后增量&lt;/strong&gt;）&lt;/p&gt;
&lt;p&gt;Copy on Write：代码是共享的，数据是私有的，子进程被创建出来后，子进程就将父进程的数据拷贝了一份给自己，如果是只读的数据，父子进程页表指向同一个物理内存，如果子进程或者父进程修改了页表，此时会分离成两份，指向不同的物理内存，让父子进程对这一块数据操作不会相互干扰；&lt;/p&gt;
&lt;p&gt;从而减少分配和复制大量资源时带来的瞬时延时，缺点就是，如果写操作很多，就会产生大量的分页中断，产生大量复制，带来延时，当然，因为redis是读多写少的场景，所以还算合适。&lt;/p&gt;
&lt;h3 id=&#34;优点&#34;&gt;优点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;RDB文件是某个时间节点的快照，默认使用LZF算法进行压缩，压缩后的文件体积远远小于内存大小，适用于备份、全量复制等场景；&lt;/li&gt;
&lt;li&gt;Redis加载RDB文件恢复数据要远远快于AOF方式；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;潜在风险&#34;&gt;潜在风险&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;风险在于快照的创建频率，快照是每隔一段时间进行创建和写入的，如果频繁创建快照，多快照写盘会影响磁盘IO，因此每次都进行全量快照并不可取。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;如果频率过低，则会导致宕机时丢失的数据过多。解决方式是RDB + AOF一起使用，在两次快照期间用AOF代替。&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;当使用copy on write机制时，主线程会为其申请额外的空间，当进行频繁的写操作时，会导致内存很快被耗光。当实例系统开启了Swap机制时，超过内存使用量部分会转移到磁盘，访问磁盘的那部分就会很慢，如果没有开启Swap机制，则会触发OOM，Redis进程可能被kill或宕机；&lt;/li&gt;
&lt;li&gt;另外，当出现频繁的写操作时，由于生成RDB的子进程需要CPU核运行，主线程、多个线程或后台进程会竞争使用CPU，导致性能降低；&lt;/li&gt;
&lt;li&gt;实时性不够，无法做到秒级别的持久化；&lt;/li&gt;
&lt;li&gt;RDB文件是二进制，没有可读性，而AOF文件可以在了解其结构后手动修改或补全；&lt;/li&gt;
&lt;li&gt;版本兼容RDB文件问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;aofappend-only-file&#34;&gt;AOF（Append Only File）&lt;/h2&gt;
&lt;h3 id=&#34;相关命令和配置-1&#34;&gt;相关命令和配置&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;bgrewriteaof&lt;/code&gt;：执行后，Redis主进程fork子进程执行&lt;strong&gt;AOF重写&lt;/strong&gt;，该子进程会创建新的AOF文件来存储重写结果，防止影响旧文件；&lt;/p&gt;
&lt;p&gt;redis.conf文件里的配置：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;appendonly yes&lt;/code&gt;：aof默认是关闭的，如果要打开，设置成yes；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;appendfsync&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;no：每次命令只写内存(日志缓冲区)，刷盘记日志的操作由操作系统决定，不阻塞主线程，调用fsync，通常最多30s；&lt;/li&gt;
&lt;li&gt;everysec（默认）：写命令记录到文件中，&lt;strong&gt;默认是每秒同步一次&lt;/strong&gt;（调用一次fsync），所以如果发生故障，最多会丢失一秒的数据，但使用AOF保存的数据文件比RDB快照要大；&lt;strong&gt;Redis会使用另外的线程进行刷盘；&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;always：此外AOF还能选择每接收一个写命令就追加写入到AOF文件中，虽然能避免不丢数据，&lt;strong&gt;但每个写命令都是在主线程上完成，且后面都跟着一个刷盘操作&lt;/strong&gt;，对机器的负担较大，影响服务性能；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;auto-aof-rewrite-percentage 100&lt;/code&gt;：aof文件的容量超过原来aof文件容量一倍的时候, 进行aof文件的重写，默认100；&lt;/p&gt;
&lt;p&gt;&lt;code&gt;auto-aof-rewrite-min-size 64mb&lt;/code&gt;：执行aof重写时, aof文件的最小容量，默认64MB；&lt;/p&gt;
&lt;h3 id=&#34;原理-1&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;AOF时，Redis会先把命令追加近AOF内存缓冲区，然后根据&lt;code&gt;appendfsync&lt;/code&gt;配置的策略将内存中的数据写入磁盘。&lt;/p&gt;
&lt;p&gt;不同与MySQL的WAL机制，AOF是先执行命令将数据写入内存，再写入日志。因为AOF会记录Redis收到的每一条命令，并以文本的形式保存，如果先写日志，并不知道命令是否是正确的，因此先写内存，让系统执行成功后，才会记录到日志中，避免错误命令。&lt;/p&gt;
&lt;h3 id=&#34;潜在风险-1&#34;&gt;潜在风险&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;执行完命令，还没来得及记录日志就宕机，此时会丢失该命令的记录和相应数据。如果使用Redis当缓存，且要保证Redis宕机时不直接读库，利用Redis的AOF机制时就要注意了。&lt;/li&gt;
&lt;li&gt;AOF是在命令执行后才记录日志，所以不会阻塞当前的写操作，但由于日志的写操作也是在主线程中的，虽然避免阻塞当前操作，但可能会阻塞下一个命令操作，比如刷盘时磁盘IO过慢。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;重写机制&#34;&gt;重写机制&lt;/h3&gt;
&lt;p&gt;一般用于&lt;strong&gt;避免AOF日志文件过大&lt;/strong&gt;，毕竟如果文件太大会影响磁盘IO、重放会太耗时。&lt;/p&gt;
&lt;h4 id=&#34;原理-2&#34;&gt;原理&lt;/h4&gt;
&lt;p&gt;当AOF文件大小超过配置时，执行AOF重写机制。Redis会创建一个新的AOF文件，&lt;strong&gt;读取Redis中所有键值对&lt;/strong&gt;后进行写入，但在重写时不是原样copy，而是&lt;strong&gt;会对命令进行合并，以此减小文件大小&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;重写时，主线程会fork后台的bgrewriteiaof子进程，把&lt;strong&gt;主线程的内存拷贝一份给bgrewriteiaof子进程&lt;/strong&gt;，其中也包括了Redis的最新数据，bgrewriteiaof子进程逐一写入重写日志，避免阻塞主线程。&lt;/p&gt;
&lt;p&gt;因为重写是在子进程中处理的，此时主线程仍然能处理客户端的命令，当接收到客户端的写命令时，&lt;strong&gt;会记录到AOF日志&lt;/strong&gt;中，&lt;strong&gt;同时&lt;/strong&gt;也会写进&lt;strong&gt;AOF重写日志&lt;/strong&gt;的缓冲区，等子进程将拷贝数据写完后，再把缓冲区的数据刷入，完成后即可删除旧的AOF文件，留下新的AOF重写文件。&lt;/p&gt;
&lt;h4 id=&#34;潜在风险-2&#34;&gt;潜在风险&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;主线程fork创建bgrewriteaof子进程时，内核会把主线程的PCB内容拷贝给子进程，此时会阻塞主线程，当要拷贝的内容特别大时，fork执行的时间就会变长，阻塞主线程的时间也会变长。&lt;/li&gt;
&lt;li&gt;bgrewriteaof子进程会和主线程共享内存，当主线程收到新增或修改操作时，主线程会申请新的内存空间用来保存，但是如果是bigkey，主线程就会面临申请空间过大导致耗时。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;高可用集群&#34;&gt;高可用集群&lt;/h1&gt;
&lt;p&gt;RDB和AOF保证了数据少丢失，集群部署保证服务少中断，实现高可用。&lt;/p&gt;
&lt;h2 id=&#34;主从复制---保证数据一致性&#34;&gt;主从复制 - 保证数据一致性&lt;/h2&gt;
&lt;p&gt;一般采用主从读写分离，主库进行写操作，然后再同步给从服务；而读操作发生在主从库均可。最好还是读写都在主库，从库只保证高可用，原因是主从数据同步是异步的，总有可能出现网络波动等问题导致主从库数据不一致，或者主库设置过期时间，但是到从库上有延迟导致读到过期数据，主库的过期删除无法同步到从库（4.0才解决）。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当 Redis 运行在主从模式下时，&lt;strong&gt;从库不会进行过期扫描，从库对过期的处理是被动的&lt;/strong&gt;。也就是即使从库中的 key 过期了，如果有客户端访问从库时，依然可以得到 key 对应的值，像未过期的键值对一样返回。&lt;/p&gt;
&lt;p&gt;从库的过期键处理依靠主服务器控制，&lt;strong&gt;主库在 key 到期时，会在 AOF 文件里增加一条 del 指令，同步到所有的从库&lt;/strong&gt;，从库通过执行这条 del 指令来删除过期的 key。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果写操作可以发生在主从库上，会导致主从库上的数据不一致，取数据时可能会取到旧值，而如果要保持一致，则需要加锁，加锁的话效率旧太差了。&lt;/p&gt;
&lt;p&gt;一般用在&lt;strong&gt;从节点&lt;/strong&gt;初始化加入时使用，先进行&lt;strong&gt;全量同步(通过快照)&lt;/strong&gt;，再进行&lt;strong&gt;增量同步(通过命令缓存同步)&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;相关命令&#34;&gt;相关命令&lt;/h3&gt;
&lt;p&gt;在从库上使用命令：Redis 5.0以前使用&lt;code&gt;slaveof&lt;/code&gt;、之后使用&lt;code&gt;replicaof  [主库IP] [主库端口]&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;过程&#34;&gt;过程&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;主库创建RDB快照文件，发送给从库，并在发送期间使用缓冲区(replication buffer)记录之后收到的写命令。&lt;/p&gt;
&lt;p&gt;快照文件发送完毕之后，开始向从库发送存储在缓冲区中的写命令；整个过程中主库不会被阻塞；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从库丢弃所有旧数据，载入主库发来的快照文件，之后从库开始接受主库发来的写命令；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主库每执行一次写命令，就向从库发送相同的写命令；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般只设置一个主节点，当负载上升时，主库可能无法很快地更新所有从库，或者重新连接和重新同步从库将导致系统超载。因为在一次主从数据同步过程中，主库有两个耗时的操作：生成RDB文件和传输RDB文件，如果从库数量过多，会导致主库忙于fork子进程生成RDB文件进行全量复制，导致阻塞主线程的正常请求，同时传输的带宽也带来了压力。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;：通过&lt;strong&gt;主从级联模式&lt;/strong&gt;解决，可以设置主节点为根节点，向下延申，从节点再设置从节点的方式，形成树状的主从链，让从节点帮忙同步给其子节点的方式，降低主节点的压力。&lt;/p&gt;
&lt;p&gt;同样使用命令slaveof或replicaof，只是ip换成从库的ip，这样就形成了主-从-从的模式了。&lt;/p&gt;
&lt;h2 id=&#34;主从库命令传播时网络中断&#34;&gt;主从库命令传播时网络中断&lt;/h2&gt;
&lt;p&gt;Redis2.8之前，如果主从库发生网络中断，重新连接时会进行全量复制，开销巨大。&lt;/p&gt;
&lt;p&gt;2.8之后，会使用增量复制。断连期间，主库会把收到的写命令写入缓冲区（&lt;code&gt;replication buffer&lt;/code&gt;和&lt;code&gt;repl_backlog_buffer&lt;/code&gt;）。&lt;/p&gt;
&lt;p&gt;断连时，会记录从库的偏移量，待重新连接后即可根据偏移量进行同步。由于&lt;code&gt;repl_backlog_buffer&lt;/code&gt;是环形缓冲区，如果从库同步太慢，因此可能会出现新命令覆盖到未读取的命令，只能通过调整其大小解决，配置&lt;code&gt;repl_backlog_size&lt;/code&gt;，否则，从库将进行全量复制。&lt;/p&gt;
&lt;p&gt;主从模式下，从库宕机影响不大，但主库宕机就会影响从库的同步了，此时需要哨兵机制重新选举主库，保证高可用。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;replication buffer&lt;/code&gt;：主从库在进行全量复制时，主库上用于和从库连接的客户端的 buffer，非共享，每个从库对应一个。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;repl_backlog_buffer&lt;/code&gt;：主库上用于持续保存写操作的一块专用 buffer，是一个环形缓冲区， 从库共享。为了支持从库增量复制，主库会记录自己写到的偏移量(&lt;code&gt;master_repl_offset&lt;/code&gt;)，而每个从库都会有自己的复制进度标志(&lt;code&gt;slave_repl_offset&lt;/code&gt;)记录在上面，记录自己的写偏移量。&lt;/p&gt;
&lt;h2 id=&#34;哨兵机制&#34;&gt;哨兵机制&lt;/h2&gt;
&lt;p&gt;哨兵机制会解决三个问题：1.判断主库是否宕机；2.选择哪个从库为主库；3.如何把新主库的信息通知给从库和客户端。&lt;/p&gt;
&lt;p&gt;使用&lt;strong&gt;哨兵模式&lt;/strong&gt;（sentinel）来监听和管理Redis集群，存储集群配置，作用类似ZooKeeper，哨兵节点是一台特殊的Redis，功能有限，主要用来支持哨兵机制，哨兵节点有三个任务：&lt;strong&gt;监控、选主、通知&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;原理-3&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;哨兵节点一般设置3个及以上的奇数个，哨兵节点间是平级的，会互相监控&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所有哨兵节点都会周期性的给所有主从库发送Ping命令检测Redis的主从节点是否正常运行，当有Redis节点出现问题时，进行通知。&lt;/li&gt;
&lt;li&gt;如果发生问题的节点是主节点，会从从节点中选出主节点，代替失效的主节点。&lt;/li&gt;
&lt;li&gt;之后会把新主库的连接信息发给其他从库，让他们执行&lt;code&gt;replicaof&lt;/code&gt;命令，和主库建立连接，并进行数据复制。同时把新主库的连接信息通知给客户端，让客户端把请求发送到新主库上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何监控如何判断主库不可用&#34;&gt;如何监控，如何判断主库不可用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;主观下线&lt;/strong&gt;：每个哨兵节点每隔1s对主从节点发生心跳，当有节点在超过x秒后没有进行回复，此时该节点为主观下线，还需要进一步判断。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客观下线&lt;/strong&gt;：当主观下线的节点是主节点时，该哨兵节点会通过&lt;code&gt;sentinel is-master-down-by-addr&lt;/code&gt;命令，向其它&lt;code&gt;n - 1&lt;/code&gt;个哨兵节点询问对主节点的判断，当超过 &lt;code&gt;n / 2 + 1&lt;/code&gt; 个哨兵节点认为主节点有问题时，该节点为客观下线。&lt;strong&gt;多这一步是为了防止误判。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;客观下线后，会从从节点中选举出主节点，前主节点重新上线后会被设置为从节点。&lt;/p&gt;
&lt;p&gt;Redis没有使用什么一致性算法，仅依据&lt;strong&gt;Gossip协议&lt;/strong&gt;在有效时间范围内收到其它Sentinel节点的确认。&lt;/p&gt;
&lt;p&gt;另外，如果不使用哨兵模式，只使用Redis集群，也可以实现高可用，只不过是把监控和选择转移到各个节点中。&lt;/p&gt;
&lt;h3 id=&#34;如何选举&#34;&gt;如何选举&lt;/h3&gt;
&lt;p&gt;哨兵节点会周期性的发送心跳给主从库，在此过程中会对各个节点进行打分。之后按照一定的筛选条件和规则，选出得分最高的从库为新主库。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;筛选条件：从库的在线状态，之前的网络连接状态。通过设置主从库断连的最大连接超时时间（down-after-milliseconds）、断连次数（n），当超过阈值时则说明从库的网络状况不好。&lt;/li&gt;
&lt;li&gt;打分规则：从库的优先级（比如不同从库的配置不一样，优先级也就不一样）、从库的复制进度（根据从库在&lt;code&gt;repl_backlog_buffer&lt;/code&gt;中的偏移量，从库间比较）、从库的ID号（ID号小的分高）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;如何通知&#34;&gt;如何通知&lt;/h3&gt;
&lt;p&gt;客户端在访问主从库时，不能写死主库地址，而是从哨兵节点中获取主库地址；当哨兵选出新的主库时，会更新自己存的新主库地址。哨兵节点通过 发布/订阅 机制，让客户端进行订阅和修改。从而也能让客户端了解整个主从切换过程。&lt;/p&gt;
&lt;h3 id=&#34;主从切换时可能产生脑裂&#34;&gt;主从切换时，可能产生脑裂&lt;/h3&gt;
&lt;p&gt;如果主库因为某些原因进入假死状态（但还能处理命令），被哨兵判定为客观下线，哨兵执行主从切换，但此时主库恢复正常，但此期间写操作的数据还未同步到从库，待哨兵完成主从切换后，Redis集群会短暂出现两个主库，导致客户端的写操作会发往不同的主库，或者原主库降级成从库，会清空本地数据重新载入新主库的RDB快照，导致数据不一致或丢失。&lt;/p&gt;
&lt;p&gt;判断主从库数据是否不一致，可以通过对比主从库上的复制进度差值来进行判断，计算&lt;code&gt;matser_repl_offset&lt;/code&gt;和&lt;code&gt;slave_repl_offset&lt;/code&gt;的差值，如果从库上的&lt;code&gt;slave_repl_offset&lt;/code&gt;小于原主库的&lt;code&gt;master_repl_offset&lt;/code&gt;，就说明数据丢失是因为数据未同步完成导致的。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;根本原因&lt;/strong&gt;：Redis主从集群没有使用共识算法，每个写操作没有在大多数节点写成功后才认为成功导致的。不像ZooKeeper，客户端的操作都会经过ZooKeeper的主节点，当发生脑裂时，ZooKeeper主节点无法写入大多数节点，写请求直接失败，保证数据一致性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;：在主库上配置&lt;code&gt;min-slaves-to-write&lt;/code&gt;表示主库能进行数据同步的最少从库数量；&lt;code&gt;min-slaves-max-lag&lt;/code&gt;表示主从数据复制时，从库给主库发送ACK消息的最大延迟(秒)。这样当主库假死时，无法响应哨兵心跳，也不能和从库同步，确认从库的ACK命令，原主库就无法再接收客户端的写操作。&lt;/p&gt;
&lt;h3 id=&#34;哨兵集群的高可用&#34;&gt;哨兵集群的高可用&lt;/h3&gt;
&lt;p&gt;由于哨兵需要进行客观下线的判断，因此需要多个哨兵组成集群，集群就会涉及到高可用。&lt;/p&gt;
&lt;h4 id=&#34;哨兵节点间与主从库间的相互发现机制&#34;&gt;哨兵节点间、与主从库间的相互发现机制&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;哨兵节点间的相互发现：正常情况下，每个哨兵都是平级的。每个哨兵节点在设置时的命令是&lt;code&gt;sentinel monitor &amp;lt;master-name&amp;gt; &amp;lt;ip&amp;gt; &amp;lt;redis-port&amp;gt; &amp;lt;quorum&amp;gt; &lt;/code&gt;，并不感知其他哨兵的存在。&lt;strong&gt;哨兵节点间的相互发现，依赖Redis的 发布/订阅 机制&lt;/strong&gt;。哨兵节点一旦和主库建立连接，就会把自己的连接信息(如IP、端口)发布到主库上，同时它也会订阅，从而发现其他哨兵节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哨兵节点发现从库：哨兵节点连接主库后，发送INFO命令，主库就会把从库连接信息列表发给哨兵节点，从而实现哨兵节点对从库的监控。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;哨兵节点leader选举原理&#34;&gt;哨兵节点Leader选举原理&lt;/h4&gt;
&lt;p&gt;正常情况下哨兵集群内的每个哨兵节点是平级的，但是当触发客观下线时，需要选出一个哨兵节点Leader来执行主从库切换。重新选举主库只能由一个哨兵节点来做，如果不是，可能会出现主从库集群脑裂。另外，哨兵节点越多，选举速度越慢，风险也会增加。&lt;/p&gt;
&lt;p&gt;哨兵节点Leader选举分为两个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;各个哨兵节点判断主/客观下线阶段：各个哨兵在判断主库是主观下线后，首先会给自己投Yes票，之后会发送&lt;code&gt;is-master-down-by-addr&lt;/code&gt;命令给其他哨兵节点，其他哨兵节点会根据自己的判断情况，回复Yes / No回去。该哨兵节点收集得到的Yes票，当超过设置的quorum值时，标记主库为客观下线。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个哨兵在一次选举节点只有一次投票机会，当有哨兵节点得出客观下线结论后，该哨兵再发起投票，进行Leader选举，当收集到的票数超过一半，则该哨兵节点成为Leader节点，如果没有选举成功，则等待一般是故障转移超时时间failover_timeout的2倍时间后会重新举行选举。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Redis%e5%93%a8%e5%85%b5%e4%b8%8b%e7%ba%bf%e4%b8%bb%e5%ba%93%e5%92%8cLeader%e9%80%89%e4%b8%be.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Redis%e5%93%a8%e5%85%b5%e4%b8%8b%e7%ba%bf%e4%b8%bb%e5%ba%93%e5%92%8cLeader%e9%80%89%e4%b8%be.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;Redis哨兵下线主库和Leader选举&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Redis哨兵下线主库和Leader选举&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;几个注意点&#34;&gt;几个注意点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主从复制设置时，最好在主节点上开启持久化，否则可能会导致从节点的数据被清空；&lt;/p&gt;
&lt;p&gt;当主节点关闭持久化后，从节点开始从主节点复制数据，如果此时主节点挂了，因为关闭了持久化，且重启速度比较快，哨兵节点没有发现，重启后主节点数据为空，当从节点在进行数据复制时发现主节点是空的，从节点上的数据也会被删除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis支持无磁盘复制，当使用低转速的磁盘时，可能会影响复制性能，当启动无磁盘复制时，主节点子进程直接将RDB通过网络发送给从节点，不使用磁盘。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;高可用扩展集群&#34;&gt;高可用扩展集群&lt;/h1&gt;
&lt;p&gt;一般一个Redis保存几个G内比较合适，&lt;strong&gt;当单个Redis实例要保存的键值对太多时，会影响Redis的主从复制、RDB快照和AOF日志的大小、影响从库重放速度、fork子进程的速度(太慢会导致阻塞主线程)&lt;/strong&gt;，因此需要进行对单Redis实例扩展，常见的方式是对单个Redis实例进行扩展，一般分为纵向扩展和横向扩展。&lt;/p&gt;
&lt;p&gt;redis中默认有编号0-15总共16个db，默认使用db0，每个数据库都有属于自己的空间。&lt;/p&gt;
&lt;p&gt;在redis集群时，不可以使用select命令选择db，因为redis集群仅支持db0。&lt;/p&gt;
&lt;p&gt;Redis集群最大节点个数是 &lt;strong&gt;16384&lt;/strong&gt; 个，因为Redis集群没有使用一致性hash，而是哈希槽，Redis集群就有16384个哈希槽，原因是 Redis节点发送心跳包时需要把所有槽放到这个心跳包中，让节点知道当前集群信息，&lt;code&gt;16384 = 16k&lt;/code&gt; 在发送心跳包时&lt;strong&gt;使用char进行bitmap压缩后是2k（2 * 8 (8 bit) * 1024(1k) = 16K）&lt;/strong&gt;，因此使用 2k 空间就能创建 16k 的槽数了，尽管CRC16 算法最多课分配 &lt;code&gt;2 ^ 16 - 1 = 65535&lt;/code&gt; 个槽位，压缩后也才8k，但一般来说，一个Redis集群不会超过1000个master节点，所以16k的槽位就比较合适。&lt;/p&gt;
&lt;h2 id=&#34;扩展&#34;&gt;扩展&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;纵向扩展：升级单Redis实例的配置，如内存容量、磁盘容量、CPU等，但会影响RDB快照和AOF日志大小，网络传输等，一般用在不使用Redis持久化功能的场景。&lt;/li&gt;
&lt;li&gt;横向扩展：根据key，对Redis实例进行分片，增加Redis实例个数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;分片&#34;&gt;分片&lt;/h2&gt;
&lt;p&gt;Redis分片的实现使用哈希槽。&lt;/p&gt;
&lt;h3 id=&#34;原理-4&#34;&gt;原理&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;将数据分散到集群的多个机器上，Redis里使用的概念是槽Slot，每个集群的槽数固定为16 * 1024 = 16384个，使用哈希分片算法对Key进行取模，计算方法：&lt;code&gt;HASH_SLOT = CRC16(Key) mod 16384&lt;/code&gt;，余数为Key所在的槽。&lt;/p&gt;
&lt;p&gt;之所以会使用槽，是因为要把数据和节点解耦，如果不使用槽，而是使用key与节点的映射表，当key的数量非常庞大时，映射表也会非常大，映射表的修改和迁移的性能不高。&lt;/p&gt;
&lt;p&gt;集群只需要记录槽的ID与槽节点的地址映射即可，默认情况下，当集群 16384 个槽任何一个没有指派到节点时会导致整个集群不可用，so，当有节点故障下线时，从故障发现到自动完成转移期间整个集群不可用，如果要关闭这个配置，需要在redis.conf中配置：&lt;code&gt;cluster-require-full-coverage no&lt;/code&gt;，这样就只会影响故障节点了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;集群内每台机器会存放一些槽，在集群初始化的时候会&lt;strong&gt;对集群内的机器平均分配这16384个槽&lt;/strong&gt;，使用查表法进行分配。因此，当需要扩容时，会重新计算槽的位置和迁移key，可以使用官方提供的redis-trib.rb脚本实现。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端连接分片集群后，即可获得槽与各个Redis分片节点的映射。访问时可以访问集群内的任意节点，先根据key算出在哪个槽，在查询槽和节点间的关系，找到对应的节点进行查询。&lt;/p&gt;
&lt;p&gt;另外，要注意分片后，对于Keys、scan这样的扫描命令的性能就会更加差了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当分片集群有增删时，槽与节点的映射也会随之修改，为了负载均衡，Redis需要把槽重新分布到各个分片上。但是客户端却不感知，当客户端发送命令时，如果节点上该槽已迁往别处，客户端会收到&lt;code&gt;MOVED 新槽编号 新槽所在的host&lt;/code&gt;的错误信息，客户端将重新请求，同时修改槽与节点的映射关系。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果客户端请求发生在Redis迁移槽的过程中，则会先收到&lt;code&gt;ASK 新槽编号 新槽所在的host&lt;/code&gt;的错误消息，让客户端进行重试，直到Redis完成槽的迁移，重试成功。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HashTag，如果key的格式是 &lt;code&gt;user:order:{3214}&lt;/code&gt;，由{}括起来的部分为HashTag，CRC算法在计算key在哪个槽时只会计算{}里的值，HashTag主要是让多个类型的key可以映射到同一个槽，方便范围查询。&lt;/p&gt;
&lt;p&gt;但使用HashTag可能会导致数据倾斜，使得请求无法平均分到各个分片。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般的分配规模是几十个以内，不适合构建超大规模的集群，原因是去中心化设计，选举算法使用Gossip，规模越大时，传播速度越慢。如果要构建超大规模的集群，则需要增加一层代理，进行集群间的转发，例如twemproxy或者Codis这类基于代理的集群架构。&lt;/p&gt;
&lt;h1 id=&#34;事务&#34;&gt;事务&lt;/h1&gt;
&lt;p&gt;使用 MULTI 和 EXEC 命令将多个写操作包围起来进行发送，Redis收到后会先将命令暂存到一个队列里，当收到EXEC命令时才会一起顺序执行。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果客户端发送的命令为 EXEC 、 DISCARD 、 WATCH 、 MULTI 四个命令的其中一个， 那么服务器立即执行这个命令。&lt;/p&gt;
&lt;p&gt;与此相反， 如果客户端发送的命令是 EXEC 、 DISCARD 、 WATCH 、 MULTI 四个命令以外的其他命令， 那么服务器并不立即执行这个命令， 而是将这个命令放入一个事务队列里面， 然后向客户端返回 QUEUED 回复。&lt;/p&gt;
&lt;p&gt;WATCH: 监视一个或多个key，如果事务在执行前，这个key(或多个key)被其他命令修改，则事务被中断，不会执行事务中的任何命令，此时EXEC执行结果为null。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;pipline主要用于批量发送命令，一次性发送多个请求，一次性读取所有返回结果，目的是为了减少 &lt;code&gt;连接-》发送命令 -》返回结果&lt;/code&gt; 这个过程产生的耗时，减少IO次数，减少 read() 和 write() 的系统调用次数。&lt;/p&gt;
&lt;p&gt;MULTI和EXEC事务机制与Redis pipline的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务中的每个命令会先发送到服务端，只会再执行；而pipline是会把命令请求缓存在客户端本地内存中，再发送请求一次性执行&lt;/li&gt;
&lt;li&gt;事务中的每个命令都会先发送到服务端，请求次数多，而pipline只发送一次请求&lt;/li&gt;
&lt;li&gt;一般事务和pipline会配合使用，以减少请求次数，减少网络IO，提升性能，保证多个命令发送不会被别的请求打断，保证多个事务的隔离性，&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;redis中的原子性&#34;&gt;Redis中的原子性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;更多的是为了减少客户端与服务端的通信次数。Redis本身不提供回滚机制，如果一次性传输多个命令时，当有一个命令执行失败了，剩下的命令还是会继续往下执行，无法实现事务的原子性。&lt;/li&gt;
&lt;li&gt;如果命令本身有错，只有到了EXEC命令时才会报错，整个MULTI期间的命令都不会执行，此时才保证了原子性。&lt;/li&gt;
&lt;li&gt;RDB不会在事务执行的时候执行，所以可以保证原子性。&lt;/li&gt;
&lt;li&gt;事务执行过程中的命令，AOF日志会记录，所以如果事务执行过程中宕机了，重启前需要使用&lt;code&gt;redis-check-aof工具&lt;/code&gt;检查AOF日志，去除执行到一半的事务命令，才能保证原子性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Redis中的原子操作&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Redis的 incr / decr 命令，本质上是一个&lt;code&gt;读取 -》修改 -》写入&lt;/code&gt; 的过程；&lt;/li&gt;
&lt;li&gt;为Redis定义新的数据结构实现原子操作，毕竟Redis本身是单线程的，本身不会有其他线程的影响；&lt;/li&gt;
&lt;li&gt;Lua脚本，才能实现复杂逻辑的原子操作，使用时会先通过script load命令把脚本加载到Redis中，得到唯一摘要，再通过命令evalsha + 摘要的方式执行脚本，避免每次执行脚本都要先传输，减少网络IO；另外Lua脚本的时间复杂度不易过长，否则会阻塞主线。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Demo：限制客户端每分钟访问次数不能超过20次 的Lua脚本，该脚本包含了计数、访问次数判断和过期时间设置。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;客户端先获取&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ip对应的访问次数&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;current&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redis.call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;get&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KEYS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;如果超过访问次数超过&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;次，则报错，这两步不涉及临界值的修改，因此可以不放在脚本中原子执行。&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;IF&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;current&lt;/span&gt; &lt;span class=&#34;err&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NULL&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AND&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;current&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;THEN&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ERROR&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;exceed 20 accesses per second&amp;#34;&lt;/span&gt;

&lt;span class=&#34;n&#34;&gt;Lua脚本名称&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;visit_restrict.script&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;脚本内容&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;如果访问次数不足&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;次，增加一次访问计数&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redis.call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;incr&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KEYS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;如果是第一次访问，将键值对的过期时间设置为&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;s后&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;IF&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;THEN&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;redis.call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;expire&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KEYS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;60&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;END&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;//&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;执行其他操作&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;DO&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;THINGS&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;END&lt;/span&gt;
&lt;span class=&#34;err&#34;&gt;执行命令：&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;redis&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cli&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;--eval visit_restrict.script keys , args&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;redis中的隔离性&#34;&gt;Redis中的隔离性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;需要依赖WATCH机制，因为Redis流水线命令是在EXEC命令执行后开始的，在EXEC命令还未执行前，如果要保证隔离性，需要使用WATCH监控某个key，当EXEC命令执行时，WATCH机制就会触发，如果监控的数据被修改了，就放弃此次事务的执行。&lt;/li&gt;
&lt;li&gt;如果是在EXEC命令执行后的，由于Redis是单线程的，所以并发情况下不会破坏事务隔离性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此调用方可以利用这个特性，不断的重试这个操作，知道成功为止。&lt;/p&gt;
&lt;p&gt;使用Watch的实现监控：在使用MULTI命令之前使用WATCH监控某些键值对，然后使用MULTI命令开启事务，执行各种数据结构的操作命令，此时这些命令入队列；当使用EXEC执行事务时，首先会对比WATCH所监控的键值对，如果没有发生变化，它会执行事务队列中的命令，提交事务，如果发生变化，则不执行事务中的任何命令，同时事务回滚，然后取消执行事务前的WATCH命令。&lt;/p&gt;
&lt;h2 id=&#34;redis中的一致性&#34;&gt;Redis中的一致性&lt;/h2&gt;
&lt;p&gt;在命令执行错误或 Redis 发生故障的情况下，Redis 事务机制对一致性属性是有保证的。&lt;/p&gt;
&lt;h2 id=&#34;redis中的持久性&#34;&gt;Redis中的持久性&lt;/h2&gt;
&lt;p&gt;尽管有RDB和AOF日志的支持，但是仍然有丢数据的可能。比如使用RDB模式，在一个事务执行后，而下一次的 RDB 快照还未执行前，如果发生了实例宕机，此时，事务修改的数据也是不能保证持久化的。&lt;/p&gt;
&lt;h1 id=&#34;应用场景&#34;&gt;应用场景&lt;/h1&gt;
&lt;h2 id=&#34;聚合统计---统计每日新增用户&#34;&gt;聚合统计 - 统计每日新增用户&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用Set类型&lt;/li&gt;
&lt;li&gt;一个Set记录所有登录过的用户ID：&lt;code&gt;[key：user:id，value：Set&amp;lt;userId&amp;gt;]&lt;/code&gt;，另一个Set记录每日登录过的用户ID&lt;code&gt;[key：user:id :日期，value：Set&amp;lt;userId&amp;gt;]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;统计每日新增用户，计算每日用户 Set 和累计用户 Set 的差集，使用命令&lt;code&gt;SDIFFSTORE [结果key] [user:id :日期] [user:id]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;弊端：Set的差集、并集、交集计算复杂度较高，当数据量较大时计算太慢会阻塞主线程，一般这种计算会在从库上做。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;排序统计---统计最新评论排行榜时间段内在线数等&#34;&gt;排序统计 - 统计最新评论、排行榜、时间段内在线数等&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用List，当有新元素LPush或RPush插入时，原先所有元素都会后移一位，使用Lrange读取元素时可能会读到旧数据。&lt;/li&gt;
&lt;li&gt;使用ZSet，为每个元素设置权重，按权重排序，使用Zrangebyscore则不会读到旧数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二值状态统计---统计是否签到存不存在有没有问题&#34;&gt;二值状态统计 - 统计是否签到、存不存在、有没有问题&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;针对值只有0 或1的场景，使用bitmap，是Redis的扩展数据类型，本身是String类型的一种特殊应用。&lt;/li&gt;
&lt;li&gt;bitmap利用的是存储的String value的位。并且bitmap支持Bitop命令对多个bitmap进行按位与、或、异或操作，bitcount统计位中1的个数。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基数统计---统计一个集合中不重复的元素&#34;&gt;基数统计 - 统计一个集合中不重复的元素&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;使用Set或Hash，但是可能会比较耗内存&lt;/li&gt;
&lt;li&gt;使用HyperLogLog，专门用于基数统计，优势在于所需空间总是固定，使用&lt;code&gt;PFAdd key v1 v2 v3&lt;/code&gt;命令做添加，&lt;code&gt;PFCount key&lt;/code&gt;统计key的value数量，但是存在误差，误差率约为0.81%&lt;/li&gt;
&lt;li&gt;一般用于统计注册的IP数、每日访问IP数、页面实时UV数、在线用户数、搜索的关键词数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;geo---lbs应用&#34;&gt;GEO - LBS应用&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;底层实现是ZSet，权重值是经纬度，但是由于ZSet的权重值只能是浮点类型，因此一般会对经纬度做GeoHash编码。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GeoHash编码的基本原理是：二分区间，区间编码。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;二分区间：比如把经度范围[-180,180]会被分成两个子区间：[-180,0) 和[0,180]，如果要编码的经度值落在左区间，则用0表示，右区间用1表示，通过不断的对区间进行分区，经过N次之后，得到一个N位数的01组合。纬度同理。&lt;/p&gt;
&lt;p&gt;比如有一个点（39.923201，116.390705），以纬度为例，（-90，90）中间值为0，39.923201在（0，90）得到1，（0，90）的中间值是45，在（0，45）得到0，继续对分区进行二分和比较，最终得到一个二进制数，经度也是以同样的方式进行计算&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;区间编码：把计算过后的经纬度编码进行组合，规则：偶数位是经度编码值，奇数位是纬度编码值。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;base32进行编码&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过GeoHash编码，地图上的每个方格都能用数字进行表示，分区越多越精准。&lt;strong&gt;通过范围查询 + 方格周围方格的编码，即可实现搜索附近的人功能&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GeoHash表示一个矩形的区域，精度取决于二分的次数，次数越多越精确，经过base32编码后得到一个字符串，编码越长，范围越小，位置更精确；两个相同前缀的字符串，长度越短表示范围更大，可以通过此特性来表示两个点之间的大概距离。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Redis也提供了Geo的数据类型&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;保存时间序列数据&#34;&gt;保存时间序列数据&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;时间序列数据的特点是插入速度要快，数据一旦插入就不变、查询模式较多。&lt;/li&gt;
&lt;li&gt;可以基于Hash和ZSet实现。Hash实现插入快速和点查询，ZSet实现范围查询，但由于插入一条数据的时候需要同时操作Hash和ZSet，因此要求这个操作是原子的。&lt;/li&gt;
&lt;li&gt;ZSet只能提供范围查询，聚合查询只能在让客户端查回去之后自己做，但是大量数据查询传输比较依赖网络资源，可能会导致其他操作响应速度变慢，如果想要Redis实现的话，就得依靠RedisTimeSeries。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;消息队列&#34;&gt;消息队列&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;消息队列一般要解决三个问题：顺序消费、幂等消费、消息可靠性保证&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用List&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;List的每个元素除了消息的内容外还要保存消息的唯一id，用于解决重复性消费；&lt;/li&gt;
&lt;li&gt;List类型有提供BRPOP供消费者阻塞读取，避免循环读取带来的消耗；&lt;/li&gt;
&lt;li&gt;List类型有提供BRPOPLPUSH命令，让消费者读取时会把数据存入另一备份List中，用于避免消费者从List中移除消息读取时宕机，重启后可重新读取消息。&lt;/li&gt;
&lt;li&gt;List不支持消费组实现，无法避免生产速度大于消费速度的场景。&lt;/li&gt;
&lt;li&gt;通过 BLPOP 命令，在没有消息的时候，它会一直阻塞，直至有消息到来。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实现延迟队列：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用ZSet，拿时间戳当score，调用ZADD命令生产消息，ZRANGEBYSOCRE命令获取N秒前的数据进行轮询处理。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用Stream类型，解决多端消费问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Stream的XADD命令，可以为其生成全局唯一ID。&lt;/li&gt;
&lt;li&gt;读取时使用命令XRead，可支持指定ID读取，也支持超时阻塞读取。&lt;/li&gt;
&lt;li&gt;命令XGroup创建消费组，XREADGROUP指定组内哪个消费者进行消费。&lt;/li&gt;
&lt;li&gt;Streams 会自动使用内部队列（也称为 PENDING List）留存消费组里每个消费者读取的消息，直到消费者使用 XACK 命令进行回复。如果消费不成功，它就不会给 Streams 发送 XACK 命令，消息仍然会留存。当消费者重启后，用 XPENDING 命令查看已读取、但尚未确认处理完成的消息。&lt;/li&gt;
&lt;li&gt;Stream是Redis5.0以后才有的专门用来处理消息队列的。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;缓存可能引发的问题以及应对方法&#34;&gt;缓存可能引发的问题以及应对方法&lt;/h1&gt;
&lt;p&gt;使用Redis来构建缓存有两种模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只读缓存：加速读请求。应用读取数据，先向Redis查询，查不到再查库，然后保存到缓存中。应用写数据，先改库，删掉旧缓存数据。这种方式可以很好的保证了一致性。&lt;/li&gt;
&lt;li&gt;读写缓存：同时加速读写请求。读写都会在缓存里发生，最新的数据是在Redis中，但需要严重依赖Redis的持久化。这种方式对一致性的保证就差了点，特别是在高并发下。
&lt;ul&gt;
&lt;li&gt;同步直写：优先保证数据可靠。写请求会同时修改缓存和库，等到都完成了才返回，需要保证原子性。&lt;/li&gt;
&lt;li&gt;异步写回：优先保证快速响应。写请求会先在缓存中处理，等到这些增改数据要从缓存中淘汰，才会写回数据库。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缓存雪崩&#34;&gt;缓存雪崩&lt;/h2&gt;
&lt;p&gt;现象：缓存大面积失效导致请求到达数据库&lt;/p&gt;
&lt;p&gt;应对方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存过期时间设置均匀，不能让一大片缓存在某一时间全部失效，比如设置过期时间时加入随机数，让过期时间在一个范围内波动。&lt;/li&gt;
&lt;li&gt;请求时加锁(比如利用redission的rlock)，后续请求只能等到前面的查完数据库，进行缓存后，才能继续，但会造成吞吐量降低，响应时间变长，或者可以使用semaphore设置一定的信号量，不至于只有一个请求去回源数据库。&lt;/li&gt;
&lt;li&gt;不设置key的过期时间，另开一个定时任务定期全量更新缓存；或者定时任务定期扫描，将快要过期的key延迟过期时间；设置多级缓存。&lt;/li&gt;
&lt;li&gt;灰度发布，对缓存进行预热。&lt;/li&gt;
&lt;li&gt;服务降级，当访问的数据是非核心数据，直接返回预定义数据或空值；当访问的数据是核心数据，仍允许查缓存，查库。&lt;/li&gt;
&lt;li&gt;缓存标记，比如，给数据设置缓存过期时间为60分钟，标记缓存过期时间为30分钟，当时间超过缓存标记时间后，触发缓存更新，但此时实际缓存还能返回旧数据，直到缓存更新完成，才会返回新缓存。&lt;/li&gt;
&lt;li&gt;如果是Redis实例发生宕机，只能在应用层中实现服务熔断或请求限流。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缓存击穿&#34;&gt;缓存击穿&lt;/h2&gt;
&lt;p&gt;现象：大量请求访问热点数据时，但&lt;strong&gt;热点数据刚好过期&lt;/strong&gt;，此时请求击穿缓存层，直接到达数据库&lt;/p&gt;
&lt;p&gt;应对方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不给热点数据的缓存设置过期时间，一直保留，或者热点数据快要到期前，异步刷新缓存，重新设置过期时间。&lt;/li&gt;
&lt;li&gt;使用互斥锁或者信号量，当有大量请求访问一个过期的热点数据时，只有一定数量的请求会到达数据库查询数据并缓存，其他请求等待缓存加载即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缓存穿透&#34;&gt;缓存穿透&lt;/h2&gt;
&lt;p&gt;现象：&lt;strong&gt;查询一个一定不存在的数据&lt;/strong&gt;，导致请求一直到达数据库，数据也不在数据库中。&lt;/p&gt;
&lt;p&gt;应对方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用布隆过滤器，将可能出现查询的值哈希到一个bitMap中，进行拦截，虽然布隆过滤有一定的误报几率，但也能一定程度的减少穿透的影响，常见的方案是配合2一起降低穿透带来的影响。&lt;/li&gt;
&lt;li&gt;如果查询结果为空，也加入缓存中（可以直接设置为空，或者使用特殊标识来表示），并设置过期时间。&lt;/li&gt;
&lt;li&gt;通过异步更新服务 + 消息队列的方式进行全量缓存的更新。缓存的设置还是照旧，只是当有数据更新时，触发消息交给消息队列，再由异步更新服务消费消息，实现缓存更新。&lt;/li&gt;
&lt;li&gt;利用数据库的Bin Log，当数据库执行更新操作时，从数据库接收到Bin Log之后根据Bin Log更新Redis缓存，道理跟消息队列类似，只是不用担心消息发送失败问题。&lt;/li&gt;
&lt;li&gt;前端预防，对请求进行检测。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缓存无底洞&#34;&gt;缓存无底洞&lt;/h2&gt;
&lt;p&gt;现象：增加缓存节点，性能不升反降，原因是客户端要维护大量的连接，如果key分布在不同机器，需要查多次&lt;/p&gt;
&lt;p&gt;应对方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少网络请求，能批量查尽量批量查&lt;/li&gt;
&lt;li&gt;将key进行分类，存到指定节点，查询同类的key时只需要特定的节点去查&lt;/li&gt;
&lt;li&gt;并发查询&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缓存污染&#34;&gt;缓存污染&lt;/h2&gt;
&lt;p&gt;现象：对于那些访问次数很少的数据，一直留存在缓存中，占用缓存空间。&lt;/p&gt;
&lt;p&gt;应对方案：Redis的淘汰策略，一般会使用LRU、LFU、TTL的淘汰策略。&lt;/p&gt;
&lt;h2 id=&#34;主动更新缓存要注意的点&#34;&gt;主动更新缓存要注意的点&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;不推荐先更新缓存再更新数据库（也称 Write Behind Caching 模式，更新数据时，只更新缓存，异步 / 同步 更新数据库）原因是数据库操作可能失败，导致缓存与数据库不一致；&lt;/p&gt;
&lt;p&gt;这个模式也有点像Linux的PageCache算法，好处是因为直接操作内存，异步，write back可以合并同一个数据的多次操作，IO性能极高，但因为要保证数据一致性，write back的实现就会很复杂，它需要知道哪些数据被更新了，然后还要持久化到磁盘上，比如操作系统的write back仅会在当这个缓存需要失效、内存不够、进程退出时，才会真正持久化。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不推荐先更新数据库再更新缓存（也称 Write Through 模式），原因是当AB两个操作同时写，两者的操作顺序无法保证，导致数据不一致，即并发写导致脏数据；另外，更新到缓存的数据也不一定被访问；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不推荐先删缓存再更新数据库，访问时再进行加载，原因是并发情况下，删除缓存后来不及更新数据库，但旧值已经被其他线程读到了，更新到缓存了；或者数据库操作失败了，但缓存已经没了，导致其他请求还要再读一次数据库，应对的方案是延迟双删：&lt;code&gt;先删缓存 -》更新数据库 -》sleep -》再删除缓存&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;推荐先更新数据库再删除缓存（也称为Cache Aside 模式），访问时再进行加载，虽然也可能出现3中的情况，比如读缓存时缓存失效，紧接着一个并发写操作，就有可能出现读操作覆盖了写操作后的数据更新，导致数据不一致，但实际上发生的概率不大，带来的影响会相对小一些，因为写操作通常会比读操作慢，再加上要锁表，而读操作必须在写操作前进入数据库操作，而又要晚于写操作更新缓存，条件就很苛刻了。&lt;/p&gt;
&lt;p&gt;如果删除缓存失败了，可以延迟任务进行删除重试，因为删除操作一般是幂等的，所以即使重复删除也没关系，另外，相比Read/Write Through模式（更新数据库后更新缓存操作），不会因为并发读写产生脏数据。还有由于会删除缓存，所以要注意缓存击穿问题。&lt;/p&gt;
&lt;p&gt;另外，即使使用了先更新数据库再删除缓存的模式，在主从同步延迟的场景也会导致不一致(对于其他模式也是)，解决方案仍然是延迟双删，只是sleep的时间最好等于延迟时间；&lt;/p&gt;
&lt;p&gt;如果还要强一致，就只能使用2PC、3PC、Raft之类的一致性协议或者分布式锁等方案来解决了，但是性能就保证不了了；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另外的方案是利用数据库的能力 + 消息队列的方式，如根据MySQL的Bin log来更新缓存；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Redis%e7%bc%93%e5%ad%98%e6%96%b9%e6%a1%88%e6%93%8d%e4%bd%9c.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Redis%e7%bc%93%e5%ad%98%e6%96%b9%e6%a1%88%e6%93%8d%e4%bd%9c.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;Redis缓存方案操作 - 极客时间Redis核心技术与实战&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Redis缓存方案操作 - 极客时间Redis核心技术与实战&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;极客时间 - Redis核心技术与实战：讲得很不错，推荐。&lt;/p&gt;
&lt;p&gt;还有其他看过的别人博客，但是当时忘记把链接贴下来。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>etcd和ZooKeeper</title>
        <link>http://nixum.cc/p/etcd%E5%92%8Czookeeper/</link>
        <pubDate>Wed, 23 Sep 2020 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/etcd%E5%92%8Czookeeper/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;zookeeper&#34;&gt;ZooKeeper&lt;/h1&gt;
&lt;p&gt;ZooKeeper保证的是CP，不保证每次服务请求的可用性，在极端环境下，ZooKeeper可能会丢弃一些请求，消费者程序需要重新请求才能获得结果。另外在进行leader选举时集群都是不可用，所以说，ZooKeeper不能保证服务可用性。&lt;/p&gt;
&lt;h2 id=&#34;使用场景&#34;&gt;使用场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;集群管理，监控节点存活状态&lt;/li&gt;
&lt;li&gt;主节点选举，当服务以master-salve模式进行部署，当主节点挂掉后选出新的主节点&lt;/li&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;分布式锁，提供独占锁、共享锁&lt;/li&gt;
&lt;li&gt;分布式自增id&lt;/li&gt;
&lt;li&gt;搭配Kafka、dubbo等使用&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;顺序一致性：同一客户端发起的事务请求，最终将会严格地按照顺序被应用到 ZooKeeper 中去。&lt;/li&gt;
&lt;li&gt;原子性：所有事务请求的处理结果在整个集群中所有机器上的应用情况是一致的，也就是说，要么整个集群中所有的机器都成功应用了某一个事务，要么都没有应用。&lt;/li&gt;
&lt;li&gt;单一系统映像：无论客户端连到哪一个 ZooKeeper 服务器上，其看到的服务端数据模型都是一致的。&lt;/li&gt;
&lt;li&gt;可靠性：一旦一次更改请求被应用，更改的结果就会被持久化，直到被下一次更改覆盖。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;数据模型&#34;&gt;数据模型&lt;/h2&gt;
&lt;p&gt;类似文件系统，根节点为 / ，每创建一个节点会从根节点开始挂，树形结构，每个数据节点称为znode，可以存储数据，每个znode还有自己所属的节点类型和节点状态&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;持久节点：一旦创建就一直存在，直到将其删除。&lt;/li&gt;
&lt;li&gt;持久顺序节点：一个父节点可以为其子节点 &lt;strong&gt;维护一个创建的先后顺序&lt;/strong&gt; ，这个顺序体现在 &lt;strong&gt;节点名称&lt;/strong&gt; 上，是节点名称后自动添加一个由 10 位数字组成的数字串，从 0 开始计数。&lt;/li&gt;
&lt;li&gt;临时节点：临时节点的生命周期是与 &lt;strong&gt;客户端会话&lt;/strong&gt; 绑定的，&lt;strong&gt;会话消失则节点消失&lt;/strong&gt; 。临时节点 &lt;strong&gt;只能做叶子节点&lt;/strong&gt; ，不能创建子节点。&lt;/li&gt;
&lt;li&gt;临时顺序节点：父节点可以创建一个维持了顺序的临时节点(和前面的持久顺序性节点一样)。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;zab协议&#34;&gt;ZAB协议&lt;/h2&gt;
&lt;p&gt;通过ZAB协议保证注册到ZooKeeper上的主从节点状态同步，该协议有两种模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;崩溃恢复&lt;/p&gt;
&lt;p&gt;当整个 Zookeeper 集群刚刚启动或者Leader服务器宕机、重启或者网络故障导致&lt;strong&gt;不存在过半的服务器与 Leader 服务器保持正常通信时，所有服务器进入崩溃恢复模式&lt;/strong&gt;，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息广播&lt;/p&gt;
&lt;p&gt;当集群中超过半数机器与该 Leader 服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始接收客户端的事务请求生成事物提案（超过半数同意）来进行事务请求处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;选举算法和流程&#34;&gt;选举算法和流程&lt;/h3&gt;
&lt;p&gt;ZooKeeper集群机器要求至少三台机器，机器的角色分为Leader、Follower、Observer；当 Leader 服务器出现网络中断、崩溃退出与重启等异常情况时，ZAB 协议就会进入恢复模式并选举产生新的Leader服务器。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Leader选举：节点在一开始都处于选举阶段，一个节点只要求获得半数以上投票，就可以当选为准Leader；&lt;/li&gt;
&lt;li&gt;Discovery发现：准Leader收集其他节点的数据，同步 Followers 最近接收的数据，并将最新的数据复制到自身；&lt;/li&gt;
&lt;li&gt;Synchronization同步：准Leader将自身最新数据同步给其他落后的Follower节点，同步完成后，告知其他节点自己正式当选为Leader；&lt;/li&gt;
&lt;li&gt;Broadcast广播：Leader正式对外服务，处理client请求，对消息进行广播，当收到一个写请求后，会生成Proposal广播给各个Follower节点，一半以上Follower节点应答后，Leader再发送Commit命令给各个Follower，告知他们提交相关提案。如果有新的节点加入，还需要对新节点进行同步。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;默认使用FastLeaderElection算法，比如现在有5台服务器，每台服务器均没有数据，它们的编号分别是1, 2, 3, 4, 5按编号依次启动，它们的选择举过程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;服务器1启动，给自己投票，然后发投票信息，由于其它机器还没有启动所以它收不到反馈信息，服务器1的状态一直属于Looking。&lt;/li&gt;
&lt;li&gt;服务器2启动，给自己投票，同时与之前启动的服务器1交换结果，由于服务器2的编号大所以服务器2胜出，但此时投票数没有大于半数，所以两个服务器的状态依然是Looking。&lt;/li&gt;
&lt;li&gt;服务器3启动，给自己投票，同时与之前启动的服务器1,2交换信息，由于服务器3的编号最大所以服务器3胜出，此时投票数正好大于半数，所以服务器3成为leader，服务器1,2成为Follower。&lt;/li&gt;
&lt;li&gt;服务器4启动，给自己投票，同时与之前启动的服务器1,2,3交换信息，尽管服务器4的编号大，但之前服务器3已经胜出，所以服务器4只能成为Follower。&lt;/li&gt;
&lt;li&gt;服务器5启动，后面的逻辑同服务器4成为Follower。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;通知机制&#34;&gt;通知机制&lt;/h2&gt;
&lt;p&gt;客户端会对某个znode建立一个watcher事件，当该znode发生变化时，这些客户端会收到ZooKeeper的通知，然后客户端根据znode的变化来做出相应的改变，类似观察者模式&lt;/p&gt;
&lt;h1 id=&#34;etcd&#34;&gt;ETCD&lt;/h1&gt;
&lt;h2 id=&#34;总体&#34;&gt;总体&lt;/h2&gt;
&lt;p&gt;是一个CP系统，分为三个版本，V1、V2和V3&lt;/p&gt;
&lt;p&gt;共识算法使用Raft。将复杂的一致性问题分解成Leader选举、日志同步、安全性三个独立子问题，只有集群一半以上节点存活即可提供服务，具备良好可用性。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/ETCD%e6%9e%b6%e6%9e%84.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/ETCD%e6%9e%b6%e6%9e%84.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;etcdctl支持负载均衡、健康检测、故障转移，3.4版本中负载均衡使用轮询算法，轮询endpoints的每个节点建立长连接，将请求发送给etcd server。client和server之间使用HTTP/2.0协议通信。&lt;/p&gt;
&lt;p&gt;etcd server在处理一个请求时会先将一系列的拦截器串联成一个执行，常见的拦截器有debug日志、metrics统计、etcd learner节点请求接口和参数限制等能力，另外还要求执行一个操作前集群必须有Leader，若请求延时超过指定阈值，会打印来源IP的慢查询日志。&lt;/p&gt;
&lt;h3 id=&#34;v2版本&#34;&gt;V2版本&lt;/h3&gt;
&lt;p&gt;数据模型参考ZooKeeper，使用基于目录的层次模式，使用Restful 风格的API，提供常用的Get/Set/Delete/Watch等API，实现对key-value数据的查询、更新、删除、监听等操作。&lt;/p&gt;
&lt;p&gt;Key—Value存储上使用简单内存树，一个节点包含节点路径、父亲节点、孩子节点、过期时间、Value的值，是典型的低容量设计，数据全放内存，无需考虑数据分片，只保存Key的最新版本。&lt;/p&gt;
&lt;p&gt;在Kubernetes中的使用场景：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用Kubernetes声明式API部署服务的时候，Kubernetes 的控制器通过etcd Watch 机制，会实时监听资源变化事件，对比实际状态与期望状态是否一致，并采取协调动作使其一致。Kubernetes 更新数据的时候，通过CAS 机制保证并发场景下的原子更新，并通过对key 设置TTL来存储Event事件，提升Kubernetes 集群的可观测性，基于TTL特性，Event事件key到期后可自动删除。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;功能局限：不支持范围查询、分页查询、多key事务&lt;/li&gt;
&lt;li&gt;Watch机制可靠性问题：V2是内存型，不保存key历史版本的数据库，只在内存中使用滑动窗口保存最近1000条变更事件，当写请求比较多、网络波动等容易产生事件丢失问题&lt;/li&gt;
&lt;li&gt;性能问题：使用HTTP/1.x协议，当请求响应较大时无法进行压缩；Json解析消耗CPU；当watcher较多时，由于不支持多路复用，会创建大量的连接；大量的TTL一样也需要为每个key发起续期，无法批量操作&lt;/li&gt;
&lt;li&gt;内存开销问题：简单内存树保存key和value，量大时会导致较大的内存开销，保证可靠还需要全量内存树持久化到磁盘，消耗大量CPU和磁盘IO&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;v3版本&#34;&gt;V3版本&lt;/h3&gt;
&lt;p&gt;为了解决V2版本的缺点，才诞生了V3版本&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在内存开销、Watch 事件可靠性、功能局限上，它通过引入B-tree、 boltdb 实现一个MVCC数据库，数据模型从层次型目录结构改成扁平的key-value，提供稳定可靠的事件通知，实现了事务，支持多key原子更新，同时基于boltdb的持久化存储，显著降低了etcd 的内存占用、避免了etcd v2 定期生成快照时的昂贵的资源开销。&lt;/p&gt;
&lt;p&gt;性能上，首先etcd v3 使用了 gRPC API，使用protobuf 定义消息，消息编解码性能相比JSON 超过2倍以上，并通过 HTTP/ 2.0 多路复用机制，减少了大量 watcher 等场景下的连接数。&lt;/p&gt;
&lt;p&gt;其次使用 Lease优化TTL机制，每个Lease具有一 个 TTL，相同的TTL 的key关联一 个Lease，Lease过期的时候自动删除相关联的所有key，不再需要为每个key单独续期。&lt;/p&gt;
&lt;p&gt;最后是etcd v3支持范围、分页查询，可避免大包等 expensive request。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;应用&#34;&gt;应用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;服务发现&lt;/li&gt;
&lt;li&gt;消息发布订阅，利用Watcher机制&lt;/li&gt;
&lt;li&gt;负载均衡&lt;/li&gt;
&lt;li&gt;分布式锁：支持独占锁和顺序锁&lt;/li&gt;
&lt;li&gt;集群监控和Leader选举&lt;/li&gt;
&lt;li&gt;配置存储&lt;/li&gt;
&lt;li&gt;各种读多写少的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;读操作&#34;&gt;读操作&lt;/h2&gt;
&lt;p&gt;客户端通过etcdctl发送get请求&lt;code&gt;etcdctl get [key名称] --endpoints [多个etcd节点地址]&lt;/code&gt;，etcdctl通过负载均衡算法选择一个etcd节点，发起gRpc调用，etcd server收到请求后经过一系列gRpc拦截器后，进入KV Server模块。之后根据读的行为，进行对应的操作&lt;/p&gt;
&lt;p&gt;读操作之前，如果有一个写操作：client发出一个写请求后，若Leader收到写请求，会将此请求持久化到WAL日志，并传播到各个节点，若一半以上的节点持久化成功，则该请求对应的日志条目被标识为已提交，etcd server模块异步从Raft模块获取已提交的日志，应用到状态机(boltdb等)。&lt;/p&gt;
&lt;h3 id=&#34;串行读&#34;&gt;串行读&lt;/h3&gt;
&lt;p&gt;直接读状态机（boltdb等）的数据返回，无需通过Raft协议与集群进行交互的模式，可能会读到旧数据。即：写请求广播到各个节点，但串行读可能读到某个还没进行写请求提交的节点(但可能其他节点已提交)，从而读到旧数据。&lt;/p&gt;
&lt;p&gt;这种读取方式低延时，高吞吐，适用于读取数据敏感度低、对数据一致性要求不高的场景。&lt;/p&gt;
&lt;h3 id=&#34;线性读默认&#34;&gt;线性读（默认）&lt;/h3&gt;
&lt;p&gt;一旦一个值更新成功后（指有超过半数节点更新提交成功），任何线性读的client都能及时访问到。&lt;/p&gt;
&lt;h4 id=&#34;readindex保证数据一致性&#34;&gt;ReadIndex：保证数据一致性&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;节点C收到一个线性读请求后，首先会从Leader获取集群最新的已提交的日志索引(committed index)；&lt;/li&gt;
&lt;li&gt;Leader收到ReadIndex请求后，为防止脑裂异常，会向各个Follower节点发送心跳确认，待一半以上节点确认Leader身份后，才能将已提交的索引(committed index))返回给节点C。&lt;/li&gt;
&lt;li&gt;C节点继续等待，直到状态机上已应用索引(applied index)大于等于Leader的已提交索引(committed index)时，通知读请求，数据已赶上Leader，可以从状态机中访问数据&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;既然Follower节点都已经发送ReadIndex请求了，为啥不直接把读请求转发给Leader？原因是ReadIndex比较轻量，而读请求不轻，大量的读请求会造成Leader节点有比较大的负载。&lt;/p&gt;
&lt;h4 id=&#34;mvcc支持key多历史版本多事务功能&#34;&gt;MVCC：支持Key多历史版本，多事务功能&lt;/h4&gt;
&lt;p&gt;核心是内存树形索引模型treeIndex + 嵌入式KV持久化存储库boltdb组成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;boltdb&lt;/strong&gt;会对key的每一次修改，都生成一个新的版本号对象，以&lt;strong&gt;版本号为key，value为用户key-value&lt;/strong&gt;等信息组成的结构体。版本号全局递增，通过&lt;strong&gt;treeIndex模块保存用户key和版本号的映射&lt;/strong&gt;。查询时，先去treeIndex模块查询key对应的版本号，根据版本号到boltdb里查询对应的value信息。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;treeIndex基于B树实现，只会保存用户的key和版本号的映射，具体的value信息则保存再boltdb里。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;boltdb基于B+树实现的kv键值库，支持事务，提供Get/Put等API，etcd通过boltdb实现一个key的多历史版本。在读取boltdb前，会从一个内存读事务buffer中，二分查找要访问的key是否在buffer里，提高查询速度。&lt;/p&gt;
&lt;p&gt;若buffer未命中，就进到boltdb中查询。boltdb通过bucket隔离集群元数据于用户数据，每个bucket对应一张表（一颗B+树），用户数据的key的值等于bucket名字，etcd MVCC元数据存放的bucket是meta。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;写操作&#34;&gt;写操作&lt;/h2&gt;
&lt;p&gt;客户端通过etcdctl发送put请求&lt;code&gt;etcdctl put [key值] [value值] --endpoints [多个ectd节点地址]&lt;/code&gt;，etcdctl通过负载均衡算法选择一个etcd节点，发起gRpc调用，etcd server收到请求后经过一系列gRpc拦截器、Quota模块后，进入KV Server模块，KV Server模块向Raft模块提交一个写操作的提案。随后，Raft模块通过HTTP网络模块转发到集群的多数节点持久化，状态变成已提交，etcd server从Raft模块获取已提交的日志条目，传递给Apply模块，Apply模块通过MVCC模块执行命令内容，更新状态机。&lt;/p&gt;
&lt;p&gt;etcd写入的value大小默认不超过1.5MB&lt;/p&gt;
&lt;h3 id=&#34;quota模块&#34;&gt;Quota模块&lt;/h3&gt;
&lt;p&gt;etcd的db文件配额只有2G，当超过时，整个集群变成只读，无法写入，这个限制主要是为了保证etcd的性能，官方建议最大不超过8G，不禁用配额。&lt;/p&gt;
&lt;p&gt;当etcd server收到写请求时，会先检测db大小 + 上请求时的key-value大小，判断是否超过配额，如果超过，会产生一个NO SPACE的告警，并通过Raft日志同步给其他节点，告知db无空间，并将告警持久化存储到db中，使得集群内其他节点也都拒绝写入，变成只读。&lt;/p&gt;
&lt;p&gt;如果达到配额后，再次去修改配额大小，还需要额外发送一个取消警告，消除NO SPACE告警带来的影响。&lt;/p&gt;
&lt;p&gt;其次是要检测etcd的压缩配置，如果没有机制去回收旧版本，会导致内存和db大小一直膨胀。&lt;/p&gt;
&lt;p&gt;回收机制有多种，常见的是保留最近一段时间的历史版本，给旧版本数据打上free标记，后续新写入的数据直接覆盖而无需申请新空间。另一种回收机制是回收空间，减少db大小，但会产生碎片，产生碎片就需要整理，旧的db文件数据会写入新的db文件，对性能影响较大。&lt;/p&gt;
&lt;h3 id=&#34;kvserver模块&#34;&gt;KVServer模块&lt;/h3&gt;
&lt;p&gt;写请求在通过Raft算法实现节点间的数据复制前，由KVServer进行一系列的检查。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;限速判断，保证集群稳定，避免雪崩。比如Raft模块已提交的日志索引(committed index)比已应用到状态机的日志索引(applied index)超过了5000。&lt;/li&gt;
&lt;li&gt;尝试获取请求中的鉴权信息，若使用了鉴权，则判断请求中的密码、token是否正确。&lt;/li&gt;
&lt;li&gt;检查写入的包大小是否超过默认的1.5MB。&lt;/li&gt;
&lt;li&gt;通过检查后，生成一个唯一的ID，并将该请求关联到一个对应的消息通知channel，向Raft模块发起一个提案，之后KV Server会等待写请求的返回，写入结果通过消息通知channel返回，或者超时，默认超时时间是7秒。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;wal模块&#34;&gt;WAL模块&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;Raft模块收到提案后，如果当前节点是Follower节点，则转发给Leader，只有Leader才能处理写请求。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leader收到提案后，通过Raft模块输出待转发给Follower节点的消息和待持久化的日志条目，日志条目记录了写操作的内容。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leader节点从Raft模块获取到以上消息和日志条目后，将写请求提案消息广播给集群各个节点，同时需要把集群Leader任期号、投票信息、已提交索引、提案内容持久化待一个WAL日志文件中，用于保证集群一致性、可恢复性。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当一半以上节点持久化此日志条目后，Raft模块通过channel告知etcd server模块，写请求提案已被超半数节点确认，提案状态转为已提交，从channel中取出提案内容，添加到FIFO队列中，等待Apply模块顺序、异步依次执行提案内容。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;WAL持久化机制&lt;/strong&gt;：先将Raft日志条目内容序列化后保存到WAL记录的Data字段，计算Data的CRC值，设置Type为EntryType，组成一个完成的WAL记录，最后记录WAL记录的长度，顺序写入WAL长度，再写入记录内容，调用fsync持久化到磁盘。&lt;/p&gt;
&lt;p&gt;主要作用是为了保证etcd重启时，重放日志提案，保证命令的执行。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;WAL日志结构
LenField -------- 数据长度
Type ------------ WAL记录类型，有5种，分别是文件元数据记录、日志条目记录、状态信息记录、CRC、快照
CRC ------------- 校验码
Data ------------ WAL记录内容

Raft日志条目Data的结构
Term ----------- uint64，Leader任期号，随Leader选举增加
Index ---------- 日志条目的索引，单调递增，同时也用于确保幂等操作
Type ----------- 日志类型，如 普通的命令日志还是集群配置变更日志
Data ----------- 提案内容
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;apply模块&#34;&gt;Apply模块&lt;/h3&gt;
&lt;p&gt;从FIFO队列取出提案执行，同时会保证可靠性，包括crash重启，消费消息的幂等，防止重复提交。通过consistent index字段存储系统当前已执行过的日志条目索引 + 日志条目中的Index字段保证幂等。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;从FIFO队列取出提案后，如果之前没被执行过，则进入到MVCC模块&lt;/p&gt;
&lt;p&gt;etcd再进行更新时会为key生成一个版本号，版本号的生成单调递增，启动时默认是1，如果有持久化的数据，则读取boltdb中的数据的最大值，作为当前版本号，版本号格式&lt;code&gt;{[版本号],[子版本号]}&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写操作执行时，MVCC会递增当前版本号作为key的版本号，存储到treeIndex中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将新生成的版本号做为key，写操作对应的value写入boltdb，每个key对应一个bucket，boltdb的value包括写操作的key名，key创建时的版本号，最后一次修改时的版本号，key自身修改的次数，写操作的value值，租约信息。将这些信息序列化成一个二进制数据，写入boltdb中，此时还只在boltdb的内存bucket buffer中。此时如果有读请求，会优先从bucket buffer中读取，其次才从boltdb读。&lt;/p&gt;
&lt;p&gt;boltdb不是每个value都是直接写到磁盘的，因为key递增，会顺序写入，所以会合并多个写事务请求，异步(默认每个100ms)，批量事务一次性提交，提高吞吐量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;raft协议&#34;&gt;Raft协议&lt;/h2&gt;
&lt;p&gt;Raft协议保证了etcd在节点故障、网络分区等异常场景下的高可用和数据强一致性。&lt;/p&gt;
&lt;p&gt;为了避免单点故障，常见的多副本复制方案有两种：主从复制和去中心化复制。&lt;/p&gt;
&lt;p&gt;除了复制方案，另一种是共识算法如Paxos或Raft。&lt;/p&gt;
&lt;p&gt;Raft将共识算法拆分成三个子问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Leader选举，Leader故障后集群快速选出新Leader。&lt;/li&gt;
&lt;li&gt;日志复制，集群只有Leader能写入日志，Leader负责复制日志到Follower节点，强制Follower节点与自己保持一致。&lt;/li&gt;
&lt;li&gt;安全性，一个任期内集群只能产生一个Leader；已提交的日志条目在发生Leader选举时，一定会存在更高任期的新Leader日志中；各个节点的状态机应用的任意位置的日志条目内容一样；发起竞选投票时，任期值小的节点不会竞选成功；如果集群不出现故障，那么一个任期将无限延续下去；投票出现冲突也有可能直接进入下一任再次竞选。&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;当有节点宕机时：&lt;/p&gt;
&lt;p&gt;如果是 Follower 节点宕机，如果剩余可用节点数量超过半数，集群可以几乎没有影响的正常工作。&lt;/p&gt;
&lt;p&gt;如果是 Leader 节点宕机，那么 Follower 就收不到心跳而超时，发起竞选获得投票，成为新一轮 任期 的 Leader，继续为集群提供服务。&lt;strong&gt;需要注意的是：etcd 目前没有任何机制会自动去变化整个集群总共的节点数量&lt;/strong&gt;，即如果没有人为的调用 API，etcd 宕机后的节点仍然被计算为总节点数中，任何请求被确认需要获得的投票数都是这个总数的半数以上。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;leader选举&#34;&gt;Leader选举&lt;/h3&gt;
&lt;p&gt;Raft协议定义集群中节点的状态，任何时刻，每个节点肯定处于某一状态&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Follower：同步Leader收到的日志，etcd启动时的默认状态，等待 Leader 发来心跳信息。若等待超时，则状态由 Follower 切换到 Candidate 进入下一轮 term 发起竞选，等到收到集群多数节点的投票时，该节点转变为 Leader。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Candidate：可以发起Leader选举。当Follower接收Leader的心跳信息超时时，转为此状态，并立即发起竞选Leader投票，自增任期号，投票给自己，并向其他节点发送竞选Leader投票的消息，当获得多数节点的支持后，即可变成Leader节点。&lt;/p&gt;
&lt;p&gt;节点收到竞选消息后可能出现两种情况：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;节点判断&lt;strong&gt;发出竞选消息的节点的数据至少和自己一样新，并且任期号大于自己的&lt;/strong&gt;，并且自己还没投票给其他节点，就可以投票给发出竞选消息的节点了。&lt;/li&gt;
&lt;li&gt;节点此时也发出了竞选，并投票给自己，此时将拒绝投票给发出竞选消息的节点，相互等待直至竞选超时，开启新一轮竞选。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;3.4版本后，节点在进入Candidate前，会先进入PreCandidate状态，此时不自增任期号，而是直接发起预投票，若可以获得多数节点支持，才能变成Candidate，自增任期号发起选举。&lt;/p&gt;
&lt;p&gt;Candidate 在等待其它节点投票的过程中如果发现别的节点已经竞选成功成为 Leader 了，就会切换为 Follower 节点。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;为了确保在最短时间内选出Leader，防止竞选冲突&lt;/strong&gt;，当节点处于Candidate状态时，有一个竞选的超时时间，且该超时时间是一个随机值，每一个 Candidate 的超时时间都不一致，所以会有时间差。在这个时间差内，如果 Candidate1 收到的竞选信息比自己发起的竞选信息的任期号大（即对方为新一轮 term），并且新一轮想要成为 Leader 的 Candidate2 包含了所有提交的数据，那么 Candidate1 就会投票给 Candidate2，这样就保证了只有很小的概率会出现竞选冲突。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;为了防止别的 Candidate 在遗漏部分数据的情况下发起投票成为 Leader&lt;/strong&gt;，当竞选超时时，会重新发起新一轮选举，此时任期号提升，发起新一轮投票，投票时，如果别的节点发现发起竞选的节点的数据不完整，就不会投票给他，以此来解决这个问题。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leader：唯一性，拥有同步日志的特权，通过定时广播心跳给Follower节点，以维持Leader身份。Leader节点有一个任期号，充当Raft算法的逻辑时钟，可以比较各个节点的数据新旧、识别过期Leader等。&lt;/p&gt;
&lt;p&gt;默认的心跳间隔时间是100ms，默认的竞选超时时间是1000ms，当超时时间大于竞选时间时，节点从Follower状态转为Candidate状态。&lt;/p&gt;
&lt;p&gt;当现有Leader发现新的Leader任期号后，就会转为Follower节点；当现有Leader因为crash重启后，会先变成Follower，若此时无法与其他节点通信，也会进入选举流程，不过会先转为PreCandidate发起预投票，避免因数据落后且在Candidate状态因自增任期号，在恢复通信后造成选举异常。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;日志复制&#34;&gt;日志复制&lt;/h3&gt;
&lt;p&gt;Leader节点通过NextIndex字段标识要发送给Follower节点的下一个日志条目索引，MatchIndex字段标识Follower节点已复制的最大日志条目索引，每个节点都有。&lt;/p&gt;
&lt;p&gt;一个日志条目被确认为已提交的前提是它需要被Leader同步到一半以上节点。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端发送写操作消息msg给etcd，进入Leader节点的Raft模块&lt;/li&gt;
&lt;li&gt;Leader节点的etcd server模块通过channel从Raft模块获取Ready结构，通过HTTP协议的网络模块将追加日志条目消息广播给Follower，并同时将待持久化的日志持久化到WAL文件中，最后将日志条目追加到稳定的Raft日志存储中。Raft日志存储在内存中，即使丢失也可以通过WAL文件重建。&lt;/li&gt;
&lt;li&gt;各个Follower收到追加日志条目消息，通过安全检查后，会持久化消息到WAL日志中，并将消息追加到Raft日志存储，随后向Leader回复一个应答追加日志条目的消息，告知Leader当前已复制的日志最大索引。&lt;/li&gt;
&lt;li&gt;Leader收到应答追加日志条目消息后，将Follower回复的已复制日志最大索引更新到追踪Follower进展的MatchIndex字段，根据该字段信息，计算出一个位置，如果这个位置已经被一半以上节点持久化，那么这个位置之前的日志条目都可以被标记成已提交。Leader通过心跳信息告知已提交的日志索引位置给Follower。&lt;/li&gt;
&lt;li&gt;各个节点的etcd server模块，通过channel从Raft模块获取已提交的日志条目，应用日志条目内容到存储状态机，返回给客户端。&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Raft 为了保证数据的强一致性，所有的数据流向都是从 Leader 流向 Follower，所有 Follower 的数据必须与 Leader 保持一致，如果不一致会被覆盖。&lt;/p&gt;
&lt;p&gt;一个更新数据的请求都最先由 Leader 接收，WAL存下来，然后同步到其他节点；当Leader节点收到大多数Follower 节点的反馈后，提交数据，然后异步通知其他 Follower也进行数据提交。所以写请求肯定是发送到Leader里，而读请求可以发送到任一节点，但要注意是要串行读还是线性读。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;安全性&#34;&gt;安全性&lt;/h3&gt;
&lt;p&gt;Raft通过给选举和日志复制增加规则，保证当Leader crash后，能在众多Follower中选举出有最新日志条目的Follower成为新Leader。&lt;/p&gt;
&lt;p&gt;当节点收到选举投票时，需检查发出选举消息的节点的最后一条日志的任期号，若小于自己则拒绝投票，如果相同，日志比自己短，也拒绝投票。节点需将投票信息持久化，防止异常重启后再投票给其他节点。&lt;/p&gt;
&lt;p&gt;在复制上，通过Leader完全特性、只附加原则和日志匹配保证Leader提交消息并广播给其他节点后crash，这条新消息不会被其他节点删除的问题和各个节点的同Raft日志位置含有相同的日志条目。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全特性：某个日志条目在某个任期号中已被提交，那么这个条目必然出现在更大任期号的所有Leader中&lt;/li&gt;
&lt;li&gt;只附加原则：Leader只能追加日志条目，不能删除&lt;/li&gt;
&lt;li&gt;日志匹配：追加日志时会进行一致性检查，Leader发送追加日志的消息时，会把新的日志条目紧接之前的条目的索引位置和任期号包含在里面，Follower节点会检查相同索引位置的任期号是否与Leader一致，一致才追加。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当Follower日志和Leader冲突时，会导致两者的日志不一致，此时Leader会强制Follower直接复制自己的日志来解决，因此在Follower中冲突的日志条目会被Leader的日志覆盖，Leader会记录Follower复制进度的nextIndex，如果Follower在追加日志时一致性检查失败，就会拒绝请求，此时Leader会减小nextIndex值并重试，最终在某个位置让Follower跟Leader一致。尽管WAL日志模块只能追加，对于那些想要删除的持久化日志条目，WAL模块确实没有删除，当发现一个raft log index位置上有多个日志条目时，会通过覆盖的方式，将最后写入的日志条目追加到raft log中，通过覆盖实现删除。&lt;/p&gt;
&lt;h2 id=&#34;鉴权&#34;&gt;鉴权&lt;/h2&gt;
&lt;p&gt;etcd鉴权体系由控制面和数据面组成。&lt;/p&gt;
&lt;p&gt;控制面：通过etcdctl和鉴权API动态调整认证、鉴权规则，AuthServer收到请求后，为了确保各个节点间鉴权元数据一致性，会通过Raft模块进行数据同步。当对应的Raft日志条目被集群半数以上节点确认后，Apply模块通过鉴权存储AuthStore模块，执行日志条目内容，将规则存储到boltdb的鉴权表里。&lt;/p&gt;
&lt;p&gt;数据面：由认证和授权组成。目前有两种认证机制：密码认证和证书认证。通过认证后，在访问MVCC模块前，还需要进行授权，检查client是否有权限操作你请求的数据路径，使用的是RBAC机制。&lt;/p&gt;
&lt;h3 id=&#34;认证&#34;&gt;认证&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;密码认证：etcd鉴权模块使用bcrpt库的blowfish算法，基于明文密码、随机分配的salt、自定义的cost、迭代多次计算得到一个hash值，并将加密算法版本、salt值、cost、hash值组成一个字符串，作为加密后的密码。以用户名为key，用户名、加密后的密码作为value，存储到boltdb的authUsers bucket里。&lt;/p&gt;
&lt;p&gt;验证密码成功后，返回一个token给client，后续请求携带此token而无需进行密码校验了。默认的token过期时间是5分钟，仅在开发或测试环境中使用。正式环境一般使用JWT。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;证书认证：类似HTTPS，证书认证在稳定性和性能上都优于密码认证。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;授权&#34;&gt;授权&lt;/h3&gt;
&lt;p&gt;使用RBAC授权模型。&lt;/p&gt;
&lt;h2 id=&#34;租约-lease&#34;&gt;租约 Lease&lt;/h2&gt;
&lt;p&gt;etcd通过Lease实现活性检测，可以检测各个客户端的存活能力，业务client需要定期向etcd发送心跳请求汇报讲课状态，属于主动型上报，让etcd server保证在约定的有效期内，不删除client关联到此lease上的key-value，若未在有效期内续租，就会删除Lease和其关联的key-value。&lt;/p&gt;
&lt;p&gt;基于Lease的TTL特性，可以解决类似Leader选举、Kubernetes Event自动淘汰、服务发现场景中故障节点自动剔除等问题。&lt;/p&gt;
&lt;p&gt;检查Lease是否过期、维护最小堆、针对过期Lease发起revoke操作，都由Leader节点负责。&lt;/p&gt;
&lt;p&gt;创建Lease时，etcd会保存Lease信息到boltdb的lease bucket中，与该Lease关联的节点需要定期发送KeepAlive请求给etcd server续约Lease。&lt;/p&gt;
&lt;p&gt;etcd在启动时，会创建Lessor模块，通过两个异步任务管理Lease：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;一个RevokeExpiredLease任务定时检测是否有过期的Lease，使用最小堆管理Lease，每隔500ms进行检查，发起撤销过期Lease的操作，获取到LeaseId后通知整个集群删除Lease和关联的数据；过期默认淘汰限速是每秒1000个。&lt;/li&gt;
&lt;li&gt;另一个是CheckpointScheduledLease，定时(默认5min)触发更新Lease的剩余到期时间的操作，定期批量将Lease剩余的TTL基于Raft Log同步给Follower节点，更新其LeaseMap中剩余的TTL信息；另外，Leader节点收到KeepAlive请求后，重置TTL，并同步给Follower节点进行更新。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Lease续约是一个高频率的操作，当完成Lease的创建和节点数据的关联，在正常情况下，节点存活时，需要定时发送KeepAlive请求给etcd续期健康状态的Lease。TTL时间过长会导致节点异常无法从etcd中删除，过短会导致client频繁发送续约请求。另外，Lease的数目可能会很大。为了解决这个问题，etcd在v3版本上，一个是采用grpc解决连接复用问题，减少连接数，另一个是当有不同的key的TTL相同，会复用同一个Lease，减少Lease数目。&lt;/p&gt;
&lt;p&gt;Lease最小的TTL时间是 比选举的时间长，默认是2s&lt;/p&gt;
&lt;h2 id=&#34;mvcc&#34;&gt;MVCC&lt;/h2&gt;
&lt;p&gt;MVCC特性由treeIndex、Backend/boltdb组成，实现对key-value的增删查改功能。MVCC模块将请求划分为两个类别，分别是读事务（ReadTxn）和写事务（WriteTxn）。读事务负责处理range请求，写事务负责put/delete操作。&lt;/p&gt;
&lt;p&gt;TreeIndex中key的版本号与boltdb中的value关联。&lt;/p&gt;
&lt;h3 id=&#34;treeindex模块&#34;&gt;TreeIndex模块&lt;/h3&gt;
&lt;p&gt;基于内存版本的B-tree实现Key索引管理，保存用户key与版本号revision的映射关系。之所以使用B-tree，是因为etcd支持范围查询，B树每个节点可以容纳比较多的数据，树高度低，查找次数少，so不用哈希表或平衡二叉树。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;keyIndex&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;         &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;     &lt;span class=&#34;c1&#34;&gt;// key值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;modified&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;revision&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 最后一次修改key时的etcd版本号
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;generations&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;generation&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 保存一个key若干代版本号信息，每代包含对key的多次修改版本号列表
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;generation&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;ver&lt;/span&gt;      &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;         &lt;span class=&#34;c1&#34;&gt;// key的修改次数 
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;created&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;revision&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// generation结构创建时的版本号
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;revs&lt;/span&gt;     &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;revision&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 每次修改key时的revision追加到此数组
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;revision&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 全局递增主版本号，随put/txn/delete事务递增，一个事务内的key main版本号一致，空集群时启动时默认为1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;sub&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 事务内的子版本号，从0开始随事务内put/delete递增
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;backendboltdb模块&#34;&gt;Backend/boltdb模块&lt;/h3&gt;
&lt;p&gt;负责etcd的key-value持久化存储，主要由ReadTx、BatchTx、Buffer组成，ReadTx定义了抽象的读写事务接口，BatchTx在ReadTx之上定义了抽象的写事务接口，Buffer是数据缓存区。Backend支持多种实现，当前使用boltdb，基于B+ tree实现，支持事务的key-value嵌入式数据库。&lt;/p&gt;
&lt;p&gt;value的数据结构，版本号格式&lt;code&gt;{main, sub}&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;用户的key&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;用户的value&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;create_revision&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key创建时的版本号&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;与treeIndex中generate的created对应&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;mod_revision&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key最后一次修改时的版本号&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;put操作时的全局版本号&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;作为该值&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key的修改次数&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;每次修改时&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;与treeIndex中generate的ver值&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;lease&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;：&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;一般情况下为了etcd的写性能，默认堆积的写事务数大于1万才在事务结束时同步持久化，由backend的一个goroutine完成，通过事务批量提交，定时将boltdb页缓存中的脏数据提交到持久化存储磁盘中。&lt;/p&gt;
&lt;h3 id=&#34;创建更新操作&#34;&gt;创建/更新操作&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;在treeIndex中获取key的KeyIndex信息&lt;/li&gt;
&lt;li&gt;填充boltdb的value数据，写入新的key-value到blotdb和buffer中&lt;/li&gt;
&lt;li&gt;创建/更新KeyIndex到treeIndex中&lt;/li&gt;
&lt;li&gt;backend异步事务提交，将boltdb中的数据持久化到磁盘中&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;查询操作&#34;&gt;查询操作&lt;/h3&gt;
&lt;p&gt;创建一个读事务对象(TxnRead / ConcurrentReadTx)，全量拷贝当前写事务未提交的buffer数据，读不到则从boltdb中查询&lt;/p&gt;
&lt;h3 id=&#34;删除操作&#34;&gt;删除操作&lt;/h3&gt;
&lt;p&gt;删除操作是软删除，原理类似更新，会在被删除的key版本号追加删除标志t，对应的boltdb value也变成了只包含用户key的KeyValue结构，treeIndex模块也会给此key的KeyIndex结构追加一个空的generation对象，标识此索引对应的key被删除，当查询时发现其存在空的generation对象，并且查询的版本号大于等于被删除的版本号时，返回空。&lt;/p&gt;
&lt;p&gt;删除key时会生成events，Watch模块会根据key的删除标识，生成对应的Delete事件；或者当重启etcd，遍历boltdb中的key构建treeIndex内存树时，未这些key上次tombstone标识。&lt;/p&gt;
&lt;p&gt;真正删除treeIndex中的KeyIndex、boltdb的value是通过压缩组件异步完成，之所以要延迟删除，一个是为了watcher能够有相应的处理，另一个是减少B tree平衡影响读写性能。&lt;/p&gt;
&lt;h2 id=&#34;watch&#34;&gt;Watch&lt;/h2&gt;
&lt;p&gt;客户端订阅etcd的某个key，当key发生变化时，客户端能够感知。这也是Kubernetes控制器的工作基础。&lt;/p&gt;
&lt;h3 id=&#34;client获取事件的方式&#34;&gt;client获取事件的方式&lt;/h3&gt;
&lt;p&gt;V2版本：使用轮询推送，每一个watcher对应一个TCP连接，client通过HTTP/1.1协议长连接定时轮询server，获取最新数据变化事件。但是大量的轮询会产生一定的QPS，server端会消耗大量的socket、内存等资源。&lt;/p&gt;
&lt;p&gt;V3版本：使用流式推送，因为使用的是基于HTTP/2的gRpc协议，实现了一个TCP连接支持多gRPC stream，一个gRPC stream又支持多个watcher，降低了系统资源的消耗。&lt;/p&gt;
&lt;h3 id=&#34;事件的存储和保留&#34;&gt;事件的存储和保留&lt;/h3&gt;
&lt;p&gt;V2版本：滑动窗口，使用环形数组存储历史事件版本，当key被修改后，相关的事件就会被添加到数组中来，若超过一定容量（默认1000），则会淘汰旧事件，容易导致事件丢失，当事件丢失时，client需要获取最新的版本号才能继续监听，查询成本比较大。&lt;/p&gt;
&lt;p&gt;V3版本：MVCC，将事件保存到boltdb中，持久化到磁盘中，通过配置压缩策略控制历史版本数。&lt;/p&gt;
&lt;p&gt;版本号是etcd的逻辑时钟，当client因网络等异常连接断开后，通过版本号可以从server的boltdb获取错过的历史事件，而无需全量同步，它是etcd Watch机制数据量增量同步的核心。&lt;/p&gt;
&lt;h3 id=&#34;事件推送机制&#34;&gt;事件推送机制&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/etcd%e4%ba%8b%e4%bb%b6%e6%8e%a8%e9%80%81%e6%9e%b6%e6%9e%84.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/etcd%e4%ba%8b%e4%bb%b6%e6%8e%a8%e9%80%81%e6%9e%b6%e6%9e%84.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;client对每一个key发起的watch请求，etcd的gRPCWatchServer收到watch请求后，会创建一个serverWatchStream，它负责接收client的gRPC Stream的create/cancel watcher请求（recvLoop goroutine)，并将从MVCC模块接收的watch事件转发给client（sendLoop goroutine）&lt;/p&gt;
&lt;p&gt;当serverWatchStream收到create watcher请求后，serverWatchStream会调用MVCC模块的WatchStream子模块分配一个watcher id，并将watcher注册到MVCC的WatchableKV模块。&lt;/p&gt;
&lt;p&gt;watchableStore将watcher划分为synced / unsynced / victim三类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;synced watcher：如果创建的watcher未指定版本号或版本号为0或指定版本号大于etcd server当前的最新版本号，那它就会保存在 synced watcherGroup中，表示此类watcher监听的数据都已经同步完毕，等待新的变更。&lt;/li&gt;
&lt;li&gt;unsynced watcher：如果创建的watcher指定的版本号小于etcd server当前最新版本号，那它就会保存在 unsynced watcherGroup中，表示此类watcher监听的数据还未同步完成，落后于当前最新数据的变更，正在等待同步。&lt;/li&gt;
&lt;li&gt;victim：当接收watch事件的channel的buffer满了，该watcher会从synced watcherGroup中删除，然后保存到victim的watcherBatch中，通过异步机制重试保证事件可靠性。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当etcd启动时，WatchableKV模块会运行syncWatcherLoop和syncVictimsLoop goroutine，分别负责不同场景下的事件推送。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;syncWatcherLoop：遍历unsynced watcherGroup中的每个watcher，获取key的所有历史版本，转成事件，推送给接收的channel，完成后将watcher从unsynced watcherGroup转移到synced watcherGroup。&lt;/li&gt;
&lt;li&gt;syncVictimsLoop：遍历victim watcherBatch，尝试将堆积的事件再次推送到watcher的接收channel中，若推送失败则再次加入等待重试；若推送成功，watcher监听的最小版本号小于当前版本号，则加入unsynced watcherGroup中，大于则加入synced watcherGroup中。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;高效的找到监听key的所有watcher&#34;&gt;高效的找到监听key的所有watcher&lt;/h3&gt;
&lt;p&gt;由于watcher可以监听key范围、key前缀，&lt;/p&gt;
&lt;p&gt;当收到创建watcher请求时，会把watcher监听的key的范围插入到区间树中，当产生一个事件时，etcd首先会从map中找到是否有watcher监听了该key，其次还要从区间树中找到与key相交的所有区间，得到所有watcher。&lt;/p&gt;
&lt;h2 id=&#34;事务&#34;&gt;事务&lt;/h2&gt;
&lt;p&gt;etcd事务API由IF、Then、Else语句组成。&lt;/p&gt;
&lt;p&gt;etcd通过WAL日志 + consistent index + boltdb保证原子性；&lt;/p&gt;
&lt;p&gt;WAL日志+boltdb保证持久性；&lt;/p&gt;
&lt;p&gt;数据库和业务程序保证一致性；&lt;/p&gt;
&lt;p&gt;通过MVCC机制实现读写不阻塞，解决隔离性的脏读问题；MVCC快照读解决隔离性的不可重复读问题；MVCC版本号实现冲突检测机制，在串行提交事务时保证读写的数据都是最新的，未被他人修改。&lt;/p&gt;
&lt;h2 id=&#34;boltdb&#34;&gt;boltdb&lt;/h2&gt;
&lt;h3 id=&#34;磁盘布局&#34;&gt;磁盘布局&lt;/h3&gt;
&lt;p&gt;boltdb文件存放在etcd数据目录下的member/snap/db文件，etcd启动时，会通过mmap机制将db文件映射到内存，后续从内存中快速读取文件中的数据。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/etcd_boltdb%e6%96%87%e4%bb%b6%e5%b8%83%e5%b1%80.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/etcd_boltdb%e6%96%87%e4%bb%b6%e5%b8%83%e5%b1%80.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;开头两个是固定的db元数据meta page；freeList page记录db中哪些页是空闲的，可使用的；&lt;/p&gt;
&lt;p&gt;写操作时，会先打开db文件并增加文件锁，防止其他进程以读写模式打开后操作meta和free page，导致db文件损坏；然后通过mmap机制将db文件映射到内存中，并读取两个meta page到db对象实例，校验meta page的magic version、checksum是否有效，若两个meta page都无效，说明db文件损坏，将异常退出。&lt;/p&gt;
&lt;p&gt;执行put请求前会先执行bucket请求，先根据meta page中记录root bucket的root page，按照B+树的查找算法，从root page递归搜索到对应叶子节点page面，返回key名称，leaf类型；如果leaf类型未bucketLeafFlag，且key相等，说明已经创建过，不允许bucket重复创建，否则往B+树种添加一个flag为bucketLeafFlag的key，key的名称为bucket name，value为bucket结构；&lt;/p&gt;
&lt;p&gt;执行完bucket请求，就会进行put请求，跟创建bucket类似，根据子bucket的root page，从root page递归搜索此key到leaf page，如果没有找到，则在返回的位置插入新key和value，插入位置的查找使用二分法。&lt;/p&gt;
&lt;p&gt;当执行完一个put请求时，值只是更新到boltdb的内存node数据结构里，此时还未持久化。当代码执行到tx.commit api时，才会将node内存数据结构中的数据持久化到boltdb中。一般是经过 删除节点后重平衡操作、分裂操作、持久化freelist、持久化dirty page、持久化meta page。&lt;/p&gt;
&lt;h2 id=&#34;压缩&#34;&gt;压缩&lt;/h2&gt;
&lt;p&gt;由于更新和删除都会增加版本号，内存占用和db文件就会越来越大，当达到etcd OOM和db大小的最大配额时，最终不可写入，因此需要适合的压缩策略，避免db大小增长失控。&lt;/p&gt;
&lt;p&gt;压缩是使用Compact接口，可以设置自动也可通过业务服务手动调用，压缩时首先会检查请求的版本号rev是否被压缩过，然后更新当前server已压缩的版本号，并将耗时的压缩任务保存在FIFO队列种异步执行。压缩任务执行时，首先会压缩treeIndex模块中的keyIndex索引，其次会遍历boltdb中的key，删除已废弃的key，遍历boltdb时会控制删除的key数100个，每批间隔10ms，分批完成删除操作。&lt;/p&gt;
&lt;p&gt;压缩过程中，compact接口会持久化存储当前已调度的压缩版本号到boltdb，保证当发生crash后各个节点间的数据一致性。&lt;/p&gt;
&lt;p&gt;压缩时会保留keyIndex中的最大版本号(为了保证key仍存在)，移除小于等于当前压缩的版本号，通过一个map记录treeIndex中有效的版本号返回给boltdb模块使用。&lt;/p&gt;
&lt;p&gt;遍历删除boltdb中的数据后，db文件不会变小，而是通过freelist page记录哪些页是空闲的，覆盖使用&lt;/p&gt;
&lt;p&gt;使用参数&lt;code&gt;--auto-compaction-retention &#39;[0|1]&#39;&lt;/code&gt;0表示关闭自动压缩，1 表示开启自动压缩策略，使用参数&lt;code&gt;--auto-compaction-mode &#39;[periodic|revision]&#39;&lt;/code&gt;，periodic表示周期性压缩，revision表示版本号压缩&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;时间周期性压缩：只保留最近一段时间写入的历史版本，periodic compactor会根据设置的压缩时间间隔，划分为10个区间，通过etcd MVCC模块获取当前的server版本号，追加到rev数组中，通过当前时间减去上一次执行compact操作的时间，如果间隔大于设置的压缩时间，则取出rev数组首元素，发起压缩。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;版本号压缩：保留最近多少个历史版本，revision compactor会根据设置的保留版本号数，每隔5分钟定时获取当前server最大版本号，减去想保留的历史版本数，得到要压缩的历史版本，发起压缩。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;极客时间 - etcd实战课&lt;/p&gt;
</description>
        </item>
        <item>
        <title>消息队列</title>
        <link>http://nixum.cc/p/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</link>
        <pubDate>Tue, 22 Sep 2020 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;使用场景&#34;&gt;使用场景&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;秒杀系统，一般秒杀系统处理包含几个步骤：风险控制、库存锁定、生成订单、短信通知、更新统计数据等，而决定秒杀是否成功只在前两个步骤，后续的操作就可以通过消息队列&lt;strong&gt;异步&lt;/strong&gt;处理完成，加快整个流程的处理，&lt;strong&gt;减少等待时间，提升并发量&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;隔离网关和后端服务，实现&lt;strong&gt;流量控制，保护&lt;/strong&gt;后端服务，但会增加系统调用链，导致总体响应变长，异步增加系统复杂性。&lt;/li&gt;
&lt;li&gt;令牌桶，目的也是进行流量控制。&lt;/li&gt;
&lt;li&gt;服务解耦，数据同步，比如订单系统在订单状态发生变化时发出消息通知，其他服务订阅后做相应处理。&lt;/li&gt;
&lt;li&gt;连接流计算任务和数据，比如集群日志处理，大数据统计&lt;/li&gt;
&lt;li&gt;将消息广播给其他接收者&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;好处&#34;&gt;好处&lt;/h2&gt;
&lt;p&gt;流量削峰和流量控制、异步处理、解耦、广播、最终一致性&lt;/p&gt;
&lt;h2 id=&#34;缺点&#34;&gt;缺点&lt;/h2&gt;
&lt;p&gt;可用性降低、复杂度提高、一致性问题、消息延迟&lt;/p&gt;
&lt;h1 id=&#34;常见消息队列&#34;&gt;常见消息队列&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特性&lt;/th&gt;
&lt;th&gt;ActiveMQ&lt;/th&gt;
&lt;th&gt;RabbitMQ&lt;/th&gt;
&lt;th&gt;RocketMQ&lt;/th&gt;
&lt;th&gt;Kafaka&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;单机吞吐量&lt;/td&gt;
&lt;td&gt;万级，吞吐量比RocketMQ和Kafka要低了一个数量级&lt;/td&gt;
&lt;td&gt;万级，吞吐量比RocketMQ和Kafka要低了一个数量级&lt;/td&gt;
&lt;td&gt;10万级，RocketMQ也是可以支撑高吞吐的一种MQ&lt;/td&gt;
&lt;td&gt;10万级别，这是kafka最大的优点，就是吞吐量高。一般配合大数据类的系统来进行实时数据计算、日志采集等场景&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;topic数量对吞吐量的影响&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;使用队列模型，通过Exchange模块实现发布-订阅模型，Exchange位于生产者和队列之间，由Exchange决定将详细投递到哪个队列。&lt;/td&gt;
&lt;td&gt;topic可以达到几百，几千个的级别，吞吐量会有较小幅度的下降这是RocketMQ的一大优势，在同等机器下，可以支撑大量的topic&lt;/td&gt;
&lt;td&gt;topic从几十个到几百个的时候，吞吐量会大幅度下降。所以在同等机器下，kafka尽量保证topic数量不要过多。如果要支撑大规模topic，需要增加更多的机器资源&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;可用性&lt;/td&gt;
&lt;td&gt;高，基于主从架构实现高可用性&lt;/td&gt;
&lt;td&gt;高，基于主从架构实现高可用性&lt;/td&gt;
&lt;td&gt;非常高，分布式架构&lt;/td&gt;
&lt;td&gt;非常高，kafka是分布式的，一个数据多个副本，少数机器宕机，不会丢失数据，不会导致不可用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;消息可靠性&lt;/td&gt;
&lt;td&gt;有较低的概率丢失数据&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;经过参数优化配置，可以做到0丢失&lt;/td&gt;
&lt;td&gt;经过参数优化配置，消息可以做到0丢失&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;时效性&lt;/td&gt;
&lt;td&gt;ms级&lt;/td&gt;
&lt;td&gt;微秒级，这是rabbitmq的一大特点，延迟是最低的&lt;/td&gt;
&lt;td&gt;ms级&lt;/td&gt;
&lt;td&gt;延迟在ms级以内&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;功能支持&lt;/td&gt;
&lt;td&gt;MQ领域的功能极其完备&lt;/td&gt;
&lt;td&gt;基于erlang开发，所以并发能力很强，性能极其好，延时很低&lt;/td&gt;
&lt;td&gt;MQ功能较为完善，还是分布式的，扩展性好&lt;/td&gt;
&lt;td&gt;功能较为简单，主要支持简单的MQ功能，在大数据领域的实时计算以及日志采集被大规模使用，是事实上的标准&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;优劣势总结&lt;/td&gt;
&lt;td&gt;非常成熟，功能强大，在业内大量的公司以及项目中都有应用。偶尔会有较低概率丢失消息，而且现在社区以及国内应用都越来越少，官方社区现在对ActiveMQ 5.x维护越来越少，几个月才发布一个版本而且确实主要是基于解耦和异步来用的，较少在大规模吞吐的场景中使用&lt;/td&gt;
&lt;td&gt;erlang语言开发，性能极其好，延时很低；吞吐量到万级；拥有灵活的路由配置；MQ功能比较完备而且开源提供的管理界面非常棒，用起来很好用；社区相对比较活跃；RabbitMQ确实吞吐量与其他几个相比会低一些，这是因为他做的实现机制比较重；对消息的堆积支持不是很好，当有大量消息积压时，会导致RabbitMQ性能急剧下降；erlang开发，比较小众，很难读源码，很难定制和掌控。&lt;/td&gt;
&lt;td&gt;接口简单易用，日处理消息上百亿之多，可以做到大规模吞吐，性能也非常好，分布式扩展也很方便，社区维护还可以，可靠性和可用性都是ok的，还可以支撑大规模的topic数量，支持复杂MQ业务场景。java实现，源码易读；中文社区活跃度，文档相对来说简单，接口这块不是按照标准JMS规范走的有些系统要迁移需要修改大量代码。&lt;/td&gt;
&lt;td&gt;kafka的特点其实很明显，就是仅仅提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，而且分布式可以任意扩展。同时kafka最好是支撑较少的topic数量即可，保证其超高吞吐量。而且kafka唯一的一点劣势是有可能消息重复消费，那么对数据准确性会造成极其轻微的影响，在大数据领域中以及日志采集中，这点轻微影响可以忽略这个特性天然适合大数据实时计算以及日志收集。异步批量操作性能极佳，但是同步收发信息因为要攒一批消息才进行处理会导致响应延时比较高。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;rabbitmq&#34;&gt;RabbitMQ&lt;/h2&gt;
&lt;p&gt;模型：生产者 -》exchange交换器 -》队列 -》消费者&lt;/p&gt;
&lt;p&gt;生产者通过指定一个RoutingKey来选择对应的交换器，一个交换器可以对接多个队列，队列通过BindingKey绑定对应的交换器。&lt;/p&gt;
&lt;p&gt;生产者只能把消息发送给交换器，发送时指定RoutingKey，当消息的RoutingKey与某个队列的BindingKey匹配时，消息从交换器路由到队列，队列才是真正存储消息的地方。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;交换器的4种类型&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fanout：扇形发出，把所有发送到该交换器的消息路由到所有与其绑定的队列中，此时RoutingKey不起作用；&lt;/li&gt;
&lt;li&gt;direct：把消息路由到BindingKey和RoutingKey完全匹配的队列中；&lt;/li&gt;
&lt;li&gt;headers：不依赖路由键匹配规则路由消息。是根据发送消息内容中的headers属性进行匹配。性能差，基本用不到；&lt;/li&gt;
&lt;li&gt;topic：虽然也是BindingKey和RoutingKey进行匹配才能转发到对应的队列，但是支持模糊匹配；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RabbitMQ有个默认的交换器，名字是空串，类型为direct，所有队列以自己的名字为BindingKey绑定到该默认的交换器上，这样生产者如果要发送消息到默认的交换器上时，指定RoutingKey为对应队列的名字即可，看起来就好像是直接发给某个队列一样了。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息传输&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;消息基于信道channel传输，信道是建立在真实的TCP连接内的虚拟连接，且每条TCP连接上的信道数量没有限制。push模式下，若一个队列有多个消费者，RabbitMQ默认将以轮询的方式发送给消费者，还有另一种模式是根据消费者的消费能力来做分发，空闲的消费者将处理更多的消息。&lt;/p&gt;
&lt;p&gt;默认情况下，无法被路由的消息会被直接丢弃，如果设置了&lt;code&gt;mandatory=true&lt;/code&gt;并配合ReturnListener，可以实现消息回发给备用交换器。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息去重&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般是保证消费者消费时幂等，比如：在消息体加入一个业务id来实现&lt;/li&gt;
&lt;li&gt;消息由生产者产生时，MQ内部会对每条消息生产一个inner-msg-id，作为去重的依据，避免重复消息进入队列&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;RabbitMQ事务&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;生产者在发送数据之前，开启RabbitMQ事务，然后发送消息，如果消息没有被RabbitMQ接收到，生产者就会收到异常报错，此时会回滚消息或者重试；&lt;/p&gt;
&lt;p&gt;事务机制是同步的，因此吞吐量不高，太耗性能，一般使用生产者确认模式保证消息不丢。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;生产者确认模式&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生产者确认模式只确保消息正确到达交换器，对于从交换器路由到队列失败的消息，则会被丢弃掉，导致消息丢失，so 对于不可路由的消息，则有Return消息机制（通过在交换器设置回调函数处理，监听路由不可达消息）和备份交换器（路由不可达的消息都发往这个交换器）来解决；&lt;/li&gt;
&lt;li&gt;将信道设置成confirm模式，此时需要发送方确认，所有在信道上发布的消息都会被指定一个唯一的ID，一旦消息被投递到目标队列、或者消息被写入磁盘后，信道会发送一个ack给生产者；&lt;/li&gt;
&lt;li&gt;如果RabbitMQ发生内部错误而导致消息丢失，会发生一条 nack（not ack）消息给生产者表示未确认；&lt;/li&gt;
&lt;li&gt;发送方确认模式是异步的，生产者在等待确认的同时，可以继续发送消息，当生产者接收到确认消息后，生产者的回调方法就会触发来处理确认消息；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;消费者确认模式&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;消费者接收的每一条消息后都必须进行确认，消费者只有确认了消息，RabbitMQ才会安全地把消息从队列中删除；&lt;/li&gt;
&lt;li&gt;RabbitMQ仅通过消费者的连接中断来确认是否需要重新发送消息，只要连接不中断，RabbitMQ会给消费者足够长的时间来处理消息，保证数据的最终一致性；&lt;/li&gt;
&lt;li&gt;如果消费者接收到消息后没法发送确认消息，连接也未断开，RabbitMQ会认为该消费者繁忙，之后不会再给该消费者发放更多的消息；&lt;/li&gt;
&lt;li&gt;不设置自动ack，消费者在处理完消息之后收到发送ack给RabbitMQ；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;RabbitMQ持久化机制&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;RabbitMQ持久化消息后，如果RabbitMQ挂了，恢复只会会自动读取之前存储的数据，持久化设置有两个步骤，必须同时设置才能保证消息不丢，持久化机制一般配合生产者确认模式，只有消息被持久化到磁盘了，才会给生产者发送ack。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;创建队列时，设置持久化，确保RabbitMQ能持久化队列的元数据，但它并不会持久化消息的数据；&lt;/li&gt;
&lt;li&gt;生产者发送消息时设置 &lt;code&gt;deliberyMode = 2&lt;/code&gt; ，此时RabbitMQ才会将消息数据持久化到磁盘上；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;消费者一旦从队列中消费了一条消息并回复ack，RabbitMQ就会从持久化日志中移除这条消息，so 在消费消息前，如果RabbitMQ重启，服务器会自动重建交换器和队列，加载持久化日志中的消息到对应的队列或交换器上，保证消息不会丢失。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;高可用&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;都是基于主从部署，有普通集群模式和镜像集群模式，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;普通集群模式：多台机器，每台部署一个RabbitMQ实例，我们创建的队列，&lt;strong&gt;只会放在一个实例上，但每个实例都会同步队列里的元数据&lt;/strong&gt;（元数据是队列的一些配置信息，可以通过其找到队列所在的实例），消费的时候，如果&lt;strong&gt;连接到了另一个实例，那么该实例会从队列所在实例上拉去数据过来消费&lt;/strong&gt;，实现多个节点服务某个队列的读写操作；&lt;/li&gt;
&lt;li&gt;镜像集群模式：我们所创建的队列，&lt;strong&gt;无论元数据还是队列里的消息都会存在多个实例上&lt;/strong&gt;，即每个RabbitMQ节点都有这个队列的一个完整镜像，包含队列里的全部数据。&lt;strong&gt;队列每次收到消息时，都会自动把消息同步到多个实例的队列上，每个节点都有这个队列的完整数据&lt;/strong&gt;，所以任意一台机器宕机了，还可以从别的机器进行消费，但这种方式对带宽压力比较大；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;kafka&#34;&gt;Kafka&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Topic：主题，一个主题可以分为一个或多个分区；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Broker：一台Kafka就是一个Broker，一个集群由多个Broker组成，一个Broker可以容纳多个Topic；Broker负责接收和处理生产者发送的消息，&lt;strong&gt;Broker内可以将每个主题topic配置成M个分区&lt;/strong&gt;（类似mongo的分片），每个分区是一组有序的消息日志，每条消息的位移从0开始，依次递增；&lt;/p&gt;
&lt;p&gt;Broker持久化时，使用消息日志来保存数据，日志是追加写入的物理文件，避免的随机IO，提升吞吐量；一个Topic中的一个分区大文件会被分成多个小的文件端，即一个日志会被细分成多个日志段，消息被追加写到当前最新的日志段中，写满一个日志段后，Broker会自动切分出一个新的日志段，并将老的日志段封存，后台有定时任务定期检查老的日志段是否能被删除，回收磁盘空间；&lt;/p&gt;
&lt;p&gt;每个日志段的默认大小是1G，当文件大于1G时，会滚动一个新的日志段，并且以上一个日志段最后一条消息的位移命令；&lt;/p&gt;
&lt;p&gt;通过索引信息将元数据全部映射到内存；通过索引信息就能快速定位消息和确定response的最大大小；通过索引文件稀疏存储，大幅降低索引文件元数据占用空间大小；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Partition：分区，&lt;strong&gt;一个Topic可以分布到多个Broker上&lt;/strong&gt;，每个分区是一个有序队列，生产者生产的&lt;strong&gt;每条消息只会被发送到一个分区&lt;/strong&gt;中，分区中的每条消息都会被分配一个有序的id（offset）；&lt;/p&gt;
&lt;p&gt;Kafka只保证一个分区中的每条消息按顺序消费，不保证一个Topic中多个分区间的消费顺序；&lt;/p&gt;
&lt;p&gt;第一个分区（编号为0）的第一个副本放置的位置是随机从Broker列表中选择的，其他分区的第一个副本放置位置相对于第0个分区依次往后移，剩余的副本相当于第一个副本放置位置由&lt;code&gt;nextReplicacShift&lt;/code&gt;决定，该数也是随机产生的；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;每个分区可以配置多个副本，每个分区的副本只能有一个对外提供服务，其他的副本仅作备份&lt;/strong&gt;，即其不允许读写分离，原因是kafka主从同步比较耗时，会产生延时，导致数据一致性问题；&lt;/p&gt;
&lt;p&gt;分区仅支持增加，不允许减少，不然分区减少时，原有的数据不好分配，且破坏了分区有序，实现起来很复杂；&lt;/p&gt;
&lt;p&gt;分区的好处是实现负载均衡，对于消费者来说，提高并发度，提升吞吐量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Consumer Group：消费组，是Kafka实现广播和单播的手段，由多个消费者实例共同组成一个消费组来消费某一组主题，这组主题中的每个分区都只会被组内一个消费者消费，组内的其他消费者都不能消费；通过同一消费组内多消费者同时消费，加速消费吞吐量；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Offset：Kafka存在两种位移字段，一个是消息位移，表示分区中每条消息的位置，单调递增；另一个是消费者位移，表示每个消费者在消费过程中会记录它当前消费到分区的哪个位置上，代表消费者的消费进度；&lt;/p&gt;
&lt;p&gt;Kafka的存储文件通过 &lt;code&gt;[offset].kafka&lt;/code&gt; 来命名，方便根据offset进行查找；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Rebalance：消费组有重平衡功能，当组内某个消费者挂掉后，其他消费者会自动重新分配订阅主题的分区进行消费；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kafka参数topic级别的参数的优先级会大于broker级别的参数；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kafka是基于日志结构的消息引擎，消费者在消费消息时，只是从磁盘文件上读取数据而已，消费者不会删除消息，只是修改对应的位移，而RabbitMQ和ActivityMQ在消息消费成功后，是直接删除消息的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ZooKeeper在Kafka中的作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Broker注册，每个Broker启动时，都会在&lt;code&gt;/brokers/ids&lt;/code&gt;创建自己的节点，记录自己的IP地址和端口；&lt;/li&gt;
&lt;li&gt;Topic注册，由于&lt;strong&gt;同一个Topic的消息会被分成多个分区并将其分布在多个Broker上&lt;/strong&gt;，分区与Broker的映射由ZooKeeper维护；&lt;/li&gt;
&lt;li&gt;提供负载均衡能力，ZooKeeper会尽力将分区分布到不同的Broker节点上，生产者产生消息后也会尽量投递到不同Broker的分区里，当消费者消费时，ZooKeeper会根据当前的分区数量和消费者数量实现动态负载均衡。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kafka判断节点是否存活的条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点必须可以维护和ZooKeeper的连接，ZooKeeper通过心跳机制检查每个节点的连接；&lt;/li&gt;
&lt;li&gt;如果节点是Follower，它必须能及时同步Leader的写操作，保持在一定的延时内；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;总结起来Kafka实现高吞吐率的原因：顺序读写、零拷贝、文件分段、批量发送、数据压缩、分区、高效的日志分段及索引设计、重复利用page cache、reactor网络模型、支持多磁盘驱动、mmap操作内存很快，减少用户空间到内核空间的拷贝等；&lt;/p&gt;
&lt;p&gt;缺点：由于是批量发送，数据并非真正实时、不支持MQTT协议、仅支持分区内消息有序，无法实现全局消息有序、需要依赖Zookeeper进行元数据管理；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;分区机制&#34;&gt;分区机制&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;生产者发送消息给到某一主题的Broker，最后在保存到该主题下的某一个分区，而不会在多个分区中被保存多份。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;分区的作用是提供负载均衡的能力，不同的分区能被放置在不同的节点Broker上&lt;/strong&gt;，对数据的读写操作也是以分区为粒度而进行的，使得每个节点的机器都能独立地指向各自分区的读写请求，&lt;strong&gt;以此提高吞吐量和伸缩性&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分区也能实现消息的顺序性，比如一个主题设置一个分区，或者生产者发送消息时指定key或者分区，消息的顺序性只保证在一个分区内有序，通过位移实现；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分区策略，要合理使用分区策略，避免消息数据产生倾斜，对某些分区产生性能瓶颈，导致下游消费能力下降&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;轮询策略，顺序分配：比如一个主题下有3个分区，生产者发送消息时会被依次分配到每个分区，默认的分区策略，具有非常高的负载均衡能力，最大限度保证消息被平均分配到所有分区中；&lt;/li&gt;
&lt;li&gt;随机策略：消息会被随机分配到某一分区上；&lt;/li&gt;
&lt;li&gt;按消息的key保序策略：根据不同的key分配到不同的分区上，有点像RabbitMQ的RoutingKey；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;消息压缩&#34;&gt;消息压缩&lt;/h3&gt;
&lt;p&gt;Kafka消息分为两层：消息集合 和 消息，一个消息集合包含若干条日志项，日志项才是真正封装消息的地方，Kafka不会直接操作具体的一条条消息，而是在消息集合这个层面进行写入操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;压缩是时间换空间，目的是用较小的CPU资源换更少的磁盘占用和带宽、网络IO传输；&lt;/li&gt;
&lt;li&gt;压缩的地方有两处：生产者端和Broker端，一般来说，生产者在发送消息时会指定压缩算法，比如GZip；大部分情况下，Broker只是原样保存消息，但会在两种情况下对消息重新压缩，比如Broker端和生产者端使用不同的压缩算法，此时Broker接收到消息后会先解压在重新进行压缩；或者Broker为了兼容 V1 或 V2 两个版本的消息，此时也会发生消息格式转换，这种场景下对性能的影响很大，还会用不上 零拷贝 特性；&lt;/li&gt;
&lt;li&gt;解压的地方有两处：消费者端和Broker端，消费组端会根据消息集合中指定的压缩算法进行解压；Broker解压则是因为需要对消息进行校验，但这种场景要区别于上面两种；&lt;/li&gt;
&lt;li&gt;压缩算法中，吞吐量方面：LZ4 &amp;gt; Snappy &amp;gt; zstd、GZip，压缩比方面：zstd &amp;gt; LZ4 &amp;gt; GZip &amp;gt; Snappy，Snappy比较耗CPU资源，其他差别不大；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;消息可靠性&#34;&gt;消息可靠性&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Kafka只对 已提交 的消息做 有限度 的持久化保证。&lt;/p&gt;
&lt;p&gt;已提交：Broker成功地接收到一条消息并写入到日志文件后，告诉生产者这条消息已成功提交，我们可以指定是一个Broker成功保存算已提交或者多个Broker都保存成功才算成功。&lt;/p&gt;
&lt;p&gt;有限度的持久化保证：只要不是所有的Broker都挂掉，就能保证消息永远不会丢。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生产者发送消息给Broker时是异步的，Kafka sdk会在生产者那攒一批消息在一起发送，如果此时出现问题就会丢消息，所以一般要配合回调函数，等Broker通知生产者消息发送成功；或者使用同步发送的方法发送消息；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每一个消费者在消费消息时，在Broker上有一个位移标识，表示当前消费到 topic分区的哪个位置，所以消费者在消费时要保证先消费消息，再更新位移标识，避免更新标识后消息消费被中断，导致消息丢失，so一般最好手动提交位移更新，不开启自动；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;连接管理&#34;&gt;连接管理&lt;/h3&gt;
&lt;p&gt;生产者：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;建立TCP连接：Kafka Java SDK中，生产者会在启动时，读取&lt;code&gt;bootstrap.servers&lt;/code&gt;得到Broker的地址，然后与这些地址上的Broker建立TCP连接，通常&lt;code&gt;bootstrap.servers&lt;/code&gt;不需要配置太多的Broker地址，3~4个足以，一旦生产者连接到集群中其中一台Broker，就能拿到整个集群的Broker信息，此时再重新建立TCP连接，此外，生产者也会每5分钟获取集群的metadata来更新Broker信息，创建新的TCP连接。&lt;/li&gt;
&lt;li&gt;关闭TCP连接：用户主动关闭；Kafka默认设定，在9分钟内如果没有任何请求经过该TCP连接，就会主动关闭；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;消费者：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;建立TCP连接：消费者poll拿消息的时候，消费者首次启动后调用poll方法，会与任一Broker建立连接，获得它的协调者对应的Broker，再与该Broker建立连接。此时消费者就知道之后消息获取要通过哪个Broker了，当消费的连接断开后，下次会直接向该Broker发起连接。&lt;/p&gt;
&lt;p&gt;总共会建立3种连接：1. 确定协调者和获取集群元数据；2. 连接协调者，使其可以进行管理操作；3. 拉取消息进行消费，之后基本上就只有2和3两种TCP连接了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭TCP连接：用户主动关闭；Kafka默认设定，在9分钟内如果没有任何请求经过该TCP连接，就会主动关闭；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;无论是生产者的PRODUCE请求还是消费者FETCH请求发送到Broker，Broker都会采用Reactor模型处理请求。默认情况下，&lt;code&gt;num.network.threads = 3&lt;/code&gt;，即每台Broker启动时会创建3个网络线程处理客户端的请求，当网络线程拿到请求后，将请求放到一个共享请求队列中，接下来，Broker有个IO线程池，专门从共享请求队列中取出请求，执行真正的处理，默认的IO线程数是&lt;code&gt;num.io.threads = 8&lt;/code&gt;，IO线程处理完成后，将生成的响应发送到网络线程池的响应队列中，由对应的网络线程将Response返回给客户端，即网络线程只处理请求的接收和响应，真正处理逻辑在IO线程。&lt;/p&gt;
&lt;p&gt;所有网络线程共享同一个请求队列，但每个网络线程拥有自己的请求响应队列。&lt;/p&gt;
&lt;p&gt;Purgatory组件用于缓存延时请求，比如设置了&lt;code&gt;acks=all&lt;/code&gt;的生产者请求，此时请求必须等待ISR中所有副本都接收到了消息后才能返回，此时处理该请求的IO线程就必须等待其他Broker的写入结果，因为要等待结果，请求不能立即被处理，就会暂存在Purgatory中，直到获取到结果，才将响应放到对应的网络线程的响应队列中。&lt;/p&gt;
&lt;p&gt;生产者的PRODUCE请求和消费者的FETCH请求，都属于数据类请求，LeaderAndIsr、StopReplica请求称为控制类请求，控制类请求可以直接令数据类请求失效，优先级较高，Kafka内部使用两套网络线程池和IO线程池处理这两类请求。之所以要这样做，是为了解决当有消息积压在Broker中，但此时发生副本切换或删除主题时，导致请求不能被立马感知，只能等到超时的问题。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Kafka%e5%a4%84%e7%90%86%e8%af%b7%e6%b1%82.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Kafka%e5%a4%84%e7%90%86%e8%af%b7%e6%b1%82.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;实现-精确一次-qos&#34;&gt;实现 精确一次 QoS&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;幂等性：生产者在发送消息时，会多带一些信息给Broker，使得Broker可以通过这些信息对重复性消息去重；&lt;/p&gt;
&lt;p&gt;生产者的幂等性只能保证某一主题下的一个分区、单会话上不会出现重复性消息，无法实现多个分区、跨会话幂等，多分区或跨会话幂等只能依赖事务；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;事务性：Kafka支持提交读隔离级别的事务，保证多条消息原子性写入目标分区，且保证消费者只能看到事务提交成功的消息；多条消息在一个事务内被提交到Broker，要么全部成功，要么全部失败，就算写入失败，Broker也会把它们写入底层的日志中，消费者可以选择读或者不读这些消息，读取是隔离级别的未提交读，不读取则是提交读；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;消费组&#34;&gt;消费组&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;是一种可扩展且具有容错性的消费机制，一个消费组内有多个消费者或实例，共享一个公共的Group ID，组内的所有消费者协调在一起消费某个或多个主题下所有分区，每个分区可以被多个消费组消费，但只能由同一个消费组内的一个消费者来消费；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果所有消费者都属于同一个消费组，那就是点对点模型，如果所有消费者被分散在不同的消费组，则是发布/订阅模式；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般情况下，消费者实例的数量等于该消费组订阅主题的分区总数，如果大于分区总数，多余的实例并不会被分配任何分区，会永远空闲，比较浪费；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Broker会保存每个消费组消费分区的位移，老版本中，每个消费组的位移是保存在ZooKeeper中，但是由于位移的更新比较频繁，而ZooKeeper是个CP要保存数据一致性，并不适合频繁更新，会有性能问题，所以新版本分区位移是保存在Broker的主题中；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;重平衡rebalance&#34;&gt;重平衡Rebalance&lt;/h3&gt;
&lt;p&gt;是一种协议，会对一个主题下的所有分区平均分给一个组里的所有消费者，由Broker通过一定的分配规则进行协调，&lt;strong&gt;为消费组内的每个消费者分配该主题下要消费的分区&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;重平衡触发条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;组内消费者数量变更，如组成员的加入、离开或者组成员崩溃；&lt;/li&gt;
&lt;li&gt;主题的数量变更；&lt;/li&gt;
&lt;li&gt;主题内分区数量变更；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;重平衡时，所有消费者会停止消费，类似STW，直到重平衡结束，因为重平衡后，消费者可能需要重新与Broker建立TCP连接，会比较耗时间和资源；&lt;/p&gt;
&lt;p&gt;重平衡由协调者Coordinator管理，它存在于Broker中，消费者提交位移时，是向协调者所在的Broker提交位移，然后由协调者负责执行消费组的注册、成员管理等元数据的操作；&lt;/p&gt;
&lt;p&gt;消费组通过位移主题，确定协调者在哪个Broker上，计算方法：通过对GroupId做哈希计算，对位移主题分区数取模，得到分区号，在找到该分区副本中的Leader，该Broker就是协调者了。&lt;/p&gt;
&lt;p&gt;每个消费者默认情况下每10s会发送心跳给协调者，表明存活，如果协调者收不到，就会认定该消费组已挂，触发重平衡；另外，默认情况下下，如果消费者在5分钟内无法拉取消息并处理完，也会被认定已挂，触发重平衡；&lt;/p&gt;
&lt;p&gt;一般情况下，心跳发送时间间隔设置为&lt;code&gt;heartbeat.interval.ms = 2s&lt;/code&gt;，会话超时时间为&lt;code&gt;session.timeout.ms = 6s&lt;/code&gt;，即需要3次心跳都没被接收到，就算消费者挂掉；&lt;code&gt;max.poll.interval.ms&lt;/code&gt; 表明消费者处理一批消息的最迟时间；&lt;/p&gt;
&lt;p&gt;重平衡过程中，通过消费者的心跳线程通知其他消费者，Broker通过在心跳中设置&lt;code&gt;REBALANCE_IN_PROCESS&lt;/code&gt;，响应给消费者，通知消费者要开始重平衡了。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Kakfa%e9%87%8d%e5%b9%b3%e8%a1%a1%e7%8a%b6%e6%80%81%e6%b5%81%e8%bd%ac.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Kakfa%e9%87%8d%e5%b9%b3%e8%a1%a1%e7%8a%b6%e6%80%81%e6%b5%81%e8%bd%ac.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;对于消费者来说，重平衡分为两个步骤：1. 加入组，JoinGroup请求； 2. 等待领导者消费者分配方案，SyncGroup请求；&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;当组成员加入组时，会向协调者发送JoinGroup请求，在该请求中，每个成员都将自己订阅的主题上报，协调者收集所有成员的订阅信息，收集完成后，选出领导者消费者，并把组成员信息以及订阅信息发送给Leader；&lt;/p&gt;
&lt;p&gt;一般情况下，第一个发送JoinGroup请求的成员自动成为领导者，之后由领导者制定分区分配方案；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;领导者向协调者发送SyncGroup请求，领导者将 1 中制定的分配方案发送给协调者，其他成员也会向协调者发送SyncGroup请求，只是请求中没有实际内容，这一步主要是让协调者接收分配方案后，统一以SyncGroup响应的方式分发给所有成员们，使得组内所有成员都知道自己该消费哪些分区。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;位移主题&#34;&gt;位移主题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;为了解决老版本&lt;strong&gt;消费组消费位移管理依赖&lt;/strong&gt;ZooKeeper导致性能不高的问题，新版本的位移管理方案是通过&lt;code&gt;__consumer_offsets&lt;/code&gt;这个主题来实现的，以达到支持高持久性和高频写操作的目的。&lt;/p&gt;
&lt;p&gt;该主题只是Kafka一个普通主题，同样可以对它进行操作，只是消息的格式由Kafka定义，用户无法修改，无法随意向这个主题写消息，属于内部主题，一般不需要去管理它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息体类型分为3种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般位移消息：消息体格式是Key-Value形式的，key为&lt;code&gt;&amp;lt;GroupId，主题名，分区号&amp;gt;&lt;/code&gt;，消息体除了保存位移值，还保存时间戳、用户自定义数据等元数据供Kafka做其他操作&lt;/li&gt;
&lt;li&gt;用于保存Consumer Group信息的消息&lt;/li&gt;
&lt;li&gt;用于删除Group过期位移或者删除Group的消息，一旦某个消费组下的所有消费者都停止，且它们的位移数据都已经被删除时，就会向位移主题写入这条消息，表明要删除这个消费组的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;创建时机：默认情况下，第一个消费者启动时，会自动创建位移主题，默认配置是50个分区，3个副本，也可以手动通过API创建&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;位移提交分为自动提交和手动提交，类似ACK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Broker会在后台启动一个线程，使用Compact策略来定时删除位移主题中的过期消息，避免磁盘被占满，判断的依据是消息的时间&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;消费组消费位移&#34;&gt;消费组消费位移&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;消费位移记录的是下一条消息的位移，而不是当前最新消费的位移，消费者会为分配给他的每个分区提交自己的位移数据，通过消费位移来表明消费者的消费速度和记录，当消费者故障重启后，还能继续消费，避免重复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消费者处理消息时是一批一批处理的，处理完成后更新这一批消息的位移，如果这一批消息量太大，也可以选择处理一定数量后就更新位移，避免一次失败后要重新全部消费；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认开启自动提交，设置自动提交位移时，是每5s自动提交一次，可能出现重复消费；&lt;/p&gt;
&lt;p&gt;同步手动提交时，虽然比较精准，但是提交时是同步的，会阻塞等待Broker的返回，此时消费者无法继续消费；&lt;/p&gt;
&lt;p&gt;异步手动提交，需要注册回调函数，处理Broker返回的结果，但也因为异步，无法进行重试；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;副本&#34;&gt;副本&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Kafka每个主题划分成若干分区，&lt;strong&gt;每个分区可以有多个副本，副本仅提供数据冗余，提高消息存储的安全性，提高容灾能力，同一个分区的多个副本只允许有一个进行读写&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;副本本质上是一个只能追加写消息的提交日志，同一个分区下的所有副本保存相同的消息序列，副本分散在不同的Broker上，从而分摊部分Broker宕机带来的数据不可用问题，所以，&lt;strong&gt;每台Broker都可能保存有各个主题下不同分区的不同副本&lt;/strong&gt;，单个Broker可以保存成百上千个副本。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Kafka通过基于领导者的副本机制，保证所有副本的数据一致性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每个分区在创建时要选举一个副本，作为Leader，其他副本作为Follower；&lt;/li&gt;
&lt;li&gt;Follower副本不对外提供服务，即不响应生产者和消费者的任何读写请求，所有读写请求都由Leader副本处理，即Leader副本所在的Broker，Follower副本唯一的任务是从Leader副本中异步拉取消息，写入到自己的提交日志中，实现日志同步；&lt;/li&gt;
&lt;li&gt;如果Leader副本挂掉，即对应的Broker宕机，Kafka依赖ZooKeeper提供的Watch监控功能实时感知，开启新Leader的选举，从Follower副本中选出一个Leader，老Leader回归后，降级为Follower副本加入；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这种副本机制的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保生产者写入的消息，消费者能立即读到，因为如果是读Follower副本，可能存在延迟；&lt;/li&gt;
&lt;li&gt;确保消费者读取时，不会因为负载均衡之类的原因，导致一会能读到消息一会读不到；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;Leader副本和Follower副本组成的集合叫ISR&lt;/strong&gt;，ISR由分区Leader维护，Kafka确保Follower副本的进度跟Leader副本的差距，不看两者之间相差多少消息，而是看Follower副本在复制消息时可被允许的最大延迟时间：&lt;code&gt;replica.lag.time.max.ms&lt;/code&gt;，只要超过这个数，就说明Follower同步落后了，如果落后太多，这个Follower副本就会被踢出ISR，如果后面进度追上了，才会加回ISR；ISR中至少有一个副本，且该副本为Leader；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;被踢出ISR的分区副本组成的集合叫OSR&lt;/strong&gt;，新加入的Follower也会存入OSR列表，ISR列表 + OSR列表 = AR（assigned ）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当ISR为空时，说明Leader副本也挂掉了，此时需要选举&lt;/strong&gt;，Kafka把所有不在ISR中的存活副本称为非同步副本，通过&lt;code&gt;unclean.leader.election.enable&lt;/code&gt;控制新Leader是否要从这些非同步副本中选举，如果选举，由于它们进度落后前Leader，是会造成丢数据的问题，这里就涉及到C和A的选择了，一般是不开启它，&lt;strong&gt;C比较重要&lt;/strong&gt;，所以一般选择同步进度最高的Follower作为Leader；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;副本中的&lt;strong&gt;高水位&lt;/strong&gt;（Hight Water）：表示消息的位置，即位移，取值来自分区中对应的ISR列表中最小的LEO作为高水位，消费者最多只能消费到高水位所在位置的上一条信息。&lt;/p&gt;
&lt;p&gt;当消息位移小于高水位，属于已提交的消息，消费者只能消费已提交的消息，当消息位移大于等于高水位，属于未提交的消息，即处于已提交的消息和未提交的消息的边界就是高水位。&lt;strong&gt;高水位主要是定义消息的可见性，用来标识分区下哪些消息可以被消费&lt;/strong&gt;，帮助Kafka完成副本同步。&lt;strong&gt;提交指的是消息成功写入到Leader副本。&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;副本中的&lt;strong&gt;LEO&lt;/strong&gt;（Log End Offset）：&lt;strong&gt;表示副本写入的日志文件中下一条消息的位移值&lt;/strong&gt;，同一副本下，其高水位的值不会大于LEO的值。每一个副本都有对应的高水位和LEO的值，**分区的高水位就是其Leader副本的高水位，**Leader副本所在的Broker，还保存了其他Follower副本的LEO值。更新时，Kafka会更新所有副本的高水位和LEO值，同时也会更新Leader副本上所有其他Follower副本的LEO值，但不更新其高水位，目的是帮助Leader副本确定其高水位。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;LSO（Last Stable Offset）：对未完成的事务而言，LSO的值等于事务中第一条消息的位置，对于已完成的事务而言，它的值与高水位相同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：消息发送给分区的Leader后，会同步给Follower，消费者消费时，只能根据ISR列表，查看哪些消息在高水位上，才能被读取，&lt;strong&gt;高水位取决于ISR列表里偏移量最小的分区&lt;/strong&gt;，类似木桶原理，从而保证一致性，否则，如果消息没有同步到多个Follower，Leader就宕机了，如果有落后的Follower被选举为Leader，又被消费者消费了，就破坏一致性了；引入高水位机制，如果Broker间消息的复制慢了，那么消息到达消费者的时间就会随之变长。&lt;/p&gt;
&lt;h4 id=&#34;副本同步机制&#34;&gt;副本同步机制&lt;/h4&gt;
&lt;p&gt;流程总结：1. 生产者发送消息；2. Zookeeper找到分区Leader；3. 推送消息；4. 通过ISR列表通知给Follower；5. Follower从Leader拉取消息，发送ack；6. Leader收到所有副本的ack，更新Offset，并向生产者发送ack，表示消息写入成功。&lt;/p&gt;
&lt;p&gt;具体流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;生产者发送消息给Broker时， Leader副本，处理生产者请求流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;写入消息到本地磁盘&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新分区高水位值&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;获取Leader副本所在的Broker端保存的所有远程Follower副本LEO值，LEO-1、LEO-2&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取Leader副本高水位值：currentHW&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新当前高水位值：currentHW = max{currentHW， min（LEO-1、LEO-2 &amp;hellip;）}&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leader副本，处理Follower副本拉取消息的请求，流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;读取磁盘或页缓存中的消息数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用Follower副本发送请求中的位移值更新远程Follower副本LEO值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新分区高水位，流程同上&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Follower副本，从Leader副本拉取消息后的流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;写入消息到本地磁盘&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新LEO值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新高水位值&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;获取Leader发送的高水位值：currentHW&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;获取步骤2中更新过的LEO值：currentLEO&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新高水位为：min（currentHW，currentLEO）&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Kafka%e5%88%86%e5%8c%ba%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6%e6%b5%81%e7%a8%8b.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Kafka%e5%88%86%e5%8c%ba%e5%90%8c%e6%ad%a5%e6%9c%ba%e5%88%b6%e6%b5%81%e7%a8%8b.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;可以看到，Follower副本拉取了两次，一次是更新LEO的值，一次是更新高水位，Leader副本高水位的更新和Follower副本高水位的更新在时间上是错配的。在&lt;code&gt;min.insync.replicas=1&lt;/code&gt;的情况下，当Follower副本更新高水位时，如果此时先是Follower副本宕机，重启后会根据高水位进行日志截断，造成同步进度丢失，此时Leader也宕机，会进行Leader选举，之前的Follower可能会为Leader，就会出现数据不一致的情况，因此引入Leader Epoch机制解决。&lt;/p&gt;
&lt;p&gt;Leader Epoch机制，实际上就是Leader版本号+起始位移值，Leader版本号在Leader每次重启后都会增加，Leader副本每次将消息写入磁盘后，都会更新起始位移值，并保存在checkpoint文件中。当有Follower宕机或重启时，从请求Leader副本获取Leader Epoch的数据进行保存，避免之后如果Leader宕机后，选出的的新Leader丢失同步进度，避免数据不一致。&lt;/p&gt;
&lt;h3 id=&#34;控制器&#34;&gt;控制器&lt;/h3&gt;
&lt;p&gt;Kafka的控制器依赖ZooKeeperd的临时节点机制和Watch机制，实现对整个集群的管理和协调，集群中只能有一个Broker能成为控制器，第一个在ZooKeeper中成功创建controller节点的Broker会被指定为控制器。虽然控制器只有一个，但是依赖ZooKeeper的Watch机制，当运行中的控制器突然宕机或终止时，Kafka能快速感知并启动备用控制器进行替换。&lt;/p&gt;
&lt;p&gt;控制器内部也是通过事件驱动 + 状态机的方式，去处理状态，解决多线程并发访问问题。&lt;/p&gt;
&lt;p&gt;控制器的职责：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主题管理 - 创建、删除、增加分区；&lt;/li&gt;
&lt;li&gt;分区重分配；&lt;/li&gt;
&lt;li&gt;Preferred领导者选举，主要是为了避免部分Broker负载过重而提高的一种更换Leader的方案；&lt;/li&gt;
&lt;li&gt;集群成员管理 - 新增Broker、Broker主动关闭、Broker宕机；&lt;/li&gt;
&lt;li&gt;保存了最全的集群元数据，向其他Broker提供数据服务，其他Broker会定期接收控制器发送过来的元数据更新请求，更新内存中的缓存数据。比较重要的元数据：主题信息、分区信息、所有Broker的信息、当前正在进行Preferred领导者选择的分区列表、分区重分配的分区列表；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;kafka中的时间轮&#34;&gt;Kafka中的时间轮&lt;/h3&gt;
&lt;p&gt;通过DelayQueue（优先级队列实现，队列里的每个元素，都是某一个具体时间的list） + 环形数组（数组的每个元素是个list，索引代表时间格）&lt;/p&gt;
&lt;p&gt;DelayQueue会根据环形数组中的每个元素进行排序；&lt;/p&gt;
&lt;p&gt;添加任务时，判断任务执行时间，加入环形数组中，对应的环形数组的元素（list），加入DelayQueue中。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Kafka%e6%97%b6%e9%97%b4%e8%bd%ae%e7%ae%80%e5%8d%95%e5%ae%9e%e7%8e%b0.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Kafka%e6%97%b6%e9%97%b4%e8%bd%ae%e7%ae%80%e5%8d%95%e5%ae%9e%e7%8e%b0.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&#34;消息模型&#34;&gt;消息模型&lt;/h1&gt;
&lt;p&gt;1.点对点：队列、监听器&lt;/p&gt;
&lt;p&gt;2.发布订阅：监听器、监听器、观察者模式&lt;/p&gt;
&lt;h2 id=&#34;一般消息队列架构&#34;&gt;一般消息队列架构&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;主要是设计中间的消息转发，将一次RPC转化成两次RPC；&lt;/li&gt;
&lt;li&gt;选择通信协议；&lt;/li&gt;
&lt;li&gt;消息的可靠性确认；&lt;/li&gt;
&lt;li&gt;消息持久化；&lt;/li&gt;
&lt;li&gt;消息模型；&lt;/li&gt;
&lt;li&gt;事务特性；&lt;/li&gt;
&lt;li&gt;分布式集群特性；&lt;/li&gt;
&lt;li&gt;消息队列一般有两种模式，pull模式（消费方主动向队列拉取数据），比如kafka，push模式（由队列向消费方推送数据）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e6%9e%b6%e6%9e%84.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97%e6%9e%b6%e6%9e%84.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;消息队列架构&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;消息队列架构&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一般来说，一个主题可以分配给多个Broker，每个Broker可以有多个队列；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;多个生产者对于同一个主题的消息，可以发送到不同的队列（轮询发，随机挑一个发，只往某个一个发）；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消费组订阅的是主题，消费主题里的所有队列的消息，消费消息时，可以只是去读队列里的消息，不一定会删掉，但是一般会设置消息可见性，组里的消费者读取队列里的消息时，其他消费者对此消息不可见；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多个消费组在消费同一主题时，消费组之间互不影响，即消息可以同时被多个消费组消费；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消费组内部可以包含多个消费者，同一消费组内，每个队列只能被一个消费者占用，一个消息只会被组内一个消费者消费；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每个消费组内部维护自己的消费位置，记录消费某一队列中消息的位置，消费位置与消费者无关&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;关于消息的序列化和反序列化&#34;&gt;关于消息的序列化和反序列化&lt;/h2&gt;
&lt;p&gt;除了常见的json、XML、protobuf、Kryo、Hession等方案，还能自主设计&lt;/p&gt;
&lt;p&gt;客户端和服务端维护一份字段顺序，在序列化时只存对应对象的值，从而减少序列化对象的长度，比如&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;03   | 08 7a 68 61 6e 67 73 61 6e | 17 | 01
User |    z h a n g s a n         | 23 | true
03表示对象类型，08表示名字的长度，然后字段值以名字、年龄、是否yi&#39;wei
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;关于消息的断句&#34;&gt;关于消息的断句&lt;/h2&gt;
&lt;p&gt;数据传输过程中，收到的分段不一定是发出去的分段，因此需要合理的分段，来让数据语义明确。比如在每个分段前加数据的长度&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;03下雨天 03留客天 02天留 03我不留
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;关于消息的存储&#34;&gt;关于消息的存储&lt;/h2&gt;
&lt;p&gt;消息队列的存储一般比较简单，每个主题包含若干分区，每个分区(队列)都是WAL，写入时尾部追加，不允许修改，读取的时候，根据一个索引序号进行查询，连续顺序往下读。&lt;/p&gt;
&lt;h3 id=&#34;kafka-1&#34;&gt;Kafka&lt;/h3&gt;
&lt;p&gt;以分区为单位，每个分区包含一组消息文件和一组索引文件，消息文件和索引文件一一对应，具有相同的文件名，但文件扩展名不一样，文件名就是这个文件中第一条消息的索引序号；每个索引中保存索引序号（表示这条消息是这个分区中的第几条消息），和 对应的消息在消息文件中的绝对位置。&lt;/p&gt;
&lt;p&gt;以分区为单位，粒度更细，比较灵活，容易进行数据迁移和扩容。&lt;/p&gt;
&lt;p&gt;Kafka为了节省存储空间，采用稀疏索引，每隔几条消息创建一条索引。&lt;/p&gt;
&lt;p&gt;写入消息时，在文件尾部追加写入，一个文件满了再写下一个文件；&lt;/p&gt;
&lt;p&gt;查找消息时，先根据文件名找到所在索引的索引文件，然后二分法遍历索引文件内的索引，找到离目标最近的索引，再去消息文件中找到这条索引对应的位置，顺序遍历消息文件，找到目标消息。&lt;/p&gt;
&lt;h3 id=&#34;rocketmq&#34;&gt;RocketMQ&lt;/h3&gt;
&lt;p&gt;以Broker为单位，每个Broker只包含一组消息文件和索引文件，在该Broker上的所有主题的消息都存放在这一组消息文件中，索引文件则按照主题和队列分别建立，每个队列对应一组索引文件。&lt;/p&gt;
&lt;p&gt;以Broker为单位，粒度较粗，但在写入时文件更少，有更好的批量和顺序写入。&lt;/p&gt;
&lt;p&gt;索引采用定长稠密索引，为每条消息都创建索引，每个索引的长度固定20个字节。&lt;/p&gt;
&lt;p&gt;写入消息时，Broker上所有主题、所有队列的消息都按照自然顺序追加写入同一个消息文件中，一个文件满了再写下一个；查找消息时，直接根据队列的消息序号，计算出索引的全局位置（索引序号 乘 固定长度20），直接读取索引，再根据索引在消息文件中找到对应的消息，查找速度比Kafka快，但耗存储。&lt;/p&gt;
&lt;h2 id=&#34;消息队列服务质量qos&#34;&gt;消息队列服务质量QoS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;at-most-once：最多一次，消息可能丢失，不会重复发送，即消息要么被发送一次，要么不会被发送；
&lt;ul&gt;
&lt;li&gt;生产者完全依赖TCP/IP的传输可靠性，发送一次就结束。kafka中设置&lt;code&gt;acks=0&lt;/code&gt;打开此模式；&lt;/li&gt;
&lt;li&gt;消费者消费时先保存消息，再进行处理。kafka中设置消费者自动提交偏移量并设置较短的提交时间间隔；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;at-least-once：最少一次，消息绝不会丢，但可能重复发送，解决上一个级别消息发送失败的问题；一般使用此等级。
&lt;ul&gt;
&lt;li&gt;生产者发送消息时要做防丢保证，检查发送结果，并在失败或超时时重新发送消息，直到broke确认收到，so可能会重复发送。kafka中设置&lt;code&gt;acks=1或all&lt;/code&gt;并设置&lt;code&gt;retries&amp;gt;0&lt;/code&gt;打开此模式；&lt;/li&gt;
&lt;li&gt;消费者先处理消息，再保存消费进度，处理消息时幂等。kafka中设置消费者自动提交偏移量并设置很长的提交时间间隔，或者直接关闭自动提交偏移量，处理消息后手动调用同步模式的偏移量提交。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;exactly-once：正好一次，每条消息有且只有一次被传输；
&lt;ul&gt;
&lt;li&gt;生产者发送消息要保证防丢， 可能需要借助外部组件实现只发送一次。&lt;/li&gt;
&lt;li&gt;消费者处理消息时要幂等，或者对接收的消息进行去重。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三个级别的可靠性依次增加，但相应的也会增加延迟和带宽占用。&lt;/p&gt;
&lt;h2 id=&#34;案例一---异步消息的处理&#34;&gt;案例一 - 异步消息的处理&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/JD_JMQ%e6%b6%88%e6%81%af%e6%8e%a5%e6%94%b6%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/JD_JMQ%e6%b6%88%e6%81%af%e6%8e%a5%e6%94%b6%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;收到请求后，我们在Handler中不做过多的处理，执行必要的检查后，将请求放到一个内存队列中，也就是图中的RequestsQueue。请求被放入队列后，Handler的方法就结束了。可以看到，在Handler中只是把请求放到了队列中，没有太多的业务逻辑，这个执行过程是非常快的，所以即使是处理海量的请求，也不会过多的占用IO线程。&lt;/li&gt;
&lt;li&gt;由于要保证消息的有序性，整个流程的大部分过程是不能并发的，只能单线程执行。所以，接下来我们使用一个线程WriteThread从请求队列中按照顺序来获取请求，依次进行解析请求等其他的处理逻辑，最后将消息序列化并写入存储。序列化后的消息会被写入到一个内存缓存中，就是图中的JournalCache，等待后续的处理。&lt;/li&gt;
&lt;li&gt;执行到这里，一条一条的消息已经被转换成一个连续的字节流，每一条消息都在这个字节流中有一个全局唯一起止位置，也就是这条消息的Offset。后续的处理就不用关心字节流中的内容了，只要确保这个字节流能快速正确的被保存和复制就可以了。&lt;/li&gt;
&lt;li&gt;这里面还有一个工作需要完成，就是给生产者回响应，但在这一步，消息既没有落盘，也没有完成复制，还不能给客户端返回响应，所以我们把待返回的响应按照顺序放到一个内存的链表PendingCallbacks中，并记录每个请求中的消息对应的Offset。&lt;/li&gt;
&lt;li&gt;然后，我们有2个线程，FlushThread和ReplicationThread，这两个线程是并行执行的，分别负责批量异步进行刷盘和复制，刷盘和复制又分别是2个比较复杂的流程。刷盘线程不停地将新写入JournalCache的字节流写到磁盘上，完成一批数据的刷盘，它就会更新一个刷盘位置的内存变量，确保这个刷盘位置之前数据都已经安全的写入磁盘中。复制线程的逻辑也是类似的，同样维护了一个复制位置的内存变量。&lt;/li&gt;
&lt;li&gt;最后，我们设计了一组专门用于发送响应的线程ReponseThreads，在刷盘位置或者复制位置更新后，去检查待返回的响应链表PendingCallbacks，根据QOS级别的设置（因为不同QOS基本对发送成功的定义不一样，有的设置需要消息写入磁盘才算成功，有的需要复制完成才算成功），将刷盘位置或者复制位置之前所有响应，以及已经超时的响应，利用这组线程ReponseThreads异步并行的发送给各个客户端。&lt;/li&gt;
&lt;li&gt;这样就完成了消息生产这个流程。整个流程中，除了JournalCache的加载和卸载需要对文件加锁以外，没有用到其他的锁。每个小流程都不会等待其他流程的共享资源，也就不用互相等待资源（没有数据需要处理时等待上游流程提供数据的情况除外），并且只要有数据就能第一时间处理。&lt;/li&gt;
&lt;li&gt;这个流程中，最核心的部分在于WriteThread执行处理的这个步骤，对每条消息进行处理的这些业务逻辑，都只能在WriteThread中单线程执行，虽然这里面干了很多的事儿，但是我们确保这些逻辑中，没有缓慢的磁盘和网络IO，也没有使用任何的锁来等待资源，全部都是内存操作，这样即使单线程可以非常快速地执行所有的业务逻辑。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个里面有很重要的几点优化：&lt;/p&gt;
&lt;p&gt;第一是使用异步设计，把刷盘和复制这两部分比较慢的操作从这个流程中分离出去异步执行；&lt;/p&gt;
&lt;p&gt;第二是使用了一个写缓存JournalCache将一个写磁盘的操作，转换成了一个写内存的操作，来提升数据写入的性能；&lt;/p&gt;
&lt;p&gt;第三是这个处理的全流程是近乎无锁的设计，避免了线程因为等待锁导致的阻塞；&lt;/p&gt;
&lt;p&gt;第四是把回复响应这个需要等待资源的操作，也异步放到其他的线程中去执行。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;案例二---kafka高性能io&#34;&gt;案例二 - Kafka高性能IO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Kafka的SDK，生产者调用SDK发送消息时，看起来只发了一条，但是SDK处理时不是一条一条发的，而是先把消息放到内存中缓存起来，攒一批，异步一块发给broker，broker会把这一批消息当成一条处理，消费者pull消息，也是一次性拉取这一批消息进行处理，从而减少Broker处理请求的次数，减轻压力。&lt;/p&gt;
&lt;p&gt;Kafka有一个参数可以让消费者阻塞直到有新消息到达 或者 消息堆积到一定数量之后才接收 ，避免Broker没有消息时，消费者不断轮询。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;顺序读写，Broker收到消息后，顺序写入对应的log文件，一个文件写满就开启新文件顺序写下去，消费时也是从log文件的某一位置开始，顺序的读出来。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用PageCache加速读写，数据写入文件时，先写入PageCache，再一批一批写入磁盘，读取文件时，也是先从PageCache中读取数据，当PageCache中没有数据，会引发os的缺页中断，读取先从会被阻塞，直到数据从文件中复制到PageCache，再从PageCache中读取数据。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;零拷贝提升消费性能：一般来说，Broker处理消费时，会先从文件复制数据到PageCache，从PageCache复制数据到应用内存，从应用内存复制到Socket的缓冲区，发送数据。如果文件中的数据无需其他处理，可以使用零拷贝，直接将数据从PageCache复制到socket缓冲区，减少复制次数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;常见问题&#34;&gt;常见问题&lt;/h1&gt;
&lt;p&gt;以下问题都是需要分具体的MQ的，这里简单说下通用方法。一般异常会出现的场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;生产者：网络或内部问题导致消息发送失败，没发出去；或者是发出去了，但是没有接受成功响应导致重复发送。&lt;/li&gt;
&lt;li&gt;消费者：消费者获取了消息，处理消息的过程中宕机，恢复时消息如何处理。&lt;/li&gt;
&lt;li&gt;消息队列：宕机重启时会丢数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如何利用事务消息实现分布式事务&#34;&gt;如何利用事务消息实现分布式事务&lt;/h2&gt;
&lt;p&gt;以RocketMQ为例，生产者先发送一个半消息给MQ，此时的半消息对消费者不可见，完成之后执行本地事务，根据本地事务的执行结果，对刚刚发送的半消息进行commit或rollback，只有commit之后，消费者才能消费此消息。如果生产者本地事务提交成功后宕机，MQ会调用生产者提供的反查方法确认半消息的之后的执行状态，反查方法会有三个结果：提交、回滚、不确定，如果查询结果是不确定，MQ则会进行重试，直到查到确定的结果或者超重试次数。这种场景其实是默认消费者一定会消费成功的，如果要让消费者消费不成功时，生产者也回滚，那就不能用这种方案了。&lt;/p&gt;
&lt;h2 id=&#34;如何保证高可用性&#34;&gt;如何保证高可用性&lt;/h2&gt;
&lt;p&gt;集群 + zookeeper + 负载均衡&lt;/p&gt;
&lt;p&gt;以ActiveMQ为例（因为是主从架构）&lt;/p&gt;
&lt;p&gt;使用ZooKeeper（集群）注册所有的ActiveMQ Broker。只有其中的一个Broker可以提供服务，被视为 Master，其他的 Broker 处于待机状态，被视为Slave。如果Master因故障而不能提供服务，Zookeeper会从Slave中选举出一个Broker充当Master。
Slave连接Master并同步他们的存储状态，Slave不接受客户端连接。所有的存储操作都将被复制到 连接至 Master的Slaves。如果Master挂了，得到了最新更新的Slave会成为 Master。故障节点在恢复后会重新加入到集群中并连接Master进入Slave模式&lt;/p&gt;
&lt;p&gt;消息数据可以持久化或非持久化，在集群内共享，当有节点挂掉后，其他节点也可以通过这些共享的数据顶上。另外，也可通过定时任务定时对失败的消息进行补偿。&lt;/p&gt;
&lt;p&gt;数据的持久化存储可以存储在文件系统 &amp;gt; 分布式KV &amp;gt; 分布式文件系统 &amp;gt; 数据库（速度上的排列，但可靠性就要反过来了）&lt;/p&gt;
&lt;h2 id=&#34;如何解决消息重复问题保证消息幂等性&#34;&gt;如何解决消息重复问题，保证消息幂等性&lt;/h2&gt;
&lt;p&gt;消息幂等，可以保证即使消息被重复消费也无所谓，一般来讲，重复发送总是存在的，要避免的是即使重复消费也能保证业务正确。要解决消息重复发送，除非允许消息丢失，但很明显，消息不丢的优先级肯定更高。&lt;/p&gt;
&lt;p&gt;消息重复消费需要解决3个问题：1.第一条消息已经消费成功了，第二条消息将直接成功；2.并发场景下，消息重复，击穿幂等挡板的问题；3.生产者发送重复的消息：重复的消息id一致或者不一致&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;常见实现幂等性方法&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;保证消息幂等一般是在消费者做，比如业务操作本身就是幂等的，不然就是在消息本身上做文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;消费者处理消息的时候将消息入库记录，利用数据库的唯一键约束 + 事务来实现，比如事务开启时，先把消息入库，再进行其他业务操作，然后再提交事务，保证消息只被消费一次；&lt;/p&gt;
&lt;p&gt;这种方案有局限性，一个它需要依赖关系型数据库，另一个是需要所有的操作都在同一个库里，保证在同一个库内，不允许跨库操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于上面那种方案，如果涉及到跨服务、库的调用，则可以将跨服务的操作也抽成一个消息，通过将对不同服务或库的操作也改成事务+消息的方式来做，就可以解决这个问题，但是会导致增加业务的复杂度。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息入库 + 消息TTL去重表 + 消息状态的方案：消费者接收到消息，插入消息去重表，并设置过期时间，如果插入成功，此时消息的状态为消费中，执行业务代码，成功后更新消息状态为已消费，然后发送ack，如果业务代码执行失败，则将消息从消息表删除，重新投递；如果消息一开始就插入失败了，判断消息的状态，如果消息状态是已消费，则返回ack，如果状态是消费中，则重新投递，之所以要多这一步是为了解决并发时候重复消息的问题；插入时设置过期时间，是为了解决消息重复投递时，每次都是看到消息是消费中的状态，导致消息最终去了死信的问题；&lt;/p&gt;
&lt;p&gt;当然此方案中如果涉及到跨服务、库的调用，需要保证这一次调用也是幂等的，该方案仅仅是解决上面的方案中依赖关系型数据库和事务的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;更新数据时设置前置条件，如果满足该条件则更新数据，否则拒绝更新数据，在更新数据的同时，变更前置条件中需要判断的数据，这样当重复执行这个操作时，由于第一次更新已经修改了前置条件，不满足前置条件时，则不会重复执行更新数据的操作，比如给数据增加一个版本号，每次更新数据前，比较当前数据的版本号是否和消息中的版本号一致，如果不一致就拒绝更新数据，更新数据的同时，版本号+1，实现幂等更新。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在发送消息时，给消息指定一个全局唯一的ID，消费时，先根据这个ID检查这条消息是否被消费过，如果没消费过，才更新数据，然后标记消息为已消费。但该方案在分布式系统中比较复杂，高可用，高性能都有一定的影响，需要使用分布式锁或者分布式事务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于无法处理的消息导致MQ重复发送，可以设置重复次数，过了重复次数将消息持久化到其他地方，比如死信队列，以后处理。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如何保证消息顺序&#34;&gt;如何保证消息顺序&lt;/h2&gt;
&lt;p&gt;100%的顺序消息的条件比较苛刻，需要允许消息丢失且生产者到消费者都是单点单线程，一般是保证在不丢消息的前提下，尽量减少重复消息，不保证投递顺序。。&lt;/p&gt;
&lt;p&gt;允许重复消息时，可以通过&lt;strong&gt;序列号&lt;/strong&gt;或者&lt;strong&gt;状态机&lt;/strong&gt;来解决消息幂等处理和消息顺序的问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;序列号&lt;/strong&gt;：消费者接收消息时，只接收比最新序列号大的消息，重复消息因为序列号比当前序列号小，所以可以抛弃，比如消息顺序是123，消费者当前也收到123了，再收到123其中一个就可以不进行处理了；如果消息顺序不一致，比如消息顺序是123，但先接收到的是3，1和2还没收到，那就只能先把3存起来，等待12的到来，具体可以参考TCP协议的通信机制。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;状态机&lt;/strong&gt;：将业务流程设定成一系列的状态扭转，不同的状态只能处理不同的消息，就可以依靠状态流的扭转来实现顺序消息&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;减少重复消息的处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;消息队列收到消费者的确认信号后，将消息id清除或进行标记；&lt;/p&gt;
&lt;p&gt;发送方要进行重发前对消费者进行询问请求&lt;/p&gt;
&lt;h2 id=&#34;如何保证消息的可靠性传输&#34;&gt;如何保证消息的可靠性传输&lt;/h2&gt;
&lt;p&gt;消息传输有3个阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;消息的传输包括生产者发送消息给消息队列&lt;/li&gt;
&lt;li&gt;消息在Broker端存储，如果是集群，消息会复制到其他副本&lt;/li&gt;
&lt;li&gt;消费者通过pull模式拉取数据 或者 消息队列通过push模式向消费者发送消息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;保证消息可靠，一般是使用 &lt;strong&gt;持久化机制 或 事务 + ack机制&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;持久化不一定带有事务特性，比如直接日志落地，如果持久化要实现事务特性，可以使用分布式事务或者本地数据库事务。&lt;/p&gt;
&lt;p&gt;消息的确认机制（ack机制），消息发送完成后，需要收到接收方的确认信号，确认信号的返回可以是收到后消息后就立即返回，比如默认auto ack机制，或者是接收方法接收到消息，处理完该消息后才发送确认信号。另外，当接收方无法处理消息，比如消费能力不够，网络不佳等情况，接收方也可以直接拒绝消息，等待发送方重新发送，所以这里就涉及到消息的重复发送了，通过直接拒绝消息来减少业务负担。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ACK模式描述了Consumer与broker确认消息的方式(时机),比如当消息被Consumer接收之后,Consumer将在何时确认消息。对于broker而言，只有接收到ACK指令,才会认为消息被正确的接收或者处理成功了,通过ACK，可以在consumer（producer）与Broker之间建立一种简单的“担保”机制.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;消息发送阶段：生产者往Broker发送消息前，可以做一次消息持久化，收到Broker的ack响应后，要正确处理，以此保证消息在生产阶段不会丢失。在此阶段，Broker并不关心生产者是否收到ack响应，因为在生产者的角度，消息已经持久化后成功发出了，如果没有收到ack，最多就重复发送，那就会收到重复的ack，保证消息一定落到了Broker，当然前提是Broker能幂等处理。&lt;/p&gt;
&lt;p&gt;发送方只有在消息入库成功，事务提交后，才会发送消息，如果发送失败，可以靠定时任务重试。注意本地事务做的是业务落地和消息落地的事务。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息到达Broker阶段：对于单节点Broker，在收到消息后，将消息持久化到磁盘，再给生产者返回ack响应；对于集群Broker，在收到消息后，至少要把消息发送到两个以上节点，再给生产者返回ack响应。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息消费阶段：对于pull模式，消费者拉取消息后，先成功执行完业务逻辑后，才给Broker发送消费ack响应，如果Broker没有收到消费者的确认响应，下次拉取的仍然是同一条消息。&lt;/p&gt;
&lt;p&gt;支持广播的消息队列需要对每个待发送的endpoint，持久化一个发送状态，直到所有endpoint状态都OK才可删除消息。&lt;/p&gt;
&lt;p&gt;无论是pull模式还是push模式，在允许重复消息的情况下，还可通过定时任务轮询未消费消息发送给消费者处理来保证最终一致性。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;保证消息从生产者到MQ或者MQ到消费者的过程在同一个会话中，保证原子性；在事务性会话中，当一个事务被提交的时候，确认自动发生；事务回滚，消息再次传送；一个事务提交才能进行下个事务，效率较差。&lt;/p&gt;
&lt;p&gt;在非事务性会话中，消息何时被确认取决于创建会话时的应答模式ACK模式，分为自动确认(onMessage方法成功返回，如果抛异常会交由异常消息监听器，或者重复次数发送)、手动确认、不必须确认,批量(重复有标记)。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;检测消息丢失的方法&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过消息队列的有序性来验证是否有消息丢失。生产者发出消息时附加一个连续递增的序号，由消费者来检查这个序号的连续性。在分布式系统上，在发送消息时必须指定分区，消费者在每个分区单独检查消息序号的连续性。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;消息的丢失处理&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;生产者消息丢失处理：发送消息时产生一个id，MQ接收到消息后回传id，超过一定时间没收到则重发&lt;/p&gt;
&lt;p&gt;MQ消息丢失处理：开启消息队列持久化 和 消息持久化，持久化后才回传id给生产者&lt;/p&gt;
&lt;p&gt;消费者消息丢失处理：取消自动ack，在方法处理完之后调用方法，发送确认ack给MQ，如果消息处理的时间太长，但可能导致重复发送&lt;/p&gt;
&lt;h2 id=&#34;关于pull模式和push模式&#34;&gt;关于pull模式和push模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;push模式的弊端，如果消费者消费能力不够，就会导致消息在消息队列中堆积，消息队列也需要保存这些消息，记录这些消息的状态；而pull模式是消费者按能力消费，所以没有这样问题。&lt;/li&gt;
&lt;li&gt;push模式下要保证顺序消息也比较麻烦，需要等待消费者确认一个消息后才能发送下一个，吞吐量就不太行了&lt;/li&gt;
&lt;li&gt;pull模式的弊端，因为消费者拉取消息的时间间隔比较难把握，间隔时间不合理就会导致消息消费存在延迟和忙等，常见的作法是消费者建立连接后hold住一段时间，保存一个长连接，设置等待时间进行断开，在这段时间内进行消息消费&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;如何解决消息队列的延时以及过期失效问题&#34;&gt;如何解决消息队列的延时以及过期失效问题？&lt;/h2&gt;
&lt;p&gt;手动查询丢失消息，重新导入&lt;/p&gt;
&lt;p&gt;可以设置死信队列，过期或者重复多次为被消费的消息会进入死信队列&lt;/p&gt;
&lt;h2 id=&#34;如何解决消息积压问题&#34;&gt;如何解决消息积压问题？&lt;/h2&gt;
&lt;p&gt;一般消息积压，要不就是发送快了，要不就是消费慢了，一般先查MQ监控，判断生产速度和消费速度是否异常。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;生产者发送消息太慢也会导致积压，比如，生产者在一个事务内先发送半消息，处理业务逻辑，提交事务，事务成功后才会提交半消息，此时该消息才会被消费者所见，如果事务处理得太慢，也会造成消息堆积。&lt;/p&gt;
&lt;p&gt;so 生产者最好可以支持批量发送或者并行发送两种发送方式；对于实时性不强的业务，生产者可以积累一定量的消息才发送给MQ；对于批量发送的消息，消费时也要批量消费&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修复消费者，检查消费者是不是对某一消息进行重复消费，恢复消费速度；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;扩充原来的数量，消费之后再恢复原来架构。比如新键一个topic，建立比原先多n倍的队列，多n倍的消费者处理，每批消费者对应一个队列（分区），确保消费者的实例数和队列(分区)数相等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果可以持久化消息，也可以先丢弃消息，之后再将持久化消息导入队列再处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务降级，减少生产者的发送消息的数量&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;延迟队列&#34;&gt;延迟队列&lt;/h1&gt;
&lt;p&gt;任意延迟消息有两个难点，一个是消息因为有不同的过期时间，且投递顺序不定，因此处理消息时需要排序，另一个是延迟消息的存储，因为如果MQ基于WAL方式实现，日志文件会被过期删除，其最多只能保存一段时间的数据。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;通过RabbitMQ的TTL消息 + 死信队列实现，消息的TTL过期之后，会被转发到死信，消费者直接消费死信队列里的消息即可。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于Kafka，由于Kafka本身不支持延迟消息，只能通过额外方案实现。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实现固定过期时间的延迟消息&lt;/strong&gt;：设置两个Topic，一个用于生产者投递设定好过期时间的消息，另一个是用于立即消费消息。生产者设定消息过期时间后，投递到第一个消息队列，消费者消费消息后判断是否需要立即执行，如果需要则把消息投递到第一个Topic，由真正的消费者执行消费。消费第一个队列的消费者如果判断出消息不能被投递到第二个队列，需要使用Kafka提供的 开始/暂停 API 来消费消息，不能使用sleep暂停消费消息，也不能重新投递（因为消息的顺序性），否则会导致Broker认为消费者不可用，触发 重平衡机制。&lt;/p&gt;
&lt;p&gt;缺点：消息只能是固定的延迟，如果每条消息的延迟时间不同，就得使用多种Topic和对应的消费者；延迟时间不宜过长，因为WAL机制，消息堆积可能会导致日志文件被删除&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Kafka%e5%bb%b6%e8%bf%9f%e9%98%9f%e5%88%97%e5%ae%9e%e7%8e%b0.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Kafka%e5%bb%b6%e8%bf%9f%e9%98%9f%e5%88%97%e5%ae%9e%e7%8e%b0.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;多级时间轮优化排序；将普通消息和延迟消息的commitLog分开保存，以保存较长时间；延迟消息数据按固定延迟划分，分段加载，时间轮只加载临近到期的消息，比如每30分钟一个块写入文件，整点时计算下一个30分钟的消息hash到对应的时间轮上，而超过时间轮限制的，直接落盘。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e6%97%b6%e9%97%b4%e8%bd%ae%e5%bb%b6%e8%bf%9f%e9%98%9f%e5%88%97.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e6%97%b6%e9%97%b4%e8%bd%ae%e5%bb%b6%e8%bf%9f%e9%98%9f%e5%88%97.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;消息写入WAL&lt;/li&gt;
&lt;li&gt;Dispatcher处理延迟消息
&lt;ul&gt;
&lt;li&gt;延迟消息一定时间的直接写入TimeWheel&lt;/li&gt;
&lt;li&gt;延迟超过一定时间写入DelayMessageStorage&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;DelayMessageStorage对DelayMsgFile构建一层索引，这样在映射到TimeWheel时只需要做一次Hash操作&lt;/li&gt;
&lt;li&gt;通过TimeWheel将消息投递到ConsumeQueue中完成对Consumer的可见&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/266156267&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;几种延迟队列实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://developer.aliyun.com/article/660438&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;如何在MQ中实现支持任意延迟的消息？&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://xuyangyang.club/articles/2018/07/23/1532348839398.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;消息队列常见问题和解决方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://youzhixueyuan.com/design-the-message-queue.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;如何从0到1设计一个MQ消息队列&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://shift-alt-ctrl.iteye.com/blog/2020182&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ActiveMQ消息传送机制以及ACK机制详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/zhaobryant/article/details/80557103&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;架构文摘：消息队列设计精要&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tech.meituan.com/2016/07/01/mq-design.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;消息队列设计精要&lt;/a&gt;，这个讲的不错&lt;/p&gt;
&lt;p&gt;极客时间 - 消息队列高手课 - 李玥&lt;/p&gt;
</description>
        </item>
        <item>
        <title>网络</title>
        <link>http://nixum.cc/p/%E7%BD%91%E7%BB%9C/</link>
        <pubDate>Sun, 22 Sep 2019 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/%E7%BD%91%E7%BB%9C/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;基本&#34;&gt;基本&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;OSI七层模型&lt;/th&gt;
&lt;th&gt;对应网络协议&lt;/th&gt;
&lt;th&gt;作用&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;应用层&lt;/td&gt;
&lt;td&gt;HTTP、TFTP、FTP、NFS、SMTP、Telnet&lt;/td&gt;
&lt;td&gt;应用程序间通信的网络协议&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;表示层&lt;/td&gt;
&lt;td&gt;Rlogin、SNMP、Gopher&lt;/td&gt;
&lt;td&gt;数据格式化、加密、解密&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;会话层&lt;/td&gt;
&lt;td&gt;SMTP、DNS&lt;/td&gt;
&lt;td&gt;建立、维护、管理会话连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;传输层&lt;/td&gt;
&lt;td&gt;TCP、UDP&lt;/td&gt;
&lt;td&gt;建立、维护、管理端到端连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络层&lt;/td&gt;
&lt;td&gt;IP、ICMP、ARP、RARP、AKP、UUCP&lt;/td&gt;
&lt;td&gt;IP寻址和路由选择&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;数据链路层&lt;/td&gt;
&lt;td&gt;FDDI、Ethernet、Arpanet、PDN、SLIP、PPP&lt;/td&gt;
&lt;td&gt;控制网络层与物理层间的通信&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;物理层&lt;/td&gt;
&lt;td&gt;IEEE 802.1A、IEEE 802.2到802.11&lt;/td&gt;
&lt;td&gt;比特流传输&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;数据链路层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;数据包叫Frame，“帧”；&lt;/li&gt;
&lt;li&gt;由两部分组成：标头和数据，标头标明数据发送者、接收者、数据类型；&lt;/li&gt;
&lt;li&gt;用MAC地址定位数据包路径；&lt;/li&gt;
&lt;li&gt;相关设备是交换机；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网络层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据包叫packet，“包”；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IPv4：32个二进制，4字节*8位；IPv6：1同一子网28个二进制，8字节*16位；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;子网掩码与IP的and运算判断是否为同一子网下；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;路由：把数据从原地址转发到目标地址，同一局域网内，通过广播的方式找到，不同局域网内，原主机先将包根据网关添加路由器/主机地址，通过交换机的广播方式发给目标主机，原主机将数据包传输给目标主机，再由目标主机根据MAC广播交给对应目标&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ping ip，使用ICMP协议可以确认 IP 包是否成功送达目标地址、报告发送过程中 IP 包被废弃的原因和改善网络设置；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ARP协议：IP与MAC地址的映射，ARP会在以太网中以广播的形式，获取IP对应的MAC地址；&lt;/p&gt;
&lt;p&gt;仅限IPv4，IPv6使用 Neighbor Discovery Protocol替代；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;相关设备是路由器，网关&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传输层：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据包叫segment，“段”；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Socket、UDP、TCP见下&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;应用层使用TCP传输数据时，会先将数据打到TCP的Segment中，然后TCP的Segment会打到IP的Packet中，然后再打到以太网Ethernet的Frame中，传输到目标主机后，再一层层解析，往上传递。&lt;/p&gt;
&lt;h1 id=&#34;从浏览器输入url之后都发生了什么&#34;&gt;从浏览器输入URL之后都发生了什么&lt;/h1&gt;
&lt;p&gt;浏览器输入URL，按回车，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;浏览器根据输入内容，匹配对应的URL和关键词，校验URL的合法性，从历史记录、书签等地方，找到可能对应的URL，进行补全，使其符合通用URI的语法。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发起请求，从URL中解析出域名，首先查看本地hosts文件，判断是否有这个域名对应的ip，如果没有，请求本地DNS服务器，先查询本地DNS服务的缓存，如果没有再向上级DNS服务器发送请求，递归查询，直到找到对应的IP地址，然后本地DNS服务器就把对应关系保存在缓存中&lt;/p&gt;
&lt;p&gt;注意根DNS服务器没有记录具体的域名和IP的对应关系，而是告诉本地DNS服务器可以到域服务器上继续查询，给出的是域服务器的地址。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;拿到域名对应的IP后，应用层程序准备好数据后，委托给操作系统，复制应用层数据到内核的内存空间中，交给网络协议栈（将其打包为tcp包(传输层)，帧(数据链路层)，并将数据从内核拷贝到网卡，后续由网卡负责数据的发送），与Web服务器建立 TCP/IP 连接（三次握手具体过程）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立连接后，发起一个HTTP 请求，经过路由器的转发，通过Web服务器（CDN、反向代理之类的）的防火墙，该 HTTP 请求到达了Web服务器。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务器处理该 HTTP 请求，返回一个 HTML 文件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;浏览器解析该 HTML 文件，解析HTML文件后，构建dom树 -》构建render树 -》布局render树 -》绘制 render树，自上而下加载，边加载边解析渲染，显示在浏览器端，对于图片音频等则是异步加载。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本质上是OSI七层模型 + 相应协议、组件实现；建立一次TCP后，在HTTP 1.1请求头配置keep-alive=true后，默认保持两小时的连接，可以一直进行http请求，但同时只处理一个http请求，HTTP 2.0才允许并行多个；&lt;/p&gt;
&lt;h1 id=&#34;http方法&#34;&gt;HTTP方法&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.runoob.com/http/http-methods.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;菜鸟HTTP教程/HTTP请求方法&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;get和post的区别&#34;&gt;Get和Post的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;语义上的区别，Get一般表示查询、获取，Post是更新，创建&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Get具有幂等性，Post没有&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;参数传递方面，Get一般参数接在Url上，对外暴露，有长度限制（1024个字节即256个字符），只接收ASCII字符，需要进行url编码&lt;/p&gt;
&lt;p&gt;Post参数放在request body里，支持多种编码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GET请求会被浏览器主动cache，而POST不会，除非手动设置&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GET产生的URL地址可以加入书签，而POST不可以&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GET在浏览器回退时是无害的，而POST会再次提交请求&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其实本质都是一种协议的规范，规定参数的存放位置，参数长度大小等，当然也可以反着来，只要服务器能够理解即可&lt;/p&gt;
&lt;p&gt;幂等性：同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的，每次返回的结果一样，不产生副作用；&lt;/p&gt;
&lt;p&gt;根据语义，简单的把get看成查询，只要服务器的数据没变，每次查询得到的结果是一样的，而把post看成添加，每次post请求都会创建新资源，服务器状态改变&lt;/p&gt;
&lt;p&gt;具有幂等性的方法：GET、HEAD、OPTIONS、DELETE、PUT&lt;/p&gt;
&lt;p&gt;没有幂等性的方法：POST&lt;/p&gt;
&lt;p&gt;安全性：安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。&lt;/p&gt;
&lt;h1 id=&#34;常见状态码&#34;&gt;常见状态码&lt;/h1&gt;
&lt;p&gt;参考&lt;a class=&#34;link&#34; href=&#34;http://www.runoob.com/http/http-status-codes.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;HTTP状态码&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;301：永久移动请求的网页已永久移动到新位置，即永久重定向；返回信息会包括新的URI，浏览器会自动定向到新URI。今后任何新的请求都应使用新的URI代替，新的URI会放在响应header的Location字段中；搜索引擎会抓取新内容同时也将旧地址修改为新地址。301调整默认会被浏览器cache，用户后续多次访问该url时会，浏览器会直接请求跳转地址。&lt;/li&gt;
&lt;li&gt;302：临时移动请求的网页暂时跳转到其他页面，即暂时重定向；旧地址的资源还在，只是重定向到临时的新地址中，对SEO有利，搜索引擎会抓取新内容保存旧地址。如果在响应头中通过Cache-Control或Expires，也可以实现301中浏览器缓冲的效果。&lt;/li&gt;
&lt;li&gt;405：请求的Method被禁止，比如Post的接口用成了Get&lt;/li&gt;
&lt;li&gt;502：Bad Gateway，作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应&lt;/li&gt;
&lt;li&gt;503：Service Unavailable，服务不可用&lt;/li&gt;
&lt;li&gt;504：Gateway Time-out，充当网关或代理的服务器，未及时从上游服务器收到请求&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;http头&#34;&gt;HTTP头&lt;/h1&gt;
&lt;h2 id=&#34;connection-keep-alive&#34;&gt;Connection: keep-alive&lt;/h2&gt;
&lt;p&gt;保持长连接，连接复用，避免频繁建立连接带来的性能损耗。HTTP1.0默认是关闭的，HTTP1.1默认是开启的。对应的key是Connection。可以设置参数&lt;code&gt;Keep-Alive: max=5, timeout=120&lt;/code&gt;表示一次keep-alive可以发送的请求次数是5，连接保持时间是120s，&lt;strong&gt;默认是2小时&lt;/strong&gt;，可以一直进行HTTP请求，但&lt;strong&gt;一个TCP连接同一时间只支持一个HTTP请求&lt;/strong&gt;，即一次连接中，请求是一个个处理的，如果前一个没处理完，没办法处理下一个，也就是下一个不返回。&lt;/p&gt;
&lt;p&gt;不同的浏览器对同一Host建立的TCP连接数量的限制取决于浏览器本身，像Chrome最多允许同时建立6个TCP连接，假如一个HTML页面有很多图片需要加载，且这些图片都是同一Host，且HTTPs，那浏览器在TLS 后会和服务器确认是否启用HTTP2，如果启用就可以同一连接下同时下载多个，如果不启用，就仍然用那几个连接，排队去等了。&lt;/p&gt;
&lt;p&gt;另外多个HTTP连接，是可以建立在一个TCP连接上的。&lt;/p&gt;
&lt;p&gt;与TCP的keep-alive不同：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;TCP 的 keep-alive 是由操作系统内核来控制，存在于内核态，通过 &lt;code&gt;keep-alive&lt;/code&gt; 报文来防止 TCP 连接被对端、防火墙或其他中间设备意外中断，主要的作用是保活，和上层应用没有任何关系，只负责维护单个 TCP 连接的状态，其上层应用可以复用该 TCP 长连接，也可以关闭该 TCP 长连接。&lt;/li&gt;
&lt;li&gt;HTTP 的 keep-alive是由应用层控制，存在于用户态， 机制则是和自己的业务密切相关的，浏览器通过头部告知服务器要&lt;strong&gt;复用这个 TCP 连接，请不要随意关闭&lt;/strong&gt;。只有到了 &lt;code&gt;keep-alive&lt;/code&gt; 头部规定的 &lt;code&gt;timeout&lt;/code&gt; 才会关闭该 TCP 连接，不过这具体依赖应用服务器，应用服务器也可以根据自己的设置在响应后主动关闭这个 TCP 连接，只要在响应的时候携带 &lt;code&gt;Connection: Close&lt;/code&gt; 告知对方&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是可见，两种keep-alive都是为了连接复用&lt;/p&gt;
&lt;h2 id=&#34;content-length&#34;&gt;Content-Length&lt;/h2&gt;
&lt;p&gt;表示本次响应的数据长度，后面的字节就属于下一个响应的了，因为HTTP是基于TCP进行通信的，应用层需要解决粘包的问题，HTTP为了解决这个问题，有两种解决方案：1. 设置Content-Length作为响应的边界；2. 响应体设置回车符、换行符作为响应的边界，常见于&lt;code&gt;Transfer-Encoding=chunked&lt;/code&gt;&lt;/p&gt;
&lt;h2 id=&#34;upgrade&#34;&gt;Upgrade&lt;/h2&gt;
&lt;p&gt;一般是用于协议升级，比如WebSocket，浏览器与服务器使用WebSocket通信时，会先通过普通的HTTP建立连接，在请求头里带上&lt;code&gt;Upgrade: WebSocket; Connection: Upgrade; Sec-WebSocket-Key: 随机生成的base64码&lt;/code&gt;，发送给服务器。&lt;/p&gt;
&lt;p&gt;如果服务器支持WebSocket协议，就会走WebSocket握手流程，根据客户端生成的basae64码，使用公钥变成另一个字符串，放在&lt;code&gt;Set-WebSocket-Accept&lt;/code&gt;响应头中，并带上101响应码，表示协议切换，要建立起WebSocket连接。&lt;/p&gt;
&lt;h2 id=&#34;http缓存&#34;&gt;HTTP缓存&lt;/h2&gt;
&lt;p&gt;对于一些重复性的HTTP请求，比如每次请求得到的数据都是一样的，就可以把这对请求响应缓存在本地，从而提升性能。&lt;/p&gt;
&lt;h3 id=&#34;强制缓存&#34;&gt;强制缓存&lt;/h3&gt;
&lt;p&gt;由两个响应头字段实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Cache-Control: 值可以是max-age=x秒，或者 s-maxage=x秒（代理缓存，如CDN），或者public、private表示缓存是否共享，或者no-cache表明不缓存，或者no-store表示禁止缓存&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Expires: 值可以是 max-age+请求时间，但需要配合Last-modified使用，或者直接是绝对时间，表示缓存什么时候到期&lt;/code&gt;，&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;Cache-Control&lt;/code&gt;的优先级高于&lt;code&gt;Expires&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;客户端接收到的响应头包括这两个字段中的一个时，在之后的时间里就不会去请求服务端获取数据，直接使用本地缓存，本地缓存一般是直接存在磁盘，响应码后面会直接标识 &lt;code&gt;200（from dish cache）&lt;/code&gt;&lt;/p&gt;
&lt;h3 id=&#34;协商缓存&#34;&gt;协商缓存&lt;/h3&gt;
&lt;p&gt;客户端与服务端协商，根据结果判断是否使用本地缓存，有两种头部&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;请求头中的If-Modified-Since，表示用来与响应资源比较，判断是否缓存是否被修改过，单位是秒&lt;/code&gt;配合&lt;code&gt;响应头中的Last-Modified，表示响应资源的最后修改时间，单位是秒&lt;/code&gt;字段实现，如果缓存被修改过，返回&lt;code&gt;HTTP 200&lt;/code&gt;，如果没被修改过，返回&lt;code&gt;HTTP 304&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;响应头中的ETag，表示缓存响应标识&lt;/code&gt;配合&lt;code&gt;请求头中的If-None-Match，表示资源过期时，如果响应头里有Etag，则再次向服务器发起请求时，会设置If-None-Match的值位Etag&lt;/code&gt;，服务器会对比&lt;code&gt;If-None-Match&lt;/code&gt;的值，如果有缓存有修改，返回304，否则返回200&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ETag&lt;/code&gt;的优先级高于&lt;code&gt;Last-Modified&lt;/code&gt;，ETag可以解决那种文件内容不变，但文件修改时间改变的场景；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;https&#34;&gt;HTTPS&lt;/h1&gt;
&lt;p&gt;HTTPS主要解决HTTP的安全问题，如报文内容安全（加密解决），防篡改（签名解决），防冒充（CA认证解决）。&lt;/p&gt;
&lt;p&gt;HTTPS = HTTP + SSL/TLS，SSL是介于HTTP之下TCP之上的协议层，提供 加密明文，验证身份，保证报文完整 的保障。TLS是升级版的SSL，作用类似，比SSL多了些其他功能，现在绝大多数浏览器都不支持SSL了，而是支持TLS。&lt;/p&gt;
&lt;p&gt;HTTP 先和 TLS 通信，再由 TLS 和 TCP 通信。一般情况下，TLS需要先经过TCP三次握手，建立可靠连接之后，才能做TLS握手的事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;加密&lt;/p&gt;
&lt;p&gt;使用 对称加密 加密 报文（私钥加密私钥解密）&lt;/p&gt;
&lt;p&gt;使用 非对称加密 加密 对称加密的密钥，保证该密钥的传输安全（客户端公钥加密，服务端私钥解密；或者 服务端私钥加密，客户端公钥解密）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;验证身份&lt;/p&gt;
&lt;p&gt;通过第三方（CA）发布TLS 证书，对通信方进行认证&lt;/p&gt;
&lt;p&gt;服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。&lt;/p&gt;
&lt;p&gt;所以这里涉及到两个公钥，一个是服务端用于 TLS 的公钥，一个是CA证书的公钥；&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;TLS 证书主要是表明了该域名归属，日期等信息，还包含了用于报文加密的公钥和私钥以及数字签名，TLS 证书被服务端持有&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;进行 HTTPs 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了，通信时使用上述的加密机制保护报文；&lt;/p&gt;
&lt;p&gt;证书信任的方式：操作系统和浏览器内置；CA颁发；手动导入证书&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;保护报文完整&lt;/p&gt;
&lt;p&gt;TLS 提供&lt;strong&gt;报文摘要&lt;/strong&gt;功能（即签名）结合加密和认证来进行完整性保护&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;在HTTP的基础上，以TLS 1.2版本为例，RSA算法的握手流程：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;客户端访问服务端的网页，首先经过浏览器内置的受信任的CA机构列表，查看该服务器是否向CA机构提供了证书；CA会对服务端提供的公钥和服务端的相关信息进行Hash，然后用CA的私钥进行签名，将签名的公钥和服务端提供的公钥和信息一起整成一份证书；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果服务器证书中的信息与当前正在访问的网站（域名等）一致，那么浏览器就认为服务端是可信的，并从服务器证书中取得服务器公钥；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果还没有取得服务器中的证书，则与服务器建立TCP连接，之后开始TLS的流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;客户端向服务端发送请求，把自己支持的TLS版本，加密套件、一个随机数 发给服务端；&lt;/li&gt;
&lt;li&gt;服务端收到请求后，确认客户端的TLS版本，加密套件，然后也生成一个随机数，与证书和公钥一起发给客户端；&lt;/li&gt;
&lt;li&gt;客户端收到服务端的证书、公钥，需要验证该证书是否真实有效：先通过浏览器或操作系统内置的拿到CA证书，使用CA证书的公钥对CA证书进行解密，得到的CA证书的Hash值，然后与从服务端收到的证书的Hash值进行比较，判断是否一致，一致说明服务端可信；&lt;/li&gt;
&lt;li&gt;客户端在验证服务端的证书是有效的之后，再生成一个随机数（也称预主密钥），使用刚刚收到的服务端公钥进行加密后发送出去；&lt;/li&gt;
&lt;li&gt;服务端收到预主密钥后，用私钥进行解密，得到预主密钥的值；&lt;/li&gt;
&lt;li&gt;最后，客户端用预主密钥，使用第1步和第2步的随机数计算出会话密钥；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;建立会话密钥：客户端通过服务器公钥加密会话密钥发送给服务端，服务端用自己私钥解密得到会话密钥，用于接收和发送数据，之后传输的http数据都是经过加密的。&lt;/p&gt;
&lt;p&gt;每个会话会生成一个会话密钥，每个会话的会话密钥均不同。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;总结：非对称加密的手段传递密钥，然后用密钥进行对称加密传递数据，对称加密的密钥由客户端生成，每次会话密钥都不一样，CA会保存服务端提供的非对称加密的公钥并签名；&lt;/p&gt;
&lt;p&gt;过程中，客户端会产生两个随机数，第一个用于制作会话密钥(对报文做对称加密时使用)，第二个用于验证公钥是否可用；服务端会生成一个随机数，给客户端制作会话密钥；&lt;/p&gt;
&lt;h1 id=&#34;rsa非对称加密&#34;&gt;RSA非对称加密&lt;/h1&gt;
&lt;p&gt;例子：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;公钥为（7，33）
假设源数据翻译成十进制为：3，1，15
对其求7次幂为：2187，1，170859375
对其求33的余：9，1，27
得到密文：9，1，27

私钥为（3，33）
得到密文：9，1，27
对其求3次幂为：729，1，19683
对其求33的余：3，1，15
得到明文：3，1，15

设公钥为（e,n），私钥为（d,n）
即 明文^e%n=密文，密文^d%n=明文
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;&lt;strong&gt;公钥和私钥的制作过程&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成两个质数：p和q&lt;/li&gt;
&lt;li&gt;两个质数相乘：N = p * q&lt;/li&gt;
&lt;li&gt;使用欧拉函数计算：T = (p-1) * (q-1)&lt;/li&gt;
&lt;li&gt;选出公钥，条件：质数 &amp;amp;&amp;amp; 1 &amp;lt; 公钥 &amp;lt; T，不是T的因子，即E&lt;/li&gt;
&lt;li&gt;计算私钥，条件：（D * E）% T = 1&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当p和q特别大时，生成的T和N都非常大，即使公开N，也很难暴力算出p和q，所以破解非常困难&lt;/p&gt;
&lt;h1 id=&#34;http-20&#34;&gt;HTTP 2.0&lt;/h1&gt;
&lt;p&gt;设备变好，内容形式多样，页面资源变多，实时性要求变高使得HTTP1.1延时变高，像在Chrome连接最大并发量是6个，且每一个连接都需要经过TCP和TLS握手耗时，HTTP1.1本身一个连接只能处理一个请求，才能继续处理，每次请求头部都巨大且重复，不支持服务端消息推送；&lt;/p&gt;
&lt;p&gt;HTTP2.0建立在Https协议的基础上，支持二进制流而不是文本，支持多路复用而不是有序阻塞，支持数据压缩减少包大小，支持server push等特性，实现低延时，高性能。&lt;/p&gt;
&lt;h2 id=&#34;头部压缩&#34;&gt;头部压缩&lt;/h2&gt;
&lt;p&gt;http1.x的头带有大量信息，而且每次都要重复发送，字段是ASCII编码，效率较低。http/2使用HPACK算法来压缩header。&lt;/p&gt;
&lt;p&gt;HPACK算法包含三个组成部分：静态字典、动态字典、哈夫曼编码(用于压缩)；通过字典长度较小的索引表示对于的字段、再使用哈夫曼编码进行压缩，可高达50%~90%的压缩率。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;静态字典表&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;存储高频的字段和对应的索引，比如一些常见的HTTP请求头字段和值以及对应的索引，索引从1开始自增，代表对应的字段；&lt;/p&gt;
&lt;p&gt;HTTP2.0头部基于二进制编码（把索引值翻译成二进制数），不需要使用冒号、空格、或者\r\n作为分隔符，直接使用字符串长度来分割索引和值；&lt;/p&gt;
&lt;p&gt;各自缓存之后，之后发送的请求如果不包含首部，就会自动使用之前请求发送的首部，如果首部发生变化，则只需将变化的部分加入到header帧中，改变的部分会加入到头部字段表中，首部表在HTTP2.0的连接存续期内始终存在，由客户端喝服务端共同渐进式更新。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;动态字典表&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;静态表只包含了 61 种高频出现在头部的字符串，不在静态表范围内的头部字符串就要自行构建动态表，它的 Index 从 &lt;code&gt;62&lt;/code&gt; 起步，会在编码解码的时候随时更新。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如有新的不存在静态字典表的字段出现在双方的通信中，双方就会为这个新的字段更新一个对应的索引，记录到动态字典表中。动态字典表生效有一个前提是，必须在同一连接上，重复传输完成相同的HTTP头部，如果在一个连接上只发送了一次，或者重复传输时总是略有变化，动态字典表就无法充分利用了。&lt;/p&gt;
&lt;p&gt;动态字典表会随着通信时间的累积，越变越大，占用的内存也越大，会影响服务器性能，因此一般服务器会提供类似&lt;code&gt;http2_max_requests&lt;/code&gt;的配置，限制一个连接能传输的请求数量，避免动态字典表无限增大，当达到上限后，就会关闭连接来释放内存，等下次连接再重新建立动态字典表。&lt;/p&gt;
&lt;h2 id=&#34;二进制分层帧&#34;&gt;二进制分层帧&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/HTTP2%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%b8%a7%e7%9a%84%e7%bb%93%e6%9e%84.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/HTTP2%e4%ba%8c%e8%bf%9b%e5%88%b6%e5%b8%a7%e7%9a%84%e7%bb%93%e6%9e%84.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;帧类型有10种，分为数据帧和控制帧两大类；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;标志位用于携带简单的控制信息，比如END_HEADERS表示数据结束标志，相当于HTTP1.x里的空行或者/r/n；END_Stream表示单向数据发送结束，后续不会有数据帧；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;流标识符，用来标识帧属于哪个Stream，用于接收双方在乱序的帧里找到相同的StreamID，从而有序的组装信息；为了防止两端流ID冲突，客户端发起的流具有奇数ID，服务器端发起的流具有偶数ID；&lt;/p&gt;
&lt;p&gt;每个Stream是一个逻辑联系，一个独立的双向的frame存在于客户端和服务器端之间的HTTP2.0连接中。一个HTTP2.0连接上可包含多个并发打开的Stream，这个并发Stream的数量能够由客户端设置。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;帧数据：由HPACK算法压缩过的HTTP头和包体；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;消息：一个完整的请求或响应，由一个或多个帧组成。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在二进制分帧层上，http2.0会将所有传输信息分割为更小的消息和帧，并对它们采用二进制格式的编码将其封装，新增的二进制分帧层同时也能够保证http的各种动词，方法，首部都不受影响，兼容上一代http标准。其中，http1.X中的首部信息header封装到Headers帧中，而request body将被封装到Data帧中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;多路复用&#34;&gt;多路复用&lt;/h2&gt;
&lt;p&gt;HTTP2.0通过多路复用实现并发传输，多个Stream复用同一条TCP连接，达到并发的效果，解决HTTP1.1队头阻塞问题，避免频繁建立TCP、TLS握手的时间，减少TCP慢启动对流量的影响，提高HTTP传输的吞吐量。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多个 Stream 跑在一条 TCP 连接，同一个 HTTP 请求与响应是跑在同一个 Stream 中，HTTP 消息可以由多个 Frame 构成， 一个 Frame 可以由多个 TCP 报文构成。&lt;strong&gt;不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ）&lt;/strong&gt;，因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而&lt;strong&gt;同一 Stream 内部的帧必须是严格有序的&lt;/strong&gt;；即多个Stream传输时是并行交错的，但是同一个Stream的帧是有序的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;连接是持久的，客户端和服务器之间只需要一个连接，每个数据流可以拆分成很多不依赖的帧，这些帧可以乱序发送，也可以分优先级，多个流的数据包能够混合在一起通过同样的连接传输，服务端在根据不同帧首部的流标识进行区分和组装。&lt;/p&gt;
&lt;h2 id=&#34;请求优先级&#34;&gt;请求优先级&lt;/h2&gt;
&lt;p&gt;将HTTP消息分为很多独立帧之后，就可以通过优化这些帧的交错喝传输顺序进一步优化性能，服务端也可以根据流的优先级，优先将最高优先级的帧发送给客户端。&lt;/p&gt;
&lt;h2 id=&#34;服务端推送&#34;&gt;服务端推送&lt;/h2&gt;
&lt;p&gt;服务端可以对一个客户端请求发送多个响应，而无需客户端明确地请求，省去客户端重复请求的步骤。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;服务器推送资源时，会先发送 PUSH_PROMISE 帧，告诉客户端接下来在哪个 Stream 发送资源，然后用偶数号 Stream 发送资源给客户端。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;使用长连接需要考虑的点&#34;&gt;使用长连接需要考虑的点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;客户端和服务端的数量，因为要保持连接，如果客户端的数量远超服务端的数量，服务端与每个客户端都维持一个长连接，对服务端来说负担比较大，此时需要设置一个合理的超时时间，在空闲时间过长时断开连接，释放服务端资源；&lt;/li&gt;
&lt;li&gt;因为长连接的多路复用，连接一旦建立便不会断开，流量会被分到同一个服务端，会导致负载不均衡，需要连接池能分辨出服务端的多个实例，自己实现；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;tcptransmission-control-protocol-传输控制协议&#34;&gt;TCP（Transmission Control Protocol 传输控制协议）&lt;/h1&gt;
&lt;h2 id=&#34;特点&#34;&gt;特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;面向连接的，提供可靠交付（只保证传输层可靠），丢包重传，有状态服务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有流量控制，拥塞控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供全双工通信&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;头部20字节&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每一条 TCP 连接只能是点对点的（一对一）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP协议在内核中实现，升级起来比较麻烦，还需要client端和server端同时支持；&lt;/li&gt;
&lt;li&gt;TCP建立连接有延时，启动时慢启动，拥塞避免，比如应用层HTTP要建立连接，需要先建立TCP连接，无法整合在一起；&lt;/li&gt;
&lt;li&gt;TCP存在队头阻塞问题，因为要保证收到的字节数有序且完整，内核要保证收到连续的包才允许应用层读取，如果中间有一个包超时重传了，就会阻塞应用层;&lt;/li&gt;
&lt;li&gt;IP变动，端口变动需要重新建立TCP连接，比如切换wifi和4G&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于TCP的Keep-Alive：&lt;/p&gt;
&lt;p&gt;连接的双方在物理层面没有连接的概念，连接也不是一直存在数据交互，所以双方是感知不到对方的连接有没有关掉的，TCP keep-alive 也是TCP的保活机制，其基本原理是，在一段时间内没有数据传输，就会给连接对端发送一个探测包，如果收到对方回应的 ACK，则认为连接还是存活的，在超过一定重试次数之后还是没有收到对方的回应，则丢弃该 TCP 连接，通过这种方式，来实现连接的概念。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;应用场景&#34;&gt;应用场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;HTTP、FTP文件传输、SSH、SMTP&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;包头&#34;&gt;包头&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/TCP%e5%8c%85%e5%a4%b4.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/TCP%e5%8c%85%e5%a4%b4.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;TCP包头&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;TCP包头&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;端口号&lt;/strong&gt;：用于找到目标主机上的应用程序进程，TCP包是没有IP地址的，因为IP数据是网络层的事，所以这一层只有端口号；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;序号&lt;/strong&gt;：让包能顺序发送和接收，&lt;strong&gt;解决乱序问题，也可以区分连接的阶段，区分不同的连接&lt;/strong&gt;。三次握手除了确立双方建立连接，最重要的是确立双方包的序列号，每一次连接都要有不同的序列号用于区别，序列号的起始通常是随时间，如果每次连接的序列号相同，可能会导致前一次连接的包发送到了下一次连接里；序号的增加和传输的字节数相关；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确认序列号&lt;/strong&gt;：发出去的数据包时进行确认的标记，&lt;strong&gt;解决丢包问题&lt;/strong&gt;，接收方回复的ACK包的确认序号 = 发送方数据包的序号 + TCP的数据载荷字节数，注意此时的载荷数据可能是这一次报文的完整数据，也有可能是包含了上一次报文的部分数据和此次报文的部分数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;状态位&lt;/strong&gt;：客户端和服务端连接的状态，即包的类型，操控TCP的状态机；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;窗口大小&lt;/strong&gt;：&lt;strong&gt;解决流量控制问题&lt;/strong&gt;，标识自己当前的处理能力；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;TCP通过四元组可以唯一的确定一个连接&lt;/strong&gt;，四元组：源地址、源端口、目的地址、目的端口，其中，源地址、目标地址在IP头部中，告诉IP协议发送报文给目标主机，源端口和目标端口在TCP头部中，告诉TCP协议要把报文发给哪个进程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP和UDP可以使用同一个端口&lt;/strong&gt;，因为TCP和UDP在内核中是两个独立的模块，&lt;strong&gt;主机收到数据包后，可以在IP包头的协议号里判断数据包是TCP还是UDP&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在客户端中，针对同一个端口，可以与多个不同的服务端建立TCP连接，原因是TCP是通过四元组确定一个唯一连接的，&lt;strong&gt;对客户端来说，只要多个服务端的IP不同，就可以复用同一个端口&lt;/strong&gt;，不会导致连接冲突的问题。&lt;/p&gt;
&lt;p&gt;同理，在服务端中，只要绑定的IP不是同一个，就可以复用同一个端口，一般针对服务端绑定IP来说，有几种可能，比如本身机器的IP，或者 127.0.0.1 或者 0.0.0.0（比较特殊，在没设置&lt;code&gt;SO_REUSEPORT&lt;/code&gt;情况下，表示绑定该主机上的所有IP，就会出现冲突）&lt;/p&gt;
&lt;p&gt;理论上，服务端单机TCP的最大连接数 = 客户端IP数 x 客户端端口数，即 2^32 * 2^16 = 2^48，但会受操作系统资源影响，所以有一定的上限，以Linux为例，影响因素有：文件描述符限制、内存限制；&lt;/p&gt;
&lt;h2 id=&#34;术语&#34;&gt;术语&lt;/h2&gt;
&lt;p&gt;SYN：发起一个新连接，并在其序号进行初始值的设定&lt;/p&gt;
&lt;p&gt;ACK：回复，确认序号有效&lt;/p&gt;
&lt;p&gt;ack：回复，确认序号，=发送方seq+1&lt;/p&gt;
&lt;p&gt;FIN：释放一个连接&lt;/p&gt;
&lt;p&gt;RST：复位标志，表示TCP连接中出现异常，需要重新连接&lt;/p&gt;
&lt;p&gt;FIN：表示今后不再有数据发送，希望断开连接&lt;/p&gt;
&lt;p&gt;MTU：一个网络包的最大长度，一般是1500字节&lt;/p&gt;
&lt;p&gt;MSS：除去IP和TCP头部后，一个网络包能容纳的TCP数据的最大长度&lt;/p&gt;
&lt;h2 id=&#34;建立连接---三次握手&#34;&gt;建立连接 - 三次握手&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e4%b8%89%e6%ac%a1%e6%8f%a1%e6%89%8b.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;三次握手&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;三次握手&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;第一次握手：Client将标志位SYN置为1，随机产生一个值seq=j，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。 每一端先发出去的都会有SYN，收到之后会发出ACK。&lt;/p&gt;
&lt;p&gt;如果client发送失败，会周期性进行超时重传，直到收到server的确认。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第二次握手：Server收到数据包后由标志位SYN=1知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=j+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。&lt;/p&gt;
&lt;p&gt;如果server发送响应失败，会周期性进行超时重传，直到收到client的确认。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;第三次握手：Client收到确认后，检查ack是否为j+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=k+1，并将该数据包发送给Server，Server检查ack是否为k+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，可以开始传输数据了。&lt;/p&gt;
&lt;p&gt;第三次握手可以顺便携带数据，前两次则不行。&lt;/p&gt;
&lt;p&gt;client第三次握手，此时client会认为自己已经ESTABLISHED，server还未收到，此时仍然为active状态：如果server一直没收到连接请求，server会重复第二次握手，直到自己收到第三次握手的请求，此时server才是ESTABLISHED；如果此时client发送了data数据且加上了ACK，server也会切换为established；如果server有数据发送却发送不出，也会重复第二次握手。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于半连接队列、全连接队列，如果队列满了，后续的连接会被丢掉。&lt;/p&gt;
&lt;p&gt;半连接队列是一个哈希表，因为队列里都是不完整的连接，便于在第三次握手时通过哈希表，快速取出对应的连接；&lt;/p&gt;
&lt;p&gt;全连接队列是一个链表，因为存在此队列里的连接已经是可用的了，直接从头节点里获取即可；&lt;/p&gt;
&lt;h3 id=&#34;作用&#34;&gt;作用&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;三次握手后初始化socket，序号和窗口大小，并建立TCP连接。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确定双方TCP包的起始序号，保证连接后的可靠有序传输&lt;/strong&gt;：比如接收方可以去除重复的数据、接收方可以按序号进行顺序接收、或者用于标识已发送的数据包中，哪些已被对方接收。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;确定了序号就可以区分新老连接，防止旧的重复连接初始化造成混乱&lt;/strong&gt;：由于可能出现client与server建立连接并进行通信后断开重连，如果每次连接没有新的起始序号，会导致server分辨不出收到的包是这次连接的还是上次连接的，这个号会作为以后的数据通信序号，以保证应用层接收到的数据不会因网络传输问题而乱序。&lt;/p&gt;
&lt;p&gt;另外，每个连接都会有不同的序号，序号的起始号随时间变化，每4微秒加一，如果有重复，需要4.55个小时后才会出现，因为IP包头里有TTL(生存时间)，超过4小时早过期了。&lt;/p&gt;
&lt;p&gt;序号有回绕问题，所以只能最大程度的避免，比如Linux&lt;strong&gt;使用PAWS机制来解决序号回绕的问题&lt;/strong&gt;(需要开启&lt;code&gt;tcp_timestamps&lt;/code&gt;)，其实就是包序号配合上时间戳，判断时间戳是否是递增的，来解决序号回绕问题，比如回绕时，新老序号不一样，新序号从0开始，老序号是最大值，此时配合上时间戳，就能检查出来包是否可以被接收。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;server端多出一个状态，用来检查client端是否接收到自己的报文，从而&lt;strong&gt;避免客户端重复建立连接，造成不必要的资源浪费&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;不使用两次握手进行连接的原因&#34;&gt;不使用两次握手进行连接的原因&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;因为两次握手，只保证一方的初始序号能被对方成功接收，双方无法确认对方收到了自己的序号&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;如果两次握手确定连接，client发送连接请求给server，server接收后发送响应给client，此时连接建立，client可以正常的发送和接收，但是server并不知道自己发送的请求client有没有收到，此时server端无法确认自己的序号。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;因为两次握手，server端没有中间状态给客户端来阻止历史连接&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;如果client发送连接请求给server，server收到连接请求，响应回去后就建立连接，意味着这时双方可以互发数据，但如果此时客户端没有进入ESTABLISHED状态，重复发起连接，server端无法分辨是数据包还是连接包。（因为此时server端已经认为双方可以互发数据包了，server端只有在收到RST报文才会断开连接，本质上还是没有确认包序号导致的问题）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;因为两次握手，如果server端每收到SYN就建立连接，会导致建立多个冗余的无效连接，造成资源浪费&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;因为server端没有中间状态来检测client端是否接收到自己回复的ACK，如果client端重复发送多个SYN报文，而server端每次收到SYN就建立连接，就会建立多个冗余的无效连接，造成资源浪费。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另外，三次握手是因为第二次握手的时候，server收到client的请求和自己的请求一次性响应回了client，也可以把这一步拆出来，变成四次握手也是可以的，三次是至少的要求。四次挥手的第二和三次不能合并是因为此前连接已建立，贸然关闭会导致部分报文没有接受完成。&lt;/p&gt;
&lt;h3 id=&#34;传输时tcp层使用mss分包的原因&#34;&gt;传输时，TCP层使用MSS分包的原因&lt;/h3&gt;
&lt;p&gt;MSS用于TCP分片，描述一个网络包能容纳的TCP数据的最大长度，一般来说，TCP建立连接时，会协商双方的MSS值，如果数据包超过MSS值，就需要进行分片，由它形成的IP包长度也不会大于MTU（1500字节），以MSS为单位进行分片传输，这样的好处是重传时只需重传特定分片，不用重传所有分片，增加重传的效率。虽然本身IP层也能分包，但是由于IP层并没有超时重传机制，如果一个IP分片丢失，会导致整个IP报文的所有分片都需要重传。&lt;/p&gt;
&lt;h3 id=&#34;连接过程中超时或者握手丢失怎么办&#34;&gt;连接过程中超时或者握手丢失怎么办？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第一次握手超时或丢失，此时server端没有响应SYN-ACK回去，client端苦苦等待，就会触client端的超时重传机制，重传SYN报文，重传的SYN报文序号跟之前一样。Linux下重试次数是5次，第一次超时重传是1秒后，第二次两秒，&lt;strong&gt;每次超时的时间是上一次的 2 倍&lt;/strong&gt;，如果5次都超时，总共要等等63s，TCP才会断开连接；&lt;/li&gt;
&lt;li&gt;第二次握手超时或丢失，虽然server端响应了SYN-ACK给客户端了，但是client端收不到，此时client会跟上面的一样，进行超时重传SYN报文（继续第一次握手）；而server端因为迟迟收不到client端的ACK，也会触发超时重传，重传SYN-ACK报文（继续第二次握手）。Linux下也是重试5次，机制跟上面一样；&lt;/li&gt;
&lt;li&gt;第三次握手超时或丢失，由于ACK不会重传，此时是server端触发超时重传，重传SYN-ACK，直到收到第三次握手或达到最大重传次数（继续第二次握手）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;SYN报文被丢弃可能的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;PAWS机制 + NAT环境下，因为client端A和B通过NAT网关与server端建立连接，在server端看来，client端其实是同一个，此时如果client端A和B都开启了PAWS机制，数据包带有时间戳有先后顺序，就会导致server端丢弃client的数据包了；&lt;/li&gt;
&lt;li&gt;半连接队列 / 全连接队列 满了，此时后来的SYN包都会被丢弃；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;已建立连接但重复接收syn包会怎么样&#34;&gt;已建立连接但重复接收SYN包会怎么样&lt;/h3&gt;
&lt;p&gt;当client端与server端建立连接后，client端宕机重启，再次发起SYN连接（四元组相同），但server端仍然处于上一个连接的ESTABLISHED状态，因为报文序号的原因，此时server端能知道此报文号不是自己期望的，那就会回复一个携带了正确序号和确认号的ACK报文（Challenge ACK，携带了server端下一次想要接收的序号），client端收到这个Challenge ACK后，发现确认号不是自己期望的，就会回复RST报文，server端收到后就会释放掉该连接。&lt;/p&gt;
&lt;p&gt;Challenge ACK的作用是告诉发送方报文的序号是错误的，并给发送方正确的包序号。&lt;/p&gt;
&lt;h3 id=&#34;如何关闭连接&#34;&gt;如何关闭连接&lt;/h3&gt;
&lt;p&gt;server端关闭连接时，如果贸然关闭整个server端，会导致所有连接到此server端的client端都断开，最佳实践是可以单独关闭每一条TCP连接，原理就是伪造一个SYN包发送给server端，获取Challenge ACK，反向制作出RST报文，分别发送给client端和server端，让双方断开连接。&lt;/p&gt;
&lt;p&gt;TCP如果发现到达的报文序号对于当前的连接是不正确的，就会发送一个RST重置报文，从而使得连接断开，因此，TCP对RST重置报文的序号要求很严格，一定要等于下一个预期接收包的序号（可以利用challenge ACK实现），才能进行重置，断开连接。TCP重置攻击的原理，就是不断向TCP发送RST包，让正常的TCP连接断开，解决方案是IP层使用IPsec协议，通过加密和认证的方式判断数据来源。&lt;/p&gt;
&lt;h3 id=&#34;建立连接后出故障了怎么办&#34;&gt;建立连接后出故障了怎么办？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;TCP设有一个保活计时器，每收到一次请求都会复位这个计时器，server端在一段时间内没有进行数据交互时，就会触发这套keep-alive机制，如果规定时间(2小时)内没收到，则发送探测报文测试对方是否出现故障，连续10次/75分钟，仍没反应，说明对方故障；&lt;/p&gt;
&lt;p&gt;如果没有开启这个机制，server端就还是一直保持在ESTABLESHED状态；&lt;/p&gt;
&lt;p&gt;这个机制主要是探测对端主机是否宕机重启的场景，如果是对端应用进程崩溃的，因为TCP连接是由操作系统内核维护的，能感知到并进行资源回收，进入四次挥手流程断开连接；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果client端宕机后重启，还收到了之前TCP连接的报文，就会回复RST报文，断开连接；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果client端宕机后没有重启，server端发送数据收不到ACK，会进行超时重传，直至达到上限，断开连接；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;syn-flood攻击的关系&#34;&gt;SYN Flood攻击的关系&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;TCP三次握手时，客户端发送SYN到服务端，服务端收到之后，便回复&lt;strong&gt;ACK和SYN&lt;/strong&gt;，状态由&lt;strong&gt;LISTEN变为SYN_RCVD&lt;/strong&gt;，此时这个连接就被推入了半连接队列。&lt;/p&gt;
&lt;p&gt;当客户端回复ACK, 服务端接收后，三次握手就完成了。这时连接会等待被具体的应用取走，在被取走之前，它被推入ACCEPT队列，即全连接队列。&lt;/p&gt;
&lt;p&gt;SYN Flood攻击，在短时间内，伪造&lt;strong&gt;不存在的IP地址&lt;/strong&gt;，向服务器大量发起SYN报文。当服务器回复SYN+ACK报文后，不会收到ACK回应报文，导致服务器上建立大量的半连接半连接队列满了，此时服务器就无法处理正常的TCP请求。&lt;/p&gt;
&lt;p&gt;应对方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;调大&lt;code&gt;netdev_max_baklog&lt;/code&gt;&lt;/strong&gt;，该参数用于当网卡接收数据包的速度大于内核处理速度时，用一个队列保存这些数据包，默认是1000。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;增大TCP半连接队列的长度&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;减少SYN+ACK重传的次数&lt;/strong&gt;：受到SYN Flood攻击，会有大量处于SYN_REVC状态的TCP连接，处于这个状态会重传SYN+ACK，通过减少其重试次数上限，来快速关闭连接。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;开启&lt;code&gt;net.ipv4.tcp_syncookies&lt;/code&gt;&lt;/strong&gt;：在收到SYN包后，服务器根据一定的方法，以数据包的源地址、端口等信息为参数计算出一个cookie值作为自己的SYNACK包的序列号，回复SYN+ACK后，服务器并不立即分配资源进行处理，等收到发送方的ACK包后，重新根据数据包的源地址、端口计算该包中的确认序列号是否正确，如果正确则建立连接，否则丢弃该包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;SYN Proxy防火墙&lt;/strong&gt;：服务器防火墙会对收到的每一个SYN报文进行代理和回应，并保持半连接。等发送方将ACK包返回后，再重新构造SYN包发到服务器，建立真正的TCP连接。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;关闭连接---四次挥手&#34;&gt;关闭连接 - 四次挥手&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%9b%9b%e6%ac%a1%e6%8c%a5%e6%89%8b.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;四次挥手&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;四次挥手&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一次挥手：Client发送一个FIN、一个seq，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。&lt;/li&gt;
&lt;li&gt;第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号ack为收到seq+1（与SYN相同，一个FIN占用一个序号），Server进入CLOSE_WAIT状态。&lt;/li&gt;
&lt;li&gt;第三次挥手：Server发送一个FIN、一个ACK、ack为上面的seq+1、一个seq，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。&lt;/li&gt;
&lt;li&gt;第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态（等待时间设为2MSL，即报文最大生存时间），接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手，Server会比Client早一点关闭TCP连接。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于TCP连接是全双工的，因此，每个方向都必须要单独进行关闭。这一原则是当一方完成数据发送任务后，发送一个FIN来终止这一方向的连接，&lt;strong&gt;收到一个FIN只是意味着这一方向上没有数据流动了，即不会再收到新数据了（但仍然可能收到在途的数据）&lt;/strong&gt;，但是在这个TCP连接上仍然能够发送数据，直到这一方向也发送了FIN。首先进行关闭的一方将执行主动关闭，而另一方则执行被动关闭。&lt;/p&gt;
&lt;h3 id=&#34;关闭连接需要四次挥手的原因&#34;&gt;关闭连接需要四次挥手的原因&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;四次挥手：第一次挥手Client发送消息确定Client想关闭连接，第二次挥手Server发送消息确定Client可以关闭连接，第三次挥手Server发送消息确定Server想关闭连接，第四次挥手Client发送消息确定Server可以关闭连接，少了哪一次都可能导致没有完全关闭，造成一方可发送或者接收。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;之所以要四次，是因为server收到FIN后，不能同时发送ACK确认信号和FIN，&lt;strong&gt;有可能此时client有一些报文还没收完，如果client没有收到，server才有能重发&lt;/strong&gt;，所以第二、三次挥手不能合并。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭连接时，&lt;strong&gt;当收到对方的FIN报文时，仅仅表示对方不再发送新数据&lt;/strong&gt;，但对方还能发送旧数据或接收数据，己方也未必把全部数据都发送给对方了，所以己方先发送ACK，告知对方我知道你不会再发送新数据，之后己方还仍然可以发送一些数据给对方，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方的ACK和FIN一般都会分开发送。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;正常情况下，是否发送第三次挥手的控制权不在内核，而在被动关闭方的应用层，取决于其什么时候调用关闭函数，调用了关闭函数，才会发第二个FIN，在关闭之前，还可以继续发送数据，所以二三次挥手的ACK和FIN是分开发的。&lt;/p&gt;
&lt;p&gt;关闭函数有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;close()函数&lt;/code&gt;，会使得socket不再有发送和接收的能力，当使用&lt;code&gt;close()函数&lt;/code&gt;关闭连接时，由于不再具有发送和接收的能力，会直接返回RST报文给对方，然后内核释放连接，属于粗暴关闭。当客户端调用了&lt;code&gt;close函数&lt;/code&gt;，服务端继续读操作，就会报&lt;code&gt;Connection reset by peer&lt;/code&gt;，如果是写操作，则程序会产生&lt;code&gt;SIGPIPE&lt;/code&gt;信号，交由应用层程序的信号处理器处理，默认是进程终止退出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;shutdown()函数&lt;/code&gt;，会使socket只关闭发送方向而不关闭读取方向，此时会经历完整的四次挥手，属于优雅关闭。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;只有在特定场景下，才会出现三次挥手：当被动关闭方在TCP挥手过程中，没有数据要发送，同时没有开启&lt;code&gt;TCP_QUICKACK, 即开启了TCP延时确认机制（该机制可以使得ACK和数据报文一起发送，提升效率）&lt;/code&gt;，那么第二三次挥手可以合并传输，此时是三次挥手。&lt;/p&gt;
&lt;h3 id=&#34;断开连接过程中超时或者挥手丢失怎么办&#34;&gt;断开连接过程中超时或者挥手丢失怎么办？&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;第一次挥手时超时或丢失，当重试到达上限后，client端会直接断开连接；&lt;/li&gt;
&lt;li&gt;第二次挥手时超时或丢失，由于ACK不会重传，所以是client端进行第一次挥手的超时重传，当重试到达上限后，client端会直接断开连接；&lt;/li&gt;
&lt;li&gt;第三次挥手时超时或丢失，此时client端处于FIN_WAIT2状态，如果client端是调用close函数，则该状态最多持续60s，到时直接关闭；如果client端调用的是shutdown函数，则只关闭了发送方向，此时仍然可以接受数据，但状态会一直处于FIN_WAIT2；而server端会重传FIN，直到到达上限，server断开连接；&lt;/li&gt;
&lt;li&gt;第四次挥手时超时或丢失，server端会进行超时重传，当重试到达上限后，server端会直接断开连接；client此时的状态是TIME_WAIT，在定时2MSL后（每次收到第三次挥手会进行重置），超时client端就会断开连接；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;主动关闭连接的那一方需要time_wait状态的原因&#34;&gt;主动关闭连接的那一方需要TIME_WAIT状态的原因&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;保证被动关闭连接的那一方能正确的关闭连接&lt;/strong&gt;：client端发送的最后一个ACK报文给server端，这个ACK报文是可能丢失，此时server接收不到，那他就会重新发送FIN报文，client端就能在这2MSL内收到这个重传的报文，再次进入2MSL等待时间，发送ACK给server端，直到两者都进入closed状态。如果没有2MSL等待时间，而是client端发送完报文直接关闭，就会出现server端无法接收而导致无法进入closed状态；&lt;/li&gt;
&lt;li&gt;如果server超过了2MSL时间依然没收到client的ACK，会再次重发第三次挥手，但此时client会发送RST标志，表示异常关闭连接；&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;防止历史连接中的数据，被后面相同的四元组连接错误的接收&lt;/strong&gt;：client端在发送完最后一个ACK报文段后，在经过2MSL，可以使本连接持续的时间内所产生的所有报文都从网络消失，用这个时间让这个连接不会和后面的连接混在一起，使得下一个新的连接不会出现旧的连接请求报文；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;time_wait等待时间是2msl的原因&#34;&gt;TIME_WAIT等待时间是2MSL的原因&lt;/h3&gt;
&lt;p&gt;MSL（Maximum Segment Lifetime，报文最大生存时间，单位是时间），与IP头中的TTL的区别，TTL是指IP数据包可以经过的最大路由数，每经过一次处理它的路由，次数就减一，值为0时会进行丢弃，同时发送ICMP报文通知源主机，而MSL会设置一个大于等于TTL被消耗为0的时间，确保报文已被自然消亡。&lt;/p&gt;
&lt;p&gt;TTL值一般是64，Linux将MSL设置为30秒，TIME_WAIT设置为2MSL，表示一来一回的时间，相当于至少允许报文丢失一次，即server端可以在client端处于TIME_WAIT状态下重试两次。&lt;/p&gt;
&lt;p&gt;2MSL的时间从client端收到FIN后发送ACK开始计时，重复收到FIN报文则会进行重置。&lt;/p&gt;
&lt;h3 id=&#34;time_wait状态下client端收到相同四元组的syn包会怎么样&#34;&gt;TIME_WAIT状态下，client端收到相同四元组的SYN包，会怎么样&lt;/h3&gt;
&lt;p&gt;此时要看SYN包是否合法（合法的SYN包，其序号和时间戳会比期望下一个收到的序号或时间戳要大）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果是合法的SYN包，就会重用此四元组连接，跳过2MSL进入SYN_RECV状态，进入三次握手建立连接；&lt;/li&gt;
&lt;li&gt;如果收到非法的SYN包，就会再回复一个第四次握手的ACK报文（Challenge ACK），server端收到后，发现不是自己期望收到的ACK，就会回复RST报文给client端；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;高并发下存在大量time_wait状态的连接的原因-及-解决办法&#34;&gt;高并发下存在大量TIME_WAIT状态的连接的原因 及 解决办法&lt;/h3&gt;
&lt;p&gt;TIME_WAIT状态是 &lt;strong&gt;主动发起连接关闭的那一方&lt;/strong&gt; 才会存在，可以是客户端，也可以是服务端&lt;/p&gt;
&lt;p&gt;可能产生的原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;短连接场景下，无论是客户端还是服务端，请求头里带&lt;code&gt;Connection: close&lt;/code&gt;，都是服务端在处理完这次请求后，主动关闭连接；因为如果由客户端来关闭，服务端还得处理一次这次关闭的socket；&lt;/li&gt;
&lt;li&gt;长连接超时，双方建立长连接之后，在一段时间没有数据通信，服务端就会关闭连接；&lt;/li&gt;
&lt;li&gt;HTTP长连接的请求数量达到上限，服务端就会关闭连接，比如在一些QPS比较高的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可能产生的影响：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果在客户端，存在大量TIME_WAIT状态的连接，可能导致端口占用（此时无法对同一四元组建立连接，对其他四元组建立连接还是没问题），连接未能及时回收，导致无法创建新连接；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果在服务端，存在大量TIME_WAIT状态的连接，可能导致系统资源占用，如文件描述符、内存资源、CPU资源、线程资源等。端口资源倒是不会受限，因为服务端只监听一个端口，此时只会导致无法与客户端同一四元组建立连接而已，对其他客户端连接没有影响，只要同一个客户端使用新端口，也不会有影响，所以更多是对系统资源的占用；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决办法：&lt;/p&gt;
&lt;p&gt;TIME_WAIT的状态是必定存在的，所以一般来说，只能尽量减少（降低等待时间，降低出现的次数）TIME_WAIT带来的危害，比如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以设置&lt;code&gt;tcp_tw_reuse（连接复用）&lt;/code&gt;和&lt;code&gt;tcp_timestamps（报文带上 时间戳，防止回绕）&lt;/code&gt;参数解决，该参数的作用是让client端能快速复用处于TIME_WAIT的端口，如果在TIME_WAIT期间，client端以相同四元组再次建立连接，会判断TIME_WAIT是否超过一秒，超过则可以正常使用这个端口，但是可能会误接收上次连接的RST，导致连接断开，如果第四次挥手的ACK丢了，此时被动关闭的那一方可能不能被正常关闭；&lt;/p&gt;
&lt;p&gt;这种方案有个风险点，快速复用 TIME_WAIT 状态的端口，导致新连接可能被回绕序号的RST报文断开，因为RST报文比较特殊，TCP在处理的时候，发生即使RST报文的时间戳过期了，序号正确，还是能被接收；如果没打开&lt;code&gt;tcp_tw_reuse&lt;/code&gt;，停留2MSL，那这个RST报文就不会出现在这个新连接里了；&lt;/p&gt;
&lt;p&gt;另外，此方案只适用于客户端，即服务发起端；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;修改&lt;code&gt;tcp_max_tw_buckets&lt;/code&gt;参数，调小TIME_WAIT的等待时间；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将短链接改成长连接，比如HTTP，把响应头的&lt;code&gt;Connection: close&lt;/code&gt;改成&lt;code&gt;Connection: keep-alive&lt;/code&gt;，告诉服务端不要关闭，尽量复用链接；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;尽量不在服务端关闭连接；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;增加可用端口的范围；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;服务端出现大量close_wait状态的原因&#34;&gt;服务端出现大量CLOSE_WAIT状态的原因&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;CLOSE_WAIT状态是 &lt;strong&gt;被动关闭连接的那一方&lt;/strong&gt; 才会存在，一般是在服务端，如果 被动关闭方 没有及时关闭连接，那就无法发出 FIN 报文，从而无法使得 CLOSE_WAIT状态的连接转变为 LAST_ACK 状态。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发生这种情况通常是代码问题，没有及时调用close方法关闭连接导致；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;滑动窗口&#34;&gt;滑动窗口&lt;/h2&gt;
&lt;p&gt;TCP协议规定在建立连接后，会确定包的序号的起始ID，按照ID一个个发送，只有上一个数据包收到应答，才能发送下一个，这样就会导致效率比较低，为了解决这个问题，引入了滑动窗口，通过窗口来实现累计确认或累计应答的目的，应答某个ID的包就表示在这个ID之前的包都收到了，才允许发送下一个（可以理解成批量批量的ACK）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;窗口大小即自己的数据接收缓冲池的大小，由接收端决定，窗口标识了无需等待确认应答，还可以继续发送数据的最大值。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发送窗口和接收窗口所存放的字节数，都是放在操作系统内存缓冲区的，会受操作系统影响，如果接收端不能及时接收数据，可能导致窗口变小，发送端无法发送数据；如果先发生减少缓存，再收缩窗口，则可能出现丢包问题，因此TCP规定只能先收缩窗口，再减少缓存来避免丢包问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于发送缓冲区大小决定了发送窗口的上限，而发送窗口又决定了「已发送未确认」的飞行报文的上限。因此，发送缓冲区不能超过「带宽时延积」，尽量靠近最好。带宽时延积 = RTT * 带宽，如果发送缓冲区超过带宽时延积，此时网络过载，容易丢包，如果小于带宽时延积，带宽用不满，比较浪费。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/TCP%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/TCP%e6%bb%91%e5%8a%a8%e7%aa%97%e5%8f%a3.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在发送端和接收端会分别使用缓存来保存这些包的记录，一般分为四个：1. 已发送并确认的、2. 已发送未确认的、3. 没有发送但准备发送的，且大小在接收方处理范围内的、4. 没有发送且暂时不会发送的，&lt;strong&gt;滑动窗口就是处理第二、三部分的数据包&lt;/strong&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;由发送方和接收方在三次握手阶段，互相通知自己的最大可接收的字节数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当发送方窗口左部字节已发送且收到确认，窗口右滑直到左部第一个字节不是已发送并且已确认的状态，接受方窗口移动同理，此时可用窗口变大，表示可以继续发送数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;接收窗口只会对窗口内最后一个按序到达的字节进行确认，确认之后表示之前的所有字节都接收到了；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发送窗口为0，表明可用窗口耗尽，在未收到ACK确认之前无法继续发送数据；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在处理过程中，当接收缓冲池的大小发生变化时，会给对方发送更新窗口大小的通知。&lt;/p&gt;
&lt;h3 id=&#34;粘包问题&#34;&gt;粘包问题&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;实际上因为TCP是面向字节流，而字节流本身没有粘包/拆包的概念，TCP层只管提供可靠性消息传输，不然为什么会对网络分层呢，粘包是应用层没有处理好导致&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。&lt;/p&gt;
&lt;p&gt;只有TCP会（通过窗口大小来接收数据，窗口大小又是动态的），而UDP因为有消息边界（头部有规定报文的大小），所以不会&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;产生的原因&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送端粘包：发送端等到缓冲区满了才发送出去，造成粘包；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有时为了提高发送数据的效率，服务端会把多个数据块合并成一个大的数据块后封包发送，但由于面向流的通信是无消息保护边界的，接收端就很难分辨出完成的数据包。&lt;/p&gt;
&lt;p&gt;当要发送的数据大于TCP发送缓冲区剩余大小，将会发生拆包；当待发送数据大于（最大报文长度），TCP在传输前将进行拆包。即TCP报文长度-TCP头部长度&amp;gt;MSS。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;接收端粘包：接收端不及时接收缓冲区的包，造成多个包接收；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方法&lt;/p&gt;
&lt;p&gt;粘包主要就是没有处理好数据包的边界，因此我们可以&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发送固定长度的消息；消息尺寸和消息一块发送；特殊标记标记消息区间；&lt;/li&gt;
&lt;li&gt;通信双方规定好协议 + 编解码器（比如规定定长的请求头、请求体），按协议的格式进行解析；比如将数据分成两部分，一部分是头部，一部分是内容体，其中头部结构大小固定，且有一个字段声明内容体的大小。&lt;/li&gt;
&lt;li&gt;程序控制发送和接收频率；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/kex1n/p/6502002.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TCP粘包问题分析和解决（全）&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;流量控制&#34;&gt;流量控制&lt;/h2&gt;
&lt;p&gt;TCP&lt;strong&gt;需要解决可靠传输和包的乱序问题，就需要知道网络实际的数据处理带宽或数据处理速度，才不会引起网络拥塞，导致丢包，so需要做流量控制&lt;/strong&gt;。在TCP的包头中通过Window字段控制，这个字段是接收端每次ACK时会告诉发送端自己还有多少缓冲区可以接收数据，于是发送端就可以根据这个接收端的处理能力来发送数据，而不会导致接收端处理不过来，从而实现流量控制。&lt;/p&gt;
&lt;p&gt;实现滑动窗口，发送端和接收端在进行数据交互时，会商定滑动窗口的大小，&lt;strong&gt;在对于包的确认时会携带一个窗口的大小（通过ACK通知）&lt;/strong&gt;，通过该窗口大小来实现流量控制（或者时不时发送一个窗口探测的数据段来确认双方的窗口大小），当发送方和接收方的滑动窗口大小为0时，发送方会定时发送窗口探测数据包，来更新窗口大小。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;窗口关闭&lt;/strong&gt;（Zero Window）：当滑动窗口的大小变成0，意味着发送端不发数据了，当接收方的滑动窗口可以更新时，会通过ACK通知发送端，但是这个窗口大小的ACK报文是可能丢失的，丢失会导致双方互相等待，导致死锁。&lt;/p&gt;
&lt;p&gt;所以收到Zero Window的那一方（即滑动窗口变为0），会启动一个持续计时器，如果计时器超时，就会发送Zero Window Probe报文进行探测，更新自己的窗口大小，这个值会被设置成3次，每次大约30-60s，如果3次过后还是0，可能就会断开连接了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;糊涂窗口综合征&lt;/strong&gt;（Silly Window Syndrome）：如果接收方太忙，来不及取走滑动窗口里的数据，就会导致发送方可发送的数据越来越小，如果每次发送的数据太小，带宽没有占用，实际上是很亏的，这种现象就叫Silly Window Syndrome。&lt;/p&gt;
&lt;p&gt;解决方法有多种，一种是如果这个问题是接收端引起的，当收到的数据导致滑动窗口的大小小于某个值，就直接回滑动窗口为0的ACK给发送端，把滑动窗口关闭，等接收方的滑动窗口大于某个值是，才把滑动窗口打开，让发送端发数据过来；另一种是如果这个问题是发送端引起的，就延时处理，攒多点数据一块发。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;重传机制&#34;&gt;重传机制&lt;/h2&gt;
&lt;p&gt;**丢包问题：**发送方按顺序发送一系列的包，接收方接收这些包是中间一部分包没收到&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;产生原因
&lt;ul&gt;
&lt;li&gt;中间这些包经过其他链路导致延时接收方还没收到；&lt;/li&gt;
&lt;li&gt;接收方收到且发送了ACK给发送方，但是发送方没有收到ACK；&lt;/li&gt;
&lt;li&gt;网卡丢包，数据链路有点问题，或者网卡性能不足，数据包真的丢了；&lt;/li&gt;
&lt;li&gt;因为顺序发送和接收问题，接收方后面的包收到了，但是前面的包还没收到，导致后面的包收到了也不能发送ACK给发送端；&lt;/li&gt;
&lt;li&gt;建立连接时，半连接队列 或者 全连接队列 满了，新来的包就会被丢掉；&lt;/li&gt;
&lt;li&gt;流量控制机制产生的丢包；&lt;/li&gt;
&lt;li&gt;接收数据时，数据会先暂存在内核缓冲区，如果缓冲区过小，发送速度又过快，产生溢出而丢包；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，为了保证可靠传输，解决丢包问题，就需要保证当报文丢失，在一定次数内持续重试，直到成功，又要确保如果重传都失败了，及时放弃传输，避免死循环的问题。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;解决方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;超时重传&lt;/strong&gt;（Retransmission Timeout，RTO），超时重传有一个计时器，在报文发送出去后开始计时，如果在时限内收到回复的ACK，计时器就清零，如果在时限内还没收到ACK，就触发重传。&lt;/p&gt;
&lt;p&gt;超时时间由自适应重传算法来决定，另外是每次重试的时间间隔会加倍，超过两次认为网络环境差，取消重传。&lt;strong&gt;超时重传主要解决丢包时干等回复ACK的问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;RTO初始值是1秒，建立连接后，RTO会被动态计算，上限是2min，下限是200ms。RTO的设置尤为关键，设置过长，重发就慢，效率低性能差；设置过短，就会导致没有丢就重发，重发过快，就会增加网络拥塞，导致更多的超时，从而又导致更多的重发，因此无法设置成一个写死的值，而是通过RTT算法动态调整。一般超时重传时间RTO会略大于报文往返时间RTT的值。&lt;/p&gt;
&lt;p&gt;由于ACK本身没有ACK了，如果ACK发生丢失，ACK会视情况重传，比如，如果发送方收到了后续的ACK，就说明前面的内容都接收到了，就不会重传；如果没收到后续的ACK，则触发超时重传机制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;快速重传机制&lt;/strong&gt;，因为包是有顺序的，所以客户端可以检测出缺失的包，然后发送对应的冗余ACK（称为DupAck）给服务端，通过在服务端设置收到规定通过发送/接收冗余的ACK包的次数（一般是3个），如果达到了规定次数就把序号等于这个ACK号的包进行重传，不等超时时间，so &lt;strong&gt;快速重传主要是解决超时等待过久的问题&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;快速重传的触发条件是：收到3个或以上的重复ACK，即DupACK&lt;/p&gt;
&lt;p&gt;比如：接收端中间漏收了Seq2，后面又接收到了Seq3、4、5，那就会在接收时重复发送ACK2，发送端收到重复的ACK后就会重新发送Seq2了。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/TCP%e5%bf%ab%e9%80%9f%e9%87%8d%e4%bc%a0%e6%9c%ba%e5%88%b6.jpeg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/TCP%e5%bf%ab%e9%80%9f%e9%87%8d%e4%bc%a0%e6%9c%ba%e5%88%b6.jpeg&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;但是快速重传有一个问题，ACK只向发送端告知最大的有序报文段，并不确定是哪一个报文丢失了，此时发送端不知道要重传哪些包，是重传一个，还是重传所有。&lt;/p&gt;
&lt;p&gt;以上图为例，由于报文的顺序性，接收端收不到Seq2，但Seq3、Seq4、Seq5都接收到了，但是ACK的时候只重复了ACK2，此时发送端只知道必定要重传Seq2，但是并不清楚是否要重传Seq3、Seq4、Seq5。&lt;/p&gt;
&lt;p&gt;SACK就是为了解决这个问题：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Linux中的SACK机制，它会在TCP头里加一个SACK（Selective ACK）的东西，SACK还是基于快速重传的ACK，只是SACK会把接收端收到的所有包的序列，都反馈给发送端，发送端根据遗漏的ACK序号，进行重传。SACK部分最多只能容纳4个块。&lt;/p&gt;
&lt;p&gt;比如在上面的场景中，接收端在发送ACK时，带上SACK，SACK上带有Seq3、4、5的信息，这样发送端就知道只需重传Seq2了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;另外，还有个D-SACK（Duplicate SACK），在SACK上做扩展，DSACK使用SACK的第一个段作为标识，这个段表示接收范围，通过比较这个段的值和SACK的回复范围，进行判断，让发送方知道是发出去的包丢了，还是接收方回应的ACK包丢了；还是发送方的超时太短，导致重传；还是先发出去的包后到的情况，还是数据包被复制了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SACK和D-SACK的区别在于次数和目的，SACK通过重复重传来告诉发送方要重传什么数据，D-SACK用来告诉发送方哪些数据被重复接收。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Linux-SACK%e5%bf%ab%e9%80%9f%e9%87%8d%e4%bc%a0%e6%9c%ba%e5%88%b6.jpeg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Linux-SACK%e5%bf%ab%e9%80%9f%e9%87%8d%e4%bc%a0%e6%9c%ba%e5%88%b6.jpeg&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;拥塞控制&#34;&gt;拥塞控制&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;产生原因：对资源的需求超过了可用的资源，网络吞吐量下降，如果网络出现拥塞，数据包将会丢失或延迟到达，发送方以为发送失败又会继续重传，从而导致网络拥塞程度更高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;判定方式：只要发送端没有在规定时间收到ACK应答报文，就会发生超时重传，此时会认定网络出现拥塞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP通过数据包发送和确认的往返时间RTT，丢包率来判断是否拥塞，使用滑动窗口来进行拥塞控制&lt;/strong&gt;，控制发送方的发送速率，避免包丢失和超时重传。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;解决方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;慢开始 + 拥塞避免，一开始慢慢的发送，逐渐增大发送速率（线性上升直至网络最佳值），再慢下来依次重复。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;慢开始阶段，TCP连接每收到一个数据的ACK（不包括重复的ACK），拥塞窗口就翻倍增加一个MSS(最大报文大小)，当达到了慢开始的阈值，增长速度就会放缓，进入拥塞避免阶段，变成了每过一个RTT，拥塞窗口就会增长一个MSS；&lt;/p&gt;
&lt;p&gt;每一个TCP连接独立维护自己的拥塞窗口，拥塞窗口一般比MSS大，一般是MSS的某个倍数，MSS的上限一般是1460字节，一个窗口就是n个MSS；发送窗口大小 = min(拥塞窗口大小，接收窗口大小)；&lt;/p&gt;
&lt;p&gt;拥塞窗口由发送方维护，不放在TCP头部中；&lt;/p&gt;
&lt;p&gt;拥塞避免时会重复慢开始，每次收到一个数据的ACK，拥塞窗口增加量会进行减半，在再次进入慢开始+拥塞避免，所以，慢开始不止在TCP连接启动时发生，也有可能在传输过程中反复发生。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/TCP_%e6%85%a2%e5%bc%80%e5%a7%8b&amp;#43;%e6%8b%a5%e5%a1%9e%e9%81%bf%e5%85%8d.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/TCP_%e6%85%a2%e5%bc%80%e5%a7%8b&amp;#43;%e6%8b%a5%e5%a1%9e%e9%81%bf%e5%85%8d.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;慢开始&amp;#43;拥塞避免&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;慢开始+拥塞避免&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;快重传 + 快恢复，当拥塞发生时，减少超时重传的使用，而是使用快速重传机制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;TCP每发送一个报文，就会启动一个超时计时器，如果在限定时间内没有收到这个报文的ACK，发送方就会认为报文丢失，此时就会进行超时重传，一般最小的超时重传时间是200ms，为了解决每次丢包都要等待200ms或者更长的时间才会重传的问题，TCP就会采用快速重传，一旦发送方收到3次重复确认，就不用等超时计时器了，会直接重传这个报文。&lt;/p&gt;
&lt;p&gt;在Reno拥塞控制算法中，TCP在遇到拥塞点后，不会反复进行慢开始+拥塞避免，而是拥塞窗口减半，直接进入快速重传，不进入慢开始，保持跟拥塞避免一样的线性增长，直到下一个拥塞点。&lt;/p&gt;
&lt;p&gt;网络上的限速，原理其实就是设置拥塞窗口的上限，当超过限制，就会丢弃这些报文，主动进入拥塞避免阶段，确保传输速度。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/TCP%e6%8b%a5%e5%a1%9e_%e5%bf%ab%e9%80%9f%e6%81%a2%e5%a4%8d.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/TCP%e6%8b%a5%e5%a1%9e_%e5%bf%ab%e9%80%9f%e6%81%a2%e5%a4%8d.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;快恢复&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;快恢复&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了实现上面两种机制，TCP使用BBR拥塞算法，来达到高带宽和低延时的平衡&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;流量控制和拥塞控制的区别：&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;流量控制针对接收方，为了让接收方能来得及接收，根据接收方自己的能力，控制发送速度，防止分组丢失；&lt;/p&gt;
&lt;p&gt;而拥塞控制是为了防止过多的数据包注入到网络中，降低整个网络的拥塞程度，避免出现网络负载过载；&lt;/p&gt;
&lt;h2 id=&#34;优化&#34;&gt;优化&lt;/h2&gt;
&lt;p&gt;参考：https://xiaolincoding.com/network/3_tcp/tcp_optimize.html&lt;/p&gt;
&lt;h1 id=&#34;udpuser-datagram-protocol-用户数据报协议&#34;&gt;UDP（User Datagram Protocol 用户数据报协议）&lt;/h1&gt;
&lt;h2 id=&#34;特点-1&#34;&gt;特点&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不可靠的、无连接的，尽最大可能交付，只负责发送数据，无状态服务&lt;/li&gt;
&lt;li&gt;没有拥塞控制，流量控制&lt;/li&gt;
&lt;li&gt;面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），一个一个地发，一个一个地收&lt;/li&gt;
&lt;li&gt;头部只有8字节&lt;/li&gt;
&lt;li&gt;支持一对一、一对多、多对一和多对多的交互通信。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;应用场景-1&#34;&gt;应用场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;针对网络资源少，对丢包不敏感的应用，比如应用层的DHCP，在获取IP地址和子网掩码的使用，DNS、SNMP等&lt;/li&gt;
&lt;li&gt;需要广播的应用，比如DHCP、VXLAN&lt;/li&gt;
&lt;li&gt;需要处理速度快，时延低，容忍丢包、网络拥塞的应用，比如直播、视频，允许丢包，虽然丢包会导致丢帧，但影响不会很大；实时游戏、物联网终端的数据收集，其实大多数会基于UDP做一定的改进，减少UDP劣势的影响&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;包头-1&#34;&gt;包头&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/UDP%e5%8c%85%e5%a4%b4.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/UDP%e5%8c%85%e5%a4%b4.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;UDP包头&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;UDP包头&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;UDP包头比较简单，两端通信时，通过网络层里的IP，将数据包发送给对应的机器，IP头里有个8位协议，表明该数据是UDP协议的，解析到传输层，通过UDP包头提供端口号，让目标机器监听该端口号的应用程序进行处理&lt;/p&gt;
&lt;h2 id=&#34;使用场景&#34;&gt;使用场景&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;网络环境较好，如内网应用，或者对于丢包不敏感的应用&lt;/li&gt;
&lt;li&gt;需要广播或多播&lt;/li&gt;
&lt;li&gt;需要处理速度快，时延低，容忍丢包和网络拥塞&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;udp如何实现tcp&#34;&gt;UDP如何实现TCP&lt;/h1&gt;
&lt;p&gt;建立连接，是为了在客户端和服务端维护连接，而建立一定的数据结构来维护双方交互的状态，通过这样的数据结构来保证面向连接的特性。&lt;/p&gt;
&lt;p&gt;UDP属于传输层，协议已经定死了，要实现TCP的功能只能在应用层实现，模拟TCP有的那些功能：确认机制、重传机制、窗口确认机制、流量控制、拥塞控制等那些功能。&lt;/p&gt;
&lt;p&gt;UDP实现可靠性，可以简单理解成，将TCP的三次握手发送数据全程用UDP去发送，模拟TCP的包头&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;seq/ack机制，确保数据发送到对端&lt;/li&gt;
&lt;li&gt;数据包 + 序号，确保有序性&lt;/li&gt;
&lt;li&gt;数据包 + 确认序号，确保不丢包&lt;/li&gt;
&lt;li&gt;添加发送和接收缓冲区，主要是用户超时重传。&lt;/li&gt;
&lt;li&gt;定时任务实现超时重传机制。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;发送端发送数据时，生成一个随机seq=x，然后每一片按照数据大小分配seq。数据到达接收端后接收端放入缓存，并发送一个ack=x的包，表示对方已经收到了数据。发送端收到了ack包后，删除缓冲区对应的数据。时间到后，定时任务检查是否需要重传数据&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/AaronHyk/article/details/81505562&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;如何实现UDP的可靠传输&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;比如有QUIC协议，就是基于UDP实现的可靠传输协议，也是在应用层实现的。&lt;/p&gt;
&lt;h1 id=&#34;套接字socket&#34;&gt;套接字Socket&lt;/h1&gt;
&lt;p&gt;Socket是对TCP或UDP协议的封装，本质上是一个调用接口，而非协议，工作在OIS模型的第五层（会话层）&lt;/p&gt;
&lt;h2 id=&#34;基于tcp协议的socket&#34;&gt;基于TCP协议的Socket&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%9f%ba%e4%ba%8eTCP%e7%9a%84Socket.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%9f%ba%e4%ba%8eTCP%e7%9a%84Socket.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;基于TCP的Socket&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;基于TCP的Socket&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务端只调用bind()方法，不调用listen()方法，如果客户端直接根据这个ip和端口进行连接，此时无法联通，服务端会直接返回RST报文；&lt;/li&gt;
&lt;li&gt;但是不调用listen()，是可以建立TCP连接的，而socket不行而已。在TCP中，存在自连接，即客户端自己连自己，不能有服务端参与，此时是可以建立连接的。虽然不调用listen()方法，不会创建半连接队列和全连接队列，但内核有个全局的hash表，可以存放socket连接的信息，连接信息通过回环地址从这个全局hash表中取出，最后成功建立连接；&lt;/li&gt;
&lt;li&gt;不调用accept()方法，也能进行三次握手，建立连接，甚至，服务端在执行accept()方法前，如果客户端发送消息给服务端，服务端能正常回复ACK确认包的。因为accept()方法本身不参与握手，执行accept()只是为了从全连接队列里取出一条可用连接而已。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基于udp协议的socket&#34;&gt;基于UDP协议的Socket&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%9f%ba%e4%ba%8eUDP%e7%9a%84Socket.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%9f%ba%e4%ba%8eUDP%e7%9a%84Socket.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;基于UDP的Socket&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;基于UDP的Socket&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;服务端如何管理这些连接和资源？&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;父进程使用子进程来管理连接和资源，子进程在完成连接和数据通信后告诉父进程进行回收&lt;/li&gt;
&lt;li&gt;线程池 + 连接池，每个线程管理一个socket，连接池实现socket复用&lt;/li&gt;
&lt;li&gt;IO多路复用，一个线程维护多个socket，如Java NIO、Netty的网络模型&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;连接池实现&#34;&gt;连接池实现&lt;/h1&gt;
&lt;p&gt;写得真不错，清晰易懂 &lt;a class=&#34;link&#34; href=&#34;https://yusank.space/posts/conn-pool/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://yusank.space/posts/conn-pool/&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/jungle_hello/article/details/51465119&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TCP/IP参考1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_18425655/article/details/52163228&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TCP/IP参考2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;&#34; &gt;极客时间 - 趣谈网络协议&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://coolshell.cn/articles/11564.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TCP 的那些事儿&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://juejin.cn/post/6983639186146328607&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;面试必备！TCP协议经典十五连问！&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://xiaolincoding.com/network/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;小林coding - 图解网络&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://coolshell.cn/articles/11564.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://coolshell.cn/articles/11564.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://coolshell.cn/articles/11609.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://coolshell.cn/articles/11609.html&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>分布式相关</title>
        <link>http://nixum.cc/p/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3/</link>
        <pubDate>Fri, 14 Aug 2020 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/%E5%88%86%E5%B8%83%E5%BC%8F%E7%9B%B8%E5%85%B3/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;分布式理论&#34;&gt;分布式理论&lt;/h1&gt;
&lt;p&gt;一个分布式系统最多只能满足 C、A、P 这三项中的两项。&lt;/p&gt;
&lt;h2 id=&#34;cap理论&#34;&gt;CAP理论&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C：Consistency，一致性，数据状态转化一致，写操作完成后的读操作，可以&lt;strong&gt;获取到最新的值&lt;/strong&gt;；&lt;/li&gt;
&lt;li&gt;A：Availability，可用性，指的是服务一直可用，可以&lt;strong&gt;正常响应&lt;/strong&gt;，或者在规定时间内可以获取到响应；&lt;/li&gt;
&lt;li&gt;P：Partition tolerance，分区容错，指的是当有节点故障不连通时(比如网络出问题)，就会&lt;strong&gt;分区，但仍然能对外提供服务&lt;/strong&gt;；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;矛盾在于这三个特性不能同时满足，比如&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当分布式集群内有两个主从服务发生网络故障，但此时服务仍然可以访问，此时具有分区容错性。&lt;/p&gt;
&lt;p&gt;当对主服务对数据进行修改时，由于网络问题，无法同步到从服务，当访问到从服务时，无法获取到最新的值，此时满足可用性，但是无法满足一致性。&lt;/p&gt;
&lt;p&gt;当主从服务间网络恢复，写操作的数据虽然能在服务间同步了，但还未同步完成，此时访问从服务无法获取最新值，此时满足了一致性，但是无法满足可用性。&lt;/p&gt;
&lt;p&gt;简单概括，只要满足分区容错，就会设置复制集，复制集同时也保证了可用，但是复制集又会有数据同步，此时又有一致性问题&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以，一般只会满足其中两个&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、满足CA舍弃P，也就是满足一致性和可用性，舍弃容错性。但是这也就意味着你的系统不是分布式的了，因为涉及分布式的想法就是把功能分开，部署到不同的机器上，而且如果出现了分区错误，必定会导致部分功能不可用，此时也无法满足A，所以 P 其实是必然存在的，只有单机是CA。&lt;/p&gt;
&lt;p&gt;2、满足CP舍弃A，也就是满足一致性和容错性，舍弃可用性。如果你的系统允许有段时间的访问失效等问题，这个是可以满足的。就好比多个人并发买票，后台网络出现故障，你买的时候系统就崩溃了。真正的强一致性在做同步的过程中会阻塞所有请求，导致性能会特别差，此时可用性就降低了，所以像ZooKeeper这种允许同步到一半节点以上就算成功的，不算是真正的强一致性。&lt;/p&gt;
&lt;p&gt;3、满足AP舍弃C，也就是满足可用性和容错性，舍弃一致性。这也就是意味着你的系统在并发访问的时候可能会出现数据不一致的情况。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以为了分布式服务能正常使用，一般时会满足分区容错性和可用性，在一致性上不追求强一致性，而是一个逐渐一致的过程。&lt;/p&gt;
&lt;h2 id=&#34;base理论&#34;&gt;BASE理论&lt;/h2&gt;
&lt;p&gt;BASE理论是对CAP三者均衡的结果，基于CAP理论演化而来，通过牺牲强一致性来获得高可用。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Basically Available（基本可用）: 允许暂时不可用，比如访问时可以等待返回，服务降级，保证核心可用等。&lt;/li&gt;
&lt;li&gt;Soft state（软状态）: 允许系统存在中间状态，而该中间状态不会影响系统整体可用性，比如允许复制集副本间的数据存在延时，数据库的数据同步过程。&lt;/li&gt;
&lt;li&gt;Eventually consistent（最终一致性）: 系统中的所有数据副本经过一定时间后，最终能够达到一致的状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与数据库ACID类似，只是强度减弱了&lt;/p&gt;
&lt;p&gt;参考：&lt;a class=&#34;link&#34; href=&#34;&#34; &gt;CAP 定理的含义&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;关于可靠性可用性稳定性&#34;&gt;关于可靠性、可用性、稳定性&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可靠性Reliability&lt;/strong&gt;：不出事故，故障率低，关注的是系统无故障地持续运行的概率，比如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;MTBF（Mean Time Between Failure）：即平均无故障时间，是指从新的产品在规定的工作环境条件下开始工作到出现第一个故障的时间的平均值。MTBF越长表示可靠性越高，正确工作能力越强 。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MTTR（Mean Time To Repair）：即平均修复时间，是指可修复产品的平均修复时间，就是从出现故障到修复中间的这段时间。MTTR越短表示易恢复性越好。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MTTF（Mean Time To Failure）：即平均失效时间。系统平均能够正常运行多长时间，才发生一次故障。系统的可靠性越高，平均无故障时间越长。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;与可用性的关系：Availability = UpTime/(UpTime+DownTime) = MTBF / (MTBF + MTTR)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;可用性Availability&lt;/strong&gt;：不出事故，如果出事故可以快速恢复，关注的是服务运行持续时间，比如&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;通俗叫法&lt;/th&gt;
&lt;th&gt;可用性级别&lt;/th&gt;
&lt;th&gt;年度宕机时间&lt;/th&gt;
&lt;th&gt;周宕机时间&lt;/th&gt;
&lt;th&gt;每天宕机时间&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1个9&lt;/td&gt;
&lt;td&gt;90%&lt;/td&gt;
&lt;td&gt;36.5天&lt;/td&gt;
&lt;td&gt;16.8小时&lt;/td&gt;
&lt;td&gt;2.4小时&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2个9&lt;/td&gt;
&lt;td&gt;99%&lt;/td&gt;
&lt;td&gt;87.6小时&lt;/td&gt;
&lt;td&gt;1.68小时&lt;/td&gt;
&lt;td&gt;14分钟&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3个9&lt;/td&gt;
&lt;td&gt;99.9%&lt;/td&gt;
&lt;td&gt;8.76小时&lt;/td&gt;
&lt;td&gt;10.1分钟&lt;/td&gt;
&lt;td&gt;86秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4个9&lt;/td&gt;
&lt;td&gt;99.99%&lt;/td&gt;
&lt;td&gt;52.6分钟&lt;/td&gt;
&lt;td&gt;1.01分钟&lt;/td&gt;
&lt;td&gt;8.6秒&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5个9&lt;/td&gt;
&lt;td&gt;99.999%&lt;/td&gt;
&lt;td&gt;5.26分钟，315.36秒&lt;/td&gt;
&lt;td&gt;6.05秒&lt;/td&gt;
&lt;td&gt;0.86秒&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;稳定性Stability&lt;/strong&gt;：服务性能稳定，不时快时慢，关注的是在一个运行周期内，一定压力下，持续操作时间内的出错概率，性能优劣等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;分布式事务&#34;&gt;分布式事务&lt;/h1&gt;
&lt;h2 id=&#34;一2pc&#34;&gt;一、2PC&lt;/h2&gt;
&lt;p&gt;二阶段提交其实就是实现&lt;strong&gt;XA分布式事务&lt;/strong&gt;的关键&lt;/p&gt;
&lt;p&gt;需要有协调者和参与者，协调者负责调度，参与者负责执行，分两步完成，1：prepare阶段 2：commit阶段。&lt;/p&gt;
&lt;p&gt;2PC是&lt;strong&gt;强一致性&lt;/strong&gt;的，保证原子性和隔离性。在执行阶段，节点是处于阻塞状态，直到commit阶段完成，本地事务才会释放资源，因此性能不佳，一般用在强一致性、并发量不大的场景。&lt;/p&gt;
&lt;h3 id=&#34;正常情况下&#34;&gt;正常情况下&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;prepare阶段&lt;/strong&gt;：协调者向参与者A、B发送请求执行操作，参与者A、B开启事务，执行操作，但不commit，操作完成后，告诉协调者已经完成。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;commit阶段&lt;/strong&gt;：协调者收到参与者的完成响应，向参与者A、B发送commit请求，参与者A、B收到commit请求后，提交事务，完成操作；如果收到执行失败的响应，则发送回滚请求给参与者A、B，执行回滚。&lt;/p&gt;
&lt;h3 id=&#34;异常情况下&#34;&gt;异常情况下&lt;/h3&gt;
&lt;p&gt;在协调者等待参与者的完成响应时，协调者或参与者可能宕机，最终会导致数据不一致或阻塞，例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;：prepare阶段，协调者正常，参与者宕机，参与者没有收到询问请求，或者协调者没有收到参与者的回应&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;：协调者做超时处理，一旦超时，当作失败，向所有节点发送事务终止请求，或者发送重试请求；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;：commit阶段，正式提交发出后，如果有的参与者没有收到，或者参与者提交/回滚的确认信息没有返回，即参与者的回应超时&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决方法&lt;/strong&gt;：协调者或者参与者进行重试，或者把参与者标记为问题节点移除集群后回滚&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;：当处于commit阶段时，协调者挂掉或重启，会导致协调者收不到参与者的响应，此时协调者就不清楚commit阶段要发送什么请求过去，或者就不发请求过去了，导致参与者一直阻塞&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;：协调者维护一份事务日志，以方便宕机重启后恢复原来的状态，比如重新向参与者查询结果，但无法为参与者设置超时自动操作，因为它并不知道commit阶段自己要进行commit还是回滚&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;：当处于commit阶段时，参与者挂掉后，接收不到协调者的请求，不知道接下来要执行commit还是回滚，协调者也无法在参与者挂掉后进行回滚操作，因为也不知道参与者事务是否已经处理了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决办法&lt;/strong&gt;：不断重试，或者 3pc&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;缺点&#34;&gt;缺点&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;性能问题，参与者和协调者需要互相等待，只有当所有节点准备完毕，协调者才会进行全局提交，参与者进行本地事务后才会释放资源，阻塞时间长；&lt;/li&gt;
&lt;li&gt;单点故障，协调者一旦发生故障，参与者会一直阻塞；&lt;/li&gt;
&lt;li&gt;数据一致性问题，在commit阶段，如果一部分参与者收到提交请求，一部分收不到，此时数据不一致；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;二3pc&#34;&gt;二、3PC&lt;/h2&gt;
&lt;p&gt;3PC实际上就是将prepare阶段拆成两步，preCommit相当于一次保险阶段，作用类似于2PC的二阶段，但是它不是真正的提交。2PC只有协调者超时机制，参与者严重依赖协调者，而3PC引入了参与者超时的机制，使得参与者不用太过依赖协调者，自己有一定的处理权限，解决2PC在commit阶段，协调者在不能处理请求时，参与者一直阻塞的问题，3PC只是缓解了2PC阻塞时间过长的问题，本身也没有完全解决数据不一致的问题；&lt;/p&gt;
&lt;h3 id=&#34;正常情况下-1&#34;&gt;正常情况下&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;canCommit阶段&lt;/strong&gt;：协调者向所有参与者发送请求，参与者开启事务执行操作，将结果返回给协调者，成功完成后响应Yes，进入下一阶段，否则响应No，结束。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;preCommit阶段&lt;/strong&gt;：协调者收到所有参与者的Yes响应，进行本地事务，记录日志，然后发送处理结果的请求给所有参与者，告诉所有参与者进行预提交状态。&lt;/p&gt;
&lt;p&gt;如果参与者能收到PreCommit请求，意味着它知道大家都同意提交了，即使在commit阶段出现问题，参与者也可以在超时之后进行事务提交。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;commit阶段&lt;/strong&gt;：协调者收到所有参与者的应答响应，向所有参与者发送commit请求，参与者收到后提交事务，如果协调者发现部分参与者无法执行事务，则向所有参与者发生rollback请求，回滚事务。&lt;/p&gt;
&lt;h3 id=&#34;异常情况下-1&#34;&gt;异常情况下&lt;/h3&gt;
&lt;p&gt;如果在preCommit阶段到commit阶段之间，协调者挂了，参与者会在超时后进行事务提交，如果协调者的本意是要rollback，则会产生数据不一致的情况。&lt;/p&gt;
&lt;h2 id=&#34;三tcc&#34;&gt;三、TCC&lt;/h2&gt;
&lt;p&gt;补偿事务，每一个操作都要有对应的确认和补偿，类似于2pc，但2pc在于DB层面，TCC在于业务层面，每个业务逻辑都需要实现try-confirm-cancel的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Try阶段&lt;/strong&gt;：对于操作的数据行，增加字段表示其状态，表示正在操作，预留必须的资源；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Confirm阶段&lt;/strong&gt;：只操作预留资源，将try阶段中表示数据状态的字段修改为确认状态，表示已经完成操作，&lt;strong&gt;操作需要幂等；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Cancel阶段&lt;/strong&gt;：将try阶段进行的操作进行回滚，&lt;strong&gt;操作需要幂等；&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;通过不断重试，并发的时候还是需要分布式锁，TCC主要是保证业务逻辑的完整性。&lt;/p&gt;
&lt;p&gt;比如，在订单创建并减库存的场景中，&lt;/p&gt;
&lt;p&gt;Try阶段：订单创建时发出订单创建的事件，此时订单状态是创建中，库存服务接收到后，并不是直接减库存，而是先冻结库存，将要扣减的库存数冻结起来，订单创建完成；&lt;/p&gt;
&lt;p&gt;Confirm阶段：订单支付完成后，发出订单支付完成的事件，库存服务接收到后，才是真正的减库存&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/TCC_Try-Confirm%e6%b5%81%e7%a8%8b.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/TCC_Try-Confirm%e6%b5%81%e7%a8%8b.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Cancel阶段：如果在Try阶段出错，则对已执行Try请求的服务执行回滚，对库存进行回滚&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/TCC_Try-Cancel%e6%b5%81%e7%a8%8b.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/TCC_Try-Cancel%e6%b5%81%e7%a8%8b.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;tcc可能存在的问题&#34;&gt;TCC可能存在的问题&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;因为重试的存在，confirm和cancel需要保证幂等，可以使用事务记录表 + 状态来实现，confirm和cancel只有在存在事务记录，且状态为try时才能执行；&lt;/li&gt;
&lt;li&gt;try时，需要上锁保证并发安全，之后confirm和cancel就可以不用加锁直接完成，因为try时已经保证了数据的一致性；&lt;/li&gt;
&lt;li&gt;空回滚：可能网络或者其他原因，导致参与者cancel早于try之前被接收到（confirm则不会，因为confirm必定是try执行成果之后才会出现），此时可能产生空回滚，同样也可以使用事务记录表 + 状态来保证cancel时可以识别出是否已经执行过try操作；&lt;/li&gt;
&lt;li&gt;悬挂：可能因为网络超时等原因，参与者先cancel了，此时事务已经被判定结束，然后才接收到try，导致事务阶段一直处于try阶段，造成资源悬挂，同样也可以使用事务记录表 + 状态来解决，保证已结束的事务不会执行try操作；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;四本地消息表&#34;&gt;四、本地消息表&lt;/h2&gt;
&lt;p&gt;适合解决分布式最终一致性问题。&lt;/p&gt;
&lt;p&gt;事务性消息：本地事务和发送消息是原子性操作；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;正常情况下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;参与者A正常进行数据库事务并提交，将涉及到对参与者B的操作记录到本地消息表中，相当于一条日志，然后再用一个异步服务，读取该条日志，控制参与者B进行相关操作，完成之后更新这条本地消息的状态。&lt;/p&gt;
&lt;p&gt;异步消费操作可以利用RocketMQ事务；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：参与者A的数据库操作与日志记录是一个原子性操作&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;异常情况下&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果失败了直接重试即可，保证参与者A与B数据最终一致性。&lt;/p&gt;
&lt;p&gt;消费者在处理的时候要保证幂等。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/53324ea2df92&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.jianshu.com/p/53324ea2df92&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://blog.itpub.net/31556438/viewspace-2649246/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://blog.itpub.net/31556438/viewspace-2649246/&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;五saga&#34;&gt;五、SAGA&lt;/h2&gt;
&lt;p&gt;利用状态机实现，它将一系列分布式操作转化成一系列的本地事务，在每一个本地事务中我们都会更新数据库并且向集群中的其他服务发送一条新的消息来触发下一个本地事务；一旦本地事务因违法业务逻辑而失败，那就会立即触发一系列回滚操作来撤回之前本地事务造成的副作用。&lt;/p&gt;
&lt;p&gt;SAGA分为协同和编排两种模式，协同是非中心化的，通过各个服务的本地事务触发下一个服务的本地事务来实现；编排是通过一个中心化的协调节点，来追踪所有子任务的调用情况，根据任务的调用情况来决定调用对应的补偿方案，并在网络请求出现超时时进行重试；&lt;/p&gt;
&lt;h2 id=&#34;六简单通过可靠消息和最终一致性方案实现&#34;&gt;六、简单通过可靠消息和最终一致性方案实现&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%8f%af%e9%9d%a0%e6%80%a7%e6%b6%88%e6%81%af&amp;#43;%e6%9c%80%e7%bb%88%e4%b8%80%e8%87%b4%e6%80%a7%e7%9a%84%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%8f%af%e9%9d%a0%e6%80%a7%e6%b6%88%e6%81%af&amp;#43;%e6%9c%80%e7%bb%88%e4%b8%80%e8%87%b4%e6%80%a7%e7%9a%84%e5%88%86%e5%b8%83%e5%bc%8f%e4%ba%8b%e5%8a%a1.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;另外，&lt;strong&gt;在可靠消息服务中，更新数据库里的消息和将消息发送给MQ这一个步骤必须保证原子&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;一般可靠消息服务可以和MQ一起组合，待确认消息算半消息，其实这种实现就是RocketMQ&lt;/p&gt;
&lt;p&gt;注意点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;上游服务给可靠消息服务发送待确认消息的过程中出现问题，此时上游服务可以感知调用异常，就可以直接不执行之后的流程了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上游服务操作完本地数据库后，通知可靠消息服务确认消息或删除消息时出现问题，此时该消息在可靠消息服务里是待确认状态，在可靠消息服务里&lt;strong&gt;定时轮询待确认状态的消息，调用上游服务的接口判断这个消息的状态即可&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;如果上游响应该消息成功，可靠消息服务将消息投递到MQ即可，否则，将该消息删除。&lt;/p&gt;
&lt;p&gt;像RocketMQ就把这个操作做进了MQ里，这种待确认的消息就叫&lt;strong&gt;半消息&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下游服务一直消费消息一直失败，有两种方案：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; 1. 可以设置消息可被消费的次数，超过这个次数进死信队列，后面人工干预即可；
 2. 由于该条消息在可靠消息服务里一直是已发送状态，始终未完成，此时可靠消息服务在后台可以有定时任务，将这些消息重新丢到MQ里让下游消费即可，当然下游服务消息是需要保证幂等的；
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考：&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/21994882&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;2pc、3pc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://juejin.im/post/5bf201f7f265da610f63528a&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TCC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://yemablog.com/posts/tcc-1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;TCC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_42075590/article/details/89236625&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;华为的servicecomb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.sofastack.tech/blog/sofa-meetup-3-seata-retrospect/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;蚂蚁金服的seata分布式事务架构&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000040321750&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;分布式事务最经典的七种解决方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/yedf/dtm&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;一个go的分布式事务框架DTM&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.ruanyifeng.com/blog/2018/07/cap.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;http://www.ruanyifeng.com/blog/2018/07/cap.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/jajian/p/10014145.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/jajian/p/10014145.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/f98e8a8dae6d&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.jianshu.com/p/f98e8a8dae6d&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;分布式算法&#34;&gt;分布式算法&lt;/h1&gt;
&lt;p&gt;为了避免单点故障，常见的多副本复制方案有两种：&lt;/p&gt;
&lt;h2 id=&#34;去中心化复制如gossip&#34;&gt;去中心化复制，如Gossip&lt;/h2&gt;
&lt;p&gt;一个n个复制集节点的集群中，任意节点都可以接收写请求，但一个成功的写请求需要w个节点确认，读操作也必须查询至少r个节点。可用性高，但容易造成写冲突。&lt;/p&gt;
&lt;p&gt;简单来讲，就是一个节点会周期、随机的将事件广播给其他节点，其他节点收到后也会周期性的广播给其他节点，最终集群上所有节点都能收到消息，是一种去中心化，最终一致性的算法，压力不在来自主节点，而是所有节点都均衡负载，扩展性很好，即使有新节点加入，最终也会被广播到。&lt;/p&gt;
&lt;p&gt;当会有个拜占庭问题，就是如果有一个恶意传播节点，将会打乱原本的传播&lt;/p&gt;
&lt;p&gt;除了复制方案，另一种是共识算法如Paxos或Raft，保证集群节点高可用和数据一致性。&lt;/p&gt;
&lt;h2 id=&#34;主从复制如mysqlredis&#34;&gt;主从复制，如MySQL、Redis&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;全同步复制：主节点收到一个写请求后，必须等到全部从节点确认返回后，才能返回给客户端成功，一个节点故障将导致整个系统不可用。保证一致性，但可用性不高。&lt;/li&gt;
&lt;li&gt;异步复制：主节点收到一个写请求，立马返回给客户端，异步将请求转发给各个从节点，但主节点如果还未将请求进行转发就故障了，就会导致数据丢失。保证可用性，但一致性不高。&lt;/li&gt;
&lt;li&gt;半同步复制：主节点收到一个写请求后，至少有一个从节点或者超过半数节点收到数据，就可以返回客户端，在一致性和可用性上比较平衡。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;paxos算法&#34;&gt;Paxos算法&lt;/h2&gt;
&lt;h2 id=&#34;raft算法&#34;&gt;Raft算法&lt;/h2&gt;
&lt;p&gt;感觉像与ZAB协议类似，具体有时间再整理&lt;/p&gt;
&lt;p&gt;当Leader宕机之后，只有拥有最新日志的Follower才有资格称为Leader。&lt;/p&gt;
&lt;p&gt;关于日志检查，当Follower上的日志与leader不一致时，Leader先找到Follower同它日志一致的index，将其后边的日志一条条覆盖在Follower上。&lt;/p&gt;
&lt;p&gt;参考：&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/32052223&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Raft算法详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://raft.github.io/raftscope/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Raft动画演示&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;分布式锁&#34;&gt;分布式锁&lt;/h1&gt;
&lt;h2 id=&#34;利用数据库唯一约束&#34;&gt;利用数据库唯一约束&lt;/h2&gt;
&lt;p&gt;在数据库新建一个锁表，然后通过操作该表中的数据来实现，表的字段为客户端ID、加锁次数、资源的key，加锁次数 + 客户端ID可以判断是否可重入。&lt;/p&gt;
&lt;p&gt;当我们要锁住某个方法或资源的时候，我们就在该表中增加一条记录，想要释放锁的时候就删除这条记录。在insert前先query判断是否存在该记录。&lt;/p&gt;
&lt;p&gt;优点：简单，方便理解，且不需要维护额外的第三方中间件(比如Redis,Zk)。&lt;/p&gt;
&lt;p&gt;缺点：虽然容易理解但是实现起来较为繁琐，需要自己考虑锁超时，加事务等等。性能局限于数据库，一般对比缓存来说性能较低。对于高并发的场景并不是很适合。&lt;/p&gt;
&lt;h2 id=&#34;etcd实现&#34;&gt;etcd实现&lt;/h2&gt;
&lt;p&gt;etcd采用raft算法，一个写请求要经过集群多数节点确认，所以一旦分布式锁申请成功返回给client时，锁数据一定是持久化了集群多数节点上，不会出现Redis那种主备异步复制，当主机宕机，从机和主机数据不一致的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事务功能：etcd事务由IF、THEN、ELSE语句组成，可以比较key的修改版本号mod_revision和创建版本号create_revision，因此可以通过创建版本号create_revision检查key是否已存在，当key不存在时，创建版本号为0，此时可以进行put操作。&lt;/li&gt;
&lt;li&gt;Lease 功能：可以保证分布式锁的安全性，为锁对应的 key 配置租约，即使锁的持有者因故障而不能主动释放锁，锁也会因租约到期而自动释放，同时也支持续约。此特性解决了client出现crush故障，client与ectd集群网络出现隔离等场景下的死锁问题。一旦Lease TTL，key就会自动释放，确保其他client在TTL过期后能正常申请锁。&lt;/li&gt;
&lt;li&gt;watch功能：在实现分布式锁时，如果抢锁失败，可通过 Prefix 机制返回的 KeyValue 列表获得 Revision 比自己小且相差最小的 key（称为 pre-key），对 pre-key 进行监听，因为只有它释放锁，自己才能获得锁，如果 Watch 到 pre-key 的 DELETE 事件，则说明pre-ke已经释放，自己已经持有锁。&lt;/li&gt;
&lt;li&gt;prefix功能：例如，一个名为 /mylock 的锁，两个争抢它的客户端进行写操作，实际写入的 key 分别为：key1=”/mylock/UUID1″，key2=”/mylock/UUID2″，其中，UUID 表示全局唯一的 ID，确保两个 key 的唯一性。很显然，写操作都会成功，但返回的 Revision 不一样，通过前缀 /mylock 查询，返回包含两个 key-value 对的的 KeyValue 列表，同时也包含它们的 Revision，通过 Revision 大小，客户端可以判断自己是否获得锁，如果抢锁失败，则等待锁释放（对应的 key 被删除或者租约过期），然后再判断自己是否可以获得锁。并配合上一条的watch功能使用。&lt;/li&gt;
&lt;li&gt;reversion功能：如上一条所述，每个 key 带有一个 Revision 号，每进行一次事务加一，因此它是全局唯一的，如初始值为 0，进行一次 put(key, value)，key 的 Revision 变为 1；同样的操作，再进行一次，Revision 变为 2；换成 key1 进行 put(key1, value) 操作，Revision 将变为 3。多线程获取锁时，通过比较reversion的大小即可知道获取的顺序，避免&amp;quot;惊群效应&amp;quot;（指的是当锁被释放，会导致所有监听该key的client都尝试发起事务获取锁，性能较差）。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现的方案：通过多个client创建prefix相同，名称不同的key，哪个key的revision最小，谁就获得锁。&lt;/p&gt;
&lt;p&gt;etcd自带了concurrency包，简化分布式锁、分布式选举、分布式事务的实现。该包的分布式锁实现：当事务发现createRevision的值为0时，会创建一个prefix为/my-lock的key，key的名称为/my-lock+LeaseId，并获取/my-lock prefix下面最早创建的一个key，即revision最小，分布式锁最终由写入该key的client获得，其他client进入等待模式。未获得锁的client通过Watch机制监听prefix相同，revision比自己小的key，只有当revision比自己小的key释放了锁，才有机会获得锁。&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以通过lease功能和结点健康监测，确保客户端崩溃时，锁一定会被释放。&lt;/li&gt;
&lt;li&gt;etcd客户端etcd有相应锁实现，是否满足需求需要进一步查看源码。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强一致性带来的必定是写效率上的降低&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;zookeeper实现&#34;&gt;ZooKeeper实现&lt;/h2&gt;
&lt;p&gt;基于ZooKeeper的临时节点和顺序的特性。&lt;/p&gt;
&lt;p&gt;临时节点具备数据自动删除功能，当client与ZooKeeper连接和session断掉时，相应的临时节点就会被删除。&lt;/p&gt;
&lt;p&gt;另外，ZooKeeper也提供Watch特性监听key的变化。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;因为创建节点的唯一性，我们可以让多个客户端同时创建一个临时节点，创建成功的就说明获取到了锁 。然后没有获取到锁的客户端也像上面选主的非主节点创建一个 watcher 进行节点状态的监听，如果这个互斥锁被释放了（可能获取锁的客户端宕机了，或者那个客户端主动释放了锁）可以调用回调函数重新获得锁。&lt;/p&gt;
&lt;p&gt;共享锁：规定所有创建节点必须有序，当你是读请求（要获取共享锁）的话，如果 &lt;strong&gt;没有比自己更小的节点，或比自己小的节点都是读请求&lt;/strong&gt; ，则可以获取到读锁，然后就可以开始读了。&lt;strong&gt;若比自己小的节点中有写请求&lt;/strong&gt; ，则当前客户端无法获取到读锁，只能等待前面的写请求完成&lt;/p&gt;
&lt;p&gt;排他锁：如果你是写请求（获取独占锁），若 &lt;strong&gt;没有比自己更小的节点&lt;/strong&gt; ，则表示当前客户端可以直接获取到写锁，对数据进行修改。若发现 &lt;strong&gt;有比自己更小的节点，无论是读操作还是写操作，当前客户端都无法获取到写锁&lt;/strong&gt; ，等待所有前面的操作完成&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;redis实现&#34;&gt;Redis实现&lt;/h2&gt;
&lt;h3 id=&#34;单机redis实现&#34;&gt;单机Redis实现&lt;/h3&gt;
&lt;p&gt;使用setnx命令，setnx命令表示如果key不存在，则可以set成功，返回1，否则返回0，根据返回值来判断是否加锁成功，注意setnx不支持设置key、value的同时还要设置过期时间，过期时间主要是保证资源占用时间过长后可以释放锁，避免死锁，所以如果要用来加锁，必须使用Lua脚本来保证原子性&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span class=&#34;kr&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redis.call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;setnx&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KEYS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KEYS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;then&lt;/span&gt;
  &lt;span class=&#34;n&#34;&gt;redis.call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;expire&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KEYS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KEYS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;span class=&#34;kr&#34;&gt;end&lt;/span&gt;

&lt;span class=&#34;kr&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ok&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;不过从2.6.12起，set涵盖了setex、setnx功能，并且set本身可以设置过期时间，因此可以使用以下命令进行加锁&lt;/p&gt;
&lt;p&gt;命令：&lt;code&gt;SET [key: 资源代表的key] [value: 客户端事务Id] NX PX [时间，EX的单位是秒，PX的单位是毫秒] &lt;/code&gt;，要注意旧版本的setnx命令不支持设置过期时间&lt;/p&gt;
&lt;p&gt;解锁，先判断锁是不是自己加的，如果是才可以解锁，即删除该key，需要保证这两个步骤的原子性，否则可能会出现因为查询时间过长导致删掉了别人的锁&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span class=&#34;kr&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redis.call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;get&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KEYS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ARGV&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;then&lt;/span&gt;
    &lt;span class=&#34;kr&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redis.call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;del&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KEYS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;span class=&#34;kr&#34;&gt;else&lt;/span&gt;
    &lt;span class=&#34;kr&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;span class=&#34;kr&#34;&gt;end&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;为了保证Redis的高可用，就会部署Redis集群，但在集群环境下还使用上述方案可能会出现锁偶尔失效。比如Redis设置主从节点，一般加锁解锁会在主节点上进行，但是当加锁后，主节点宕机，从节点还未进行同步，从节点提升为主节点，其他服务就有机会获取到锁了，此时就出现了多个服务对同一资源的操作问题；另外，当发生网络分区现象时，Redis可能出现脑裂，出现多个master，使得多个client可以获得锁。&lt;/p&gt;
&lt;h3 id=&#34;集群redis实现&#34;&gt;集群Redis实现&lt;/h3&gt;
&lt;p&gt;RedLock与Redission实现，有空再进行补充，先把RedLock的基本思想简单描述一下&lt;/p&gt;
&lt;p&gt;假设有5个Redis节点，&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;加锁时，顺序在5个节点上申请锁，使用同样的key、value、超时时间，申请锁的超时时间，因为需要同时请求多个节点，避免加锁时间花费过长&lt;/li&gt;
&lt;li&gt;当在3个节点上成功申请到锁，且申请锁消耗的时间 小于 锁的有效时间，就算申请成功。申请锁消耗的时间采用获得锁的当下时间减去加锁请求时的时间戳得到&lt;/li&gt;
&lt;li&gt;锁申请到后，锁的有效时间 = 锁的过期时间 - 申请锁获得的时间&lt;/li&gt;
&lt;li&gt;如果申请锁失败了，申请成功锁的节点会执行解锁操作，进行重置&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://zhangtielei.com/posts/blog-redlock-reasoning.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RedLock算法的争议&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;分布式自增id&#34;&gt;分布式自增id&lt;/h1&gt;
&lt;h2 id=&#34;数据库自增id&#34;&gt;数据库自增id&lt;/h2&gt;
&lt;p&gt;利用MySQL的自增id来实现，服务在需要用到自增id时，会向MySQL发送请求。通过事务的方式，先增长id再进行查询&lt;/p&gt;
&lt;p&gt;优点：简单方便&lt;/p&gt;
&lt;p&gt;缺点：性能不是很好，还有一个是可用性问题，如果数据库不可用了，会导致其他服务不可用，如果使用主从方式部署，虽然可靠性提升了，但如果主库挂掉后，从库数据没有及时同步，会出现ID重复&lt;/p&gt;
&lt;p&gt;解决：使用双主模式，两个主节点的自增序列错开，比如设置节点A的起始值为1，步长为2，节点B的起始值为2，不出为2。但是这种方案又有一个缺点，那就是扩展性不好，假如两个节点不够用了，第三个节点加入时的起始值和步长不好设置&lt;/p&gt;
&lt;p&gt;解决：客户端通过号段的方式来获取自增id，每次从数据库获取时不再是获取一个，而是获取一段范围内的一批id，缓存在本地，减少IO和竞争&lt;/p&gt;
&lt;h2 id=&#34;分段--发号器&#34;&gt;分段 + 发号器&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tech.meituan.com/2017/04/21/mt-leaf.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;参考美团的Leaf方案&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Leaf是基于MySQL的分布式ID生成方案，简单总结如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Leaf为不同的业务设定一个tag，定义不同的号段长和初始值，每个业务获取ID都相互隔离，互不影响；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Leaf发号时是发给proxy，每次发一个号段，以减少MySQL的写压力，proxy会把获取到的号段做缓存；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有了proxy之后如果要对发号器(Leaf)做扩展，直接扩展proxy，并且多分配一些号段即可，无需变更MySQL；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;proxy会在号段内号的数量剩余10%时获取下一批，以避免并发获取时卡顿，还能及时补充号源，不怕DB宕机；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;proxy消耗完一个号段后，从DB上更新号段，获取下一个范围的号段；&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;k&#34;&gt;Begin&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;UPDATE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;table&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SET&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max_id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max_id&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;step&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WHERE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;biz_tag&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;test_tag&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;SELECT&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tag&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;max_id&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;step&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;FROM&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;table&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;WHERE&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;biz_tag&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;test_tag&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;Commit&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;另一种方案可参考&lt;a class=&#34;link&#34; href=&#34;https://tech.youzan.com/id_generator/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;有赞&lt;/a&gt;，总结一下就是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;发号器主备部署，对外只有一个实例提供服务，发号器本身的高可用也是通过etcd来实现；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生成的id存储在etcd，使得发号器本身无状态，利用etcd的cp特性，保证数据的一致性，同时也可以解决数据库主从同步导致的id重复问题；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;号的生成有两种方式：全局单调自增、类雪花id 两种方案，生成一批id后缓存到本机内存中，有请求进来就发一个id；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发号器预先生成一批id，异步持久化到etcd，复制到半数乃至全部机器上；如果id消耗速度快于异步持久化速度，此时会阻塞；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;利用etcd实现发号器的高可用方案：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;March 的高可用是利用 etcd 的 ttl 和 watch 实现的。启动时，先尝试创建一个新的带 ttl 的 Node。如果成功，就成为了主节点；如果由于已存在而失败，就成为了备节点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;主节点&lt;/p&gt;
&lt;p&gt;定时用前一次请求返回的 index 刷新 Node 的 ttl，保持自己的主节点角色。发现刷新失败时，说明主节点角色已经被抢走，从抢主节点过程重新开始。与此同时，还会等待 demote 请求。收到 demote 请求时，会等待新的主节点信息，然后将自己置为备节点。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;备节点&lt;/p&gt;
&lt;p&gt;先查询主节点的信息。在备节点收到发号请求时，会按 Redis Cluster 协议重定向到主节点。之后就开始 Watch Node 的变化。检测到变化后，也开始抢主节点过程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这样，可以做到在主节点发生故障时，最多等待一个 ttl 就能检测到，并完成切换。而在主动切换时，结合客户端，可以做到完全无损，只有毫秒级的阻塞。&lt;/p&gt;
&lt;p&gt;此外，每个节点都会存保存各自的带 ttl 的节点信息，同时定时刷新，用于返回给客户端集群信息。每个发号器在每次持久化时，也会携带上上一次持久化获得的 index。一旦不匹配出错，也会将自身重置为备节点。这可以避免网络堵塞或进程僵死造成原主失效而自身却不知道。在发生非预期错误时，HA goroutine 会等待 2 * ttl，以免不断出错造成死循环。此外，备节点也需要能够完成用户认证。但因为认证是不能重定向的，所以还需要检测 etcd 上的用户信息变化，重新同步用户数据。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;雪花算法&#34;&gt;雪花算法&lt;/h2&gt;
&lt;p&gt;分布式ID固定是一个long类型的数字，占64位，通过一定的规则编排这64位来实现&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;-------------------------------------------------------------------
|  bit   | 66 |           65 ~ 24        |  23 ~ 13  |   12 ~ 1   |
| length | 1  |             41           |    10     |     12     |
|  part  |none|         timestamp        |  machine  |  sequence  |
-------------------------------------------------------------------
41位的时间戳可以使用69年，41位的时间戳是精确到毫秒级别的
12位的序列号可以让同一个节点一毫秒内生产4096个ID
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一般可以自己调整时间戳、机器id、序列号的位数来控制ID的并发量、使用年限等，满足不同的场景，机器ID可以自己配置在节点上、配置中心、数据库。&lt;/p&gt;
&lt;p&gt;优点：简单方便，整型易操作，有需要还可以将整型进行进制转化，转成字符串类型的id&lt;/p&gt;
&lt;p&gt;缺点：因为使用到了时间，如果节点上的时钟回拨，会导致ID重复；如果服务部署在docker内，获取时间和机器id要注意；由于机器不同，生成的id是自增的，但是不一定连续；而且还有个问题，前端js是没有long类型的，整型最多支持53位，所以如果返回给前端还要做一次转化。&lt;/p&gt;
&lt;p&gt;可以允许 sequence 段溢出，溢出的部分会加到 timestamp 段上去，这样即使在时间戳精度范围内 sequence 耗尽了，也不用阻塞请求，同时也确保即使机器时钟回拨导致的id重复，但这种有个坏处是无法通过id解析出正确的时间戳。&lt;/p&gt;
&lt;h2 id=&#34;利用etcd&#34;&gt;利用ETCD&lt;/h2&gt;
&lt;p&gt;etcd 能满足不会丢失的，多副本，强一致的全部需求。两种方案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;利用ETCD实现分布式锁，对存储在ETCD中的自增ID加锁实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;利用ETCD的boltdb，boltdb是一个单机支持事务的KV存储，key是reversion，value是key-value，bolted会把每个版本都保存下来，实现多版本机制&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;用etcdctl通过批量接口写入两条记录：

etcdctl txn &amp;lt;&amp;lt;&amp;lt;&#39;
  put key1 &amp;quot;v1&amp;quot;
  put key2 &amp;quot;v2&amp;quot;

再通过批量接口更新这两条记录：
etcdctl txn &amp;lt;&amp;lt;&amp;lt;&#39;
  put key1 &amp;quot;v12&amp;quot;
  put key2 &amp;quot;v22&amp;quot;

boltdb中其实有了4条数据：
rev={3 0}, key=key1, value=&amp;quot;v1&amp;quot;
rev={3 1}, key=key2, value=&amp;quot;v2&amp;quot;
rev={4 0}, key=key1, value=&amp;quot;v12&amp;quot;
rev={4 1}, key=key2, value=&amp;quot;v22&amp;quot;

此时可以发现reversion由两部分组成，第一部分为main rev，每次事务进行会加一，第二部分sub rev，同一个事务中每次操作加一。另外ETCD提供了命令和选项来控制存储的空间问题
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;利用zookeeper&#34;&gt;利用ZooKeeper&lt;/h2&gt;
&lt;p&gt;利用ZooKeeper的顺序一致性和原子性，当客户端每次需要自增id时，创建一个持节顺序节点，ZooKeeper为了保证有序，会给这些节点编号，同时ZooKeeper会保证并发时不会产生冲突，创建成功后会返回类似/root/generateid0000000001的结果，再进行截取即可，另外，为了保证不浪费空间，可以用完该znode后进行删除。&lt;/p&gt;
&lt;p&gt;缺点：ZooKeeper是CP，不保证完全高可用，另外，由于数据需要再ZooKeeper间进行过半数同步完才算写入成功，性能也一般&lt;/p&gt;
&lt;h2 id=&#34;利用redis&#34;&gt;利用Redis&lt;/h2&gt;
&lt;p&gt;使用Redis的incr命令来实现原子性的自增和返回&lt;/p&gt;
&lt;p&gt;优点：简单方便&lt;/p&gt;
&lt;p&gt;缺点：需要对id进行持久化，虽然Redis本身提供了RDB和AOF，但如果宕机了，仍然有可能出现重复ID，如果为Redis搭建集群，由于Redis主从复制时异步复制的，无法保证master宕机之前将最新的id同步给其他子节点，导致宕机恢复之后可能会产生重复的id，需要针对这种情况做特殊处理，比如当id重复时报特殊错误码，跳过这个错误的id区间。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>微服务</title>
        <link>http://nixum.cc/p/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</link>
        <pubDate>Wed, 20 Oct 2021 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;一些概念理解&#34;&gt;一些概念理解&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;微服务：http://dockone.io/article/3687&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;中间件（Middleware）：是处于操作系统和应用程序之间的软件，用来屏蔽底层的技术细节，以自身的复杂性换来了应用程序开发的简单。广义中间件的定义是非常广泛的，比如消息、注册配置中心、网关、数据库访问、集成平台等等，都属于中间件的范畴。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;云原生：应用程序从设计之初即考虑到云的环境，原生为云而设计，在云上以最佳状态运行，充分利用和发挥云平台的弹性和分布式优势。代表技术包括容器、服务网格、微服务、不可变基础设施和声明式API（如K8s），组合起来就算服务容器化，整体使用微服务架构，应用支持容器编排调度。&lt;/p&gt;
&lt;p&gt;云原生的本质其实是&lt;strong&gt;基础设施与业务的解耦，以及基础设施自身的标准化&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IaaS：基础结构即服务，基础设施，如AWS的EC2、S3等，只提供比较原始的硬件功能，用户不用买服务器，自己去构建网络，防火墙、硬盘存储等基础设施，即提供基础环境配备。剩下的由用户自己完成。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;PaaS：平台即服务，中间件、解决方案、工具和服务的集合，如AWS的DocDB、Redis、SQS、SNS等设施，让用户更专注自己业务逻辑的开发，对于使用的工具，拿来即用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;FaaS：功能即服务，service less，如AWS的lambda，用户只需要写对应的业务方法就能提供对应的服务，其他都不用管&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SaaS：软件即服务，应用层面了，比如Shopify、moka，提供某一业务领域的解决方案，直接注册使用即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DevOps：一种模式，与敏捷挂钩，集文化理念、实践和工具于一身，快速迭代和部署，提供组织快速交付应用的能力。自动化部署、自动化运维，适合敏捷开发和快速迭代，解决传统开发和运维相互独立，沟通频繁，效率低等问题&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;限流&#34;&gt;限流&lt;/h1&gt;
&lt;p&gt;下面的方案都是单机版本的，在分布式环境下可以把限流的实例放到Redis里，或者直接使用Lua脚本实现，保证并发安全。&lt;/p&gt;
&lt;h2 id=&#34;固定窗口&#34;&gt;固定窗口&lt;/h2&gt;
&lt;p&gt;规定单位时间内可访问的次数，比如规定接口一分钟内只能访问10次，以第一次请求为起始，计数1，一分钟内计数超过10后，后续的请求直接拒绝，只能等到这一分钟结束后，重置计数，重新开始计数。&lt;/p&gt;
&lt;p&gt;但是这样有个问题，如果在大部分请求集中在第一个窗口的后10s内，和第二个窗口的前10s内，虽然他们都符合限流策略，但是在临界的20s内，请求还是有可能压垮系统。&lt;/p&gt;
&lt;p&gt;算法Demo：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;fixWinLimiter&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;            &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;maxLimitCount&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 最大限制数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;currentCount&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 当前计数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;fixInterval&lt;/span&gt;      &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 为了简化，单位设置为秒
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;lastReqStartAt&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 秒级时间戳
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewFixWinLimit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fixInterval&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;maxLimitCount&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fixWinLimiter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fixWinLimiter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;           &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;maxLimitCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;maxLimitCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;fixInterval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;fixInterval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fixWinLimiter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;IsPass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;now&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;now&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lastReqStartAt&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fixInterval&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentCount&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lastReqStartAt&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;now&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentCount&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;maxLimitCount&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentCount&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 测试
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 10s内只允许通过10次
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;f1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewFixWinLimit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;IsPass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;pass: %d&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;no pass: %d&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;滑动窗口&#34;&gt;滑动窗口&lt;/h2&gt;
&lt;p&gt;与固定窗口类似，只是以时间片划分，比如规定窗口一秒内只能请求5次，每次请求时会按照前一秒内的请求数量进行判断，超过则拒绝。&lt;/p&gt;
&lt;p&gt;这种算法本质上只是把固定窗口计数限流的时间片变小了，仍然有可能出现固定窗口计数限流的临界点问题。&lt;/p&gt;
&lt;p&gt;算法Demo：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;slidingWinLimiter&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;          &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;limitInterval&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 限制的时间间隔
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;lastReqAt&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 上一次请求的时间
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;winCount&lt;/span&gt;           &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 窗口计数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;currentWinIndex&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 当前窗口索引
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;currentWinMaxLimit&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 当前窗口最大限制数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;winNum&lt;/span&gt;             &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 窗口数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewSlidingWinLimiter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;limitInterval&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;winMaxLimitCount&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;winNum&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;slidingWinLimiter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;slidingWinLimiter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;               &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;limitInterval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;limitInterval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;lastReqAt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;          &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;winCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;           &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;winNum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;currentWinMaxLimit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;winMaxLimitCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;winNum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;             &lt;span class=&#34;nx&#34;&gt;winNum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;slidingWinLimiter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;IsPass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;now&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 每个窗口的时间间隔
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;eachWinInterval&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;float64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;limitInterval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;float64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;winNum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 判断前后两次请求的时间差是否在当前窗口内，不是则重置当前窗口，使用下一个窗口
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;float64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;now&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lastReqAt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;eachWinInterval&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;winCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentWinIndex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentWinIndex&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentWinIndex&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;%&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;winNum&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lastReqAt&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;now&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 判断是否超过当前窗口的限制
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;winCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentWinIndex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentWinMaxLimit&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;winCount&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentWinIndex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;f1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewSlidingWinLimiter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;IsPass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;pass: %d&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;no pass: %d&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;漏桶&#34;&gt;漏桶&lt;/h2&gt;
&lt;p&gt;控制流水，水(请求)持续加入桶中，底部以恒定速度流出，如果加水速度大于漏出速度，水则溢出，请求拒绝。即宽进严出，无论请求多少，请求的速率有多大，都按照固定的速率流出。&lt;/p&gt;
&lt;p&gt;优点：能够确保资源不会瞬间耗尽，避免请求处理发生阻塞现象，还能保护被系统调用的外部服务，让其免受突发请求的冲击。&lt;/p&gt;
&lt;p&gt;缺点：对于突发请求仍然会以一个恒定的速率进行处理，其灵活性会弱一些，容易发生突然请求超过漏桶容量，导致后续请求被直接丢弃。&lt;/p&gt;
&lt;p&gt;一般用在对第三方提供服务的请求限制上，比如我们服务接入shopify的服务，为了不触发shopify的限流，就可以使用漏桶算法。&lt;/p&gt;
&lt;p&gt;算法Demo：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bucketLimiter&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;          &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;lastReqAt&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 单位：秒
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;bucketCap&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 桶的容量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;bucketBalance&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 桶的余量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;rate&lt;/span&gt;          &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 每时间单位内漏桶的漏出速率
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewBucketLimiter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rate&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bucketCap&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucketLimiter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucketLimiter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;          &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;bucketCap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;nx&#34;&gt;bucketCap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;bucketBalance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;rate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;          &lt;span class=&#34;nx&#34;&gt;rate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;lastReqAt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucketLimiter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;IsPass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;now&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 计算时间差内可通过的计数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;diffInterval&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;now&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lastReqAt&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;diffCount&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;diffInterval&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rate&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 计算桶中剩余的量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucketBalance&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;diffCount&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucketBalance&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucketBalance&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lastReqAt&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;now&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 判断是否加水后是否溢出
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucketBalance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucketCap&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;bucketBalance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 测试
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    	&lt;span class=&#34;c1&#34;&gt;// 单位时间内漏出速度是2，桶的容量是5
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;f1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewBucketLimiter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;IsPass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;pass: %d&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;no pass: %d&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;令牌桶&#34;&gt;令牌桶&lt;/h2&gt;
&lt;p&gt;类似信号量，令牌桶会单独维护一个令牌的存储桶，为这个桶设置一个上限，同时又会有令牌持续将放入桶中，以应对一定的突发流量，比如桶的上限是1000，每秒持续放入1000个令牌，当前1s有800个请求发生并消耗令牌，由于每秒会放入1000个令牌，后1s就有1200个令牌可以被消耗，因此下一秒可以应对1200个请求。&lt;/p&gt;
&lt;p&gt;优点：在限制平均流入速率的同时，还能面对突发请求，确保资源被充分利用，不会被闲置浪费。&lt;/p&gt;
&lt;p&gt;缺点：舍弃处理速率的强控制力，如果某些功能依赖外部服务，可能会让外部服务无法承受压力，导致无法正常返回，还浪费此次获取的令牌。&lt;/p&gt;
&lt;p&gt;漏桶和令牌桶的区别：漏桶是限制流出速度，令牌桶是限制流入速度。&lt;/p&gt;
&lt;p&gt;算法Demo：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;tokenLimiter&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;           &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;lastReqAt&lt;/span&gt;      &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 单位：秒
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;availableToken&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 可用的令牌数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;maxTokenLimit&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 最大令牌数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;rate&lt;/span&gt;           &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 每时间单位内token的加入速率
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewTokenLimiter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rate&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;maxTokenLimit&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tokenLimiter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tokenLimiter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;           &lt;span class=&#34;nb&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Mutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;lastReqAt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;maxTokenLimit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;maxTokenLimit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;availableToken&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;maxTokenLimit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;rate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;           &lt;span class=&#34;nx&#34;&gt;rate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tokenLimiter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;IsPass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;now&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Now&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 计算时间差内可通过的计数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;diffInterval&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;now&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lastReqAt&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;diffCount&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;diffInterval&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;rate&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 把可通过的量加入令牌桶里
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;availableToken&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;diffCount&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;availableToken&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;maxTokenLimit&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;availableToken&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;maxTokenLimit&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lastReqAt&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;now&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 判断是否有令牌可取
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;availableToken&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;t&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;availableToken&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;--&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 测试
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    	&lt;span class=&#34;c1&#34;&gt;// 单位时间内漏出速度是2，桶的容量是5
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;f1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewTokenLimiter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;go&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;IsPass&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;pass: %d&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
				&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Println&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;no pass: %d&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
			&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sleep&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;time&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Second&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;容错&#34;&gt;容错&lt;/h1&gt;
&lt;p&gt;一旦发现上游服务调用失败，为了进一步减少错误的影响，可以设置容错策略&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;FailFast 快速失败：当消费者调用远程服务失败时，立即报错，消费者只发起一次调用请求。&lt;/li&gt;
&lt;li&gt;FailOver 失败自动切换：当消费者调用远程服务失败时，重新尝试调用服务，重试的次数一般需要指定，防止无限次重试。&lt;/li&gt;
&lt;li&gt;FailSafe 失败安全：当消费者调用远程服务失败时，直接忽略，请求正常返回报成功。一般用于可有可无的服务调用。&lt;/li&gt;
&lt;li&gt;FailBack 失败自动恢复：当消费者调用远程服务失败时，定时重发请求。一般用于消息通知。&lt;/li&gt;
&lt;li&gt;Forking 并行调用：消费者同时调用多个远程服务，任一成功响应则返回。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;熔断&#34;&gt;熔断&lt;/h1&gt;
&lt;p&gt;作用：防止下游服务不断地尝试可能超时和失败的服务，能达到应用程序执行而不必等待上游服务修正错误；下游服务可以自我诊断上游服务的错误是否已修正，如果没有，则不放量，如果有，则会慢慢增加请求，再次尝试调用。&lt;/p&gt;
&lt;p&gt;上游服务是指那些不依赖于任何其他服务的服务，而下游服务依赖于上游服务的服务。&lt;/p&gt;
&lt;p&gt;熔断一般分为三种状态：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Closed关闭：服务正常时，熔断处于关闭状态&lt;/li&gt;
&lt;li&gt;Open开启：当我们设定10s的滑动窗口内错误率达90%，则从Closed变为Open状态&lt;/li&gt;
&lt;li&gt;HalfOpen半开启：再经过10s的窗口期，此时从Open状态转为HalfOpen状态，按照 &lt;code&gt;0.5 * (Now() - Start()) / Duration &lt;/code&gt;的公式放量，直到成功率变为90%，转为Closed状态，否则转为Open状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;滑动窗口的时间不能设置太长，否则熔断恢复时间也会变长；错误统计只统计系统异常不通知业务异常。&lt;/p&gt;
&lt;h1 id=&#34;降级&#34;&gt;降级&lt;/h1&gt;
&lt;p&gt;作用：解决资源不足喝访问量增加的矛盾。在有限资源下，放弃部分无关紧要的服务，保证主业务流程能平稳运行。&lt;/p&gt;
&lt;p&gt;降级一般可以是将部分功能关闭，简化，或者将强一致性变成最终一致性。&lt;/p&gt;
&lt;h1 id=&#34;负载均衡&#34;&gt;负载均衡&lt;/h1&gt;
&lt;h2 id=&#34;常用算法&#34;&gt;常用算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;随机轮询：在可用的服务中，随机选择一个进行调用，因为每个随机数生成的概率是一致的，所以可以保证每个服务访问概率一致，一般用在服务性能差别不大，请求量远超服务节点数量的场景，保证各个服务被访问的概率相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;顺序轮询：按请求的顺序分配给各个服务器，适用于各台服务器性能相同，适用于服务各个实例性能平等且无状态的场景，如果每个服务性能不一致，可以改成动态加权轮询的方式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加权轮询：给各个服务器附上权重值，按权重的高低分配请求，适用于各台服务器性能不同，性能高的服务器权重也高&lt;/p&gt;
&lt;p&gt;静态加权轮询：服务启动时就设定好权重值，按权重值进行轮询&lt;/p&gt;
&lt;p&gt;动态加权轮询：需要客户端维护每个服务性能统计快照，并且每个一段时间更新这个快照，根据这个快照动态更新权重值，按权重值进行轮询，缺点是统计这些数据的时候存在一定的滞后性；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加权随机轮询：随机 + 二分查找的方式负载均衡，时间复杂度为O(logn)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最少链接：将请求发送给当前最少连接数的服务器上，一般来说，连接数少，说明服务空闲，向空闲的服务发送请求，获取更快响应速度，适用于服务节点性能差异较大，不好设置权重值的场景；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;加权最少链接：在最少连接的基础上，根据服务器的性能为每台服务器分配权重，再根据权重计算出每台服务器能处理的连接数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最小响应时间轮询：客户端需要记录每个服务所需的请求，得出平均的响应时间，然后根据响应时间选择最小响应时间，进行轮询，缺点是统计这些数据的时候存在一定的滞后性；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;IP地址哈希：哈希均匀分布&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二次随机选择轮询：适合后端节点权重一致的情况，通过两次随机算法，获取到两个节点，对比节点CPU等信息，选择最优节点；（比较流行）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;会话保持：根据客户端IP或cookie进行会话保持，同一个客户端每次选取后端节点的IP保持一致，适用于节点保持登录验证会话的场景，比较少用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;负载不均衡可能的原因&#34;&gt;负载不均衡可能的原因&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;长连接 + 多路复用&lt;/li&gt;
&lt;li&gt;开启会话保持&lt;/li&gt;
&lt;li&gt;服务端健康检测异常，导致客户端误以为服务端出现问题，没有均衡请求&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;通常的解决办法是根据服务端状态加权&lt;/p&gt;
&lt;h2 id=&#34;探活&#34;&gt;探活&lt;/h2&gt;
&lt;p&gt;负载均衡器上面一般会挂一个服务的多个复制集，进行流量的负载均衡，因此需要检查这多个复制集的健康情况，保证流量能正确路由到可用节点上。&lt;/p&gt;
&lt;h3 id=&#34;主动健康检查&#34;&gt;主动健康检查&lt;/h3&gt;
&lt;p&gt;设定一定时间间隔内对各个复制集执行ping操作，一般在获取节点数量过少的场景下才触发，避免长时间频繁的ping操作增加节点负担。&lt;/p&gt;
&lt;p&gt;比如通过当前节点数与15分钟前的节点数的比较，当小于80%时触发主动健康检查。&lt;/p&gt;
&lt;h3 id=&#34;被动健康检查&#34;&gt;被动健康检查&lt;/h3&gt;
&lt;p&gt;通过检查节点真实流量的响应结果，判断节点是否正常&lt;/p&gt;
&lt;h1 id=&#34;服务注册与发现&#34;&gt;服务注册与发现&lt;/h1&gt;
&lt;h2 id=&#34;调用模式&#34;&gt;调用模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;调用方发现模式&lt;/p&gt;
&lt;p&gt;由一个服务发现系统和其提供得SDK组成，SDK由调用方使用，同时SDK也可以提供负载均衡和故障转移等功能；代表例子：Eureka&lt;/p&gt;
&lt;p&gt;各个调用方在启动时会向服务发现系统注册其实例信息，比如ip、port、serviceName等，待到调用方需要调用其他服务时，便根据被调用方服务的名称去服务发现服务查询对应的ip和port，发起请求。&lt;/p&gt;
&lt;p&gt;这种方式有个缺点，就是调用方可能有多个实例，而SDK只能针对一个调用方做负载均衡，多实例下仍然有可能导致请求负载不均衡；可能还需要准备多种语言的SDK。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务端发现模式&lt;/p&gt;
&lt;p&gt;由一个专门的load balancer服务与服务发现系统配合，该load balancer服务会实时订阅服务发现系统中各个节点的信息，起到一个反向代理的作用，将收到的请求分发到对应的服务。代表例子：kube-proxy，在Kubernetes中，各个节点上会运行一个kube-proxy，kube-proxy会实时watch Service和Endpoint对象，当其配置发生变化后，会在各自的Node节点设置相关的iptables或IPVS规则，便于Pod内的服务通过service的clusterIP，经过iptables或IPCS设置的规则进行路由和转发。&lt;/p&gt;
&lt;p&gt;这种方式的好处是调用方无需感知服务发现系统，所有服务发现相关的功能都被隔离在load balancer和服务发现系统之间，但是会多一层转发，也就多一次延迟，多一次发生故障的机会。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基本功能&#34;&gt;基本功能&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;提供服务地址与域名的映射注册、查找和更新&lt;/p&gt;
&lt;p&gt;订阅机制有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;服务发现系统push推送，可以基于socket长连接推送，比如Zookeeper；基于HTTP连接的Long Polling，将各个服务的注册信息推送给各个节点，但是这种长连接的方式会存在消息丢失问题。&lt;/li&gt;
&lt;li&gt;调用方SDK定时轮询，向服务发现系统拉取各个节点的注册信息，但可能存在延迟问题&lt;/li&gt;
&lt;li&gt;以上两种方式相结合，比如Consul，调用方和服务发现系统间会建立一个最长30s的HTTP长连接，如果发生变更，调用方就会立即收到推送，如果超过30s，调用方会立即建立新连接，开始新一轮订阅。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;提供多种负载均衡方案&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;健康检查，比如心跳检测&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;服务主动探活&lt;/strong&gt;：服务注册到注册中心后，定时发送续租请求到注册中心，表明自己存活&lt;/p&gt;
&lt;p&gt;优点：该方案可最大程度&lt;strong&gt;避免IP重用&lt;/strong&gt;导致的节点在旧服务依然存活的问题(比如k8s环境)&lt;/p&gt;
&lt;p&gt;缺点：造成注册中心写操作变多，特别是在强一致性的注册中心上，频繁的节点变更会导致产生大量的通知事件，在同步到多个注册中心复制集时性能不佳；另外，仍然可能发生服务虽无法对外提供服务了，但仍然可以发送续租请求；面对不同的客户端需要提供不同语言的SDK&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;注册中心主动探活&lt;/strong&gt;：服务提供健康检查接口，比如/ping，注册中心定时访问验证节点存活；k8s的Pod探针机制&lt;/p&gt;
&lt;p&gt;优点：一定程度上解决服务主动探活不能说明服务健康的问题&lt;/p&gt;
&lt;p&gt;缺点：IP重用问题，比如A、B两个服务都有相同的端口和/ping接口做健康检查，但是当发生服务替换时，无法区分是哪个服务，除非加上名称检查&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务&lt;strong&gt;外挂一个负载均衡器&lt;/strong&gt;实现服务探活、与注册中心的通信&lt;/p&gt;
&lt;p&gt;优点：注册中心和服务均不需要主动探活，均交由负载均衡器实现&lt;/p&gt;
&lt;p&gt;缺点：需要外挂的负载均衡器，增加成本&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注册中心需要保证CP或者AP，一般来说，注册中心对一致性C的要求不是很高，因为节点的注册和反注册后通知到客户端也需要时间；对可用性的优先级较高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将上述功能包装成SDK，简化使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;可能遇到的问题&#34;&gt;可能遇到的问题&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;注册中心&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;注册中心挂掉时，此时可以持久化之前注册的Provider节点信息，并在重启后进入保护模式一段时间，在此期间先不剔除不健康的Provider节点(因为宕机期间Provider心跳无法上报)，否则可能导致在一个TTL内大量的Provider节点失效；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;需要网络闪断保护，当监测到大面积Provider心跳没有上报，则自动进入保护模式，该模式下不会剔除因心跳上报失败的Provider；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注册中心故障时，服务注册功能失效，服务也无法执行扩容操作，可以在服务内缓存服务注册表，保证服务可通信；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;调用方&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当调用方访问到某个服务发现系统不可用时，可以立即切换到下一个节点尝试；&lt;/li&gt;
&lt;li&gt;调用方优先使用缓存的服务注册表，当接收到的服务注册表的节点过少时，放弃使用；&lt;/li&gt;
&lt;li&gt;如果调用方重启了，内存中的数据不存在，可以走本地配置降级；&lt;/li&gt;
&lt;li&gt;通过在load balancer中加入被动健康检查和主动健康检查来剔除服务注册表中失效的节点，保证服务注册表的可用性&lt;/li&gt;
&lt;li&gt;参考Service Mesh的Envoy设计，不完全信任注册中心推送过来的服务注册表；&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;发现状态&lt;/th&gt;
&lt;th&gt;健康检查成功&lt;/th&gt;
&lt;th&gt;健康检查失败&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;发现&lt;/td&gt;
&lt;td&gt;路由&lt;/td&gt;
&lt;td&gt;不路由&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;未发现&lt;/td&gt;
&lt;td&gt;路由&lt;/td&gt;
&lt;td&gt;不路由、剔除失败节点&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;面对节点和服务频繁变更，导致广播风暴的场景，可以通过合并设定时间内产生的消息后再进行推送，目的是为了减少广播次数，但是这样会影响消息的时效性，要注意设定的时间不宜过长。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常见的注册中心区别&#34;&gt;常见的注册中心区别&lt;/h2&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;特征&lt;/th&gt;
&lt;th&gt;Nacos&lt;/th&gt;
&lt;th&gt;Eureka&lt;/th&gt;
&lt;th&gt;Zookeeper&lt;/th&gt;
&lt;th&gt;Consul&lt;/th&gt;
&lt;th&gt;ETCD&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;一致性协议&lt;/td&gt;
&lt;td&gt;AP或CP&lt;/td&gt;
&lt;td&gt;AP&lt;/td&gt;
&lt;td&gt;CP&lt;/td&gt;
&lt;td&gt;CP&lt;/td&gt;
&lt;td&gt;CP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;健康检查&lt;/td&gt;
&lt;td&gt;TCP、HTTP、MySQL、Client Beat&lt;/td&gt;
&lt;td&gt;TTL&lt;/td&gt;
&lt;td&gt;Keep Alive&lt;/td&gt;
&lt;td&gt;TCP、HTTP、gRPC、Cmd&lt;/td&gt;
&lt;td&gt;TTL&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;网络异常保护&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;雪崩保护&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;自动注销实例&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;访问协议&lt;/td&gt;
&lt;td&gt;HTTP、DNS&lt;/td&gt;
&lt;td&gt;HTTP&lt;/td&gt;
&lt;td&gt;TCP&lt;/td&gt;
&lt;td&gt;HTTP、DNS&lt;/td&gt;
&lt;td&gt;HTTP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;跨注册中心同步&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;K8s集成&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;不支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;td&gt;支持&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;语言实现&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;Java&lt;/td&gt;
&lt;td&gt;GO&lt;/td&gt;
&lt;td&gt;GO&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;这里再说下K8s提供的默认服务发现（1.12后默认使用coreDNS），通过为Pod挂一个 Service 或者 Pod 定义了hostname + subdomain，CoreDNS也会为其生成Pod的 DNS A记录，然后 CoreDNS 会把 Service 或 Pod 产生的DNS记录写入 CoreDNS 的 cache 或者 ETCD 中，同时在Pod的&lt;code&gt;/etc/resolv.conf&lt;/code&gt;文件中添加CoreDNS服务的访问配置，Pod即可通过 service 名称进行访问。&lt;/p&gt;
&lt;p&gt;CoreDNS会监听集群内所有Service API，当服务不可用时移除记录，在新服务创建时插入新记录，这些记录会存储在CoreDNS的cache或者ETCD中。&lt;/p&gt;
&lt;p&gt;参考：https://github.com/kubernetes/dns/blob/master/docs/specification.md&lt;/p&gt;
&lt;p&gt;具体例子查看Kubernetes那篇文章Service服务发现部分的内容。&lt;/p&gt;
</description>
        </item>
        <item>
        <title>操作系统</title>
        <link>http://nixum.cc/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</link>
        <pubDate>Mon, 09 Mar 2020 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;内核&#34;&gt;内核&lt;/h1&gt;
&lt;h2 id=&#34;pc机启动流程&#34;&gt;PC机启动流程&lt;/h2&gt;
&lt;p&gt;以Ubuntu Linux + GRUB引导程序为例：&lt;/p&gt;
&lt;p&gt;PC机加电后，加载BIOS固件， 触发PC机BIOS固件发送指令 检测和初始化CPU、内存及主板平台，加载引导设备(比如硬盘)中的第一个扇区数据到&lt;a class=&#34;link&#34; href=&#34;http://www.ruanyifeng.com/blog/2015/09/0x7c00.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;0x7c00地址开始&lt;/a&gt;的内存空间，再接着跳转到0x7c00处执行指令，加载GRUB引导程序，加载硬盘分区中的OS文件，启动操作系统。&lt;/p&gt;
&lt;h2 id=&#34;内核结构分类&#34;&gt;内核结构分类&lt;/h2&gt;
&lt;p&gt;内核：计算机资源的管理者。计算资源分为硬件资源和软件资源&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;硬件资源：CPU、内存、硬盘、网卡、显卡、IO设备、总线，他们之间通过总线进行联系；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;软件资源：对上述各种硬件资源的管理程序、设备的驱动程序&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;宏内核结构---类似单体服务&#34;&gt;宏内核结构 - 类似单体服务&lt;/h3&gt;
&lt;p&gt;将上述所有软件资源进行整合，链接在一起，形成一个大的可执行程序，控制所有硬件资源。这个大程序会在处理器的特权模式下运行，对外提供系统调用函数，供其他程序、进程调用。&lt;/p&gt;
&lt;p&gt;当应用层有程序要调用进行内存分配时，就会调用宏内核进行内存分配&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用程序调用内核内存分配API函数&lt;/li&gt;
&lt;li&gt;处理器切换到特权模式，开始运行内核代码&lt;/li&gt;
&lt;li&gt;内核的内存管理代码按照特定的算法，分配内存&lt;/li&gt;
&lt;li&gt;内存分配函数把分配的内存块的首地址返回给应用程序&lt;/li&gt;
&lt;li&gt;应用程序接收到返回后，处理器开始运行用户模式下的应用程序，应用程序使用得到的内存首地址，开始使用这块内存&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点：由于所有硬件管理程序都整合在一起，相互调用时性能极高&lt;/p&gt;
&lt;p&gt;缺点：所有硬件管理程序都整合在一起，没有模块化，扩展性差，移植性差，牵一发而动全身，每次修改都需要重新安装，其中一个模块有问题就会影响其他模块。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Linux就属于宏内核&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Linux 的基本思想是一切都是文件：每个文件都有确定的用途，包括用户数据、命令、配置参数、硬件设备等对于操作系统内核而言，都被视为各种类型的文件。Linux 支持多用户，各个用户对于自己的文件有自己特殊的权利，保证了各用户之间互不影响。多任务则是现代操作系统最重要的一个特点，Linux 可以使多个程序同时并独立地运行。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f45%e8%ae%b2-Linux.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e6%9e%81%e5%ae%a2%e6%97%b6%e9%97%b4-%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f45%e8%ae%b2-Linux.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;Linux使用宏内核架构，主要分为上述五大模块，模块间的通信通过函数调用，函数间的调用没有层次关系，所以函数的调用路径纵横交错，如果有函数出问题，那就会影响到调用它的模块，存在安全隐患，但优点是存内核调用，性能极高&lt;/p&gt;
&lt;p&gt;Linux高清全结构图：https://makelinux.github.io/kernel/map/&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;微内核结构---类似微服务&#34;&gt;微内核结构 - 类似微服务&lt;/h3&gt;
&lt;p&gt;内核仅处理进程调度、中断、内存空间映射、进程间通信等，控制硬件资源的软件资源，转成一个个服务进程，比如进程管理、内存管理、设备管理、文件管理等，和用户进程一样，只是它们提供了宏内核的那些功能。&lt;/p&gt;
&lt;p&gt;微内核内，进程间通过消息进行通信，应用程序每次要申请资源都需要发送消息到微内核，微内核再把这条消息转发给相关服务进程，直到完成这次调用。&lt;/p&gt;
&lt;p&gt;当应用层有程序要调用进行内存分配时&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;应用程序发送内存分配的消息（发送消息这个函数由微内核提供）&lt;/li&gt;
&lt;li&gt;处理器切换到特权模式，执行内核代码&lt;/li&gt;
&lt;li&gt;微内核让当前进程停止运行，并根据消息包中的数据，推送给对应的消息接收者，比如这里是内存管理服务进程。&lt;/li&gt;
&lt;li&gt;内存管理服务进程收到消息，分配一块内存&lt;/li&gt;
&lt;li&gt;内存管理服务进程，处理完成后，通过消息的形式返回分配内存块的地址给内核，然后继续等待下一条消息。&lt;/li&gt;
&lt;li&gt;微内核把包含内存地址的消息返回发送给内存分配消息的应用程序&lt;/li&gt;
&lt;li&gt;处理器开始运行用户模式下的应用程序，应用程序收到这条消息，得到内存首地址，开始使用这块内存。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点：系统结构清晰，移植性、伸缩性、扩展性强，微内核代码少，容易替换，各种系统服务进程可随时替换&lt;/p&gt;
&lt;p&gt;缺点：进程间消息依赖微内核进行消息传递，会频繁进行服务进程切换，模式切换，导致性能较差。&lt;/p&gt;
&lt;h3 id=&#34;分离硬件的相关性&#34;&gt;分离硬件的相关性&lt;/h3&gt;
&lt;p&gt;分离硬件的相关性其实就是屏蔽底层硬件操作细节，形成一个独立的软件抽象层，对外提供接口，方便应用层接入。&lt;/p&gt;
&lt;p&gt;是内核设计的一种指导思想，所以在设计操作系统内核的时候，就可以分为&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内核接口层：向应用层提供系统接口函数；&lt;/li&gt;
&lt;li&gt;内核功能层：系统函数的主要实现，实现进程管理、内存管理、中断管理、设备管理、驱动、文件系统等；&lt;/li&gt;
&lt;li&gt;内核硬件层：对硬件资源的操作，比如初始化CPU、内存、中断控制、其他IO设备&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;混合内核&#34;&gt;混合内核&lt;/h3&gt;
&lt;p&gt;混合内核在微内核的基础上进行改进，层次分明，动态加载模块到内核，兼具宏内核和微内核的优点。&lt;/p&gt;
&lt;p&gt;Windows就属于混合内核。&lt;/p&gt;
&lt;h1 id=&#34;cpu&#34;&gt;CPU&lt;/h1&gt;
&lt;p&gt;中断：中断即中止执行当前程序，转而跳转到另一个特定的地址上，去运行特定的代码，响应外部事件。&lt;/p&gt;
&lt;p&gt;硬件中断：中断控制器给CPU发送了一个电子信号，CPU对这个信号作出应答，随后中断控制器将中断号发给CPU。&lt;/p&gt;
&lt;p&gt;软件中断：CPU执行INT指令，指令后带一个常数，该常数为软中断号。&lt;/p&gt;
&lt;h2 id=&#34;位宽&#34;&gt;位宽&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;32 位和 64 位 CPU 最主要区别在于一次能计算多少字节数据：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;32 位 CPU 一次可以计算 4 个字节；&lt;/li&gt;
&lt;li&gt;64 位 CPU 一次可以计算 8 个字节；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这里的 32 位和 64 位，通常称为 CPU 的位宽，代表的是 CPU 一次可以计算（运算）的数据量。&lt;/p&gt;
&lt;p&gt;之所以 CPU 要这样设计，是为了能计算更大的数值，如果是 8 位的 CPU，那么一次只能计算 1 个字节 &lt;code&gt;0~255&lt;/code&gt; 范围内的数值，这样就无法一次完成计算 &lt;code&gt;10000 * 500&lt;/code&gt; ，于是为了能一次计算大数的运算，CPU 需要支持多个 byte 一起计算，所以 CPU 位宽越大，可以计算的数值就越大，比如说 32 位 CPU 能计算的最大整数是 &lt;code&gt;4294967295&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;CPU 中的寄存器主要作用是存储计算时的数据，内存离 CPU 太远了，而寄存器就在 CPU 里，还紧挨着控制单元和逻辑运算单元，自然计算时速度会很快。&lt;/p&gt;
&lt;p&gt;常见的寄存器种类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;通用寄存器&lt;/em&gt;，用来存放需要进行运算的数据，比如需要进行加和运算的两个数据。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;程序计数器&lt;/em&gt;，用来存储 CPU 要执行下一条指令「所在的内存地址」，注意不是存储了下一条要执行的指令，此时指令还在内存中，程序计数器只是存储了下一条指令「的地址」。&lt;/li&gt;
&lt;li&gt;&lt;em&gt;指令寄存器&lt;/em&gt;，用来存放当前正在执行的指令，也就是指令本身，指令被执行完成之前，指令都存储在这里。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;一个程序执行的时候：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;CPU 会根据程序计数器里的内存地址（存的是指令的地址），从内存里面把需要执行的指令读取到指令寄存器里面（CPU通过控制单元操作地址总线获取要访问的内存地址，通过数据总线传输）&lt;/li&gt;
&lt;li&gt;执行指令（分析指令的类型和参数，计算型的指令交给逻辑运算单元执行，存储类型的指令交给控制单元执行）&lt;/li&gt;
&lt;li&gt;根据指令长度自增（自增的步长跟CPU的位宽有关，32位的CPU，指令是4字节，计数器的值就自增4），开始顺序读取下一条指令。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;总线&#34;&gt;总线&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;总线是用于 CPU 和内存以及其他设备之间的通信，总线可分为 3 种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;地址总线&lt;/em&gt;，用于指定 CPU 将要操作的内存地址；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;控制总线&lt;/em&gt;，用于发送和接收信号，比如中断、设备复位等信号，CPU 收到信号后自然进行响应，这时也需要控制总线；&lt;/li&gt;
&lt;li&gt;&lt;em&gt;数据总线&lt;/em&gt;，用于读写内存的数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 CPU 要读写内存数据的时候，一般需要通过下面这三个总线：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先要通过「地址总线」来指定内存的地址；&lt;/li&gt;
&lt;li&gt;然后通过「控制总线」控制是读或写命令；&lt;/li&gt;
&lt;li&gt;最后通过「数据总线」来传输数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/CPU%e4%bb%8e%e5%86%85%e5%ad%98%e8%af%bb%e5%8f%96%e6%95%b0%e6%8d%ae.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/CPU%e4%bb%8e%e5%86%85%e5%ad%98%e8%af%bb%e5%8f%96%e6%95%b0%e6%8d%ae.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;cpu位宽与线路位宽&#34;&gt;CPU位宽与线路位宽&lt;/h2&gt;
&lt;p&gt;线路通过高低电压传输数据，一位一位串行传输，下一个bit必须等待上一个bit传输完成才能进行下一个，想要一次多传些数据，就要增加线路，实现并行传输。&lt;/p&gt;
&lt;p&gt;CPU想要操作内存地址，就需要地址总线，比如，CPU想操作4G大的内存，就需要32条地址总线，因为&lt;code&gt;2^32=4G&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;一般来说，CPU的位宽要大于线路的位宽，操作起来才比较方便。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;如果用 32 位 CPU 去计算两个 64 位大小的数字的和，就需要把这 2 个 64 位的数字分成 2 个低位 32 位数字和 2 个高位 32 位数字来计算，先加个两个低位的 32 位数字，算出进位，然后再计算两个高位的 32 位数字的和，最后再加上进位，就能算出结果了，可以发现 32 位 CPU 并不能一次性计算出加和两个 64 位数字的结果。&lt;/p&gt;
&lt;p&gt;对于 64 位 CPU 就可以一次性算出加和两个 64 位数字的结果，因为 64 位 CPU 可以一次读入 64 位的数字，并且 64 位 CPU 内部的逻辑运算单元也支持 64 位数字的计算。&lt;/p&gt;
&lt;p&gt;但是并不代表 64 位 CPU 性能比 32 位 CPU 高很多，很少应用需要算超过 32 位的数字，所以&lt;strong&gt;如果计算的数额不超过 32 位数字的情况下，32 位和 64 位 CPU 之间没什么区别的，只有当计算超过 32 位数字的情况下，64 位的优势才能体现出来&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;另外，32 位 CPU 最大只能操作 4GB 内存，就算你装了 8 GB 内存条，也没用。而 64 位 CPU 寻址范围则很大，理论最大的寻址空间为 &lt;code&gt;2^64&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;通常来说 64 位 CPU 的地址总线是 48 位，而 32 位 CPU 的地址总线是 32 位，所以 64 位 CPU 可以&lt;strong&gt;寻址更大的物理内存空间&lt;/strong&gt;。如果一个 32 位 CPU 的地址总线是 32 位，那么该 CPU 最大寻址能力是 4G，即使你加了 8G 大小的物理内存，也还是只能寻址到 4G 大小的地址，而如果一个 64 位 CPU 的地址总线是 48 位，那么该 CPU 最大寻址能力是 &lt;code&gt;2^48&lt;/code&gt;，远超于 32 位 CPU 最大寻址能力。&lt;/p&gt;
&lt;p&gt;如果 32 位指令在 64 位机器上执行，需要一套兼容机制，就可以做到兼容运行了。但是&lt;strong&gt;如果 64 位指令在 32 位机器上执行，就比较困难了，因为 32 位的寄存器存不下 64 位的指令&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;硬件的 64 位和 32 位指的是 CPU 的位宽，软件的 64 位和 32 位指的是指令的位宽。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;时钟周期&#34;&gt;时钟周期&lt;/h2&gt;
&lt;p&gt;硬件参数，比如2GHz的CPU，时钟频率是2G，表示1秒内会产生2G次数的脉冲信号，每一次脉冲信号高低电平的转换就是一个周期，称为时钟周期，时钟周期时间就是1/2G，即0.5ns。&lt;code&gt;程序的CPU执行时间 = 指令数 x 每条指令的平均时钟周期数 x 时钟周期时间&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在一个时钟周期内，CPU 仅能完成一个最基本的动作，时钟频率越高，时钟周期就越短，工作速度也就越快。CPU在一个时钟周期内不一定能执行完一条指令。&lt;/p&gt;
&lt;h2 id=&#34;cpu-cache&#34;&gt;CPU Cache&lt;/h2&gt;
&lt;p&gt;程序局部性原理：程序一旦编译完装载进内存中，它的地址就确定了，CPU大多数时间在执行相同的指令或者相邻的指令。&lt;/p&gt;
&lt;p&gt;内存，从逻辑上看，是一个巨大的字节数组，内存地址就是这个数组的下标。相比与CPU，内存的数据量吞吐是很慢的，当CPU需要内存数据时，内存一时间给不了，CPU就只能等，让总线插入等待时钟周期，直到内存准备好。因此内存才是决定系统整体性能的关键。为了弥补CPU、内存、硬盘的读写速度差异，不让CPU每次都要等，因此利用程序局部性原理，引入了Cache，一般CPU Cache分成了三级L1，L2，L3：&lt;/p&gt;
&lt;p&gt;Cache主要由高速的静态存储器、地址转换模块和Cache Line替换模块组成。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/CPU_Cache.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/CPU_Cache.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;CPU在读取数据和指令时，会一层一层的读，读不到就从下一层进行加载，为了让CPU执行代码执行得更快，就需要利用好CPU Cache，使得缓存的命中率提高，缓存命中了，就不用去加载内存里的数据了。&lt;/p&gt;
&lt;p&gt;CPU Cache由很多个Cache Line组成，一行大小通常为32字节或64字节，&lt;strong&gt;Cache Line是CPU从内存读取数据的基本单位&lt;/strong&gt;，他们之间通过 &lt;em&gt;直接映射Cache&lt;/em&gt; 把内存里数据的地址映射到Cache Line里。多个Cache Line又会形成一组，除了存储数据，还存储标志位，如脏位、回写位、访问位等；&lt;/p&gt;
&lt;p&gt;CPU读取的是内存地址，通过内存地址根据映射策略，在Cache里找到对应的值，通过比较双方的组标记，判断这个地址是否对应这个值。&lt;/p&gt;
&lt;p&gt;CPU Cache加载内存数据时，不是一个字节一个字节读取，是一次性读取一块一块的数据放到CPU Cache里的，比如CPU L1 Cache Line的大小是64字节，表示L1 Cache一次载入数据的大小是64字节，加载数据时会顺序加载，当有 &lt;code&gt;int array[100]&lt;/code&gt;，载入&lt;code&gt;array[0]&lt;/code&gt;时，由于int占4字节，不足64字节，因为数组在内存上是连续的，那CPU就会顺序加载数组元素&lt;code&gt;array[0] ~ array[15]&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;当CPU有多核时，线程可能在不同的CPU核心来回切换执行，这对CPU Cache不利，会导致各核心缓存重新加载，各个核心的缓存命中率变低，所以对于CPU密集型的任务，最好将线程绑定到同一个核心区处理，防止因为切换到不同的核心，导致缓存命中率下降的问题，以此来提升性能。&lt;/p&gt;
&lt;p&gt;Cache虽提升了性能，但会产生数据一致性问题。Cache可以是一个独立硬件，也可以集成在CPU中，Cache通常有多级，每一级间都有可能产生数据一致性问题。&lt;/p&gt;
&lt;p&gt;对于数据的写入，CPU都会先写入到Cache里，然后再在一个合适的时间写入内存，有写直达和写回两种策略，保持Cache和内存的数据一致性。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;写直达Write Through&lt;/strong&gt;：只要有数据写入，都会直接把数据写入内存，性能受限于内存的访问速度；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;写回Write back&lt;/strong&gt;：对于已缓存的Cache的写入，如果要写入的内存地址数据跟当前的一致，只需更新其数据，并标记为脏即可，不用写入到内存；&lt;/p&gt;
&lt;p&gt;只有在需要把缓存里的脏数据交换出去的时候，才把数据同步到内存，比如再次写入的时候，发现Cache里存的是别的内存地址的数据，且被标记为脏，就需要先把这个脏数据写入内存，再从内存读入到缓存后才进行写入，并标记为脏；&lt;/p&gt;
&lt;p&gt;当再次写入的时候，发现Cache存的是别的内存地址数据，但没有被标记为脏，则先从内存加载要更新的数据的内存地址，替换之前别的内存地址数据，然后写入更新数据，并标记为脏；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;多核场景下的保持缓存一致性，需要满足下面两点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写传播，当某个CPU核心发生写操作时，将该事件通过总线广播通知其他核心，如果其他核心有该缓存，则进行更新；&lt;/li&gt;
&lt;li&gt;事务串行化，来保证更新顺序；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;解决多核场景下一致性问题就需要数据同步协议，如MESI和MOESI。&lt;/p&gt;
&lt;p&gt;基于总线嗅探的MESI协议，就满足上面两点，MESI指的是：已修改、独占、共享、已失效，实现有限状态机，对Cache Line 进行标记，判断缓存是否需要传播更新。为了避免两个不同的核心读取到同一块数据到Cache Line，但是各自又只用到了其中一部分的场景（因为这个时候如果发生修改，会导致缓存不起作用），此时需要将他们所需的数据放到两个不同的Cache Line里，避免更新时的相互干扰，通常的做法是根据Cache Line大小，为这两部分进行多余的数据填充，使其被加载到不同的Cache Line里，即内存对齐，空间换时间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;MESI：M（Modified已修改）、E（Exclusive独占）、S（Shared共享）、I（Invalida已无效）&lt;/p&gt;
&lt;p&gt;最开始只有一个核读取了A数据，此时状态为E独占，数据是干净的，
后来另一个核又读取了A数据，此时状态为S共享，数据还是干净的，
接着其中一个核修改了数据A，此时会向其他核广播数据已被修改，让其他核的数据状态变为I失效，而本核的数据还没回写内存，状态则变为M已修改，等待后续刷新缓存后，数据变回E独占，其他核由于数据已失效，读数据A时需要重新从内存读到高速缓存，此时数据又共享了&lt;/p&gt;
&lt;p&gt;以上这些逻辑都由 Cache 硬件独立实现，软件不用做任何工作，对软件是透明的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;工作模式&#34;&gt;工作模式&lt;/h2&gt;
&lt;h3 id=&#34;实模式&#34;&gt;实模式&lt;/h3&gt;
&lt;p&gt;又称实地址模式，运行真正的指令，对指令的动作不作区分，直接执行指令的真实功能，另外，发往内存的地址是真实的，对任何地址不加限制地发往内存。&lt;/p&gt;
&lt;p&gt;访问内存 - 分段内存管理模式：内存地址由段寄存器左移4位，再加上一个通用寄存器中的值或者常数形成地址，然后由这个地址去访问内存。仅支持16位地址空间，对指令不加限制地运行，对内存没有保护隔离作用。&lt;/p&gt;
&lt;p&gt;中断实现，内存中存放一个中断向量表，该表的地址和长度由CPU的特定寄存器IDTR指向，一个条目由代码段地址和段内偏移组成，当出现中断号后，CPU就根据IDTR寄存器中的信息，计算出中断向量中的条目，进而装载CS（代码段基地址）、IP（代码段内偏移）寄存器，响应中断。&lt;/p&gt;
&lt;h3 id=&#34;保护模式&#34;&gt;保护模式&lt;/h3&gt;
&lt;p&gt;保护模式是为了应对更高的计算量和内存量，CPU寄存器扩展为32位宽，使其能够寻址32位内存地址空间和32位的数据，还实现指令区分和访问内存地址限制。&lt;/p&gt;
&lt;p&gt;为了区分哪些指令(如in、out、cli)和哪些资源(如寄存器、IO端口、内存地址)可以被访问，实现了特权级。特权级分为4级，R0~R3，R0最大，可以指向所有指令，之后依次递减，下一层是上一层的子集。内存访问则靠段描述符和特权级相互配合实现。&lt;/p&gt;
&lt;p&gt;访问内存时使用平坦模型：为了应对分段模型的缺陷，在分段模型的基础上套多一层，简化分段模型，对内存段与段之间的访问严格检查，没有权限不会放行。&lt;/p&gt;
&lt;p&gt;中断时由于要进行权限检测和特权级切换，需要扩展中断向量表的信息，每个中断用一个中断门描述符来表示，存于中断向量表中&lt;/p&gt;
&lt;h3 id=&#34;长模式&#34;&gt;长模式&lt;/h3&gt;
&lt;p&gt;又名AMD64模式，在保护模式的基础上，增加一些通用寄存器，扩展通用寄存器的位宽，所有的通用寄存器都是64位，还可单独使用低32位。低32位可以拆分成一个低16位寄存器，低16位又可以拆分为两个8位寄存器。&lt;/p&gt;
&lt;p&gt;访问内存时需要开启分页模式，弱化段模式管理，仅保留权限级别的检查，忽略段基址和段长度，地址检查交给MMU。&lt;/p&gt;
&lt;p&gt;中断时的中断向量表中的条目，中断描述符需要扩展，将其32位段内偏移扩展成支持64位&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;1、x86 CPU的位数越来越高，从16到32到64，每次进步都尽量的去兼容了之前的CPU架构，所以：
A、16位时寻址能力不足，所以要借助额外的寄存器进行1M空间的寻址；32位时，每个程序都有自己独立的4G寻址空间，操作系统用低位的1G-2G，其余留给用户程序；64位后，暂时就遇不到寻址能力不足的事情了；
B、前一代的寄存器尽量保留，不够用就扩展新的
C、寄存器的长度升级后，其低位可以兼容上一代的寄存器&lt;/p&gt;
&lt;p&gt;2、CPU同时在安全性上也要提升，从只有实模式【可以随意执行全部CPU指令，内存可以直接通过物理地址访问，随意访问随意读写】，到了32的保护模式【将指令划分为ring0到ring3，CPU指令不是你想调用就能调用；内存不是你想访问就能访问，首先CPU要允许，而且操作系统允许】，而64的长模式在安全方面与32并没有本至区别；&lt;/p&gt;
&lt;p&gt;3、从实模式到保护模式，访问内存时，需要访问的地址变大了，需要控制的内容变多了，于是引入了段描述符，所有的段描述符组成了描述符表，包括唯一的全局描述符GDT和多个局部描述符号LDT。GDT是操作系统特供，要重点关注。CPU寻址的时候，要通过段寄存器+GDTR寄存器定位到的内存中的描述符，判断是否允许访问。然后，再根据段描述符中地址进行访问。&lt;/p&gt;
&lt;p&gt;4、同时内存中内存管理有段、页、段页三种常用模式。一般在应用层，程序员感受不太到，操作系统全给咱们做完了。&lt;/p&gt;
&lt;p&gt;5、中断，其实是通过硬件或软件方式告诉CPU，来执行一段特殊的代码。比如咱们键盘输入，就是通过硬件中断的方式，告知操作系统的。在实模式下，中断是直接执行的。但到了保护模式和长模式下，就要特权级别校验通过才能执行，所以引入了中断门进行控制。在ring3调用中断一般是要通过操作系统切换到内核态ring0进行的，与内存类似，要通过中断向量表，确认中断门中权限是否允许，然后定位到指定代码执行。&lt;/p&gt;
&lt;p&gt;6、BIOS引导后，系统直接进入最简单、特权最大的实模式；而后告知CPU，切换到保护模式，并运行在ring0。后续的用户进程，一般就在ring3，想执行特权指令要通过操作系统来执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;内核态和用户态&#34;&gt;内核态和用户态&lt;/h2&gt;
&lt;p&gt;对于32位操作系统来说，寻址空间为4G(2的32次方)，即进程最大地址空间是4G。&lt;/p&gt;
&lt;p&gt;内核独立于普通的应用程序，可以访问受保护的内存空间，还有底层硬件设备的所有权限，所以，为了保护内核安全，现在的操作系统一般都强制用户进程不能直接操作系统内核。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e5%88%86%e9%85%8d.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e5%88%86%e9%85%8d.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;操作系统将&lt;strong&gt;虚拟地址空间划分为两部分，一部分为内核空间，另一部分为用户空间&lt;/strong&gt;。针对 Linux 操作系统而言，最高的 1G 字节(从虚拟地址 0xC0000000 到 0xFFFFFFFF)由内核使用，称为内核空间。而较低的 3G 字节(从虚拟地址 0x00000000 到 0xBFFFFFFF)由各个进程使用，称为用户空间；内核态在0~4G范围的虚拟空间地址都可以操作，只是3~4G范围的虚拟空间地址必须由内核态去操作，所有进程的内核态都共享3~4G这个范围的数据。&lt;/p&gt;
&lt;p&gt;之所以要分内核空间和用户空间，是因为有些CPU指令的权限比较大，可能导致系统崩溃，如果允许所有进程访问，容易出事，导致故障或崩溃，所以操作系统将CPU指令集分为两部分：特权指令和非特权指令，特权指令只允许操作系统及相关模块使用，非特权指令给普通应用程序使用。&lt;/p&gt;
&lt;p&gt;Intenel的CPU将特权等级分为4个，Ring0~Ring3，Ring0权限最高，可以使用所有CPU指令集，Ring3权限最低，只能使用常规的CPU指令集，不能操作硬件资源的CPU指令集，比如IO读写、网卡访问、申请内存等操作；&lt;/p&gt;
&lt;p&gt;Linux系统只用了Ring0和Ring3，Ring3不能访问Ring0的地址空间，当进程运行在Ring3级别时被称为运行在用户态，运行在Ring0级别被称为运行在内核态。&lt;/p&gt;
&lt;p&gt;在内核态下，进程运行在内核地址空间中，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。&lt;/p&gt;
&lt;p&gt;在用户态下，进程运行在用户地址空间中，被执行的代码要受到 CPU 的诸多检查，它们只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址，且只能对任务状态段(TSS)中 I/O 许可位图(I/O Permission Bitmap)中规定的可访问端口进行直接访问。&lt;/p&gt;
&lt;p&gt;所以，即便是单个应用程序出现错误也不会影响到操作系统的稳定性，这样其它的程序还可以正常的运行，区分内核空间和用户空间本质上是要提高操作系统的稳定性及可用性。&lt;/p&gt;
&lt;p&gt;内核会对这些特权指令集封装成一个个接口，供用户空间的应用程序使用，比如读写磁盘，分配内存、回收内存、从网络接口读写数据等。进程在用户态和内核态各有一个堆栈，用来保存在对应空间执行的上下文。&lt;strong&gt;应用程序要读磁盘数据，1. 首先通过特殊指令，从用户态进入内核态，执行特权指令，2. 从磁盘上读取数据到内核空间中，3. 再把数据拷贝到用户空间，并从内核态切换到用户态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总共有三种方式可以从用户态切换到内核态：系统调用system call、软硬中断、异常。&lt;/p&gt;
&lt;p&gt;从用户态到内核态的切换开销比较大，主要是因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保留用户态现场（上下文、寄存器、用户栈等）&lt;/li&gt;
&lt;li&gt;复制用户态参数，用户栈切到内核栈，进入内核态&lt;/li&gt;
&lt;li&gt;额外的检查（因为内核代码对用户不信任）&lt;/li&gt;
&lt;li&gt;执行内核态代码&lt;/li&gt;
&lt;li&gt;复制内核态代码执行结果，回到用户态&lt;/li&gt;
&lt;li&gt;恢复用户态现场（上下文、寄存器、用户栈等）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;cpu上下文&#34;&gt;CPU上下文&lt;/h2&gt;
&lt;p&gt;Linux是一个多任务操作系统，可以支持远大于CPU数量的任务同时进行，通过在短时间内分配CPU给任务运行实现并行的目的，因此CPU需要知道每个任务从哪里加载，哪里开始运行，需要事先帮它们设置好CPU寄存器和程序计数器，因此CPU寄存器和程序计数器就算CPU上下文。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU寄存器：CPU内置的容量小，但速度快的内存&lt;/li&gt;
&lt;li&gt;程序计数器：存储CPU正在执行指令的位置，或者即将执行的下一条指令的位置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;CPU上下文切换时，先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。&lt;/p&gt;
&lt;p&gt;而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。&lt;/p&gt;
&lt;h3 id=&#34;进程上下文切换&#34;&gt;进程上下文切换&lt;/h3&gt;
&lt;p&gt;发生系统调用时，进程从用户态进入内核态，这个过程发生上下文切换：&lt;/p&gt;
&lt;p&gt;1、保存 CPU 寄存器里原来用户态的指令位
2、为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。
3、跳转到内核态运行内核任务。
4、当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。&lt;/p&gt;
&lt;p&gt;所以，&lt;strong&gt;一次系统调用过程，实际发生了两次CPU上下文切换，用户态 -&amp;gt; 内核态 -&amp;gt; 用户态，但系统调用过程中，不会涉及虚拟内存等进程用户态的资源，也不会切换进程，系统调用过程中一直是同一个进程在运行&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;系统调用 通常也称为 特权模式切换，&lt;strong&gt;系统调用属于同进程内的CPU上下文切换&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程上下文切换指的是两个不同的进程间的切换&lt;/strong&gt;；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程是由内核来管理和调度的，进程的切换只能发生在内核态。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;进程的上下文切换就比系统调用时多了一步：在保存内核态资源（当前进程的内核状态和 CPU 寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈，这个过程就比较耗资源了。&lt;/p&gt;
&lt;p&gt;发生进程上下文切换的场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;CPU将时间片轮流分配给各个进程，当某个进程的时间片被耗尽，就会被系统挂起，切换到其他正在等待CPU执行的进程；&lt;/li&gt;
&lt;li&gt;进程在系统资源不足（比如内存不足）时进行等待，此时会被CPU挂起，并由系统调度其他进程运行；&lt;/li&gt;
&lt;li&gt;当进程通过sleep函数主动挂起，此时会重新调度；&lt;/li&gt;
&lt;li&gt;当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行；&lt;/li&gt;
&lt;li&gt;发生硬件中断时，CPU上的进程被中断挂起，转而执行内核中的中断服务程序；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;线程上下文切换&#34;&gt;线程上下文切换&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;内核中的任务调度，实际上调度的是线程，而进程只是给线程提供了共享的虚拟内存，全局变量等资源&lt;/strong&gt;，线程本身也有自己的栈和寄存器，在上下文切换时也要保存。&lt;/p&gt;
&lt;p&gt;切换场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前后两个属于不同进程的线程，因为资源不共享，在切换过程就跟进程上下文切换一样；&lt;/li&gt;
&lt;li&gt;前后两个属于同一进程的线程，因为虚拟内存是共享的，在切换时，虚拟内存这些资源保存不动，只需切换线程的私有数据、寄存器等不共享的数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;中断上下文切换&#34;&gt;中断上下文切换&lt;/h3&gt;
&lt;p&gt;硬中断：处理硬件请求，负责耗时短的任务，快速执行，会打断当前正在执行的任务，立即执行中断；&lt;/p&gt;
&lt;p&gt;软中断：由内核触发，负责硬中断中未完成的工作或者内核定义的一些中断事件，通常是耗时比较长的事情，延迟执行；Linux的软中断包括网络收发、定时、调度、RCU锁等各种类型&lt;/p&gt;
&lt;p&gt;为了快速响应硬件的事件，&lt;strong&gt;中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件&lt;/strong&gt;。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;跟进程上下文不同，中断上下文切换并不涉及到进程的用户态&lt;/strong&gt;。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;对同一个 CPU 来说，中断处理比进程拥有更高的优先级&lt;/strong&gt;，所以中断上下文切换并不会与进程上下文切换同时发生。&lt;/p&gt;
&lt;h2 id=&#34;同步原语&#34;&gt;同步原语&lt;/h2&gt;
&lt;p&gt;常见的有：原子操作、控制中断、自旋锁、信号量。底层原子操作都是依靠支持原子操作的机器指令的硬件实现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;原子操作是对单一变量。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制中断：可以作用复杂变量，一般用在单核CPU，同一时刻只有一个代码执行流，响应中断会导致代码执行流切换，此时如果两个代码执行流操作到同一个全局变量就会导致数据不一致，所以需要在操作全局变量时关闭中断，处理完开启进行控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自旋锁还有一个作用就是可以在多核CPU下处理全局变量，因为控制中断只能控制本地CPU的中断，无法控制其他CPU核心的中断，此时其他CPU是可以操作到该全局变量的。自旋需要保证读取锁变量和判断并加锁操作是原子的，且会导致CPU空转一段时间。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号量的一个作用就是解决自旋锁空转造成CPU资源浪费的缺点。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;linux初始化&#34;&gt;Linux初始化&lt;/h1&gt;
&lt;h2 id=&#34;引导-boot&#34;&gt;引导 boot&lt;/h2&gt;
&lt;p&gt;也是机器加电，BIOS自检，BIOS加载引导扇区，加载GRUB引导程序，最后由GRUB加载Linux内核镜像vmlinuz。&lt;/p&gt;
&lt;p&gt;CPU被设计成只能运行内存中的程序，无法直接运行存储在硬盘或U盘中的操作系统程序，因为硬盘U盘等外部存储并不和CPU直接相连，访问机制和寻址方式与内存不一样。如果要运行硬盘或U盘中的程序，就必须先加载到内存。&lt;/p&gt;
&lt;p&gt;由于内存RAM断电会丢失数据，BIOS不是存储在普通的内存中的，而是存储在主板上特定的一块ROM内存中，在硬件设计上规定加电瞬间，强制将CS寄存器的值设置位0xF000，IP寄存器的值设置为0xFFF0，该地址就是BIOS的启动地址了。&lt;/p&gt;
&lt;p&gt;BIOS在初始化CPU和内存后进行检查，完了之后将自己的一部分复制到内存，最后跳转到内存中运行。之后枚举本地设备进行检查和初始化，调用设备的固件程序。当设备完成检查和初始化后，BIOS就会在内存中划定一个地址范围，存放和建立中断表和中断服务程序。&lt;/p&gt;
&lt;p&gt;一般我们会把Linux镜像放在硬盘的第一个扇区中（MBR主启动记录，包含基本的GRUB启动程序和分区表），然后让硬盘作为BIOS启动后搜索到的第一个设备，当MBR被BIOS装载到0x7c00地址开始的内存空间中，BIOS会把控制权交给MBR，即GRUB。&lt;/p&gt;
&lt;p&gt;GRUB所在的第一个扇区，只有512个字节，不足以装下GRUB这种大型的通用引导器，因此GRUB的加载被分成了多个步骤和多个文件，在启动时动态加载，先加载diskboot.img，然后读取剩下的core.img，识别出文件系统，使其能够访问/boot/grub目录，最后加载vmlinuz内核文件。&lt;/p&gt;
&lt;h2 id=&#34;启动-startup&#34;&gt;启动 startup&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;1.GRUB 加载 vmlinuz 文件之后，会把控制权交给 vmlinuz 文件的 setup.bin 的部分中 _start，它会设置好栈，清空 bss，设置好 setup_header 结构，调用 16 位 main ，调用BIOS中断，进行初始化设置，包括console、堆、CPU模式、内存、键盘、APM、显卡模式等，然后切换到保护模式，最后跳转到 1MB 处的 vmlinux.bin 文件中。&lt;/p&gt;
&lt;p&gt;2.从 vmlinux.bin 文件中 startup32、startup64 函数开始建立新的全局段描述符表和 MMU 页表，切换到长模式下解压 vmlinux.bin.gz。释放出 vmlinux 文件之后，由解析 elf 格式的函数进行解析，释放 vmlinux 中的代码段和数据段到指定的内存。然后调用其中的 startup_64 函数，在这个函数的最后调用 Linux 内核的第一个 C 函数。
3.Linux 内核第一个 C 函数重新设置 MMU 页表，随后便调用 start_kernel 函数， start_kernel 函数中调用了大多数 Linux 内核功能性初始化函数，在最后调用 rest_init 函数建立了两个内核线程，在其中的 kernel_init 线程建立了第一个用户态进程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Linux%e5%88%9d%e5%a7%8b%e5%8c%96%e8%a6%81%e7%82%b9.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Linux%e5%88%9d%e5%a7%8b%e5%8c%96%e8%a6%81%e7%82%b9.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;Linux初始化要点&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Linux初始化要点&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&#34;内存管理&#34;&gt;内存管理&lt;/h1&gt;
&lt;h2 id=&#34;虚拟地址&#34;&gt;虚拟地址&lt;/h2&gt;
&lt;p&gt;由于各个应用程序由不同的公司开发，且每台计算机的内存容量都不一样，如果应用程序在运行时使用的是真实地址，将会导致各个应用程序在使用内存地址时产生冲突。为了解耦内存真实地址和应用使用的内存地址，对不同的应用程序使用的内存进行隔离和保护，引出虚拟地址概念。&lt;/p&gt;
&lt;p&gt;虚拟地址：让每个应用程序都各自享有一个从0开始到最大地址的空间，在每个应用程序独立且私有，其他应用程序无法观察到，再由操作系统将虚拟地址映射成真实的物理地址，实现内存的使用。&lt;/p&gt;
&lt;p&gt;虚拟地址由链接器产生，应用程序经过编译后通过链接器的处理变成可执行文件，链接器会处理程序代码间的地址引用，形成程序运行的静态内存空间视图。&lt;/p&gt;
&lt;p&gt;实模式下，多个进程共享所有地址空间太过危险，因此有了保护模式，保护模式下为了让各个应用程序能正确使用内存，使用了虚拟地址映射，让各个应用程序都有自己的地址空间，因此访问内存时不用考虑其他问题，访问时再经过MMU翻译得到对应的页表，不同的应用程序由于不同的页表，产生了进程地址空间隔离，但多个应用程序也可以共享某个页表，此时就涉及进程间的通信了。&lt;/p&gt;
&lt;p&gt;关于内存对齐：因为cpu总是以多个字节的块为单位访问内存的，不与它的访问块地址边界对齐cpu就要多次访问。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;虚拟内存有三个特征：多次性、对换性、虚拟性。它将程序分多次调入内存，使得在较小的用户空间可以执行较大的用户程序，所以同时容纳更多进程并发执行，从而提高系统吞吐量；发生缺页时取决于内存的存储管理方式，可以调入一个段，也可以调入一个页；虚拟性表示虚拟内存和物理内存的映射。&lt;/p&gt;
&lt;p&gt;虚拟内存的核心原理是：为每个程序设置一段&amp;quot;连续&amp;quot;的虚拟地址空间，把这个地址空间分割成多个具有连续地址范围的页 (page)，并把这些页和物理内存做映射，在程序运行期间动态映射到物理内存（通过MMU管理）。当程序引用到一段在物理内存的地址空间时，由硬件立刻执行必要的映射；而当程序引用到一段不在物理内存中的地址空间时，由操作系统负责将缺失的部分装入物理内存并重新执行失败的指令。&lt;/p&gt;
&lt;p&gt;在进程运行期间只分配映射当前使用到的内存，暂时不使用的数据则写回磁盘作为副本保存，需要用的时候再读入内存，动态地在磁盘和内存之间交换数据。&lt;/p&gt;
&lt;p&gt;如果分配后的虚拟内存没有被访问的话，虚拟内存是不会映射到物理内存的，这样就不会占用物理内存了。&lt;/p&gt;
&lt;p&gt;只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断，然后进程会从用户态切换到内核态，将缺页中断交给内核的缺页中断函数，该函数会检查是否有空闲的物理内存，如果有，就进行分配，建立虚拟内存和物理内存之间的映射关系，如果没有，就回收空闲内存，如果回收后仍然不够分配，就会触发OOM，该机制会杀死物理内存占用最高的进程，以释放内存，直到内存足够分配。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;作用&#34;&gt;作用&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;使得进程可以对运行内存使用超过物理内存的大小，如果超出内存大小，会使用swap，把不常用的内存换到磁盘&lt;/li&gt;
&lt;li&gt;每个进程有自己的页表，每个进程的虚拟内存就是相互独立的，进程也没办法访问其他进程的页表，属于私有页表，解决多进程之间地址冲突问题&lt;/li&gt;
&lt;li&gt;页表里的页表项除了物理地址外，还有一些标记属性的比特，比如控制一个页的读写权限，标记该页是否存在，为操作系统提供更好的安全性。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;所需要的最基础的硬件支持&#34;&gt;所需要的最基础的硬件支持&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;一位，用于特权模式和用户模式的切换&lt;/li&gt;
&lt;li&gt;基址寄存器：用于虚拟地址与物理地址的转换；界限寄存器：用于地址的界限检查，防止用户程序访问到不属于它的地址&lt;/li&gt;
&lt;li&gt;能转换虚拟地址并检查它是否越界&lt;/li&gt;
&lt;li&gt;修改基址/界限寄存器的特权指令&lt;/li&gt;
&lt;li&gt;注册异常处理程序的特权指令&lt;/li&gt;
&lt;li&gt;能够触发异常&lt;/li&gt;
&lt;li&gt;段寄存器，比如前两位拿来表示什么类型的段，比如栈、堆、代码区，用于计算段内的偏移量，配合基址寄存器和界限寄存器，计算出虚拟地址要映射的物理地址；设置保护位实现代码段共享；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;内存划分与组织&#34;&gt;内存划分与组织&lt;/h2&gt;
&lt;h3 id=&#34;内存碎片&#34;&gt;内存碎片&lt;/h3&gt;
&lt;p&gt;内部内存碎片：由于采用固定大小的内存分区，当一个进程不能完全使用分给它的固定内存区域时就会产生内部内存碎片，这通常难以避免；&lt;/p&gt;
&lt;p&gt;外部内存碎片：由于某些未分配的连续内存区域太小，以至于不能满足任意进程的内存分配请求，从而不能被进程利用的内存区域；&lt;/p&gt;
&lt;p&gt;如果只是简单的通过基址和界限寄存器，将划分的虚拟内存区域一整块直接映射到物理内存，由于虚拟内存并不会完全用完，中间会空出一小块，对应到物理内存里也是，导致内存利用率不高，内存碎片的产生，所以才有了分段、分页、段页式等的内存分配方案；&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e7%9b%b4%e6%8e%a5%e6%98%a0%e5%b0%84.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e7%9b%b4%e6%8e%a5%e6%98%a0%e5%b0%84.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;现在普遍使用段页式内存分配方案，将内存分为不同的段，再将每一段分成固定大小的页，通过页表机制，使得段内的页可以不必连续处于同一内存区域，只分配必要的内存，提升内存空间的利用率&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;分段&#34;&gt;分段&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%86%85%e5%ad%98%e5%88%86%e6%ae%b5.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%86%85%e5%ad%98%e5%88%86%e6%ae%b5.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;地址是二维的，一维是段号，二维是段内偏移量，每个段的长度不一样，且每个段偏移量都是从0开始编址，通过段号找到对应的段内描述符，再通过段基地址 + 段内偏移量，最终确定物理内存地址；&lt;/li&gt;
&lt;li&gt;在分段管理中，每个段内部是连续的内存分配，但是段与段之间是离散分配的，存在一个逻辑地址到物理地址的映射，即段表机制；通过段表实现虚拟地址与物理地址的映射；&lt;/li&gt;
&lt;li&gt;段的长度大小不一，可动态改变，好处是需要多少分配多少，产生连续的内存空间，坏处是不便于用一个统一的数据结构表示，容易产生外部内存碎片；&lt;/li&gt;
&lt;li&gt;产生外部内存碎片后，如果产生多个不连续的内存片段，而新的程序无法使用它，就需要进行内存交换，内存交换需要用到磁盘，就涉及到访问速度的问题，内存交换的效率就低；&lt;/li&gt;
&lt;li&gt;内存不足时，内存数据会写回硬盘来释放内存，由于段的长度大小不一，每段的读写时间就会不一样，导致性能抖动；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;分段主要是为了程序和数据可以被划分为逻辑上独立的地址空间（比如分成代码、堆、栈这些段），有助于数据的共享和保护，比如数据共享、数据保护、动态链接等，需要程序员显式划分每个段。&lt;/p&gt;
&lt;h3 id=&#34;分页&#34;&gt;分页&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%86%85%e5%ad%98%e5%88%86%e9%a1%b5.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%86%85%e5%ad%98%e5%88%86%e9%a1%b5.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;页的大小固定，可以用位图表示页的分配和释放，作为主存的基本单位，分页可以使得内存分配粒度变小，以此来减少外部内存碎片的产生，但如果程序需要的内存不足一页，由于最小分配单位是一页，就会造成内部内存碎片的情况出现；&lt;/p&gt;
&lt;p&gt;页会产生内存碎片，但可以通过修改页表的方式，让连续的虚拟页面映射到非连续的物理页面，实现分段的效果；比如有1，2，3是空闲，4已被分配，5是空闲，可以通过映射让5接上3；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;因为程序数据存储在不同的页中，而页又离散分布在内存中，因此需要一个页表来记录映射关系，页表也是存储在内存中的，通过内存管理单元MMU实现虚拟地址和物理地址的转换；&lt;/p&gt;
&lt;p&gt;通过降低内存分配的粒度 + 页表映射，解决分段内存带来的外部内存碎片过大和内存交换效率低的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分页的地址空间是一维的，分配的最小单位是页。页内的虚拟地址按位划分为页号和页内偏移，通过页号找到对应的页表，再通过页表上的物理页号找到对应的物理页，再通过页内偏移量 + 物理页的基地址，最终确定物理内存地址；&lt;/p&gt;
&lt;p&gt;所以，访问分页系统中的内存数据需要两次访问，第一次确定物理内存的地址，第二次根据第一次得到的物理地址访问内存取出数据；&lt;/p&gt;
&lt;p&gt;当进程访问虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存，更新进程页表，最后再返回到用户空间，恢复进程运行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;操作系统在对内存管理时，使用一个数据结构描述一个内存页，每个数据结构包含相邻页的指针，多个内存页形成一个链表，Linux下每页大小是4KB。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存不足时，内存数据会写回硬盘来释放内存（页置换算法），由于每页大小一致，每页的读写时间也会一致，内存交换效率相对比较稳定；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在完成虚拟内存和物理内存页之间的映射后，并不真的把页加载到物理内存里，而是只有在程序运行中，需要用到的对应虚拟内存页里面的指令和数据时，再加载到物理内存里；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;多级页表&#34;&gt;多级页表&lt;/h4&gt;
&lt;p&gt;因为每个进程有自己的虚拟空间地址，如果每个进程都拥有自己的页表，那数量会非常庞大，比如在32位CPU、页大小4KB的环境下，一个进程，4GB的虚拟内存的单级页表就需要100万个，每个页表需要4个字节存储，4G的虚拟内存就需要占4MB，当进程有100个，就需要分配400MB的内存来存储页表，但实际上进程一次可能用不到这么多虚拟地址，于是操作系统使用多级页表解决这个问题。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%a4%9a%e7%ba%a7%e9%a1%b5%e8%a1%a8.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%a4%9a%e7%ba%a7%e9%a1%b5%e8%a1%a8.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;多级页表，就是将单级页表进行分页，比如分为1024个一级页表，每个二级页表再分为1024个单表项（相乘就有100万个了），映射而成就需要4KB + 4MB内存空间，一级页表如果没被用到，二级页表就不需要创建了，所以可以省很多内存空间；&lt;/p&gt;
&lt;p&gt;页表的作用就是将虚拟地址转换为物理地址，如果虚拟地址在页表中找不到对应的页表项，就会出问题，所以页表一定要覆盖全部虚拟地址；对于64位的系统，两级页表就不够用了，需要变成四级页表，以此类推成多级页表；&lt;/p&gt;
&lt;p&gt;多级页表解决空间上的问题，但是虚拟地址到物理地址的转换就多了步骤，因为如果页表也是存在物理内存，那做虚拟地址转换时，需要先读页表所在的物理内存，得到转换后的物理地址，进而才能读到对应物理地址的值，多了一次额外的读取，降低地址转换效率，因此，需要额外的硬件来加速地址转换。&lt;/p&gt;
&lt;p&gt;为了加速地址翻译，在CPU芯片中加入一个存放程序最常访问的页表项的Cache，叫TLB（translation lookaside buffer），又叫页表缓存、转址旁路缓存、快表，CPU芯片也会封装MMU，CPU寻址时，先查TLB，没找到再去查常规的页表，TLB会利用局部性原理，会加载相邻的地址。&lt;/p&gt;
&lt;h3 id=&#34;段页式&#34;&gt;段页式&lt;/h3&gt;
&lt;p&gt;将程序分为多个有逻辑意义的段，方便管理，比如地址范围为多少多少的内存区域就给硬件用，多少多少的给内核区，多少多少给应用区等，再对段内内存进行分页，划分成固定大小的页，从而更好的利用内存，减少内存碎片的产生。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;段页式地址变换中要得到物理地址须经过三次内存访问：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次访问段表，得到页表起始地址；&lt;/li&gt;
&lt;li&gt;第二次访问页表，得到物理页号；&lt;/li&gt;
&lt;li&gt;第三次将物理页号与页内位移组合，得到物理地址。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;组织内存页&#34;&gt;组织内存页&lt;/h3&gt;
&lt;p&gt;为了能高效的分配内存，需要把内存区数据结构和内存页面数据结构关联起来，组织成一个内存分割合并的数据结构。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;以2的N次方为页面数组织页面的原因：&lt;/p&gt;
&lt;p&gt;1、内存对齐，提升CPU寻址速度
2、内存分配时，根据需求大小快速定位至少从哪一部分开始
3、内存分配时，并发加锁，分组可以提升效率
4、内存分配回收时，很多计算也更简单&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;mmu&#34;&gt;MMU&lt;/h2&gt;
&lt;p&gt;虚拟地址转换为物理地址通过MMU(内存管理单元)实现，只能在保护模式或者长模式下开启。&lt;/p&gt;
&lt;p&gt;MMU使用分页模型，即把虚拟地址空间和物理地址空间都分成同等大小的页，按照虚拟页和物理页进行转换，一个虚拟地址对应一个物理地址，一个虚拟页对应一个物理页，页大小一经配置就是固定，通过内存中存储的一个地址关系转换表（页表）实现转换。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为了增加灵活性和节约物理内存空间（因为页表是放在物理内存中的），所以页表中并不存放虚拟地址和物理地址的对应关系，只存放物理页面的地址，MMU 以虚拟地址为索引去查表返回物理页面地址，而且页表是分级的，总体分为三个部分：一个顶级页目录，多个中级页目录，最后才是页表。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分层的结构是根据页大小决定。&lt;/p&gt;
&lt;p&gt;为了解决进程通过MMU访问内存比直接访问内存多了一次内存访问，导致性能下降的问题，引入TLB快表进行加速。TLB可以简单理解成页表的高速缓存，保存了最高频次被访问的页表项，一般由硬件实现，速度极快。&lt;/p&gt;
&lt;h2 id=&#34;空闲空间管理&#34;&gt;空闲空间管理&lt;/h2&gt;
&lt;h3 id=&#34;基本机制&#34;&gt;基本机制&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;分割与合并：根据请求的大小进行空闲空间分割，回收时，对被回收空间相邻的空间进行检查，如果也是空闲空间，则进行合并；&lt;/li&gt;
&lt;li&gt;追踪已分配空间的大小：分配空间时，除了分配请求的大小，还会分配一块头部，记录已分配空间的元数据信息，方便查找和释放；&lt;/li&gt;
&lt;li&gt;嵌入空闲列表：在空闲空间本身建立空闲空间列表，实现对空闲空间的管理；&lt;/li&gt;
&lt;li&gt;内存增长：当当前的空闲空间内存耗尽，向操作系统申请更大的空闲空间&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;内存分配基本策略&#34;&gt;内存分配基本策略&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最优匹配：遍历整个空闲列表，找到和请求大小一样或更大的空闲块，返回这组候选者中最小的一块，缺点是需要遍历查找，性能不高；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最差匹配：尝试找到最大的空闲块，根据请求大小进行分割，然后把剩余的空闲块加入空闲列表，缺点是同样需要遍历，且更容易产生内存碎片，一般不使用这种策略；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;首次匹配：找到第一块满足请求的块，分配完后剩余空闲块加入空闲列表，这种方法不需要遍历所有空闲块，但不稳定，有时候会产生很多内存碎片，如何管理空闲列表的顺序就变得重要，一般是基于地址排序，通过保持空闲块按内存地址有序，方便合并，减少内存碎片；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下次匹配：不同于首次匹配每次都从列表头部开始遍历查找，下次匹配是从上次结束查找的位置开始查找，避免对列表开头进行频繁分割；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分离空闲列表：如果某个程序经常申请一种或几种大小相同的内存空间，就用一个独立的列表，只管理这样大小的对象，其他大小的对象则交给更通用的内存分配程序，像Go的内存分配就从mspan、mcache、mcentral里分配内存；&lt;/p&gt;
&lt;p&gt;这种分配方式的好处是不会产生多余的内存碎片，也没有复杂的列表查找过程，内存的分配和释放都很快；&lt;/p&gt;
&lt;p&gt;难点在于初始时要分配多少空间给这种空闲列表，常见的做法是先分配一小块内存，不够用时，向通用内存申请一块总量是页大小和对象大小的公倍数内存厚块，当内存厚快的对象引用计数为0时，则进行回收；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;伙伴系统：空闲空间首先从概念上被当成 2^N 的大空间，当有一个内存分配请求时，空间空间系统被递归一分为二，直到刚好满足请求的大小，这种分配策略只允许分配2的整数次幂大小的空闲块，因此会有内部内存碎片，好处是当内存被释放时，可以递归检查，并且检查相邻空间，如果是则合二为一，直到合并整个内存区域，或者某一块的伙伴还不能被释放；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;页置换算法&#34;&gt;页置换算法&lt;/h2&gt;
&lt;p&gt;由于程序是分多次装入内存的，运行到一定时间，在地址映射过程中如果发现要访问的页不存在内存中，会发生缺页中断，此时操作系统必须在内存里选择一个页把它移除内存，为即将调入的页面让出空间，而选择淘汰哪一页就需要页面置换算法。&lt;/p&gt;
&lt;p&gt;缺页中断与一般中断的区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号；&lt;/li&gt;
&lt;li&gt;缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e7%bc%ba%e9%a1%b5%e5%bc%82%e5%b8%b8%e6%b5%81%e7%a8%8b.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e7%bc%ba%e9%a1%b5%e5%bc%82%e5%b8%b8%e6%b5%81%e7%a8%8b.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;如果第4步不能在物理内存找到空闲页时，说明此时物理内存已满，需要使用页置换算法，选择一个物理页，如果该物理页是脏页，则把它swap到磁盘，并把被置换出去的页表的状态改成 无效，最后把正在访问的页转入这个物理页中。&lt;/p&gt;
&lt;p&gt;常见的页面置换算法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;最佳页面置换算法OPT：&lt;/p&gt;
&lt;p&gt;将当前页中未来最长时间不会被访问的页置换出去，该算法会计算内存中每个逻辑页面的下一次访问时间，然后比较，选择未来最长时间不访问的页面。由于很难预测每个页面在下一次访问前的等待时间，所以该算法只能用来衡量置换效率。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先进先出置换算法FIFO：&lt;/p&gt;
&lt;p&gt;选择在内存驻留时间很长的页面进行置换，效率一般；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最近最久未使用算法LRU：&lt;/p&gt;
&lt;p&gt;选择最长时间没有被访问的页面进行置换，开销较大，因为需要在内存中维护一个所有页面的链表，而且每次访问内存都必须更新整个链表，比较耗时，所以实际中比较少用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最近最不常用算法LFU：&lt;/p&gt;
&lt;p&gt;当发生缺页中断时，选择访问次数最少的页面，将其置换，很LRU一样，实现成本很高，需要为每个页面添加一个计数器，还需要查找链表，比较耗时，也比较少用；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;时钟页面置换算法NRU（最近未使用算法）&lt;/p&gt;
&lt;p&gt;将页面链接成一个环形列表，每个页有一个访问位0/1，1表示清除访问位，并把指针前移，重复这个过程直到找到位为0的页面；0表示需要淘汰该页面，并把新的页面插入到此位置，然后指针前移。&lt;/p&gt;
&lt;p&gt;发生缺页中断后，指针遍历环形列表，会把沿途遇到的访问位为1的修改为0，直到遇到访问位为0的页面，将其淘汰，置换成新页，然后访问位置为1；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;关于堆内存和栈内存&#34;&gt;关于堆内存和栈内存&lt;/h2&gt;
&lt;p&gt;堆内存和栈内存是基于对象生命周期、分配、回收的时机进行划分&lt;/p&gt;
&lt;p&gt;栈内存：一般是一种后进先出（LIFO）的数据结构，对连续内存的线性分配，用来存储函数调用时的局部变量、函数参数和返回值等临时性的数据简单高效，方便回收。&lt;/p&gt;
&lt;p&gt;堆内存：动态分配的内存，用来存储程序运行时动态创建的对象、数组等数据，比如指针依赖，全局变量。由于堆内存的大小和生命周期都比较不确定，所以操作系统需要动态地管理它。在使用堆内存时，程序需要显式地申请内存空间，并在不再需要时释放它，否则就可能导致内存泄漏等问题。&lt;/p&gt;
&lt;h2 id=&#34;内存分配与回收&#34;&gt;内存分配与回收&lt;/h2&gt;
&lt;h3 id=&#34;系统调用函数&#34;&gt;系统调用函数&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;brk()：从用户态的堆中分配内存，只是将堆顶指针向高地址移动，获得新内存；c语言的malloc函数，当用户分配的内存小于128KB时会调用此方法；在free释放内存时，并不会把内存归还给操作系统，而是缓存在malloc的内存池，待下次使用；&lt;/li&gt;
&lt;li&gt;mmap()：使用私有匿名映射的方式，在用户态的文件映射区分配一块内存；c语言的malloc函数，当用户分配的内存大于128KB时会调用此方法；在free释放内存时，会把内存归还给操作系统，内存得到真正的释放；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两者分配的都是虚拟内存，只有被访问到的时候才会触发缺页中断进行分配，建立映射，没访问到就不会申请。&lt;/p&gt;
&lt;h3 id=&#34;内存分配过程&#34;&gt;内存分配过程&lt;/h3&gt;
&lt;p&gt;通过上面两个函数申请的内存都是虚拟内存，此时并不会分配物理内存，当应用程序读写了这块虚拟内存，CPU就会去访问这个虚拟内存，然后发现没有映射到物理内存，CPU就会产生缺页中断，进程从用户态切换到内核态，并将缺页中断交给内核的Page Fault Handler缺页中断函数处理。该函数会判断是否有空闲的物理内存，如果有，直接分配物理内存，并建立虚拟内存和物理内存的映射，如果没有空闲的物理内存，内核就会开始内存回收工作；&lt;/p&gt;
&lt;p&gt;由于申请虚拟内存但不使用就不会分配物理内存，所以实际上是可以申请远超物理内存大小的内存，当然具体还得看CPU的位数，看具体能操作的最大范围。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;在 32 位操作系统，因为进程最大只能申请 3 GB 大小的虚拟内存，所以直接申请 8G 内存，会申请失败。&lt;/li&gt;
&lt;li&gt;在 64 位操作系统，因为进程最大只能申请 128 TB 大小的虚拟内存，即使物理内存只有 4GB，申请 8G 内存也是没问题，因为申请的内存是虚拟内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;程序申请的虚拟内存，如果没有被使用，它是不会占用物理空间的。当访问这块虚拟内存后，操作系统才会进行物理内存分配。&lt;/p&gt;
&lt;p&gt;如果申请物理内存大小超过了空闲物理内存大小，就要看操作系统有没有开启 Swap 机制：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果没有开启 Swap 机制，程序就会直接 OOM；&lt;/li&gt;
&lt;li&gt;如果有开启 Swap 机制，程序可以正常运行。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;内存回收&#34;&gt;内存回收&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;后台内存回收：物理内存紧张时，唤醒kswapd内核线程异步回收内存，不会阻塞进程的执行；&lt;/li&gt;
&lt;li&gt;直接内存回收：后台异步回收跟不上进程内存申请的速度，就会开始直接回收，此时是同步的，会阻塞进程的执行，可能造成长时间的延迟，CPU利用率过高；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果直接内存回收后，空闲的物理内存仍然不够用，就会触发OOM机制，OOM Killer机制会根据算法选择一个占用物理内存较高的进程，将其杀死，释放内存资源，如果不够，就继续杀，直到释放足够的内存位置；&lt;/p&gt;
&lt;p&gt;要想保护进程不被OOM Killer杀死，可以调大进程的&lt;code&gt;oom_score_adj参数，范围是-1000~1000&lt;/code&gt;参数，让该进程的得分尽可能的低，比如设置为-1000，永远不会被杀死；&lt;/p&gt;
&lt;h3 id=&#34;可被回收的内存类型&#34;&gt;可被回收的内存类型&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;文件页：内核缓存的磁盘数据（Buffer）和内核缓存的文件数据（Page Cache），回收时，如果是脏页，就会刷回磁盘，再回收内存，如果是干净页，则直接释放内存即可；&lt;/li&gt;
&lt;li&gt;匿名页：这部分内存没有实际载体，比如堆、栈数据，这部分内存很可能还要再次被访问，所以不能直接释放，而是通过Swap机制，交换到磁盘，再释放内存，等到需要再次使用时，从磁盘加载回去；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;回收都是基于LRU算法，优先回收不常访问的内存；&lt;/p&gt;
&lt;p&gt;因为可能会涉及到磁盘IO，如果内存回收很频繁，就可能有性能问题，常见的解决方式有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;调整文件页和匿名页的回收倾向：比如回收文件页如果是干净页，不涉及磁盘IO，那就可以设置的比例大些，匿名页的比例小一些；&lt;/li&gt;
&lt;li&gt;尽早触发kswapd内核线程异步回收内存，调整这个线程的触发配置；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;关于预读失效和缓存污染问题&#34;&gt;关于预读失效和缓存污染问题&lt;/h2&gt;
&lt;p&gt;进程读取文件数据时，会对读取的文件数据进行缓存，缓存在文件系统的PageCache中，起到加速访问数据的作用。由于Page Cache的大小是有限的，对于一些频繁访问的数据希望可以一直留在内存中，很少访问的数据希望能在某些时机被淘汰掉，所以一般是使用LRU算法来实现，但是传统的LRU算法无法解决两个问题，预读失效和缓存污染。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预读失效&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于局部性原理，Page Cache读缓存机制会进行预读，当那些预读进来的，被提前加载进来的页，实际上并没有被访问到，此时预读失效，但是这些不会被访问到的预读的页却占用了LRU链表前排的位置，而末尾淘汰的页，可能是热点数据，这样就大大降低了缓存的命中率。&lt;/p&gt;
&lt;p&gt;Linux的解决方式：使用两个LRU链表，一个活跃的，一个非活跃的，预读的时候，预读页就会加入到非活跃LRU链表的头部，当页被真正访问到的时候，才会插入活跃LRU链表的头部，如果预读页一直没有被访问，就会从非活跃链表中移除，这样就不会影响活跃链表中的热点数据。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;缓存污染&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果数据被访问了一次，就将数据加入到活跃LRU链表中，只解决了预读失效的问题，缓存污染的问题还没解决，比如，当批量读取数据的时候，由于这些数据被访问了一次，被加入到活跃LRU链表中，导致之前缓存在活跃链表中的热点数据被淘汰了，但是这些新加入的数据，只被读取了一次，之后很长一段时间都不会被访问了，就导致这个活跃LRU链表一点都不活跃，就是被污染了，当之前的热点数据被再次访问的时候，又会产生大量的磁盘IO，导致性能下降。&lt;/p&gt;
&lt;p&gt;Linux的解决方式：提高加入到活跃LRU链表的门槛，保证活跃链表中的热点数据不会被轻易替换掉。比如内存页第一次访问的时候还是加入非活跃链表，第二次被访问的时候，才将页从非活跃链表中升级到活跃链表中。&lt;/p&gt;
&lt;h2 id=&#34;linux内存管理&#34;&gt;Linux内存管理&lt;/h2&gt;
&lt;h3 id=&#34;虚拟内存空间&#34;&gt;虚拟内存空间&lt;/h3&gt;
&lt;p&gt;32 位机器上进程虚拟内存空间分布：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/32%e4%bd%8d%e6%9c%ba%e5%99%a8%e4%b8%8aLinux%e8%bf%9b%e7%a8%8b%e7%94%a8%e6%88%b7%e6%80%81%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e5%88%86%e5%b8%83.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/32%e4%bd%8d%e6%9c%ba%e5%99%a8%e4%b8%8aLinux%e8%bf%9b%e7%a8%8b%e7%94%a8%e6%88%b7%e6%80%81%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e5%88%86%e5%b8%83.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;保留区：不可访问，数值较小的地址通常认为是不合法的地址，比如设置无效的指针为NULL，就指向这里；&lt;/li&gt;
&lt;li&gt;代码段、数据段、BSS段：存储程序的二进制文件中的机器码，以及定义的有初始值的全局变量、静态变量放在数据段、没有初始值的放在BSS段；&lt;/li&gt;
&lt;li&gt;堆和待分配区域：堆空间地址增长从低地址到高地址增长，申请新内存时，只需移动堆顶指针到待分配区即可，从而实现空间扩展；&lt;/li&gt;
&lt;li&gt;文件映射和匿名映射区域：进程运行所依赖的动态链接库中的代码段、数据段和BSS段就加载在这里，mmap函数映射出来的虚拟内存地址也保存在这；&lt;/li&gt;
&lt;li&gt;栈和待分配区域：用户程序函数运行过程所需要的局部变量，函数参数等调用信息存放在此，栈空间地址增长方向是从高到低增长；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;64位机器上进程用户态虚拟内存空间分布类似，用低48位表示虚拟地址，高16位的128T表示内核虚拟内存空间，低16位的128T表示用户虚拟内存空间，中间16位空闲地址被称为 canonical address作为空洞，可用来扩展或者做非法访问用；&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;通过 fork() 函数创建出的子进程，它的虚拟内存空间以及相关页表相当于父进程虚拟内存空间的一份拷贝，直接从父进程中拷贝到子进程中。子进程共享父进程的虚拟内存空间，这样的子进程也就是线程了，在Linux中都是使用 &lt;code&gt;task_struct&lt;/code&gt; 来表示他们，因为对内核来说他们是一样的；&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;32位机器上内核虚拟内存空间，&lt;strong&gt;其前 896M 区域是直接映射到物理内存中的前 896M 区域中的，直接映射区中的映射关系是一比一映射。映射关系是固定的不会改变。主要存放进程的调用链&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/32%e4%bd%8d%e6%9c%ba%e5%99%a8%e4%b8%8aLinux%e8%bf%9b%e7%a8%8b%e5%86%85%e6%a0%b8%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e5%88%86%e5%b8%83.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/32%e4%bd%8d%e6%9c%ba%e5%99%a8%e4%b8%8aLinux%e8%bf%9b%e7%a8%8b%e5%86%85%e6%a0%b8%e8%99%9a%e6%8b%9f%e5%86%85%e5%ad%98%e7%a9%ba%e9%97%b4%e5%88%86%e5%b8%83.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;直接映射区有896M，由以下几部分组成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;前1M由系统占用，存放内核代码段、数据段、BSS段；&lt;/li&gt;
&lt;li&gt;前16M由内核用来为DMA分配内存，称为ZONE_DMA；&lt;/li&gt;
&lt;li&gt;16M到896M称为ZONE_NORMAL区，没有任何限制；&lt;/li&gt;
&lt;li&gt;物理内存896M以上的部分为高端内存区ZONE_HIGHMEM，这部分会动态映射到虚拟内存内核态剩余的128M里；这128M里还会继续分：
&lt;ul&gt;
&lt;li&gt;有8M的内存空洞；&lt;/li&gt;
&lt;li&gt;vmalloc动态映射区，映射剩余的物理内存；&lt;/li&gt;
&lt;li&gt;永久映射区，允许这段虚拟地址空间与物理高端内存建立长期的映射关系；&lt;/li&gt;
&lt;li&gt;固定映射区，在此区域的虚拟内存地址可以自由映射到物理内存的高端地址上，但是与动态映射区以及永久映射区不同的是，在固定映射区中虚拟地址是固定的，而被映射的物理地址是可以改变的；&lt;/li&gt;
&lt;li&gt;临时映射区，比如一些缓存页临时映射，用完就回收；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;伙伴系统&#34;&gt;伙伴系统&lt;/h3&gt;
&lt;p&gt;Linux使用分页机制管理物理内存系统，把物理内存分成4KB大小的页面进行管理，通过一个Page结构体表示一个物理内存页面。&lt;/p&gt;
&lt;p&gt;因为硬件的限制，Linux把属性相同的物理内存页面，归结到一个区，不同的硬件，划分不同的区。在32位的x86平台中，将0~16MB划分位DMA区，高内存区适用于要访问的物理地址空间大于虚拟地址空间，Linux内核不能建立直接映射的情况。物理内存中剩余的页面就划分位常规内存区，64位的x86平台则没有高内存区。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在很多服务器和大型计算机上，如果物理内存是分布式的，由多个计算节点组成，那么每个 CPU 核都会有自己的本地内存，CPU 在访问它的本地内存的时候就比较快，访问其他 CPU 核内存的时候就比较慢，这种体系结构被称为 Non-Uniform Memory Access（NUMA）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在内存区的上层，通过定义节点pglist_data，来包含多个区&lt;/p&gt;
&lt;p&gt;连续且相同大小的Page组成伙伴，Linux在分配物理内存页面时，首先找到内存节点，接着找到内存区，然后是合适的空闲链表，最后在其中找到页的Page结构，完成物理内存页面的分配。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;内存压缩不是指压缩内存中的数据，而是指移动内存页面，进行内存碎片整理，腾出更大的连续的内存空间。如果内存碎片整理了，还是不能成功分配内存，就要杀死进程以便释放更多内存页面&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;分配算法：关键字：快速分配路径、慢速分配路径，只有在快速分配路径失败之后，才会进入慢速分配路径，慢速分配路径中会进行内存回收相关的工作。最后，通过 expand 函数分割伙伴，完成页面分配。&lt;/p&gt;
&lt;h3 id=&#34;slab&#34;&gt;SLAB&lt;/h3&gt;
&lt;p&gt;Linux使用SLAB来分配比页更小的内存对象。&lt;/p&gt;
&lt;p&gt;SLAB分配器会把一个内存页面或者一组连续的内存页面，划分成大小相同的块，每一小块内存就是SLAB对象，在这一组连续的内存页面中除了SLAB对象，还有SLAB管理头和着色区。&lt;/p&gt;
&lt;p&gt;着色区是一块动态的内存块，建立SLAB时才会设置它的大小，目的是为了错开不同的SLAB对象地址，降低硬件Cache行中地址的争用，避免抖动产生的性能下降。&lt;/p&gt;
&lt;p&gt;Linux使用kmen_cache结构管理page对应内存页面上的小块内存对象，然后让该 page 指向 kmem_cache，由 kmem_cache_node 结构管理多个 page。&lt;/p&gt;
&lt;h1 id=&#34;进程&#34;&gt;进程&lt;/h1&gt;
&lt;p&gt;进程是一个应用程序运行时刻的实例，是应用程序运行时所需资源的容器，是一堆数据结构。操作系统记录这个应用程序使用了多少内存，打开什么文件，控制资源不可用时进行睡眠，进程运行到哪了等等这些统计信息，放到内存中，抽象成进程。&lt;/p&gt;
&lt;p&gt;进程为了让操作系统管理，需要有一个地址空间，该地址空间至少包含两部分内容：内核和用户的应用程序。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;当 CPU 在 R0 特权级运行时，就运行在内核的地址空间中，当 CPU 在 R3 特权级时，就运行在应用程序地址空间中。各进程的虚拟地址空间是相同的，它们之间物理地址不同，是由 MMU 页表进行隔离的，所以每个进程的应用程序的代码绝对不能随意访问内核的代码和数据。&lt;/p&gt;
&lt;p&gt;每个进程都有一个内核栈，指向同一个块内核内存区域，共享一份内核代码和内核数据。内核进程使用一份页表，用户进程两份页表，用户进程多了一份用户空间页表，与其它用户进程互不干扰。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于应用程序需要内核提供资源，而内核需要控制应用程序的运行，让其能随时中断或恢复执行，因此需要保存应用程序的机器上下文和它运行时刻的栈。使用内核的功能时，会先停止应用程序代码的运行，进入内核地址空间运行内核代码，然后返回结果。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;进程的机器上下文分为几个部分，一部分是 CPU 寄存器，一部分是内核函数调用路径。CPU 的通用寄存器，是中断发生进入内核时，压入内核栈中的，从中断入口处开始调用的函数，都是属于内核的函数。函数的调用路径就在内核栈中，整个过程是这样的：进程调度器函数会调用进程切换函数，完成切换进程这个操作，而在进程切换函数中会保存栈寄存器的值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;建立进程，其实就是创建进程结构体，分配进程的内核栈于应用程序栈，并对进程的内核栈进行初始化，最后将进程加入调度系统，以便投入运行。&lt;/p&gt;
&lt;h2 id=&#34;进程的状态&#34;&gt;进程的状态&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%8a%b6%e6%80%81.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e8%bf%9b%e7%a8%8b%e7%9a%84%e7%8a%b6%e6%80%81.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;关于挂起状态，是&lt;strong&gt;描述进程没有占用实际的物理内存空间的情况&lt;/strong&gt;，而阻塞状态是等待某个事件的返回；&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;阻塞挂起状态：进程在外存（硬盘）并等待某个事件的出现；&lt;/li&gt;
&lt;li&gt;就绪挂起状态：进程在外存（硬盘），但只要进入内存，立刻运行；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;导致进程挂起状态的原因不止是所用内存空间不再物理内存，还可能是sleep让进程间歇性挂起，或者用户希望挂起，比如ctrl + Z。&lt;/p&gt;
&lt;h2 id=&#34;进程的通信方式&#34;&gt;进程的通信方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;匿名管道：半双工，单向，数据只能向一个方向流动，双方需要通信时，需要建立起两个管道；且只能用于有父子关系的进程；本质是一个内核缓冲区，可以看成是内存中的文件，但不属于某种文件系统，无需显示打开，创建时直接返回文件描述符，读写时需要确定对方的存在，否则将退出；以先进先出的方式存取数据，通信的双方需制定好数据的格式；&lt;/p&gt;
&lt;p&gt;管道 = 内核里一串缓存，管道内数据没有格式的流和大小限制，匿名管道比如Linux中的 &lt;code&gt;命令A | 命令B&lt;/code&gt;，此时会在shell进程下创建两个子命令进程，形成父子关系，实现通信；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;有名管道：主要解决匿名管道只能作用与有父子关系的进程的问题，通过一个路径名关联，以文件形式存在于文件系统中，即使没有亲缘关系的进程也能通过访问路径实现通信；管道名字存在于文件系统中，内容存在内存中；打开时就得确定对方是否存在，否则将阻塞；&lt;/p&gt;
&lt;p&gt;有名管道不受父子关系限制，他是提前创建了一个类型为管道的设备文件，通过这个文件实现通信；&lt;/p&gt;
&lt;p&gt;管道通信时，FIFO，需要有接收者，否则发送者会阻塞，无法退出，生命周期随进程；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号：操作系统提供的一种异步通信机制，可以在任何时候发给某一进程，而无需指定该进程的状态，如果该进程当前处于未执行状态，该信号就由内核保存起来，直到进程回复执行并传递为止；信号接收可以被阻塞，直到阻塞解除；本质是对中断机制的模拟，异步通信，在用户态和内核态之间交互；能携带的信息较少。&lt;/p&gt;
&lt;p&gt;信号是进程间通信机制中唯一的异步通信机制，进程需要注册对于的信号处理函数，进行信号处理，一般有三种响应方式：默认、捕捉、忽略；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;消息队列：存放在内核中的消息链表，消息体由用户自定义，每个消息体都是固定大小的存储块，只有在内核重启或显示地删除时，才会被真正的删除，与管道不同的是消息队列不需要确定接收进程是否存在；一般是FIFO，但也可以实现成随机查询；对消息格式，缓冲区大小等都能进行控制，比管道灵活；消息队列通信的速度不是最及时的，因为每次数据的写入和读取都需要经过用户态与内核态之间的拷贝过程。&lt;/p&gt;
&lt;p&gt;消息队列不适合较大数据的传输，且通信不够及时，因为消息队列存在内核，so存在用户态和内核态数据的拷贝开销；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;共享内存：没什么好说的，只是在访问共享内存时要依靠一些同步或互斥机制保证并发访问安全；两个进程在虚拟内存拿出一块地址空间，映射到同一块物理内存中；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;信号量：计数器，一般用于多进程对共享内存访问的保护，内核中实现，保证原子操作，主要实现进程间的互斥和同步，不用于数据通信；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Socket通信：通信机制，可用在本机或者跨网络，由域、端口号、协议类型三个属性确定；域分为AF_INET，即网络，另一个是AF_UNIX，即文件系统；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程进程协程&#34;&gt;线程、进程、协程&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;进程&lt;/strong&gt;：可以简单理解为一个应用程序，进程是资源分配的基本单位。比如一个进程拥有自己的堆、栈、虚存空间、文件描述符等。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;线程&lt;/strong&gt;：线程是独立调度的基本单位，由CPU进行调度和执行的实体。一个进程中可以有多个线程，线程之间共享进程资源，每个线程又各自有一套独立的寄存器和栈，确保线程的控制流是相对独立的，是进程中的实际运作单位，相当于进程中的一条执行流程。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;：一个进程中可以同时存在多个线程，各个线程可以并发执行，各个线程可以共享地址空间和文件等资源；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;：大部分情况下，当进程中的一个线程崩溃时，会导致其所属进程的所有线程崩溃，因为所有线程共享进程资源，当有线程崩溃时，可能污染了共享资源，为了避免其他线程访问出错，就直接使得整个进程崩溃，线程崩溃的时候通过信号传递给进程；所以，如果不想让进程崩溃，那就得有对应的信号处理函数来实现崩溃后的操作。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程间的通信&lt;/strong&gt;：&lt;/p&gt;
&lt;p&gt;同个进程下的线程之间都是共享进程的资源，只要是共享变量都可以做到线程间通信，比如全局变量，所以对于线程间关注的不是通信方式，而是关注多线程竞争共享资源的问题，信号量也同样可以在线程间实现互斥与同步&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;协程&lt;/strong&gt;：GoLang中的协程&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在用户态层面，由线程控制，即用户应用层面自己控制，很难像抢占式调度那样强制CPU切换到其他线程/进程，只能是协作式调度，但同时也避免了上下文切换&lt;/li&gt;
&lt;li&gt;内存消耗比线程小，比如go开启协程是几kb，java开启一个线程至少1MB&lt;/li&gt;
&lt;li&gt;实现原理：在一个运行的线程上，起多个协程，每个协程会加入到调度队列中，线程会从调度队列里取出协程进行运行。队列个数默认取决于CPU的个数，协程间的切换会线程使用go提供的io函数进行控制。当有协程执行较慢时，会先将其挂起，然后唤醒其他线程，将未处理的协程队列转移到该线程，消费队列里的协程，当队列消费完成后，再切回原来的线程，继续执行刚刚挂起的协程。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考：&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/secondtonone1/p/11803961.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;图解Go协程调度原理，小白都能理解 &lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.zhihu.com/question/20862617&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Golang 的 goroutine 是如何实现的？&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;进程与线程的区别&#34;&gt;进程与线程的区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;拥有资源&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;进程是资源分配的基本单位&lt;/strong&gt;，线程不拥有资源，线程可以访问隶属进程的资源。&lt;/p&gt;
&lt;p&gt;共享的资源：内存分配页表，共享内存地址，文件资源，IO设备资源，全局变量&lt;/p&gt;
&lt;p&gt;独享的资源：寄存器，栈&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调度&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程是独立调度的基本单位&lt;/strong&gt;，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;系统开销&lt;/p&gt;
&lt;p&gt;由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I/O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程因为会共享一些进程的资源，切换时只需保存和设置少量寄存器内容，开销很小，具体体现在：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;线程的创建时间比进程快，因为进程在创建的过程中，还需要资源管理信息，比如内存管理信息、文件管理信息，而线程在创建的过程中，不会涉及这些资源管理信息，而是共享它们；&lt;/li&gt;
&lt;li&gt;线程的终止时间比进程快，因为线程释放的资源相比进程少很多；&lt;/li&gt;
&lt;li&gt;同一个进程内的线程切换比进程切换快，因为线程具有相同的地址空间（虚拟内存共享），这意味着同一个进程的线程都具有同一个页表，那么在切换的时候不需要切换页表。而对于进程之间的切换，切换的时候要把页表给切换掉，而页表的切换过程开销是比较大的；&lt;/li&gt;
&lt;li&gt;由于同一进程的各线程间共享内存和文件资源，那么在线程之间数据传递的时候，就不需要经过内核了，这就使得线程之间的数据交互效率更高了；&lt;/li&gt;
&lt;li&gt;线程有一个程序计数器（PC），记录程序从哪获取指令，每个线程有自己的一组用于计算的寄存器。如果有两个线程运行在一个CPU上，线程切换必定发生上下文切换；对于进程，进程状态保存在进程控制块（PCB），每一个线程的状态保存在线程控制块（TCB），每一个线程有自己的栈空间（ThreadLocal）；与进程相比，线程切换时，地址空间保持不变，即不需要保持切换当前使用的页表，&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通信方面&lt;/p&gt;
&lt;p&gt;线程间可以通过直接读写同一进程中的数据进行通信，无需经过内核。在java中如使用共享变量、wait/notify机制、阻塞队列；但是进程通信需要借助管道、消息队列、共享内存、信号量、信号、套接字socket&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;上下文切换的开销&lt;/p&gt;
&lt;p&gt;操作系统的任务调度，实际上的调度对象是线程，而进程只是给线程提供了虚拟内存，全局变量等资源，当两个线程不属于同一个进程，切换过程跟进程上下文切换一样；当两个线程属于同一个进程，因为有共享资源和私有资源，在切换线程时，只需要切换私有数据、寄存器等不共享的数据即可，开销就会小很多。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;线程与协程的区别&#34;&gt;线程与协程的区别&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;一个线程可以有多个协程，一个进程也可以有多个协程&lt;/li&gt;
&lt;li&gt;协程不被操作系统内核管理，完全由程序控制；线程是被分割的CPU资源，协程是组织好的程序内的代码，协程不会直接使用线程，协程直接利用的是执行器关联任意线程或线程池&lt;/li&gt;
&lt;li&gt;协程能保留上一次调用时的状态&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;协程本质上可以看作是可挂起和恢复的用户态轻量级线程，可以在没有多线程环境下模拟并发，也可以在多线程环境下代替系统线程降低切换消息，支持更多并发。&lt;/p&gt;
&lt;p&gt;操作系统最小的执行单位是线程，进程是线程的容器，操作系统是进程的容器。&lt;/p&gt;
&lt;h2 id=&#34;并发与并行&#34;&gt;并发与并行&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;并发：多个任务被处理，但同一时刻，只有一个任务在执行。单核处理器也可以做到并发，比如CPU时间分片轮转执行。&lt;/li&gt;
&lt;li&gt;并行：多个任务在同一时刻同时执行，需要多核处理器才能完成。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;两个线程分别对全局变量 i++ 100 次，可能出现什么结果？&lt;/strong&gt;-&lt;/p&gt;
&lt;h2 id=&#34;调度模型&#34;&gt;调度模型&lt;/h2&gt;
&lt;p&gt;CPU同一时刻只能运行一个进程，当一个进程不能获取某种资源导致它不能继续运行时，就应该让出CPU，因此面对多进程就需要一个合理的调度。&lt;/p&gt;
&lt;p&gt;进程的等待和唤醒可以通过信号量实现。&lt;/p&gt;
&lt;p&gt;每一个CPU都有一个空转进程，作为进程调度器最后的选择。空转进程会调用进程调度函数，在系统没有其他进程可以运行时又会调用空转进程，形成闭环。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;用户空间线程和内核空间线程之间的映射关系&lt;/strong&gt;：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;N:1模型：多个用户空间线程在1个内核空间线程上运行。优势是上下文切换非常快，因为这些线程都在内核态运行，但是无法利用多核系统的优点。&lt;/p&gt;
&lt;p&gt;1:1模型：1个内核空间线程运行一个用户空间线程。这种充分利用了多核系统的优势但是上下文切换非常慢，因为每一次调度都会在用户态和内核态之间切换。POSIX线程模型(pthread)就是这么做的。&lt;/p&gt;
&lt;p&gt;M:N模型：内核空间开启多个内核线程，一个内核空间线程对应多个用户空间线程。效率非常高，但是管理复杂。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;调度的时机和方式&#34;&gt;调度的时机和方式&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;时机&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;进程从一个运行状态到另一个状态变化，会触发一次调度；&lt;/li&gt;
&lt;li&gt;硬件时钟提供某个频率的周期性中断；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;方式&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非抢占式：系统一旦开始执行某一进程，就会让该线程就会一直执行下去，直至阻塞、完成、退出，或者发生了其他事件导致系统放弃对该进程的执行后，才会去执行另外一个进程；&lt;/li&gt;
&lt;li&gt;抢占式：系统执行某一进程，在其执行期间，系统可以立即停止当前进程，转而执行另外一个进程，待处理完后，重新回来继续执行之前停止的进程。这种抢占式调度处理，需要再时间间隔末端发生时钟中断，以便把CPU控制返回给调度程序进行调度，即时间片机制；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;调度原则&#34;&gt;调度原则&lt;/h2&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;CPU 利用率&lt;/strong&gt;：调度程序应确保 CPU 是始终匆忙的状态，这可提高 CPU 的利用率；比如发生IO事件造成的阻塞，调度程序就要从就绪队列选择另一个进程来运行；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;系统吞吐量&lt;/strong&gt;：吞吐量表示的是单位时间内 CPU 完成进程的数量，长作业的进程会占用较长的 CPU 资源，因此会降低吞吐量，相反，短作业的进程会提升系统吞吐量；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;周转时间&lt;/strong&gt;：周转时间是进程运行+阻塞时间+等待时间的总和，一个进程的周转时间越小越好；&lt;/p&gt;
&lt;p&gt;完成时间 - 到达时间，即有A、B、C三个任务同时到达，且他们的运行时间都是10s，在FIFO调度算法下，周转时间就是10s，20s，30s&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;等待时间&lt;/strong&gt;：这个等待时间不是阻塞状态的时间，而是进程处于就绪队列的时间，等待的时间越长，用户越不满意；理论上就绪队列里的进程是可执行，所以可以优先考虑；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;响应时间&lt;/strong&gt;：用户提交请求到系统第一次产生响应所花费的时间，在交互式系统中，响应时间是衡量调度算法好坏的主要标准。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;调度算法&#34;&gt;调度算法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;FCFS 先来先服务调度算法，其实就是FIFO&lt;/p&gt;
&lt;p&gt;每次从就绪队列选择最先进入队列的进程，然后一直运行，直到进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行，但会&lt;strong&gt;导致排在后面的短任务等待时间过长&lt;/strong&gt;；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SJF 最短作业优先调度算法&lt;/p&gt;
&lt;p&gt;优先选择运行时间最短的进程来运行，可能会&lt;strong&gt;导致运行时间长的任务饿死&lt;/strong&gt;，理论上只有当作业都同时到达时，SJF是一个最优的调度算法，但是事实上作业不会同时到达，如果运行时间长的作业先到，就退化成了FIFO；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;STCF 最短完成时间优先&lt;/p&gt;
&lt;p&gt;基于时钟中断和上下文切换，在SJF的基础上实现抢占，避免退化成FIFO的问题；虽然STCF的周转时间最优，但是响应时间不是，那对于交互类型的程序就不够友好；&lt;/p&gt;
&lt;p&gt;SJF和STCF算法的问题，都是先需要知道作业的运行时间，但实际上这个很难获得；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;RR 时间片轮询调度算法&lt;/p&gt;
&lt;p&gt;每个进程被分配一个时间段，称为时间片，允许该进程在该时间段中运行，时间到了就切换进程运行，该算法对时间片的设定比较严格，如果时间片过短，会导致频繁的进程上下文切换，过长又会导致短任务等待时间过长；通常时间片设定为20ms~50ms；RR算法优化了响应时间，但是周转时间最差；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HPF 最高优先级调度算法&lt;/p&gt;
&lt;p&gt;对进程设定优先级，比如设置静态优先级（进程运行时确定），动态优先级（随时间更新优先级），根据优先级进行调度，可能会导致低优先级的任务永远不会被运行到；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MLFQ 多级反馈队列调度算法&lt;/p&gt;
&lt;p&gt;结合时间片轮询 + 最高优先级调度的算法，兼顾长度任务和响应时间，比较均衡，算是平衡了上述算法的优缺点，不需要提前知道作业的运行时间，难点在于设置队列的数量、每层队列的时间片配额，多久提升一次进程的优先级。&lt;/p&gt;
&lt;p&gt;设置多个队列，每个队列有不同的优先级，每个优先级有不同的运行时间，从高到低排序，优先级越高，时间片越少，每个作业只会存在于一个队列中，一个队列中的作业使用RR进行调度；&lt;/p&gt;
&lt;p&gt;作业进入系统时，放在最高优先级队列，如果第一级队列规定的时间片没运行完成，就转入第二级队列，直至完成；高优先级队列为空，才去调度低优先级队列中的进程；&lt;/p&gt;
&lt;p&gt;如果作业在其时间片内主动释放CPU，则优先级不变，但是当运行的时间累计达到规定的配额时(无论中间释放了多少次)，还是要降级，主要是解决一些交互程序或者IO操作造成的优先级垄断问题；&lt;/p&gt;
&lt;p&gt;经过一段时间后，系统将所有工作重新加入最高级优先级队列，解决长时间运行的作业一直处于最低级导致饿死的问题；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;比例份额调度&lt;/p&gt;
&lt;p&gt;彩票调度：为每个运行的作业设置不同的权重值，通过生成随机数落在哪个范围来决定运行哪个作业，得益于随机数，理论上在长时间运行后终于趋向于我们一开始设置的比例，且不用需要额外的变量来存在进度，比较简便，缺点是如果在短作业或者运行次数较少的场景，随机数调度就不是很公平；&lt;/p&gt;
&lt;p&gt;步长调度：为每个作业设置运行步长，每次运行对步长进行累加，每次运行步长累加值最小的那个，通过这种方式解决彩票调度的公平性问题，缺点是需要额外的变量来记录每个作业的步长；&lt;/p&gt;
&lt;p&gt;这两种调度都面临的问题是如何设置一个合理的权重值或者步长值，且也无法很好的应付IO问题&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在多CPU场景下，需要考虑多CPU的cache和内存间的一致性、亲和度和同步问题，又分为两种不同的调度：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SQMS单队列调度&lt;/p&gt;
&lt;p&gt;多个CPU共享一个调度队列，优点是简单，CPU负载均衡，不需要太多修改，就能将原有的策略用在多CPU上，缺点是缺乏可扩展性，且多CPU在访问队列时，需要加锁保证并发安全，性能较差，另外，因为作业有可能被多次调度到不同的CPU上，CPU缓存亲和问题没有得到很好的保障。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;MQMS多队列调度：&lt;/p&gt;
&lt;p&gt;为每个CPU分配一个调度队列，每个CPU调度相互独立，每个调度可以选择不同的调度规则，避免单队列的方式导致的数据共享和同步问题；但需要解决负载不均衡的问题，一般是使用工作窃取算法解决；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;互斥和同步&#34;&gt;互斥和同步&lt;/h2&gt;
&lt;p&gt;一些常见的操作需要多个指令来完成，因为CPU存在中断的缘故，可能会导致多个指令无法原子执行，产生并发安全问题；&lt;/p&gt;
&lt;p&gt;进程状态的转换，共享变量的访问，都需要PV操作 + 信号量来控制，P表示请求资源，V表示释放资源，两者必须成对出现，一般利用信号量 + PV操作实现进程的互斥和同步。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flag + cas实现锁，cas对应CPU提供的原子操作指令 Test-and-Set（测试和置位）&lt;/li&gt;
&lt;li&gt;信号量 + 原子的PV函数，信号量为1就是一个互斥锁了&lt;/li&gt;
&lt;li&gt;生产者-消费者，由三个信号量实现（互斥信号量、消费者资源信号量，生产者信号量）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;锁的实现&#34;&gt;锁的实现&lt;/h3&gt;
&lt;p&gt;实现锁需要考虑几个点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;锁的基本功能是互斥，能阻止多个线程进入临界区，但不能简单的暂停中断（暂停中断只对单CPU机器有用，但是暂停中断会影响其他应用程序的中断信号，也会导致当前线程一直占有CPU，导致无法切换）&lt;/li&gt;
&lt;li&gt;公平性，每个竞争线程释放有公平的机会抢到锁，竞争的锁是否会饿死&lt;/li&gt;
&lt;li&gt;性能，当只有一个线程，即没竞争的时候，抢锁和解锁的开销；一个CPU上有多个线程竞争的性能开销；多个CPU上有多个线程竞争的性能开销；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基本原理：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;硬件提供原子指令支持，有三种，测试并设置(test-and-set)、比较并交换(compare-and-swap)、获取并增加(fetch-and-add)；&lt;/p&gt;
&lt;p&gt;使用这三种指令其中之一，即可实现一个简单的锁，没有获取锁的线程会进入自旋，这种实现方式只是实现了互斥，但不保证公平，自旋的线程在竞态条件下可能会永远自旋，导致饿死，其次，在单CPU场景下，性能较差，当有一个线程获取到锁后，其他线程运行时都自旋一个时间片，浪费CPU周期，但在多CPU场景下，性能就不错，因为有其他CPU分摊运行压力。&lt;/p&gt;
&lt;p&gt;另外，如果使用 获取并增加 指令，就可以实现公平锁，原理是每个线程lock时，会fetch-and-add得到一个编号，自旋时比较该编号判断是否可以获取锁。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;除了自旋可以等待，线程也可以主动让出CPU，比如调用os的yield()函数，最起码不会浪费CPU时间片，但是仍然会发生上下文切换，性能有提升，但不多；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用队列 + 线程挂起休眠，实现公平，避免饿死（如果同时存在未入队的线程和存在队列里的线程时，需要保证队首线程被唤醒的优先权高一些，避免队列里的线程被饿死），同时也能减少自旋带来的消耗，提升性能；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;二阶段锁，实际上就是上面两种方案的组合，自旋不是无限自旋，而是自旋一定的次数，如果还获取不到锁，就将线程挂起。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;其他同步原语&#34;&gt;其他同步原语&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;条件变量：A线程要等到B线程执行完才能继续执行，可以使用全局变量 + A线程自旋的方式实现，但是这种方案会浪费CPU时间，最好的方式是让线程A休眠，因此可以使用条件变量的wait()和signal()，条件变量的原理是队列 + 锁，当有条件不满足时，让线程加入队列等待，直到被唤醒，wait()和signal()的语义均要求在使用时需要持有锁；&lt;/li&gt;
&lt;li&gt;生产者/消费者（有界缓冲区）：通过消息队列解决并发问题，本质Broker + 锁 + 条件变量实现，要注意，通过条件变量进行唤醒和休眠，只是暗示了条件发生变化，不保证运行前后的运行状态是一致的，所以最好需要再次检查状态；另外，条件信号需要有指向性，消费者只能唤醒生产者，生产者只能唤醒消费者；&lt;/li&gt;
&lt;li&gt;信号量：使用一个信号量时，信号量的值为1，可以模拟锁；值为0，可以模拟join()，也可以+条件实现条件变量；信号量本身可以通过锁 + 条件变量 + 值 来实现；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;并发安全问题的产生&#34;&gt;并发安全问题的产生&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;非死锁缺陷：共享变量没有原子性操作，共享变量的访问顺序问题，均容易产生并发安全问题&lt;/li&gt;
&lt;li&gt;死锁缺陷：主要是要避免凑齐死锁条件&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;死锁&#34;&gt;死锁&lt;/h3&gt;
&lt;p&gt;只有同时满足以下四个条件才会发生：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥：对资源的访问需要先持有锁，比如一个线程抢到了锁&lt;/li&gt;
&lt;li&gt;持有并等待：在等待下一个资源的时候，不会释放已持有的锁，比如线程已经持有了锁，但同时在等待其他资源&lt;/li&gt;
&lt;li&gt;非抢占：已上锁的资源，在自己使用完之前不会被其他线程获取到，比如线程获取到锁后，这个锁不能被其他线程抢占&lt;/li&gt;
&lt;li&gt;循环等待：多个线程获取资源的顺序形成了环形链&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;死锁避免：破坏死锁的任一条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;互斥破坏：使用lock-free，不使用锁，比如cas，或者通过调度避免死锁，比如将线程固定调度到某一个CPU&lt;/li&gt;
&lt;li&gt;持有并等待破坏：通过原子的抢锁来避免&lt;/li&gt;
&lt;li&gt;非抢占破坏：使用tryLock()先判断&lt;/li&gt;
&lt;li&gt;循环等待破坏：使用资源时有序分配，不让它形成环依赖（最常见的破坏条件）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;银行家算法避免死锁：银行家算法主要是避免资源分配不导致死锁，需要提前知道每个线程的最大资源需求，实现资源分配表和进程资源分配表，当有线程请求或释放资源时，银行家算法通过查表判断是否有足够的资源可供分配，有则分配，没有则等待，只有通过安全检查，才允许操作，否则分配会被拒绝。&lt;/p&gt;
&lt;h2 id=&#34;linux进程调度&#34;&gt;Linux进程调度&lt;/h2&gt;
&lt;p&gt;Linux进程调度支持多种调度算法：基于优先级的调度算法、实时调度算法、完全公平调度算法CFQ；也支持多种不同的进程调度器：RT调度器、Deadline调度器、CFS调度器、Idle调度器。&lt;/p&gt;
&lt;p&gt;进程优先级越高，占有CPU时间越长；调度优先级越高，调度系统选中它的概率就越大。&lt;/p&gt;
&lt;p&gt;Linux的CFS调度器没有时间片概念，它是直接分配CPU使用时间的比例。CFS会按权重比例分配CPU时间，权重表示进程优先级，&lt;code&gt;进程时间 = CPU总时间 * 进程权重 / 就绪队列所有进程权重之和&lt;/code&gt;。对外接口提供一个nice值，范围为-20~19，数值越小，权重越大，每降低一个nice值，就能多获得10%的CPU时间。&lt;/p&gt;
&lt;p&gt;对于非实时，优先级不高的任务，Linux使用CFS完全公平调度算法，实现任务的调度；这里任务指的是线程或进程。&lt;/p&gt;
&lt;p&gt;CFS分配给每个任务的CPU时间是一样的，每个任务安排一次虚拟运行时间vruntime，如果一个任务运行得越久，该任务的vruntime值越大，而没有被运行的任务，vruntime不会变化，CFS在调度的时候，会根据权重值，优先选择vruntime少的任务，以保证每个任务的公平性。&lt;code&gt;虚拟运行时间vruntime += 实际运行时间 * nice常量 / 权重&lt;/code&gt;（nice值越低，权重值越大，计算出来的vruntime就会越小；优先级的范围是&lt;code&gt;0~139&lt;/code&gt;，其中&lt;code&gt;0~99&lt;/code&gt;是给实时任务用，&lt;code&gt;100~139&lt;/code&gt;给普通任务用，值越低，优先级越高，nice值的范围是&lt;code&gt;-20~19&lt;/code&gt;，新优先级 = 旧优先级 + nice值）。&lt;/p&gt;
&lt;p&gt;每个CPU都有自己的运行队列，用于描述此CPU上运行的所有进程，一般包含三个运行队列：DeadLine运行队列，RealTime实时运行队列，CFS运行队列（用红黑树描述），调度的优先级从大到小&lt;/p&gt;
&lt;h1 id=&#34;设备io&#34;&gt;设备I/O&lt;/h1&gt;
&lt;p&gt;操作系统本身会对设备进行分类，定义一套对应设备的操作接口，由设备的驱动程序实现，而驱动程序实现对应设备的操作，从而达到操作系统与设备解耦的目的。&lt;/p&gt;
&lt;p&gt;设备和设备驱动的信息会抽象成对应的数据结构，再通过设备表结构组织驱动和设备的数据结构。&lt;/p&gt;
&lt;p&gt;总线是设备的基础，表示CPU与设备的连接，总线本身也是一个数据结构。&lt;/p&gt;
&lt;p&gt;一个驱动程序开始是由内核加载运行，然后调用由内核提供的接口建立设备，最后向内核注册设备和驱动，完成驱动和内核的握手动作。&lt;/p&gt;
&lt;p&gt;内核要求设备执行某项动作，就会调用设备的驱动程序函数，把相关参数传递给设备的驱动程序，由于参数很多，各种操作所需的参数又不相同，就会把这些需要的参数封装在一个数据结构中，称为I/O包。&lt;/p&gt;
&lt;p&gt;在Linux中，各种设备是一个个文件，只是并不对应磁盘上的数据文件，而是对应着存在内存当中的设备文件，对这些文件的操作等同于对设备的操作。在目录 &lt;code&gt;/sys/bus&lt;/code&gt;目录下能看到所有总线下的所有设备，总线目录下有设备目录，设备目录下是设备文件。&lt;/p&gt;
&lt;p&gt;**中断：**中断用于减少CPU的开销，让CPU不在需要不断轮询设备，而是向设备发送一个请求，让对应进程睡眠，切换执行其他任务。&lt;/p&gt;
&lt;p&gt;一般用在需要长时间处理的慢速设备上使用，让CPU在中断的这段时间可以执行其他任务，而不用一直轮询等待，但如果短时间内出现大量的中断（比如网络接收数据包），会使得系统过载，CPU不断的处理中断，引发活锁，导致无法切换执行其他任务，一般的会使用 短时间轮询 + 中断（多次中断合并）的混合策略；&lt;/p&gt;
&lt;p&gt;中断处理流程：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;在 I/O 时，设备控制器如果已经准备好数据，则会通过中断控制器向 CPU 发送中断请求；&lt;/li&gt;
&lt;li&gt;保护被中断进程的 CPU 上下文；&lt;/li&gt;
&lt;li&gt;转入相应的设备中断处理函数；&lt;/li&gt;
&lt;li&gt;进行中断处理；&lt;/li&gt;
&lt;li&gt;恢复被中断进程的上下文；&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;DMA（Direct Memory Access）&lt;/strong&gt; ：让设备在 CPU 不参与的情况下，自行完成把设备 I/O 数据放入到内存，目的是减少CPU参与数据拷贝的时间，让CPU无需参与数据拷贝，因此这段时间可以执行其他任务。&lt;/p&gt;
&lt;p&gt;需要有 「DMA 控制器」硬件的支持。&lt;/p&gt;
&lt;p&gt;DMA处理流程&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/DMA%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/DMA%e5%b7%a5%e4%bd%9c%e5%8e%9f%e7%90%86.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从键盘敲入字母时，操作系统发生了什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/CPU%e7%a1%ac%e4%bb%b6%e6%80%bb%e7%ba%bf%e5%9b%be.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/CPU%e7%a1%ac%e4%bb%b6%e6%80%bb%e7%ba%bf%e5%9b%be.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;当用户输入了键盘字符，&lt;strong&gt;键盘控制器&lt;/strong&gt;就会产生扫描码数据，并将其缓冲在键盘控制器的寄存器中，紧接着键盘控制器通过总线给 CPU 发送&lt;strong&gt;中断请求&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CPU 收到中断请求后，操作系统会&lt;strong&gt;保存被中断进程的 CPU 上下文&lt;/strong&gt;，然后调用键盘的&lt;strong&gt;中断处理程序&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;键盘的中断处理程序是在&lt;strong&gt;键盘驱动程序&lt;/strong&gt;初始化时注册的，那键盘&lt;strong&gt;中断处理函数&lt;/strong&gt;的功能就是从键盘控制器的寄存器的缓冲区读取扫描码，再根据扫描码找到用户在键盘输入的字符，如果输入的字符是显示字符，那就会把扫描码翻译成对应显示字符的 ASCII 码，比如用户在键盘输入的是字母 A，是显示字符，于是就会把扫描码翻译成 A 字符的 ASCII 码。&lt;/p&gt;
&lt;p&gt;得到了显示字符的 ASCII 码后，就会把 ASCII 码放到「读缓冲区队列」，接下来就是要把显示字符显示屏幕了，显示设备的驱动程序会定时从「读缓冲区队列」读取数据放到「写缓冲区队列」，最后把「写缓冲区队列」的数据一个一个写入到显示设备的控制器的寄存器中的数据缓冲区，最后将这些数据显示在屏幕里。&lt;/p&gt;
&lt;p&gt;显示出结果后，&lt;strong&gt;恢复被中断进程的上下文&lt;/strong&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;文件系统&#34;&gt;文件系统&lt;/h1&gt;
&lt;p&gt;文件系统是操作系统为了兼容不同的物理存储设备而存在。&lt;/p&gt;
&lt;h2 id=&#34;关于文件和目录&#34;&gt;关于文件和目录&lt;/h2&gt;
&lt;p&gt;存储虚拟化一个是文件，另一个是目录；&lt;/p&gt;
&lt;p&gt;文件就是一个线性字节数组，每个字节可以读取或写入，每个文件有一个低级名称 inode，通过硬链接将文件名称与inode号连接起来；&lt;/p&gt;
&lt;p&gt;而目录则包含一个对（inode号，供用户可读的名称）的列表，将用户可读的名称映射到 inode 号上，这个对会指向其他文件或目录，从而构建成目录树；&lt;/p&gt;
&lt;h2 id=&#34;常见文件系统的实现&#34;&gt;常见文件系统的实现&lt;/h2&gt;
&lt;p&gt;文件系统会把文件数据定义成一个动态的线性字节数组，将一段范围的字节数组整合成一个文件数据逻辑块，再映射成对应存储设备的物理存储块，从而解决不同物理存储设备有不同的物理存储块的问题。即 线性字节数组 -&amp;gt; 文件数据逻辑存储块 -&amp;gt; 物理存储块。&lt;/p&gt;
&lt;p&gt;可以通过位图来标识哪些逻辑存储块是空闲，哪些是已被分配占用。&lt;/p&gt;
&lt;p&gt;通过一个包含文件系统标识、版本、状态、存储介质大小、文件系统逻辑存储块大小、位图所在存储块、根目录等信息的数据结构，作为文件系统的超级块或文件系统描述块。&lt;/p&gt;
&lt;p&gt;文件系统的格式化，指的是在存储设备上重建文件系统的数据结构，一般是先设置文件系统的超级块、位图、根目录，三者是强顺序的。&lt;/p&gt;
&lt;p&gt;Linux使用VFS虚拟文件系统作为中间层，抽象了文件系统共有的数据结构和操作函数集合，一个物理存储设备的驱动只要实现了这些函数就可以插入VFS中，从而可以同时支持各种不同的文件系统。&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e7%9b%ae%e5%bd%95%e9%a1%b9%e5%92%8c%e7%b4%a2%e5%bc%95%e5%85%b3%e7%b3%bb%e5%9b%be.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e7%9b%ae%e5%bd%95%e9%a1%b9%e5%92%8c%e7%b4%a2%e5%bc%95%e5%85%b3%e7%b3%bb%e5%9b%be.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;VFS包含四大数据结构：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;超级块结构super_block：用来存储文件系统详细信息，如块个数、块大小、空闲块、文件系统的信息、inode表的开始位置等；当文件系统被挂载时进入内存，初始化各自参数，将卷加到文件系统中，这样系统才知道在哪查找磁盘上的结构；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;目录项dentry：用来记录文件的名字，索引节点指针，以及其他目录项的层级关系，多个目录项关联起来就形成目录结构；目录项由内核维护，缓存在内存中，不存放于磁盘；&lt;/p&gt;
&lt;p&gt;目录与目录项不一样，目录是文件，持久化存在磁盘中，也通过inode访问，因为频繁查询目录需要读磁盘，效率低，所以内核就会把读过的目录用目录项缓存在内存，提升读取效率；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;文件索引节点结构inode：记录文件元信息（如inode编号、文件类型、文件大小、分配给它的块数、时间信息、访问权限、数据在磁盘的位置等），是文件的唯一标识，被存储在磁盘中，可以理解为inode是 文件名 的ID，通常有一个隐式的id用于找到inode在磁盘的位置，再通过inode找到存储的数据；&lt;/p&gt;
&lt;p&gt;与目录项是一对多的关系；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;硬链接&lt;/strong&gt;：与源文件是同一份文件，inode节点号相同；硬链接算是源文件的一个入口；只有当硬链接和对应的源文件都删除，文件实体才会被删除，所以可以通过设置硬链接防止重要文件被删；因为每个文件系统都有各自的inode数据结构和列表，所以硬链接不可用于跨文件系统。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;软链接&lt;/strong&gt;：独立文件，与源文件不是同一份文件，inode不同，类似快捷方式，存储源文件的位置信息，指向源文件；删除源文件，软连接依然存在，至少无法访问；软链接可以跨文件系统；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;进程打开文件实例结构file&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;磁盘读写最小单位是扇区，每个扇区只有512B大小，文件系统把多个扇区组成一个逻辑块，作为读写的最小单位，Linux中逻辑块大小为4KB，也就是一次性读写8个扇区&lt;/strong&gt;，提升读写效率；&lt;/p&gt;
&lt;p&gt;磁盘格式化时，会分为三个存储区，分别是超级块，索引节点区和数据块区，超级块和索引节点只有被使用时才会加载进内存；&lt;/p&gt;
&lt;p&gt;Liunx 挂载文件系统时，会读取文件系统超级块，将超级块加载进内存，从超级块出发读取并构造全部目录结构，目录结构指向存储设备文件时，是一个个文件索引节点结构，当文件被访问时，才被加载进内存，文件系统的基本操作单位是数据块，用户进程读写文件时使用字节，通过文件系统，操作对应的数据块，实现文件的读写。&lt;/p&gt;
&lt;h2 id=&#34;文件的存储&#34;&gt;文件的存储&lt;/h2&gt;
&lt;p&gt;文件的数据存放在磁盘上，就像程序在内存中存放的方式一样，有两种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;连续空间存放方式&lt;/p&gt;
&lt;p&gt;文件存放在磁盘连续的物理空间中，文件数据紧密相连，读写效率高，一次磁盘寻道就能读出整个文件，但存放时必须先知道一个文件的大小，才能分配对应的空间；&lt;/p&gt;
&lt;p&gt;但是有磁盘空间碎片和文件长度不易扩展的缺点；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;非连续空间存放方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;链表方式：通过链表离散和不连续的特点，解决磁盘碎片问题和文件动态扩展问题，提升磁盘空间利用率，但不支持直接访问。
&lt;ul&gt;
&lt;li&gt;隐式链表：文件头包含第一块和最后一块的位置，每个数据块里存放指向下一个数据块的指针；缺点在于无法直接访问数据块，只能通过指针顺序访问，同时每个数据块还要消耗空间存储指针，如果指针丢失或损坏，会导致文件数据丢失；&lt;/li&gt;
&lt;li&gt;显式链接：把隐式链表里每个数据块的指针存在一个链接表中，解决隐式链表的缺点；这个链接表，称为文件分配表，存储在内存中，提升检索速度，大大减少访问磁盘的次数，但不使用于大磁盘；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;索引方式：通过为每个文件创建一个索引数据块，存放指向文件数据块的指针列表，存放在文件头中，相当于目录，解决链表方式无法直接访问的问题，同时也解决磁盘碎片和文件不易扩展的问题，因为会为文件设置索引数据，如果文件很大，索引数据块也很大，所以只适用于小文件。&lt;/li&gt;
&lt;li&gt;链表 + 索引 组合的方式，比如链式索引块（在索引数据块留一个存放指向下一个索引块的指针），多级索引块（索引之上再创建索引，形成多级索引）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e6%96%87%e4%bb%b6%e5%ad%98%e5%82%a8%e6%96%b9%e5%bc%8f%e6%af%94%e8%be%83.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e6%96%87%e4%bb%b6%e5%ad%98%e5%82%a8%e6%96%b9%e5%bc%8f%e6%af%94%e8%be%83.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;空闲空间管理-1&#34;&gt;空闲空间管理&lt;/h2&gt;
&lt;p&gt;进行空闲空间管理，主要是为了快速找到可用空间，进行写入。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;空闲表法：&lt;/p&gt;
&lt;p&gt;为空闲空间建立一张表，表内容包括空闲区的第一个块号和该空闲区的块个数。当请求分配磁盘空间时，系统依次扫描空闲表里的内容，直到找到一个合适的空闲区域；用户撤销文件时，系统回收文件空间，也需要顺序扫描空闲表，寻找一个空闲表条目并释放空间的第一个物理块，以及它占用的块数填到这个条目；&lt;/p&gt;
&lt;p&gt;这种方法释放建立连续文件，如果是有大量空闲小空间，比较碎片，查找效率就很低；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;空闲链表法：&lt;/p&gt;
&lt;p&gt;通过链表阻止空闲块，一个空闲块通过指针指向下一块，但是这种方式无法随机访问，每当链上增加或移动空闲块时需要做很多IO操作，每个空闲块需要存储指针也浪费空间，不适合大型文件系统；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;位图法：&lt;/p&gt;
&lt;p&gt;磁盘上所有盘块都有一个二进制位与之对应，0表示空闲，1表示已分配，Linux就采用这种，空闲块使用位图，inode也使用位图；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;目录存储&#34;&gt;目录存储&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e7%9b%ae%e5%bd%95%e5%93%88%e5%b8%8c%e8%a1%a8.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e7%9b%ae%e5%bd%95%e5%93%88%e5%b8%8c%e8%a1%a8.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;目录文件的块里保存的是目录里面一项一项的文件信息（如文件名、文件inode、文件类型等），组合成列表，列表每一项就代表该目录下的文件的文件名和对应的inode，通过这个inode，就能找到真正的文件。为了查找方便，目录的格式改成了哈希表。&lt;/p&gt;
&lt;p&gt;目录查询如果通过在磁盘上反复搜索，就要不断进行IO，开销较大，所以一般是把文件目录缓存在内存，查找的时候在内存中查找，降低磁盘操作次数，提高文件系统的访问速度。&lt;/p&gt;
&lt;h2 id=&#34;访问和写入&#34;&gt;访问和写入&lt;/h2&gt;
&lt;p&gt;假设一个文件系统包含这5个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;超级块：包含该特定文件系统的信息，如有多少个inode和数据块，inode表开始的位置，标识文件系统类型的幻数；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据位图：记录数据块区的空闲和分配标记的空间管理；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;inode位图：记录inode块区的空闲和分配标记的空间管理；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;inode块区：每个inode由一个数字 i-number 隐式引用，从而计算出磁盘上相应节点的位置，取到对应的inode信息；每个inode包含关于文件的信息，如文件类型（是常规文件还是目录）、大小、分配给他的块数、保护信息（谁拥有以及谁可以访问）、时间信息（文件创建、修改、上次访问时间）、有关其数据块驻留在磁盘上的位置（比如数据指向磁盘对应位置的指针）；&lt;/p&gt;
&lt;p&gt;一个inode指向的数据块大小是有限的，如果文件特别大，通常可以给inode设置多级索引解决，比如有一个inode不是直接指向用户的数据块的，而是包含该文件涉及到的多个inode位置；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据块区：用户数据、目录数据存储、inode数据存储的位置；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;打开文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;假设通过open(&amp;quot;/foo/bar&amp;quot;, O_RDONLY)打开文件，首先会找到目录文件对应的inode对应的i-number，一般来说，会存储在超级块中，便于操作系统挂载文件系统时就能知道，一般根的inode的i-number是2；&lt;/li&gt;
&lt;li&gt;根据访问路径，从根目录开始遍历路径名，找到对应目录的inode及其目录数据块，最后找到对应文件的inode号，读入内存；&lt;/li&gt;
&lt;li&gt;文件系统做最后的权限检查，在每个进程打开的文件列表中，为此进程分配一个文件描述符，并返回给用户；&lt;/li&gt;
&lt;li&gt;open导致的IO量与路径名的长度成正比，文件所在的位置越深，IO量越多；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;读取文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;打开文件后，程序可以发出read()系统调用，从文件中读取，第一次读取将在文件的第一个块中读取（第一次的偏移量是0），查阅inode以查找这个块的位置；&lt;/li&gt;
&lt;li&gt;读取也会用新的最后访问时间更新inode，更新此文件描述符在内存中打开的文件表，更新文件偏移量，以便下一次读取第二个文件块，读取每个块需要文件系统首先查询inode，然后读取该块，再写入更新inode的最后访问时间字段，此时会发生多次磁盘IO；&lt;/li&gt;
&lt;li&gt;文件打开后，每次读取时，会读一次文件inode，读一次文件数据，写一次文件inode；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写入文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;打开文件后，程序可以发出write()系统调用，往文件写入数据，写入分为两种，一种是创建文件并写入，另一种是写入覆盖；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;覆盖写入比较简单，打开文件后，读取一次文件inode，读取一次数据位图，写入一次文件数据，写入一次数据位图，写入一次文件inode；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写入一个新文件时，每次写入操作不仅需要将数据写入磁盘，还需要决定将哪个块分配给文件，不仅要分配一个inode，还要在包含新文件的目录中分配空间，从而相应的更新磁盘的其他结构，所以每次写入文件逻辑上会发生5个IO，如果目录需要增长以容纳新条目，则还需要额外的IO；&lt;/p&gt;
&lt;p&gt;创建文件基本的5个IO：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读取inode位图，查找空闲的inode；&lt;/li&gt;
&lt;li&gt;写入inode位图，将新分配的块标记为已分配；写入新的inode（将它本身的信息写入数据块区），进行初始化；&lt;/li&gt;
&lt;li&gt;读取新inode信息，写入新inode对应的目录数据，将文件的高级名称链接到它的inode号；&lt;/li&gt;
&lt;li&gt;写入这个新inode的目录inode，进行更新；&lt;/li&gt;
&lt;li&gt;之后才说真正的数据块写入；&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关闭文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;释放文件描述符，此时不会有磁盘IO发生；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为了解决读取和写入时产生的大量IO导致的性能问题，引入系统内存来缓存重要的块，从而提升性能，比如第一次打开可能会产生很多IO来读取目录的inode和数据，但随后打开同一文件或同一目录中的文件，会命中缓存，不用IO，从而提升性能；&lt;/p&gt;
&lt;p&gt;系统内存会划分为静态内存和动态内存：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态内存：划定固定大小的缓存，在启动时进行分配，但这可能会导致浪费，缓存策略跟虚拟内存差不多，也可以使用LRU等进行维护；&lt;/li&gt;
&lt;li&gt;动态内存：将虚拟内存页面和文件系统页面集成到统一页面缓存中，从而可以灵活的分配；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缓存对写入的影响：&lt;/p&gt;
&lt;p&gt;通过延迟写入，文件系统可以将一批数据放入一个IO中完成，或者 创建一个文件，inode位图被更新，稍后在创建另一个文件时又被更新，文件系统会在第一次更新后延迟写入，从而节省一次IO 等场景，合并IO写入，从而提升性能，但在未写入磁盘时，如果系统发生崩溃，更新就会丢失，所以对于对数据完整性比较高的数据，就需要强制写入磁盘，通过调用fsync() 或 使用绕过缓存的直接 IO接口 或 使用原始磁盘接口并完全避免使用文件系统写入；&lt;/p&gt;
&lt;h2 id=&#34;文件io&#34;&gt;文件IO&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;缓冲 I/O ：利用标准库的缓存实现文件加速访问，而标准库再通过系统调用访问文件；&lt;/p&gt;
&lt;p&gt;非缓冲 I/O：直接通过系统调用访问文件，不经过标准库缓存；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;直接 I/O ：不使用内核缓存和用户程序之间的数据复制，直接经过文件系统访问磁盘文件；&lt;/p&gt;
&lt;p&gt;非直接 I/O：读操作时，数据从内核缓存中拷贝给用户程序，写操作时，数据从用户程序拷贝给内核缓存，再由内核决定什么时候写入数据到磁盘；&lt;/p&gt;
&lt;p&gt;决定刷盘的时机：内核发现缓存数据太多；用户主动调用sync函数；内存使用紧张；内核缓存缓存时间超过某个时间点；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;阻塞IO：读取数据时，线程被阻塞，直到内核数据准备好，并把数据从内核缓冲区拷贝到应用程序缓冲区，才能被读取；&lt;/p&gt;
&lt;p&gt;阻塞等待指的是 **「内核数据准备好」和「数据从内核态拷贝到用户态」**这两个过程&lt;/p&gt;
&lt;p&gt;非阻塞IO：读取数据时，当数据未准备好，就立即返回，继续往下执行；当数据准备好，内核将数据拷贝到应用程序缓冲区，就能读取数据，本质上都要同步等待，只是非阻塞IO不会一直等而已；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;page-cache&#34;&gt;Page Cache&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/PageCache.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/PageCache.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Page Cache 的&lt;strong&gt;本质是由 Linux 内核管理的内存区域&lt;/strong&gt;。我们通过 mmap 以及 buffered I/O 将文件读取到内存空间实际上都是读取到 Page Cache 中。&lt;/p&gt;
&lt;p&gt;page 是内存管理分配的基本单位， Page Cache 由多个 page 构成。page 在操作系统中通常为 4KB 大小（32bits/64bits），而 Page Cache 的大小则为 4KB 的整数倍。但并不是所有 page 都被组织为 Page Cache。&lt;/p&gt;
&lt;p&gt;Page Cache 与 buffer cache 的区别：&lt;strong&gt;Page Cache 用于缓存文件的页数据，是针对文件系统的文件缓存，属于逻辑层，最终需要映射到实际的物理磁盘；buffer cache 用于缓存块设备（如磁盘）的块数据，也就是在没有文件系统的情况下，直接对磁盘进行操作的数据的缓存。&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;页是逻辑上的概念，因此 Page Cache 是与文件系统同级的；&lt;/li&gt;
&lt;li&gt;块是物理上的概念，因此 buffer cache 是与块设备驱动程序同级的。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他们都是用来加速IO：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写数据时首先写到缓存，将写入的页标记为 dirty，然后向外部存储 flush，也就是缓存写机制中的 write-back（另一种是 write-through，Linux 默认情况下不采用）；&lt;/li&gt;
&lt;li&gt;读数据时首先读取缓存，如果未命中，再去外部存储读取，并且将读取来的数据也加入缓存。操作系统总是积极地将所有空闲内存都用作 Page Cache 和 buffer cache，当内存不够用时也会用 LRU 等算法淘汰缓存页。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Linux 2.4 版本以前的内核，这两者是分开的，但因为块设备大多是磁盘，磁盘上的数据又大都通过文件系统来组织，就会导致很多数据被缓存了两次，浪费内存，所以2.4之后的版本就融合在一起，如果一个文件的页加载到了Page Cache，那么同时buffer cache只需要维护指向页的指针即可，只有那些没有文件表示的块，或者绕过文件系统直接操作的块，才会真正放到buffer cache里。&lt;/p&gt;
&lt;p&gt;Page Cache预读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用户线程仅仅请求读取磁盘上文件 A 的 offset 为 0-3KB 范围内的数据，由于磁盘的基本读写单位为 block（4KB），于是操作系统至少会读 0-4KB 的内容，这恰好可以在一个 page 中装下。&lt;/li&gt;
&lt;li&gt;但是操作系统出于局部性原理会选择将磁盘块 offset [4KB,8KB)、[8KB,12KB) 以及 [12KB,16KB) 都加载到内存，于是额外在内存中申请了 3 个 page；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于Page Cache与文件持久化一致性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Write Through（写穿）&lt;/strong&gt;：向用户层提供特定接口，应用程序可&lt;strong&gt;主动&lt;/strong&gt;调用接口来保证文件一致性；只要上层一旦调用写入，数据落盘，就不会丢失数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Write back（写回）&lt;/strong&gt;：系统中存在&lt;strong&gt;定期任务&lt;/strong&gt;（表现形式为内核线程），周期性地同步文件系统中文件脏数据块，这是默认的 Linux 一致性方案；当系统宕机时无法保证数据落盘，就会丢失数据。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加快数据读取，读取数据时，直接读取内存中的缓存，不需要通过磁盘IO。&lt;/li&gt;
&lt;li&gt;减少IO访问次数，提高系统磁盘IO吞吐量，利用Page Cache缓存和预读得能力，又因为程序往往符合局部性原理，一次IO将多个page装入Page Cache来减少磁盘IO次数，提升磁盘IO吞吐量。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;劣势：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Page Cache需要占用额外物理内存空间，可能会导致swap操作，最终反而导致磁盘IO负载上升。&lt;/li&gt;
&lt;li&gt;Page Cache在内核，但是对应用层没有提供很好得管理API，使得不能很好进行自定义优化，只能在用户空间实现自己的page管理，利用不到Page Cacge。&lt;/li&gt;
&lt;li&gt;在某些场景下，会比Direct IO多一次磁盘读IO和磁盘写IO，Direct IO可以使得用户态读取文件直接与磁盘交互，无需使用Page Cache层。（比如利用DMA技术）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当进程使用缓冲IO写文件时，如果写到一半进程崩溃，已写入的数据不会丢失，因为调用系统调用写入文件时，先写到内核的Page Cache，如果进程崩溃，文件数据还保留在内核的Page Cache中，内核会找个合适的时机，将Page Cache中的数据持久化到磁盘，但是如果是Page Cache里的文件数据在持久化到磁盘之前，系统崩溃， 那就有可能丢失文件数据了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;崩溃与一致性&#34;&gt;崩溃与一致性&lt;/h2&gt;
&lt;p&gt;以一个简单文件系统为例，简单文件系统包含超级块、数据位图、inode位图、inode区块、数据块区，一次写入涉及到多个IO，当崩溃发生时，可能有如下场景产生不一致：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只有数据块写入磁盘，此时由于其他区块还没写入，所以不会有什么影响；&lt;/li&gt;
&lt;li&gt;只有更新后的inode区块写入磁盘，此时由于数据区块还没写入，inode指针指向的数据区块就有问题；&lt;/li&gt;
&lt;li&gt;只有更新后的数据位图写入磁盘，由于没有inode指向数据区块，数据位图指向的数据区块永远不会有人使用，此时导致空闲空间泄露；&lt;/li&gt;
&lt;li&gt;更新后inode区块和数据位图写入磁盘，但数据区块没有写入磁盘，inode指针指向的数据区块就有问题；&lt;/li&gt;
&lt;li&gt;更新后的inode区块和数据块写入磁盘，但数据位图没有写入磁盘，会导致数据区块被覆盖；&lt;/li&gt;
&lt;li&gt;更新后的数据位图和数据区块写入磁盘，但inode区块没有写入磁盘，由于没有inode指向数据区块，数据位图指向的数据区块永远不会有人使用，此时导致空闲空间泄露；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;崩溃恢复：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;fsck：文件系统检查程序，它是一款工具，会在文件系统写入数据到磁盘的多个阶段运行检查，比如检查超级块、空闲块、inode状态、inode链接、重复指针（两个不太的inode指向同一个数据块）、坏块、目录检查等，判断他们是否不一致，如果是，则会进行修复；&lt;/p&gt;
&lt;p&gt;这种方案虽然能进行崩溃恢复，但是比较原始，实现上也比较复杂，需要知道文件系统的底层原理，而且每次检查需要扫描正规磁盘，速度太慢，特别是当只有少数几个数据有问题时，扫描整个盘只为修复这几个数据，代价就特别大了。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日志：通过在将用户数据写入磁盘的时候，将相关信息记录到日志并刷盘，以实现崩溃后通过日志信息进行恢复。日志需要记录几个方面的内容，如事务开始标志、inode信息、位图信息、用户数据、事务结束标志，但是，日志写入也是要刷盘的，本身也存在崩溃导致不一致的问题，所以需要保证事务结束写入时，前面四个信息已经写入完成（它们之间的顺序可以不用保证，但一定要发生在事务结束标志写入之前完成），可以利用磁盘提供的原子性保证（磁盘会以一定块的大小一起写入，比如每次写入512字节的块），为此有两种日志方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;数据日志：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;日志写入：将事务内容（事务开始标志、inode信息、位图信息、用户数据）写入日志，等待写入完成；&lt;/li&gt;
&lt;li&gt;日志提交：将事务结束标志写入日志，等待写入完成，此时事务被认为已提交；&lt;/li&gt;
&lt;li&gt;加检查点：此时可以把用户相关的元数据和用户数据写入最终的磁盘位置；&lt;/li&gt;
&lt;li&gt;释放出空闲空间：通过更新日志中的超级块，在日志中标记该事务为空闲；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;崩溃恢复时，就可以扫描日志，恢复加检查点之前的数据了，将扫描的日志按顺序重放，文件系统尝试将事务中的块写入它们最终的磁盘位置（因为日志本身已经包含了用户数据了）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;元数据日志：数据日志中，还要记录用户数据，但检查点之后，用户数据刷盘，用户数据又存入了一次，导致额外空间浪费和开销做出的改进，通过只调整日志写入顺序，只写入一次用户数据实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户数据写入：将用户数据写入最终位置，等待完成；&lt;/li&gt;
&lt;li&gt;日志元数据写入：将事务开始标志和元数据写入日志，等待写入完成；&lt;/li&gt;
&lt;li&gt;日志提交：将事务结束标志写入日志，等待写入完成，此时事务被认为已提交，其实只要保证1和2两个步骤在3之前完成即可；&lt;/li&gt;
&lt;li&gt;加检查点元数据：将元数据更新的内容写入文件系统最终位置；&lt;/li&gt;
&lt;li&gt;释放出空闲空间：更新日志中的超级块，在日志中标记该事务为空闲；&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这种方案有个问题就是数据块区的复用，假如先有事务和用户数据文件写入同一目录，然后又删除，又创建了一个新文件，新文件可能复用了之前目录上的其他文件相同的块（块号一样，但旧数据可能还没被删除），由于是元数据日志，只记录新文件的元数据，当发生崩溃恢复时，可能会导致新文件元数据指向旧文件数据区块，所以，在删除操作发生后，元数据日志也需要将删除导致的撤销记录也写入到日志，避免这种问题的发生；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日志记录优化：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;批处理：写日志时，不会一次一个向磁盘提交每个更新，而是先写进缓存，攒一定的量，定时提交刷盘，从而避免对磁盘写入过多流量；&lt;/li&gt;
&lt;li&gt;轮转日志，避免日志文件大小膨胀，导致崩溃恢复时时间变长，也提升磁盘利用率。一般来说，一旦事务被加检查点，检查点之前的日志就允许被轮转了，此时在日志的超级块中标记日志的最新和最旧事务用于区分即可；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对文件系统的所有写入进行排序，确保磁盘上的结构永远不会处于不一致的状态，比如先写入数据区块，再写入对应的inode区块，确保inode永远不会指向错误等这样的规则，但是实现上会比较复杂；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;写时复制Copy on Write，比如日志文件系统的实现；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反向指针：写入之间不强制执行排序，但是写入的数据块都要引用它所属的inode，访问文件时，文件系统可以检查正向指针是否指向引用它的块，从而确定文件是否一致；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;日志 + 乐观崩溃一致性：尽可能多地向磁盘发出写入，事务写入日志时，在开始和结束块中包含日志内容的校验和，使得文件系统可以立即写入整个事务，而不用产生等待，崩溃恢复期间，利用事务校验和，检测文件是否一致；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;日志文件系统的实现&#34;&gt;日志文件系统的实现&lt;/h2&gt;
&lt;p&gt;日志文件系统的诞生基于以下几个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内存大小不断增长，可用缓存变大，磁盘流量更多的由写入操作组成，磁盘的性能瓶颈取决于写性能；&lt;/li&gt;
&lt;li&gt;读时发生随机IO无法避免，但写入时随机IO性能比顺序IO性能差太多；&lt;/li&gt;
&lt;li&gt;如果使用之前的位图、inode区块、数据区块这种组成，会导致磁盘出现很多短寻道和旋转延迟，性能远低于峰值顺序带宽；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基于这几个原因，引入日志文件系统，简单来说，就是写入磁盘时，首先将所有更新（包括元数据）缓存在内存段中，当段满时，顺序写入磁盘，并传输到磁盘未使用部分，日志文件系统永远不会覆写现有数据，而是始终将段写入空闲的位置，由于段比较大，使得写入性能接近峰值；&lt;/p&gt;
&lt;p&gt;文件写入磁盘之前，首先会写入内存，写入的内容包括用户数据、inode、地址引用等元数据，不断的累积写入的块，直到缓存大小达到规定的段大小时，将该段一次性写入磁盘（当有多次写入时通常是先排用户数据、再排元数据的顺序写入），段的大小跟磁盘的传输速率和定位开销有关，计算出一个越接近峰值带宽的写入大小；&lt;/p&gt;
&lt;p&gt;由于这种写入会导致inode分散再整个磁盘上（不像上面的格式，inode存储在固定位置，可以比较简单算出数据的磁盘地址），所以除了必要的元数据以外，还需要记录一个imap，用于根据给定的i-number号找到对应的inode，从而找到对应的磁盘地址；imap就写在相关inode元数据的旁边（不能写在固定位置，因为每次写入都要更新，如果存在固定位置，就又要有旋转寻道带来的消耗了）；&lt;/p&gt;
&lt;p&gt;而为了快速找到imap和inode，则会在固定的位置（检查点区域，存在在磁盘的头部和尾部两个地方，写入时是交替写入）存储inode范围映射，用于快速找到inode所在的磁盘的映射片段，检查点区域仅定期更新（比如每30s），因此性能不会太受影响；&lt;/p&gt;
&lt;p&gt;所以在平时，会先查询检查点区域，将整个inode映射片段加载进缓存，当发生读取操作时，根据i-number在缓存里查找inode映射片段，磁盘选择到对应片段，根据i-number在imap找到inode，根据inode找到用户数据的磁盘地址，开始读取文件数据，甚至可以直接缓存所有imap，快速查找；&lt;/p&gt;
&lt;p&gt;由于日志文件系统的特性，数据总是顺序写入，不会覆写现有数据，所以可能存在同一个inode指向两个用户数据块，此时就有新旧两个用户数据块了，对于用户数据块的写入会产生版本号，所以在这种常见下，可以根据版本号进行区分，同时也方便删除恢复，对于旧的用户数据块，日志文件系统会有定时任务，定时清理这些旧数据，清理时会按段清理，将里面存活的数据块打包移动到新位置，非存活的数据块则释放，恢复成空闲空间；（copy on write）&lt;/p&gt;
&lt;p&gt;对于崩溃恢复，日志文件系统本身也需要写入日志来实现崩溃恢复，原理是利用头尾两个检查点区域，并在每个段写入时指向要写入的下一个段，为了保证更新检查点以原子的方式，每次写入时，交替写入头尾两个检查点区域，并带上时间戳，当崩溃恢复时，比较头尾两个检查点区域的内容是否一致，来判断检查点区域的一致性；对于写入数据时的原子性，由于检查点是定时更新，如果间隔时间太久，可能会导致丢失太多数据，因此使用前滚技术，基本思想是从最后一个检查点区域开始，找到日志尾部的检查点区域，读取它的下一段，判断其中是否包含任何有效的更新，如果有，则恢复来当前检查点以来写入的数据和元数据；&lt;/p&gt;
&lt;h2 id=&#34;关于数据完整性&#34;&gt;关于数据完整性&lt;/h2&gt;
&lt;p&gt;数据存储在磁盘中，可能会因为磁头碰撞、磁头没接触到磁盘等问题，导致数据位不可读；宇宙射线等使得数据位翻转，导致各自内容不正确；因为磁盘固件问题，导致数据写入错误的位置等问题&lt;/p&gt;
&lt;p&gt;一般使用校验和的方式进行验证，将校验和与数据块一起存到磁盘中，从磁盘获取数据时，计算出摘要，与存储的校验和进行比较，从而判断数据的完整性，常见的校验和函数：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;异或方案：比如对一个数据块每4个字节进行异或，最终得到一个值作为这块数据的校验和；&lt;/li&gt;
&lt;li&gt;累加方案：计算每个数据块上指向二进制补码加法，忽略溢出，计算出校验和；&lt;/li&gt;
&lt;li&gt;CRC循环冗余检测，也用于网络传输的数据校验：将数据的二进制数除于多项式的二进制数得到一个余数，这个余数就是CRC校验码；比如给定数据的二进制数为&lt;code&gt;10110011&lt;/code&gt;，多项式为 &lt;code&gt;G(x)=x^4+x^3+1&lt;/code&gt;（多项式为双方事先约定的），多项式对应的二进制数是 &lt;code&gt;10000+1000+1=11001&lt;/code&gt;，两者相除，取余数，这里是取4位，得到0100，即为CRC效验码；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于数据写错位置的，则可以在数据写入时，也把位置信息也写入校验和中，读取时，将读取位置参与到摘要计算中，对比校验和，从而知道读取的数据的正确性；&lt;/p&gt;
&lt;p&gt;对于丢失写入，经典的方法是写入后立即读取，就能判断，但是这种方案非常慢，还伴随双倍的IO，成本巨大；其他方案的，比如在文件系统的每个inode和间接块中，包含文件每个块的校验和，这样即使对数据块本身的写入丢失，inode内的校验和也不会和旧数据匹配，但也仍然存在两者同时丢失的情况；&lt;/p&gt;
&lt;h1 id=&#34;网络&#34;&gt;网络&lt;/h1&gt;
&lt;p&gt;在Linux中，替代传输层以上协议实体的标准接口，称为套接字，负责实现传输层以上的所有功能，即套接字是一套通用的网络API，下层由多个协议栈实现。&lt;/p&gt;
&lt;h2 id=&#34;网络io模型&#34;&gt;网络IO模型&lt;/h2&gt;
&lt;p&gt;I / O操作通常包含以下两个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;等待网络数据到达网卡(读就绪) / 等待网卡可写(写就绪) –&amp;gt; 读取/写入到内核缓冲区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;从内核缓冲区复制数据 –&amp;gt; 用户空间(读) / 从用户空间复制数据 -&amp;gt; 内核缓冲区(写)&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;判断一个I/O模型是同步还是异步，主要看第二步在复制数据时是否会阻塞当前进程，即CPU能不能去执行其他线程。&lt;/p&gt;
&lt;p&gt;Unix网络中的5种 I/O 模型：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;同步阻塞 I / O：一次IO，内数据没有准备好时，调用方法会阻塞等待，直至完成；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步非阻塞 I / O：一次IO内，数据没有准备好时不断间隔轮询，等到数据准备好的结果后拷贝到用户态，在轮询的间隔期可执行其他操作；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;I / O多路复用：一个管道阻塞监听所有IO，内核数据是否准备好，事件驱动，监听到数据准备好后拷贝数据到用户态，如select、poll、epoll；&lt;/p&gt;
&lt;p&gt;I / O多路复用实际上就是在非阻塞I/O的基础上，增加一个线程同时监听多个文件描述符（I/O事件）阻塞等待，并在某个文件描述符可读写时收到通知，I / O复用并不是复用IO连接，而是复用线程，让一个线程可以同时处理多个连接（I/O事件）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同步信号驱动 I / O：注册回调函数，内核数据准备好后进行回调，在此期间系统可以做其他事情，数据准备阶段是异步，数据拷贝阶段是同步；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;异步 I / O：真正的异步，数据的准备和拷贝都是自动完成；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e7%bd%91%e7%bb%9cIO%e6%a8%a1%e5%9e%8b.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e7%bd%91%e7%bb%9cIO%e6%a8%a1%e5%9e%8b.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;io多路复用&#34;&gt;I/O多路复用&lt;/h3&gt;
&lt;h4 id=&#34;select&#34;&gt;select&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可监控的文件描述符个数取决于 sizeof(fd_set) 的值，默认是1024。假设服务器上 sizeof(fd_set)＝512，每 bit 表示一个文件描述符，则服务器上支持的最大文件描述符是 512*8=4096。&lt;/li&gt;
&lt;li&gt;将 fd 加入 select 监控集的同时，还要再使用一个数据结构 array 保存放到 select 监控集中的 fd，一是用于在 select 返回后，array 作为源数据和 fd_set 进行 FD_ISSET 判断，二是 select 返回后会把以前加入的但并无事件发生的 fd 清空，则每次开始 select 前都要重新从 array 取得 fd 逐一加入（FD_ZERO 最先），扫描 array 的同时取得 fd 最大值 maxfd，用于 select 的第一个参数。&lt;/li&gt;
&lt;li&gt;所以select 模型必须在 select 前循环 array（加 fd，取 maxfd），select 返回后循环 array（FD_ISSET 判断是否有事件发生）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;fd_set有个数限制，最大并发数限制：使用 32 个整数的 32 位，即 32*32=1024 来标识 fd；&lt;/li&gt;
&lt;li&gt;每次调用 select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；&lt;/li&gt;
&lt;li&gt;性能衰减严重：每次 kernel 都需要线性扫描整个 fd_set，所以随着监控的描述符 fd 数量增长，其 I/O 性能会线性下降；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;用户态有一个fd_set，是一个bitmap，表示要监听哪些fd；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;调用select时，从用户态把fd_set全量复制到内核态，由内核态遍历整个fd_set来判断是否有数据到来，置位表示有数据，把fd_set返回给用户态；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户态再遍历整个fd_set，和原始的fd_set比较，才知道哪个监听的fd是有数据的；&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;fd_set不可重用，处理完这个fd_set后，还得reset整个fd_set，之所以不可重用，是因为fd_set在select前后有两层语义，select前把要监听的fd置为1，select后把有数据fd的置为1；&lt;/p&gt;
&lt;p&gt;内核遍历判断这个fd_set时是阻塞的；&lt;/p&gt;
&lt;h4 id=&#34;poll&#34;&gt;poll&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;poll 的实现和 select 非常相似，只是描述 fd 集合的方式不同，poll 使用 pollfd 结构而不是 select 的 fd_set 结构；&lt;/li&gt;
&lt;li&gt;poll 解决了最大文件描述符数量限制的问题，但是同样需要从用户态拷贝所有的 fd 到内核态，也需要线性遍历所有的 fd 集合，所以它和 select 只是实现细节上的区分，并没有本质上的区别。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;总结：poll工作原理和select一样，只是对select做了一定优化，重新对fd做了一个包装，不再使用fd_set，而是使用pollfd，里面有events表示要监听的状态，revents表示内核实际收到的状态，解决fd_set不可重用的问题；另外，fd_set是一个bitmap，长度限制在1024，pollfd是个链表，长度上限就高很多了；&lt;/p&gt;
&lt;h4 id=&#34;epoll&#34;&gt;epoll&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;虽然原理差不多，但select&amp;amp;poll 错误预估了一件事，当数十万并发连接存在时，可能每一毫秒只有数百个活跃的连接，同时其余数十万连接在这一毫秒是非活跃的。当进程认为需要找出有报文到达的活跃连接时，就会调用select&amp;amp;poll，所以select&amp;amp;poll在高并发时会被频繁调用，如果全部待监控的连接数很多，但活跃连接很少，就会有效率问题了。&lt;/p&gt;
&lt;p&gt;epoll优化了select性能开销很大，文件描述符数量少的问题。&lt;/p&gt;
&lt;p&gt;实现上，epoll分清了高频和低频调用，内部存储分为两种：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;一个是监听列表，使用红黑树存储所有监听的fd，每个插入或删除的fd性能稳定，插入时会为该fd注册一个回调函数，保证了每个fd在其生命周期只拷贝一次&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个是就绪列表，使用链表存储，阻塞监听。当fd就绪时，就会触发回调函数由内核调用，把就绪的fd放到就绪链表里。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;epoll会去检查就绪链表，保证每次拿到的都是可用的fd，所以epoll不需要把全部监听的fd集合都从用户态拷贝到内核态，只需要拷贝已就绪的fd。&lt;/p&gt;
&lt;p&gt;select&amp;amp;poll 调用时会将全部监听的 fd 从用户态空间拷贝至内核态空间并线性扫描一遍找出就绪的 fd 再返回到用户态，epoll 内的实现只会直接返回已就绪 fd，因此 epoll 的 I/O 性能不会像 select&amp;amp;poll 那样随着监听的 fd 数量增加而出现线性衰减，实现高效。&lt;/p&gt;
&lt;p&gt;事件触发模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;边缘触发模式（ET），当被监控的 Socket 描述符上有可读事件发生时，&lt;strong&gt;服务器端只会从 epoll_wait 中苏醒一次&lt;/strong&gt;，即使进程没有调用 read 函数从内核读取数据，也依然只苏醒一次，因此我们程序要保证一次性将内核缓冲区的数据读取完；&lt;strong&gt;一般和非阻塞 I/O 搭配使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;水平触发模式（LT），当被监控的 Socket 上有可读事件发生时，&lt;strong&gt;服务器端不断地从 epoll_wait 中苏醒，直到内核缓冲区数据被 read 函数读完才结束&lt;/strong&gt;，目的是告诉我们有数据需要读取；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;epoll 支持边缘触发和水平触发的方式，而 select/poll 只支持水平触发，一般而言，边缘触发的方式会比水平触发的效率高。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;零拷贝&#34;&gt;零拷贝&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;传统的Linux的标准IO接口基于数据拷贝操作，IO操作会导致数据在操作系统内核地址空间的缓冲区和用户进程地址空间定义的缓冲区之间传输。设置缓冲区最大的好处是可以减少磁盘 I/O 的操作，而传统的 Linux I/O 在数据传输过程中深度依赖 CPU去执行数据拷贝的操作，系统开销极大，限制了操作系统有效进行数据传输操作的能力。比如一次读取磁盘文件，到写入网卡，数据的拷贝和上下文切换都由CPU来完成。&lt;/p&gt;
&lt;p&gt;所以出现了DMA技术，DMA技术就是为了解决CPU过多参与IO带来资源浪费问题，让每个IO设备都有自己的DMA控制器，由DMA控制器参与数据传输工作，CPU仅用来接收通知，&lt;strong&gt;在进行 I/O 设备和内存的数据传输的时候，数据搬运的工作全部交给 DMA 控制器，而 CPU 不再参与任何与数据搬运相关的事情，这样 CPU 就可以去处理别的事务&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;Linux中传统的IO读写通过&lt;code&gt;read()/write()&lt;/code&gt;系统调用完成。&lt;code&gt;read()&lt;/code&gt;把数据从存储器（磁盘、网卡）等读取到用户缓冲区，&lt;code&gt;write()&lt;/code&gt;把数据从用户缓冲区写到存储器。一次读取磁盘文件，到写入网卡，中间一共触发了4次用户态和内核态的上下文切换，分别是&lt;code&gt;read()/write()&lt;/code&gt;调用和返回时的切换，2次DMA拷贝（硬件与内核态之间）、2次CPU拷贝（用户态与内核态之间）。&lt;/p&gt;
&lt;p&gt;零拷贝就是指在执行IO操作时，让数据拷贝直接发生在内核，从而节省CPU周期和内存带宽。零拷贝技术基于Page Cache，利用其预读提升缓存数据访问性能，解决机械硬盘寻址慢的问题。&lt;/p&gt;
&lt;p&gt;作用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少甚至完全避免操作系统内核和用户应用程序地址空间这两者之间进行数据拷贝操作，从而减少用户态 &amp;ndash; 内核态上下文切换带来的系统开销。&lt;/li&gt;
&lt;li&gt;减少甚至完全避免操作系统内核缓冲区之间进行数据拷贝操作。&lt;/li&gt;
&lt;li&gt;帮助用户进程绕开操作系统内核空间直接访问硬件存储接口操作数据。&lt;/li&gt;
&lt;li&gt;利用 DMA 而非 CPU 来完成硬件接口和内核缓冲区之间的数据拷贝，从而解放 CPU，使之能去执行其他的任务，提升系统性能。&lt;/li&gt;
&lt;li&gt;零拷贝只适合那些数据不需要在用户态做修改的数据传输。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;实现方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少甚至避免用户空间和内核空间之间的数据拷贝：数据拷贝直接在内核完成，不经过用户态。在一些场景下，用户进程在数据传输过程中并不需要对数据进行访问和处理，那么数据在 Linux 的 Page Cache 和用户进程的缓冲区之间的传输就完全可以避免，让数据拷贝完全在内核里进行，甚至可以通过更巧妙的方式避免在内核里的数据拷贝。这一类实现一般是通过增加新的系统调用来完成的，比如 Linux 中的 &lt;code&gt;mmap()&lt;/code&gt;，&lt;code&gt;sendfile() &lt;/code&gt;以及 &lt;code&gt;splice()&lt;/code&gt; 等。&lt;/li&gt;
&lt;li&gt;绕过内核的直接 I/O：&lt;strong&gt;允许在用户态进程绕过内核直接和硬件进行数据传输&lt;/strong&gt;，内核在传输过程中只负责一些管理和辅助的工作。这种方式其实和第一种有点类似，也是试图避免用户空间和内核空间之间的数据传输，只是第一种方式是把数据传输过程放在内核态完成，而这种方式则是直接绕过内核和硬件通信，效果类似但原理完全不同。&lt;/li&gt;
&lt;li&gt;内核缓冲区和用户缓冲区之间的传输优化：这种方式侧重于在用户进程的缓冲区和操作系统的页缓存之间的 CPU 拷贝的优化。这种方法延续了以往那种传统的通信方式，但更灵活。&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;极客时间 - 操作系统实战45讲&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/266950886&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux系统中，为什么需要区分内核空间与用户空间？&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;极客时间 - Linux性能优化实战&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://strikefreedom.top/archives/linux-io-and-zero-copy&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Linux IO原理和零拷贝技术全面解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/121826927&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Unix网络编程的5种I/O模型&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000022653305&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Unix的五种IO模型介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://xiaolincoding.com/os/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;小林coding - 图解系统&lt;/a&gt;，写得通俗易懂，适合快餐式阅读，强推！&lt;/p&gt;
</description>
        </item>
        <item>
        <title>理财方案收集</title>
        <link>http://nixum.cc/p/%E7%90%86%E8%B4%A2%E6%96%B9%E6%A1%88%E6%94%B6%E9%9B%86/</link>
        <pubDate>Sat, 05 Aug 2023 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/%E7%90%86%E8%B4%A2%E6%96%B9%E6%A1%88%E6%94%B6%E9%9B%86/</guid>
        <description>&lt;p&gt;初期：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;理财软件：支付宝、微信、各个银行 app (如招商银行)、微众银行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;活钱理财，比如余额宝、余利宝、活期，银行app里的各自xx宝、各种货币基金、微众银行的活期、活期plus，优点是随时可以转入转出，收益率大概是3%&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定期理财，跨度在 1/3/6/12 个月&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;纯债基金，会有短期波动&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;指数基金、债券基金、黄金基金&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;境外的指数，如美国的标普 500 、纳斯达克 100 指数、德国的 DAX 指数、越南指数&lt;/li&gt;
&lt;li&gt;国内的指数，如中证 1000 、中证 500 、上证 50 等&lt;/li&gt;
&lt;li&gt;黄金，黄金的 ETF 指数&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>JVM</title>
        <link>http://nixum.cc/p/jvm/</link>
        <pubDate>Tue, 18 Jun 2019 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/jvm/</guid>
        <description>&lt;h1 id=&#34;jvm&#34;&gt;JVM&lt;/h1&gt;
&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h2 id=&#34;jvm内存模型&#34;&gt;JVM内存模型&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;JVM内存模型&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;JVM内存模型&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;方法区也叫永久代，持久代，非堆，不算在堆里面&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;年轻代也叫新生代&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;注意区别于Java内存模型&lt;/p&gt;
&lt;p&gt;JVM内存模型描述的是线程运行时的数据在内存的分布&lt;/p&gt;
&lt;p&gt;Java内存模型是多线程情况下数据的分布&lt;/p&gt;
&lt;h2 id=&#34;引用类型&#34;&gt;引用类型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;强引用：通过new的方式创建，不会被轻易回收&lt;/li&gt;
&lt;li&gt;软引用（SoftReference）：被软引用关联的对象只有在内存不够时才会被回收&lt;/li&gt;
&lt;li&gt;弱引用（WeakReference）：被弱引用关联的对象一定会被回收，只能存活至下次垃圾回收发生之前&lt;/li&gt;
&lt;li&gt;虚引用（PhantomReference）：比如将对象引用设置为null，该引用指向的对象就会被回收，相当于告知JVM可以回收该对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;软引用、弱引用、虚引用均可以搭配引用队列使用，且虚引用必须搭配引用队列使用。使用引用队列时，这些引用对象被垃圾收集器回收之后会进入引用队列，等待二次回收。引用队列一般用于与GC交互的场景，比如，垃圾回收时进行通知。&lt;/p&gt;
&lt;h2 id=&#34;可达性分析&#34;&gt;可达性分析&lt;/h2&gt;
&lt;p&gt;以 GC Roots 为起始点进行搜索，可达的对象都是存活的，不可达的对象可被回收，不可达指的是游离在GC Root外的对象。&lt;/p&gt;
&lt;p&gt;GC Roots包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;java虚拟机栈中引用的对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;方法执行时，JVM会创建一个相应的栈帧进入java虚拟机栈，栈帧中包括操作数栈、局部变量表、运行时常量池的引用、方法内部产生的对象的引用，当方法执行结束后，栈帧出栈，方法内部产生的对象的引用就不存在了，此时这些对象就是不可达对象，因为无法从GC Roots找到，这些对象将在下次GC时回收。&lt;/p&gt;
&lt;p&gt;比如，方法内部创建一个对象A，并持有另一个对象B，对象B引用也同时被其他线程持有，然后在方法里设置对象A=null或者方法结束后，个人认为对象A会被回收，对象B不会被回收，如果是方法外有一个对象C引用了对象A，设置对象A=null或方法结束后，对象A不会被回收&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;方法区中类静态属性引用的对象、常量引用的对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;静态属性或者静态变量，是class的属性，不属于任何实例，该属性会作为GC Roots，只要该class存在，该引用指向的对象也会一直存在，只有该class被卸载时，才会被回收。对于常量池里的字面量，当没有其他地方引用这个字面量时，也会被清除。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;本地方法栈中Native方法引用的对象&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这部分属于其他语言写的方法所使用到的对象，道理跟上面是java虚拟机栈是类似的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;垃圾回收算法&#34;&gt;垃圾回收算法&lt;/h2&gt;
&lt;h3 id=&#34;引用计数法&#34;&gt;引用计数法&lt;/h3&gt;
&lt;p&gt;为对象添加一个引用计数器，当对象增加一个引用时，计数器加 1，引用失效时，计数器减 1。引用计数为 0 的对象可被回收。&lt;/p&gt;
&lt;p&gt;比较轻便，效率较高，不需要STW，可以很快进行回收，但维护引用计数也有一定的成本&lt;/p&gt;
&lt;p&gt;但有可能出现循环引用，JVM没有使用该判断算法，可能因为编译的时候并不会检测对象是否存在循环引用？go的话会在编译期检测是否存在循环引用，但是它垃圾回收使用三色标记法，本质是标记清除&lt;/p&gt;
&lt;h3 id=&#34;复制&#34;&gt;复制&lt;/h3&gt;
&lt;h3 id=&#34;标记-清理&#34;&gt;标记-清理&lt;/h3&gt;
&lt;h3 id=&#34;标记---整理&#34;&gt;标记 - 整理&lt;/h3&gt;
&lt;h3 id=&#34;三色标记&#34;&gt;三色标记&lt;/h3&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;把所有对象放到白色的集合中&lt;/li&gt;
&lt;li&gt;从根节点开始遍历对象，遍历到的白色对象从白色集合中放到灰色集合中&lt;/li&gt;
&lt;li&gt;遍历灰色集合对象，把灰色对象引用的白色集合的对象放入到灰色集合中，同时把遍历过的灰色集合中的对象放到黑色集合中&lt;/li&gt;
&lt;li&gt;循环步骤3，直到灰色集合中没有对象&lt;/li&gt;
&lt;li&gt;步骤4结束后，白色集合中的对象为不可达对象，进行回收&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;参考：&lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000020086769&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入理解Go-垃圾回收机制&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;垃圾收集器&#34;&gt;垃圾收集器&lt;/h2&gt;
&lt;h3 id=&#34;cms&#34;&gt;CMS&lt;/h3&gt;
&lt;h4 id=&#34;执行过程&#34;&gt;执行过程&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;初始标记(&lt;strong&gt;STW&lt;/strong&gt; initial mark)：这个过程从垃圾回收的&amp;quot;根对象&amp;quot;开始，只扫描到能够和&amp;quot;根对象&amp;quot;直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。&lt;/li&gt;
&lt;li&gt;并发标记(Concurrent marking)：这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。&lt;/li&gt;
&lt;li&gt;并发预清理(Concurrent precleaning)：并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代， 或者有一些对象被分配到老年代)。通过重新扫描，减少下一个阶段&amp;quot;重新标记&amp;quot;的工作，因为下一个阶段会Stop The World。&lt;/li&gt;
&lt;li&gt;重新标记(&lt;strong&gt;STW&lt;/strong&gt; remark)：这个阶段会暂停虚拟机，收集器线程扫描在CMS堆中剩余的对象。扫描从&amp;quot;跟对象&amp;quot;开始向下追溯，并处理对象关联。&lt;/li&gt;
&lt;li&gt;并发清理(Concurrent sweeping)：清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。&lt;/li&gt;
&lt;li&gt;并发重置(Concurrent reset)：这个阶段，重置CMS收集器的数据结构状态，等待下一次垃圾回收。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;g1&#34;&gt;G1&lt;/h3&gt;
&lt;h4 id=&#34;执行过程-1&#34;&gt;执行过程&lt;/h4&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;标记阶段：首先是初始标记(Initial-Mark),这个阶段也是停顿的(stop-the-word)，并且会稍带触发一次yong GC。&lt;/li&gt;
&lt;li&gt;并发标记：这个过程在整个堆中进行，并且和应用程序并发运行。并发标记过程可能被yong GC中断。在并发标记阶段，如果发现区域对象中的所有对象都是垃圾，那个这个区域会被立即回收(图中打X)。同时，并发标记过程中，每个区域的对象活性(区域中存活对象的比例)被计算。&lt;/li&gt;
&lt;li&gt;再标记：这个阶段是用来补充收集并发标记阶段产新的新垃圾。与之不同的是，G1中采用了更快的算法:SATB。&lt;/li&gt;
&lt;li&gt;清理阶段：选择活性低的区域(同时考虑停顿时间)，等待下次yong GC一起收集，对应GC log: [GC pause (mixed)]，这个过程也会有停顿(STW)。&lt;/li&gt;
&lt;li&gt;回收/完成：新的yong GC清理被计算好的区域。但是有一些区域还是可能存在垃圾对象，可能是这些区域中对象活性较高，回收不划算，也肯能是为了迎合用户设置的时间，不得不舍弃一些区域的收集。&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;内存分配和回收策略&#34;&gt;内存分配和回收策略&lt;/h2&gt;
&lt;blockquote&gt;
&lt;h4 id=&#34;1-对象优先在-eden-分配&#34;&gt;1. 对象优先在 Eden 分配&lt;/h4&gt;
&lt;p&gt;大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。&lt;/p&gt;
&lt;h4 id=&#34;2-大对象直接进入老年代&#34;&gt;2. 大对象直接进入老年代&lt;/h4&gt;
&lt;p&gt;大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。&lt;/p&gt;
&lt;p&gt;经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。&lt;/p&gt;
&lt;p&gt;-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。&lt;/p&gt;
&lt;h4 id=&#34;3-长期存活的对象进入老年代&#34;&gt;3. 长期存活的对象进入老年代&lt;/h4&gt;
&lt;p&gt;为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁，增加到一定年龄则移动到老年代中。&lt;/p&gt;
&lt;p&gt;-XX:MaxTenuringThreshold 用来定义年龄的阈值。&lt;/p&gt;
&lt;h4 id=&#34;4-动态对象年龄判定&#34;&gt;4. 动态对象年龄判定&lt;/h4&gt;
&lt;p&gt;虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。&lt;/p&gt;
&lt;h4 id=&#34;5-空间分配担保&#34;&gt;5. 空间分配担保&lt;/h4&gt;
&lt;p&gt;在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。&lt;/p&gt;
&lt;p&gt;如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。&lt;/p&gt;
&lt;h3 id=&#34;full-gc-的触发条件&#34;&gt;Full GC 的触发条件&lt;/h3&gt;
&lt;p&gt;对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件：&lt;/p&gt;
&lt;h4 id=&#34;1-调用-systemgc&#34;&gt;1. 调用 System.gc()&lt;/h4&gt;
&lt;p&gt;只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。&lt;/p&gt;
&lt;h4 id=&#34;2-老年代空间不足&#34;&gt;2. 老年代空间不足&lt;/h4&gt;
&lt;p&gt;老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。&lt;/p&gt;
&lt;p&gt;为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对象进入老年代的年龄，让对象在新生代多存活一段时间。&lt;/p&gt;
&lt;h4 id=&#34;3-空间分配担保失败&#34;&gt;3. 空间分配担保失败&lt;/h4&gt;
&lt;p&gt;使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。具体内容请参考上面的第 5 小节。&lt;/p&gt;
&lt;h4 id=&#34;4-jdk-17-及以前的永久代空间不足&#34;&gt;4. JDK 1.7 及以前的永久代空间不足&lt;/h4&gt;
&lt;p&gt;在 JDK 1.7 及以前，HotSpot 虚拟机中的方法区是用永久代实现的，永久代中存放的为一些 Class 的信息、常量、静态变量等数据。&lt;/p&gt;
&lt;p&gt;当系统中要加载的类、反射的类和调用的方法较多时，永久代可能会被占满，在未配置为采用 CMS GC 的情况下也会执行 Full GC。如果经过 Full GC 仍然回收不了，那么虚拟机会抛出 java.lang.OutOfMemoryError。&lt;/p&gt;
&lt;p&gt;为避免以上原因引起的 Full GC，可采用的方法为增大永久代空间或转为使用 CMS GC。&lt;/p&gt;
&lt;h4 id=&#34;5-concurrent-mode-failure&#34;&gt;5. Concurrent Mode Failure&lt;/h4&gt;
&lt;p&gt;执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 GC 过程中浮动垃圾过多导致暂时性的空间不足），便会报 Concurrent Mode Failure 错误，并触发 Full GC。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;为什么有了 对象达到年龄限制后晋升的机制 还要有 动态年龄判定的机制&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果MaxTenuringThreshold设置过大，会导致本该晋升到老年代的对象一直停留在Survivor区，直到Survivor溢出，这样对象老化机制就失效了&lt;/li&gt;
&lt;li&gt;如果MaxTenuringThreshold设置过小，过早晋升的对象不能在年轻代充分回收，大量对象进入老年代，会引起频繁的Major GC&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;关于MinorGC、Major、YoungGC、FullGC的说明&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MinorGC：清理年轻代，等同于YoungGC，叫法不同而已&lt;/li&gt;
&lt;li&gt;MajorGC：清理老年代&lt;/li&gt;
&lt;li&gt;FullGC：清理整个堆空间 - 包括年轻代和老年代&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;调优&#34;&gt;调优&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;JVM调优，一般是代码已经优化到了一定程度了，到了最后阶段才会进行JVM调优&lt;/li&gt;
&lt;li&gt;对于Minor GC和Major GC频繁的优化，扩大Eden区，虽然可以降低Minor GC次数，但由于扫描的区域变大了，Minor GC时间可能会变长，但这点影比 当对象gc后仍然存活，需要复制到Survivor区带来的影响要小，影响Minor GC次数和时间的因素是每次GC后对象的存活数量，因此对于短期对象较多时，增加Eden区大小，同理，如果对象存活时间比较长、对象较多时，增加老年代大小&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;常用参数&#34;&gt;常用参数&lt;/h2&gt;
&lt;p&gt;只列举了常见的，参数大致分为三类：&lt;/p&gt;
&lt;h3 id=&#34;行为参数改变jvm基础行为&#34;&gt;行为参数：改变JVM基础行为&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-XX:+ScavengeBeforeFullGC&lt;/td&gt;
&lt;td&gt;FullGC前触发一次MinorGC&lt;/td&gt;
&lt;td&gt;默认启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:+UseGCOverheadLimit&lt;/td&gt;
&lt;td&gt;GC耗时过长，会跑OOM&lt;/td&gt;
&lt;td&gt;默认启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:-UseConcMarkSweepGC&lt;/td&gt;
&lt;td&gt;使用CMS低停顿垃圾收集器，减少FullGC暂停时间&lt;/td&gt;
&lt;td&gt;默认不启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:-UseParallelGC&lt;/td&gt;
&lt;td&gt;启用并行GC&lt;/td&gt;
&lt;td&gt;默认不启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:-UseParallelOldGC&lt;/td&gt;
&lt;td&gt;年轻代和老年代都使用并行垃圾收集器&lt;/td&gt;
&lt;td&gt;默认不启用，当-XX:-UseParallelGC启用时该项自动启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:-UseSerialGC&lt;/td&gt;
&lt;td&gt;启用串行垃圾收集器&lt;/td&gt;
&lt;td&gt;-Client时启用，默认不启用&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:+UseThreadPriorities&lt;/td&gt;
&lt;td&gt;启用本地线程优先级&lt;/td&gt;
&lt;td&gt;默认启用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;性能调优jvm性能调优参数&#34;&gt;性能调优：JVM性能调优参数&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;th&gt;说明，有些默认值在不同环境下是不同的&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-Xms&lt;/td&gt;
&lt;td&gt;整个堆的初始大小&lt;/td&gt;
&lt;td&gt;默认值：物理内存的1/64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-Xmx&lt;/td&gt;
&lt;td&gt;整个堆的最大值&lt;/td&gt;
&lt;td&gt;默认值：物理内存的1/4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-Xmn&lt;/td&gt;
&lt;td&gt;年轻代大小&lt;/td&gt;
&lt;td&gt;设置该值等同于设置了-XX:NewSize和-XX:MaxNewSize，且两者相等，官方推荐是整个堆的3/8&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:NewSize&lt;/td&gt;
&lt;td&gt;年轻代大小&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:MaxNewSize&lt;/td&gt;
&lt;td&gt;年轻代最大值&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-Xss&lt;/td&gt;
&lt;td&gt;每个线程的栈大小&lt;/td&gt;
&lt;td&gt;JDK1.5以后该值默认为1M&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:PermSize&lt;/td&gt;
&lt;td&gt;永久代大小&lt;/td&gt;
&lt;td&gt;默认值：物理内存的1/64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:MaxPermSize&lt;/td&gt;
&lt;td&gt;永久代最大值&lt;/td&gt;
&lt;td&gt;默认值：物理内存的1/4&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:NewRatio&lt;/td&gt;
&lt;td&gt;年轻代与老年代的比值&lt;/td&gt;
&lt;td&gt;默认值：2，年轻代包括Eden区和两个Survivor区，老年代不包括永久代。比如=4，表示年轻代：老年代=1：4，即年轻代占整个堆的1/5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:SurvivorRatio&lt;/td&gt;
&lt;td&gt;年轻代里Eden区与两个Survivor的比值&lt;/td&gt;
&lt;td&gt;默认值：8，表示一个Eden区：两个Survivor区的比值是8：2，一个Survivor区占整个年轻代的1/10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:SoftRefLRUPolicyMSPerMB&lt;/td&gt;
&lt;td&gt;每兆堆空闲空间中软引用的存活时间&lt;/td&gt;
&lt;td&gt;默认值：1s&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:MaxTenuringThreshold&lt;/td&gt;
&lt;td&gt;对象在年轻代的最大年龄&lt;/td&gt;
&lt;td&gt;默认值：15，即对象在年轻代熬过了15次Minor GC，达到阈值后晋升到老年代。=0时，对象初始化直接进入老年代&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:PretenureSizeThreshold&lt;/td&gt;
&lt;td&gt;对象超过多大直接在老年代中分配&lt;/td&gt;
&lt;td&gt;默认值：0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:TLABWasteTargetPercent&lt;/td&gt;
&lt;td&gt;TLAB(线程本地缓冲区)占Eden区的比例&lt;/td&gt;
&lt;td&gt;默认值：1%&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:+CollectGen0First&lt;/td&gt;
&lt;td&gt;FullGC时是否先YGC&lt;/td&gt;
&lt;td&gt;默认值：false&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:MinHeapFreeRatio&lt;/td&gt;
&lt;td&gt;GC后堆中空闲量占的最小比例&lt;/td&gt;
&lt;td&gt;默认值：40&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:MaxHeapFreeRatio&lt;/td&gt;
&lt;td&gt;GC后堆中空闲量占的最大比例&lt;/td&gt;
&lt;td&gt;默认值：70，GC后，如果发现空闲堆内存占到整个预估上限值的70%，则收缩预估上限值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:PreBlockSpin&lt;/td&gt;
&lt;td&gt;自旋锁自选次数，-XX:+UseSpinning需要先启用&lt;/td&gt;
&lt;td&gt;-XX:+UseSpinning默认启用，自旋次数默认值：10次&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;调试参数打开堆栈跟踪打印输出jvm参数显示详细信息&#34;&gt;调试参数：打开堆栈跟踪、打印、输出JVM参数，显示详细信息&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;参数&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;-XX:ErrorFile=日志路径/日志文件名称.log&lt;/td&gt;
&lt;td&gt;保存错误日志或者数据到文件中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:HeapDumpPath=堆信息文件路径/文件名称.hprof&lt;/td&gt;
&lt;td&gt;指定导出堆信息时的路径或文件名&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:-HeapDumpOnOutOfMemoryError&lt;/td&gt;
&lt;td&gt;当首次遭遇OOM时导出此时堆中相关信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:-PrintGC&lt;/td&gt;
&lt;td&gt;每次GC时打印相关信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:-PrintGCDetails&lt;/td&gt;
&lt;td&gt;每次GC时打印详细信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:-PrintGCTimeStamps&lt;/td&gt;
&lt;td&gt;打印每次GC的时间戳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:-TraceClassLoading&lt;/td&gt;
&lt;td&gt;跟踪类的加载信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:-TraceClassLoadingPreorder&lt;/td&gt;
&lt;td&gt;跟踪被引用到的所有类的加载信息&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:-TraceClassResolution&lt;/td&gt;
&lt;td&gt;跟踪常量池&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-XX:-TraceClassUnloading&lt;/td&gt;
&lt;td&gt;跟踪类的卸载信息&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;调优工具&#34;&gt;调优工具&lt;/h2&gt;
&lt;h3 id=&#34;命令行工具&#34;&gt;命令行工具&lt;/h3&gt;
&lt;h4 id=&#34;jps虚拟机进程状况工具&#34;&gt;jps：虚拟机进程状况工具&lt;/h4&gt;
&lt;p&gt;用来查看机器上的Java进程，如pid，启动时的JVM参数，启动时的主类、jar包全路径名称，类似ps命令&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;无参数：显示进程ID和类名称
-q：只输出进程ID
-m：输出传入 main 方法的参数，即main方法的String[] args
-l：输出完全的包名，应用主类名，jar的完全路径名
-v：输出启动时带的jvm参数
&lt;/code&gt;&lt;/pre&gt;&lt;h4 id=&#34;jstat虚拟机统计信息监视工具&#34;&gt;jstat：虚拟机统计信息监视工具&lt;/h4&gt;
&lt;p&gt;一般用来查看堆内gc情况，比如年轻代、老年代大小、YGC次数，平均耗时等&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/213710fb9e40&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.jianshu.com/p/213710fb9e40&lt;/a&gt;&lt;/p&gt;
&lt;h4 id=&#34;jmapjava内存印象工具&#34;&gt;jmap：Java内存印象工具&lt;/h4&gt;
&lt;p&gt;用来查看堆内存的使用情况，比如输出内存中的所有对象，可以配合eclipse MAT分析内存泄漏情况&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/huanglog/p/10302901.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/huanglog/p/10302901.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方的：https://docs.oracle.com/javase/7/docs/technotes/tools/share/jstat.html&lt;/p&gt;
&lt;h4 id=&#34;jhat虚拟机堆转储快照分析工具&#34;&gt;jhat：虚拟机堆转储快照分析工具&lt;/h4&gt;
&lt;p&gt;分析由jmap导出来的堆dump文件，作用类似Eclipse MAT，但是没MAT直观&lt;/p&gt;
&lt;h4 id=&#34;jstackjava堆栈跟踪工具&#34;&gt;jstack：Java堆栈跟踪工具&lt;/h4&gt;
&lt;p&gt;查看方法或线程的执行情况，线程的堆栈信息，死锁检测，死锁原因&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/wufaliang003/article/details/80414267&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://blog.csdn.net/wufaliang003/article/details/80414267&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官方：https://docs.oracle.com/javase/7/docs/technotes/tools/share/jstack.html&lt;/p&gt;
&lt;h4 id=&#34;jinfojava配置信息工具&#34;&gt;jinfo：Java配置信息工具&lt;/h4&gt;
&lt;p&gt;实时查看和调整JVM各项参数配置，进程运行时也能改JVM的配置&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;jinfo -sysprops [pid] 查看当前JVM全部系统属性
jinfo -flags [pid] 查看进程所有JVM参数，比jps -v更详细
jinfo -flag [[+代表打开，-代表关闭，都不写代表查看][JVM参数][赋值使用=][JVM参数值]] [pid]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;可视化工具&#34;&gt;可视化工具&lt;/h3&gt;
&lt;h4 id=&#34;jconsole&#34;&gt;JConsole&lt;/h4&gt;
&lt;p&gt;监控Java应用程序，可查看概述、内存、线程、类、VM、MBeans、CPU、堆栈内容、死锁检测&lt;/p&gt;
&lt;h4 id=&#34;visualvm&#34;&gt;VisualVM&lt;/h4&gt;
&lt;p&gt;功能比JConsole更加强大，支持插件，还能看到年轻代、老年代的内存变化，以及gc频率、gc的时间&lt;/p&gt;
&lt;h4 id=&#34;eclipse-mat&#34;&gt;Eclipse MAT&lt;/h4&gt;
&lt;p&gt;工具进行内存快照的分析，图表的方式展示，可以分析内存泄漏或溢出出现的代码段&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CS-Note&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;深入理解 Java 虚拟机 - 周志明&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/warehouse/p/9479104.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JVM（三）调优工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/ityouknow/p/6437037.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;jvm系列(七):jvm调优-工具篇&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tech.meituan.com/2017/12/29/jvm-optimize.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;从实际案例聊聊Java应用的GC优化&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/langtianya/p/3898760.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JVM -XX: 参数介绍&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>RPC与异步设计</title>
        <link>http://nixum.cc/p/rpc%E4%B8%8E%E5%BC%82%E6%AD%A5%E8%AE%BE%E8%AE%A1/</link>
        <pubDate>Wed, 09 Sep 2020 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/rpc%E4%B8%8E%E5%BC%82%E6%AD%A5%E8%AE%BE%E8%AE%A1/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;rpc&#34;&gt;RPC&lt;/h1&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/RPC%e7%ae%80%e5%8d%95%e6%a1%86%e6%9e%b6.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/RPC%e7%ae%80%e5%8d%95%e6%a1%86%e6%9e%b6.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;一个RPC框架的基本实现，高性能网络传输、序列化和反序列化、服务注册和发现，如果是实现客户端级别的服务注册和发现，还可以在SDK中提供容错、负载均衡、熔断、降级等功能。&lt;/p&gt;
&lt;p&gt;客户端发起RPC调用，实际上是调用该RPC方法的桩，它和服务端提供的RPC方法有相同的方法签名，或者说实现了相同的接口，只是这个桩在客户端承担的是请求转发的功能，向客户端屏蔽调用细节（比如向发现与注册中心查询要请求的服务方的url），使其像在使用本地方法一样；服务端在收到请求后，由其RPC框架解析出服务名和请求参数，调用在RPC框架中注册的该接口的真正实现者，最后将结果返回给客户端。&lt;/p&gt;
&lt;p&gt;一个简单的RPC实现可以由三部分组成：规定远程的接口和其实现，服务端提供接口注册和IO连接，客户端IO连接和接口代理&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;首先是定义要提供的远程接口和其实现类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;服务端使用线程池处理IO，实现多路复用，使用socket去循环accept()，每个请求建立一个线程&lt;/p&gt;
&lt;p&gt;线程里注册远程接口实例，使用InputStream接收客户端发送的参数，如接口的字节文件，判断是哪个接口，哪个方法，什么参数；接收后反射调用接口方法，将结果通过OutputStream发送回客户端&lt;/p&gt;
&lt;p&gt;客户端在发送参数可以做一个封装，加入id，服务端处理得到结果后也加入此id，返回回去，表示此次调用完成&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;客户端使用接口，动态代理的方式调用方法，在动态代理的实现里使用IO连接服务端，将远程接口字节码、方法参数这些东西做一个封装发送给服务端，等待返回结果，IO接收是阻塞的&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;参考&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/u010900754/article/details/78081428&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;【Java】java实现的远程调用例子 rpc原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.importnew.com/22003.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;RPC原理及RPC实例分析&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;异步通信&#34;&gt;异步通信&lt;/h1&gt;
&lt;p&gt;优点：解耦，减少服务间的依赖，获得更大的吞吐量，削峰，把抖动的吞吐量变得均匀。&lt;/p&gt;
&lt;p&gt;缺点：业务处理变得复杂，比如引入新的中间件，意味着要维护多一套东西，有时可能还得保证消息顺序，失败重传，幂等等处理，比较麻烦；异步也导致了debug的时候比较麻烦；&lt;/p&gt;
&lt;h2 id=&#34;定时轮询&#34;&gt;定时轮询&lt;/h2&gt;
&lt;p&gt;发送方请求接收方进行业务处理，接收方先直接返回，之后接收方在自己处理，最后将结果保存起来，发送方定时轮询接收方，获取处理结果。&lt;/p&gt;
&lt;h2 id=&#34;回调&#34;&gt;回调&lt;/h2&gt;
&lt;p&gt;发送方请求接收方进行业务处理时，带上发送方结果回调的url，接收方接收到请求后先立刻返回，之后接收方在自己处理，当处理结果出来时，调用发送方带过来的回调url，将处理结果发送给发送方。&lt;/p&gt;
&lt;p&gt;同理在于服务内部的异步回调，也是如此，只是把url换成了callback方法，比如Java中的Future类+Callable类。&lt;/p&gt;
&lt;h2 id=&#34;发布订阅&#34;&gt;发布订阅&lt;/h2&gt;
&lt;p&gt;主要靠消息队列实现，不过比较适合发送方不太care处理结果的，如果care处理结果，可以再通过一条队列将结果传递下去，执行后面的处理。&lt;/p&gt;
&lt;h2 id=&#34;事件驱动--状态机&#34;&gt;事件驱动 + 状态机&lt;/h2&gt;
&lt;p&gt;可以依靠消息队列，本质还是发布订阅那一套，只是将触发的条件换成事件，消费者根据不同的事件触发不同的逻辑，然后再通过状态机保证处理事件顺序。&lt;/p&gt;
&lt;p&gt;比较常见的场景是电商业务中围绕订单服务的一系列业务处理，比如订单创建完成后，订单服务发出订单创建的事件，对应库存服务，收到该事件，就会进行锁库操作等&lt;/p&gt;
&lt;h3 id=&#34;事件驱动模型&#34;&gt;事件驱动模型&lt;/h3&gt;
&lt;p&gt;实际上是使用了观察者模式和状态模式来实现的，比较直观的例子就是android的EventBus，chrome的V8引擎都有用到此模型，这里仅总结并进行简单介绍&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e4%ba%8b%e4%bb%b6%e9%a9%b1%e5%8a%a8%e5%9f%ba%e6%9c%ac%e6%a1%86%e6%9e%b6.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e4%ba%8b%e4%bb%b6%e9%a9%b1%e5%8a%a8%e5%9f%ba%e6%9c%ac%e6%a1%86%e6%9e%b6.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里的demo是项目中使用到的组件的一个简化，真实的组件要比这个复杂的多，这里只简单罗列出基本的原理和优缺点。&lt;/p&gt;
&lt;p&gt;原理：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;事件驱动-状态机的异步模型，本质上是底层controller维护一个阻塞队列，将外部请求转化为事件，通过事件在内部传递。&lt;/li&gt;
&lt;li&gt;controller接收到请求，从对象复用池中获取一个上下文context并init，然后将事件交由context处理。context内有一套状态的扭转的控制流程，在不同的状态接收事件对业务逻辑进行处理，最后将处理结果交由注册的回调函数异步或者同步返回。&lt;/li&gt;
&lt;li&gt;每一个状态在处理完当前逻辑操作后将发送事件给阻塞队列，并扭转为下一个状态，等待下一个事件的到来。&lt;/li&gt;
&lt;li&gt;由于controller是单线程的，各个状态在处理的时候要求速率尽可能的快，以至于不会阻塞主线程，因此在controller内部还维护了一个延迟队列，用来接收延迟事件，状态通常在进行业务处理前会起一个定时器，如果超时将发送延迟事件给到延迟队列，来避免当前操作过长导致阻塞主线程，定时器由下一个状态来取消。&lt;/li&gt;
&lt;li&gt;一般会为每个请求分配id，每个id对应一个上下文context，上下文一般使用id + Map来实现同一个请求下的上下文切换、保存和恢复，使用对象复用池来避免上下文对象频繁初始化&lt;/li&gt;
&lt;li&gt;这套模型一般应用在中间件的设计上，当然也可以抽成通用框架，在写的时候就会发现，其实变化最多的是状态流程那一块，所以完全可以把这块抽出来 + netty进行网络通信就能搭出一套web框架出来了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;是一个单线程的模型，本身就是线程安全的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;理论上一套业务逻辑拆分成小逻辑，交由不同的状态操作，各个状态的操作时间要求尽可能的短，不然会阻塞主线程&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;各个状态在进行逻辑操作时，如果处理的时间过长，一般会使用线程池+回调+事件的方式处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;状态机模式对应业务逻辑流程有比较强的控制，各个状态对应不同的职责&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对CPU的利用率比较高，吞吐量比较高，因为可以一次处理多种业务请求，每个业务请求都能进行拆分进行异步处理，速率比较快，因此性能会比常用的Spring全家桶好很多吧，至少在项目使用中的感受是这样&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;缺点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;处理请求时会初始化一个上下文context来处理，所有异步操作的结果会暂存在上下文中，对内存的占用会比较高，对上下文里的参数存储也需要一套规范&lt;/li&gt;
&lt;li&gt;模型相对来讲还是比较复杂，运用多种设计模式，包含了一些回调，需要有一定的设计模式基础，容易劝退&lt;/li&gt;
&lt;li&gt;对象复用池，对象回收，线程池的操作，一不小心会造成内存泄漏；还要注意不能阻塞主线程，因此需要配合定时器进行处理&lt;/li&gt;
&lt;li&gt;异步处理导致debug会麻烦一些，需要完善的日志调用链来补充&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
</description>
        </item>
        <item>
        <title>Java并发</title>
        <link>http://nixum.cc/p/java%E5%B9%B6%E5%8F%91/</link>
        <pubDate>Sat, 02 Mar 2019 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/java%E5%B9%B6%E5%8F%91/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;java线程的状态&#34;&gt;Java线程的状态&lt;/h1&gt;
&lt;h2 id=&#34;1状态转换&#34;&gt;1.状态转换&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e7%ba%bf%e7%a8%8b%e7%8a%b6%e6%80%81%e8%bd%ac%e6%8d%a2.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;线程状态转换&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;线程状态转换&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;“阻塞”与“等待”的区别：
“阻塞”状态是等待着获取到一个排他锁，进入“阻塞”状态都是被动的，离开“阻塞”状态是因为其它线程释放了锁，不阻塞了；
“等待”状态是在等待一段时间 或者 唤醒动作的发生，进入“等待”状态是主动的&lt;/p&gt;
&lt;h2 id=&#34;2-状态&#34;&gt;2. 状态&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;New（新建）：通过new创建一个新线程，但还没运行，还有一些其他基础工作要做&lt;/li&gt;
&lt;li&gt;Runnable（可运行，就绪）：线程调用start方法，可能处于正在运行也可能处于没有运行，取决于操作系统提供的运行时间&lt;/li&gt;
&lt;li&gt;Running（运行）&lt;/li&gt;
&lt;li&gt;Blocked（阻塞）：线程已经被挂起，等待锁的释放，直到另一个线程走完临界区或发生了相应锁对象wait()操作后，它才有机会去争夺进入临界区的权利
&lt;ol&gt;
&lt;li&gt;等待阻塞：运行的线程执行wait()方法，JVM会把该线程放入等待池中。&lt;/li&gt;
&lt;li&gt;同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。&lt;/li&gt;
&lt;li&gt;其他阻塞：运行的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Waiting（无限期等待）： 处于此状态的线程会等待另外一个线程，不会被分配CPU执行时间，直到被其他线程唤醒
&lt;ol&gt;
&lt;li&gt;没有设置timeout参数的Object.wait()&lt;/li&gt;
&lt;li&gt;没有设置timeout参数的Thread.join()&lt;/li&gt;
&lt;li&gt;LockSupport.park() 以上方法会使线程进入无限等待状态&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;Timed_waiting（限期等待）：不会被分配CPU执行时间，不过无需等待被其它线程显示的唤醒
&lt;ol&gt;
&lt;li&gt;Thread.sleep()方法&lt;/li&gt;
&lt;li&gt;设置了timeout参数的Object.wait()方法&lt;/li&gt;
&lt;li&gt;设置了timeout参数的Thread.join()方法&lt;/li&gt;
&lt;li&gt;LockSupport.parkNanos()方法&lt;/li&gt;
&lt;li&gt;LockSupport.parkUntil()方法&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;TERMINATED（结束，死亡）：已终止线程的线程状态，线程已经结束执行，run()方法走完了，线程就处于这种状态或者出现没有捕获异常终止run方法意外死亡&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;死锁&#34;&gt;死锁&lt;/h1&gt;
&lt;h2 id=&#34;死锁产生的条件&#34;&gt;死锁产生的条件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;互斥条件：一个资源每次只能被一个线程使用；&lt;/li&gt;
&lt;li&gt;请求与保持条件：一个线程因请求资源而阻塞时，对已获得的资源保持不放；&lt;/li&gt;
&lt;li&gt;不剥夺条件：进程已经获得的资源，在未使用完之前，不能强行剥夺；&lt;/li&gt;
&lt;li&gt;循环等待条件：若干线程之间形成一种头尾相接的循环等待资源关系。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;避免死锁&#34;&gt;避免死锁&lt;/h2&gt;
&lt;p&gt;一般场景发生在共享资源的使用上：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;线程1对资源A加锁后，进行业务操作，线程2对资源B加锁后进行业务操作，线程1业务处理需要用到资源B，线程2业务处理需要用到资源A，此时发生死锁&lt;/li&gt;
&lt;li&gt;线程1对资源A加锁后进行业务操作，线程2也需要用到资源A，但是线程1一直不释放锁，&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;互斥条件是保证线程安全的条件，因此不能破环，只能尽量破坏其他造成死锁的条件，比如提前分配各个线程所需资源；设置等待时间或者自旋次数，超时中断；分配好获得锁的顺序；避免逻辑中出现复数个线程相互持有对方线程所需的独占锁的情况；&lt;/p&gt;
&lt;p&gt;比如:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在合适的场景使用合适的锁类型，是否允许锁可重入的，共享还是排他&lt;/li&gt;
&lt;li&gt;避免多个线程操作多个共享资源，注意锁的申请顺序，比如给资源设置序号，顺序取放&lt;/li&gt;
&lt;li&gt;获取锁时设置超时时间&lt;/li&gt;
&lt;li&gt;减少共享资源的使用，使用ThreadLocal，消息队列，共享资源在方法内复制(set回去的时候cas)，或者设计一种模式对共享资源的访问&lt;/li&gt;
&lt;li&gt;jstack检查线程与状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;死锁检测工具&#34;&gt;死锁检测工具&lt;/h2&gt;
&lt;p&gt;Jconsole, Jstack, visualVM&lt;/p&gt;
&lt;h1 id=&#34;object和thread中关于线程的一些方法&#34;&gt;Object和Thread中关于线程的一些方法&lt;/h1&gt;
&lt;h2 id=&#34;object类中wait和notifynotifyall&#34;&gt;Object类中wait()和notify()、notifyAll()&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;wait()使得线程进入等待状态，同时释放锁，等待其他线程notify()、notifyAll()的唤醒&lt;/p&gt;
&lt;p&gt;因为wait()和notify()、notifyAll()是对象中的方法，如果wait()没有释放锁，其他线程就无法获得锁进入同步代码块中，也就无法执行notify()或者notifyAll()方法唤醒挂起的线程，造成死锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;这套方法只能在同步块synchronized中使用&lt;/strong&gt;，否则会抛IllegalMonitorStateException异常，因为如果没有synchronized，有可能会导致多线程wait时对共享资源的竞争导致问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wait、notify、synchronized都是对同一个对象进行操作&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;wait() 方法可以设置时间，时间到了也会进入就绪状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;notify()方法只会随机唤醒某个在等待的线程，notifyAll()方法是唤醒全部，之后进行竞争，排队执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可响应中断&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;会抛InterruptedException异常&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;为什么操作线程的方法wait()和notify()、notifyAll()是Object类中的？&lt;/p&gt;
&lt;p&gt;java提供的锁是对象级别的，等待需要锁，把每个对象看成一个锁，同一个对象可以放入不同的线程中，从而达到不同线程可以等待或唤醒，如果是线程里的方法，当前线程可能会等待多个线程的锁，这样操作比较复杂&lt;/p&gt;
&lt;h2 id=&#34;thread中的yield&#34;&gt;Thread中的yield()&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;静态方法&lt;/li&gt;
&lt;li&gt;yield()的作用是让步。它能让当前线程由“运行状态”进入到“就绪状态”，从而&lt;strong&gt;让其它具有相同优先级的等待线程获取执行权&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;该方法只是对线程调度器的一个建议，而且也只是建议具有相同优先级的其它线程可以运行，并不能保证在当前线程调用yield()之后，其它具有相同优先级的线程就一定能获得执行权，也有可能是当前线程又进入到“运行状态”继续运行&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;thread中的-suspend-和resume已过期&#34;&gt;Thread中的 suspend() 和resume()，已过期&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不是静态方法&lt;/li&gt;
&lt;li&gt;suspend()用于挂起线程， resume() 用于唤醒线程，需要配套使用，这两个方法被标为&lt;strong&gt;过期，不推荐&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;suspend() 在导致线程暂停的同时，并不会去释放任何锁资源。其他线程都无法访问被它占用的锁。直到对应的线程执行 resume() 方法后，被挂起的线程才能继续，从而其它被阻塞在这个锁的线程才可以继续执行&lt;/li&gt;
&lt;li&gt;如果 resume() 操作出现在 suspend() 之前执行，那么线程将一直处于挂起状态，同时一直占用锁，这就产生了死锁。而且，对于被挂起的线程，它的线程状态居然还是 Runnable&lt;/li&gt;
&lt;li&gt;不会抛InterruptedException异常&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;thread类中的sleep方法&#34;&gt;Thread类中的sleep()方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;静态方法&lt;/li&gt;
&lt;li&gt;使当前正在执行的线程进入休眠（阻塞），不会释放锁，单位是毫秒&lt;/li&gt;
&lt;li&gt;sleep() 可能会抛出 InterruptedException，因为异常不能跨线程传播回 main() 中，因此必须在本地进行处理。线程中抛出的其它异常也同样需要在本地进行处理&lt;/li&gt;
&lt;li&gt;可响应中断&lt;/li&gt;
&lt;li&gt;会抛InterruptedException异常&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;thread类中的join方法&#34;&gt;Thread类中的join()方法&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;不是静态方法&lt;/li&gt;
&lt;li&gt;在线程中调用另一个线程的 join() 方法，会将当前线程挂起（阻塞），而不是一直等待，直到目标线程结束&lt;/li&gt;
&lt;li&gt;没有释放锁&lt;/li&gt;
&lt;li&gt;可响应中断&lt;/li&gt;
&lt;li&gt;会抛InterruptedException异常&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;condition类中的await和signalsignalall&#34;&gt;Condition类中的await()和signal()、signalAll()&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Condition类中的await()和signal()、signalAll()用来代替传统Object里的wait()和notify()、notifyAll()方法，作用基本相同&lt;/li&gt;
&lt;li&gt;await()可以指定条件，Condition类中的await()和signal()、signalAll()会更加灵活&lt;/li&gt;
&lt;li&gt;Condition配合Lock(ReentrantLock)使用，Lock 可以用来获取一个 Condition对象、还有加锁解锁，阻塞队列中就使用了Condition来模拟线程间协作&lt;/li&gt;
&lt;li&gt;会抛InterruptedException异常&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;中断&#34;&gt;中断&lt;/h1&gt;
&lt;p&gt;参考&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/meiliangdeng1990/article/details/80559012&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java并发&amp;ndash;InterruptedException机制&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;关键字&#34;&gt;关键字&lt;/h1&gt;
&lt;h2 id=&#34;synchronized&#34;&gt;synchronized&lt;/h2&gt;
&lt;p&gt;在进入synchronized代码块时，执行 monitorenter，将计数器 +1，释放锁 monitorexit 时，计数器-1；当一个线程判断到计数器为 0 时，则当前锁空闲，可以占用；反之，当前线程进入等待状态。&lt;/p&gt;
&lt;p&gt;synchronized是几种锁的封装：自旋锁、锁消除、锁粗化、轻量锁、偏向锁，在加对象锁时，在对象的对象头中的Mark Word记录对象的线程锁状态，根据线程的竞争情况在这几种锁中切换&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当synchronized(xxx.class)锁住的是类时，多个线程访问不同对象(它们同类),就会锁住代码段，当一个线程执行完这个代码段后才轮到别的线程，可以理解成全局锁&lt;/li&gt;
&lt;li&gt;当synchronized(object)锁住的是对象时，多个线程访问不同对象(它们同类),它们相互之间并不影响，只有当多个线程访问同一对象时，才会锁住代码段，等到一个线程执行完之后才轮到别的线程执行&lt;/li&gt;
&lt;li&gt;当synchronized(this)锁住的是当前的对象，当synchronized块里的内容执行完之后，释放当前对象的锁。同一时刻若有多个线程访问这个对象，则会被阻塞&lt;/li&gt;
&lt;li&gt;synchronized加在方法上，作用同锁住this，即当前对象&lt;/li&gt;
&lt;li&gt;synchronized所在的方法被static修饰，则锁住的是整个类&lt;/li&gt;
&lt;li&gt;synchronized下不可被中断&lt;/li&gt;
&lt;li&gt;synchronized是非公平锁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在用synchronized关键字的时候，尽量缩小代码段的范围，能在代码段上加同步就不要再整个方法上加同步，减小锁的粒度，使代码更大程度的并发，如果锁的代码段太长了，别的线程等得就久一点&lt;/p&gt;
&lt;h2 id=&#34;synchronized和reentrantlock区别&#34;&gt;synchronized和ReentrantLock区别&lt;/h2&gt;
&lt;p&gt;相同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;都是加锁实现同步，阻塞性同步&lt;/li&gt;
&lt;li&gt;可重入&lt;/li&gt;
&lt;li&gt;有相同的并发性和内存语义&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;synchronized，是关键字，底层靠JVM实现，通过操作系统调度；ReentrantLock是JDK提供的类，源码可查&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;synchronized锁的范围看{}，能对类、对象、方法加锁，由JVM控制锁的添加和释放；&lt;/p&gt;
&lt;p&gt;ReentrantLock锁代码块，可以灵活控制加锁解锁的位置，需要手动控制锁的添加和释放，相对来讲锁的灵活，锁的细粒度都比synchronized好些&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;synchronized是非公平锁，ReentrantLock支持公平锁和非公平锁，默认是非公平锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;synchronized不可中断，除非抛异常，否则只能等同步的代码执行完；ReentrantLock持锁在长期不释放锁时，正在等待的线程可以选择放弃等待，方法如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;lock(), 如果获取了锁立即返回，如果别的线程持有锁，当前线程则一直处于休眠状态，直到获取锁&lt;/li&gt;
&lt;li&gt;tryLock(), 如果获取了锁立即返回true，如果别的线程正持有锁，立即返回false；&lt;/li&gt;
&lt;li&gt;tryLock (long timeout, TimeUnit unit)，   如果获取了锁定立即返回true，如果别的线程正持有锁，会等待参数给定的时间，在等待的过程中，如果获取了锁定，就返回true，如果等待超时，返回false；&lt;/li&gt;
&lt;li&gt;lockInterruptibly: 如果获取了锁定立即返回，如果没有获取锁定，当前线程处于休眠状态，直到或者锁定，或者当前线程被别的线程中断&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;synchronized在JDK1.6版本中进行了优化，性能跟ReentrantLock差不多，ReentrantLock仅比synchronized多了一些新功能&lt;/p&gt;
&lt;p&gt;synchronized和ReentrantLock都提供了最基本的锁功能，ReentrantLock多了一些额外的功能：可以提供一个Condition类，实现分组唤醒需要唤醒的线程；提供一些方法监听当前锁的信息&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;volatile&#34;&gt;volatile&lt;/h2&gt;
&lt;p&gt;需要先了解Java的内存模型，简单的说就是 每个线程有自己的工作内存，工作内存存在高速缓存中，而变量存在于主内存中，线程只能操作工作内存中的变量&lt;/p&gt;
&lt;p&gt;线程操作变量的时候，变量会从主内存中load到工作内存中，线程再在工作内存中使用变量，处理完之后再把变量更新到主内存中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;保证此变量对所有线程的可见性，即当以线程修改这个变量的值，新值对其他线程可知，即如果此变量发送改变，会立即同步到主内存中，volatile只能保证可见性&lt;/p&gt;
&lt;p&gt;由于java里的运算不是原子性，所有volatile变量的运算在并发下一样不安全&lt;br&gt;
当出现&lt;br&gt;
运算结构不依赖变量的当前值，或能确保只有单一的线程修改变量的值&lt;br&gt;
变量不需要与其他的状态变量共同参与不变约束&lt;br&gt;
此时需要加锁&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;禁止指令重排序优化，普通变量只会保证该方法执行过程中所依赖赋值的结果都能获得正确的结果，不能保证变量赋值操作的顺序与程序代码的执行顺序一致&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;典型用法是 检查某个状态标记以判断是否退出循环&lt;/p&gt;
&lt;p&gt;参考&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_34337272/article/details/79680771&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java多线程学习（三）volatile关键字&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/javazejian/article/details/72772461&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;全面理解Java内存模型(JMM)及volatile关键字&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;一些锁的概念&#34;&gt;一些锁的概念&lt;/h1&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/java-%e9%94%81.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/java-%e9%94%81.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;java中的锁&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;java中的锁&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.importnew.com/19472.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;java中的锁&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tech.meituan.com/2018/11/15/java-lock.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;美团技术团队 - 不可不说的Java“锁”事&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;线程池&#34;&gt;线程池&lt;/h1&gt;
&lt;p&gt;为了解决无限创建线程产生的问题，采用线程池来管理，减少在创建和销毁线程上所消耗的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;线程池 Executors静态类&lt;/strong&gt;，工厂方法生成以下线程池&lt;/p&gt;
&lt;h2 id=&#34;线程池的分类&#34;&gt;线程池的分类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;newCachedThreadPool：核心数是0，最大数是Integer.MAX_VALUE，使用SynchronousQueue，不存储任务。对于每个任务，如果有空闲线程可用，立即让他执行任务，如果没有可用得空闲线程，则创建新线程，空闲线程超时设置是1分钟，线程池可无限扩展。容易造成堆外内存溢出，一般用于大量短期任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;newFixedThreadPool：构建有固定大小的线程池，使用LinkedBlockingQueue。如果提交的任务数多于核心线程数，则把任务放到队列中，等其他任务完成后再运行他，创建的线程不会超时&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;newSingleThreadExecutor：大小为 1 的线程池，使用LinkedBlockingQueue，每次只有一个线程执行任务，从阻塞队列中取任务一个接一个执行&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这三个静态方法 返回实现了ExecutorService接口的ThreadPoolExecutor类的对象&lt;/p&gt;
&lt;p&gt;使用方式：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;ExecutorService&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;threadPool&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Executors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;newCachedThreadPool&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;threadPool&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;execute&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;线程实例&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 无返回值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Future&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;threadPool&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;submit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;实现了Callable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;的实例&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 有返回值
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;threadPool&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;shutdown&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;基础&#34;&gt;基础&lt;/h2&gt;
&lt;p&gt;在阿里巴巴开发手册中不提倡使用Executors创建，而是通过 ThreadPoolExecutor的方式去定制线程池，从而明确线程池的参数&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;ExecutorService&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;threadPool&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ThreadPoolExecutor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;一系列参数&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;具体看构造器&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 构造器
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;corePoolSize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;		&lt;span class=&#34;c1&#34;&gt;// 线程池中的线程数量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maximumPoolSize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 线程池中允许的最大数量，当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize，如果使用无界队列，该参数就没什么用了
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;long&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keepAliveTime&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 当活跃线程数大于corePoolSize时，多余的空闲线程最大存活时间
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;TimeUnit&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;unit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;		&lt;span class=&#34;c1&#34;&gt;// keepAliveTime单位
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;BlockingQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Runnable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;workQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，常见的如ArrayBlockingQueue、LinkedBlockingQuene
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ThreadFactory&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;threadFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 当线程池创建新线程时调用，例如为每个线程实现一个名字
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RejectedExecutionHandler&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;handler&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 线程池的饱和策略，线程池提供4种饱和策略，默认是AbortPolicy
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;阻塞队列&lt;/p&gt;
&lt;p&gt;当线程池中的线程数量大于等于corePoolSize的时候，把该任务封装成一个Worker对象放入等待队列&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原则对元素进行排序，此时maximumPoolSize就会限制任务数&lt;/li&gt;
&lt;li&gt;LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。队列无界时，maximumPoolSize也不起作用了&lt;/li&gt;
&lt;li&gt;SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQueue，静态工厂方法newCachedThreadPool使用了这个队列&lt;/li&gt;
&lt;li&gt;PriorityBlockingQueue：一个具有优先级的无界阻塞队列&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;饱和策略&lt;/p&gt;
&lt;p&gt;当运行的线程数量大于等于maximumPoolSize，且阻塞队列满了，才执行饱和策略&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;AbortPolicy：无法处理新任务时抛出异常，默认策略&lt;/li&gt;
&lt;li&gt;CallerRunsPolicy：只用调用者所在线程来运行任务&lt;/li&gt;
&lt;li&gt;DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务&lt;/li&gt;
&lt;li&gt;DiscardPolicy：不处理，丢弃掉。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;线程池处理过程&#34;&gt;线程池处理过程&lt;/h2&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;RUNNING：正常状态，接受新任务，处理等待队列中的任务
SHUTDOWN：不接收新任务，但会处理阻塞队列中的任务；
STOP ：不接收新任务，也不会处理阻塞队列中的任务，而且会中断正在运行的任务；
TIDYING ：所有的任务都销毁，workcount=0，线程池在转换为此状态时会执行terminated()
TERMINATED：terminated()方法执行过后变成这个
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;线程池内部有一个变量（private final AtomicInteger变量ctl，高3位保存运行状态runState，低29位保存有效线程数量workerCount）来表示线程的状态，根据这个变量表达的状态在操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果当前运行的线程少于corePoolSize，则创建新线程来执行任务（注意，执行这一步骤需要获取全局锁）&lt;/li&gt;
&lt;li&gt;如果运行的线程等于或多于corePoolSize，则将任务加入BlockingQueue&lt;/li&gt;
&lt;li&gt;如果无法将任务加入BlockingQueue(队列已满)，则创建新的线程来处理任务（注意，执行这一步骤需要获取全局锁）&lt;/li&gt;
&lt;li&gt;如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当corePoolSize  = maximumPoolSize时，多出的任务都会交给阻塞队列去处理，如果阻塞队列满了，就执行饱和策略，如果队列无界，则任务堆积&lt;/p&gt;
&lt;p&gt;线程池里线程的锁是不可重入锁&lt;/p&gt;
&lt;p&gt;执行任务的时候要对工作线程加锁的理由：工作线程run方法中有个判断，当阻塞队列中没任务时，会阻塞，循环等待任务；调用shutdown方法时，会将线程池状态设置为SHUTDOWN，并且不允许将任务加入到阻塞队列中，中断各个工作线程；如果shutdown方法中没有对工作线程加锁，并在锁内修改状态，中断工作线程，如果此时操作系统分配的时间片给到工作线程的判断中，阻塞队列没有任务，就一直阻塞了，这样线程池就一直关闭不了了。&lt;/p&gt;
&lt;p&gt;加锁操作发生在创建线程、工作线程在获取到任务后、工作线程没任务处理后退出、判断是否结束线程池、关闭线程池；线程池状态(ctl)的改变使用自旋+CAS判断操作&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程池的本质是一个生产者-消费者模型，解耦了线程和任务，达到线程复用的目的。任务管理部分充当生产者的角色，当任务提交后，线程池会判断该任务后续的流转：（1）直接申请线程执行该任务；（2）缓冲到队列中等待线程执行；（3）拒绝该任务。线程管理部分是消费者，它们被统一维护在线程池内，根据任务请求进行线程的分配，当线程执行完任务后则会继续获取新的任务去执行，最终当线程获取不到任务的时候，线程就会被回收。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/a8457013/p/7819044.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;线程池的实现原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://juejin.im/entry/58fada5d570c350058d3aaad&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入理解Java线程池&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java线程池实现原理及其在美团业务中的实践&lt;/a&gt;，这篇文章写得十分详细易理解了&lt;/p&gt;
&lt;h2 id=&#34;对线程池复用的简单理解&#34;&gt;对线程池复用的简单理解&lt;/h2&gt;
&lt;p&gt;这里先不谈如何保证线程安全，只说复用。比如corePoolSize  = 5，就是内部有5个线程Worker（继承了AQS和Runnable接口），通过ThreadFactory创建，保持在一个HashSet里，任务task就是实现了Runnable接口的类。当任务数如果大于corePoolSize  ，则加入到阻塞队列workQueue中；当然如果BlockingQueue存满了，corePoolSize 个线程里的任务还没执行完，会继续创建线程达到maximumPoolSize，多于corePoolSize 的线程没有被复用，当workQueue里没有任务了，并且线程池里也没其他任务了，这个时候就会等待keepAliveTime之后对线程进行回收。复用指的是对于接下来要执行的一系列任务，可以通过几个线程来执行，而不用重复的开启线程结束线程、一个任务对应一个线程。&lt;/p&gt;
&lt;p&gt;线程worker的run方法里通过&lt;strong&gt;直接获取任务&lt;/strong&gt;或者&lt;strong&gt;从阻塞队列workQueue里获取任务&lt;/strong&gt;作为&lt;strong&gt;循环&lt;/strong&gt;条件来执行&lt;strong&gt;任务的run方法&lt;/strong&gt;来达到线程重用，注意不是start方法&lt;/p&gt;
&lt;h2 id=&#34;线程池是如何做到当线程数量大于corepoolsize-多余的空闲线程在等待keepalivetime之后被回收&#34;&gt;线程池是如何做到当线程数量大于corePoolSize ，多余的空闲线程在等待keepAliveTime之后被回收&lt;/h2&gt;
&lt;p&gt;在Worker类里的runWorker方法里，当阻塞队列里取不出任务task.take()==null，即task.take()方法里会根据timed属性作为是否回收空闲线程的标志，在取阻塞队列里的任务为null时，会等待keepAliveTime时间，返回null的任务，相应的空闲线程数将减少，runWorker方法的finally块里根据线程数目判断是否结束此方法，以此达到当前线程被回收的目的&lt;/p&gt;
&lt;h2 id=&#34;线程池调优&#34;&gt;线程池调优&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;设置最大线程数，防止线程资源耗尽；&lt;/li&gt;
&lt;li&gt;使用有界队列，从而增加系统的稳定性和预警能力(饱和策略)；&lt;/li&gt;
&lt;li&gt;根据任务的性质设置线程池大小：CPU密集型任务(CPU个数个线程)，IO密集型任务(CPU个数两倍的线程)，混合型任务(拆分)。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;juc包内的一些类&#34;&gt;JUC包内的一些类&lt;/h1&gt;
&lt;h2 id=&#34;blockingqueue&#34;&gt;BlockingQueue&lt;/h2&gt;
&lt;h3 id=&#34;1分类&#34;&gt;1.分类&lt;/h3&gt;
&lt;p&gt;注：有界指的是，对阻塞队列初始化时&lt;strong&gt;必须&lt;/strong&gt;指明队列大小&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名称&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;ArrayBlockingQueue&lt;/td&gt;
&lt;td&gt;底层是数组，有界，需要初始化时指明容量大小，支持公平模式，默认非公平模式，读写都是只有一把锁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LinkedBlockingQueue&lt;/td&gt;
&lt;td&gt;底层是链表，有界，默认容量是Integer.MAX_VALUE，使用读锁和写锁，因此吞吐量比ArrayBlockingQueue大&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;PriorityBlockingQueue&lt;/td&gt;
&lt;td&gt;底层是数组 + 堆排实现排序，无界，默认容量是11，最大是Integer.MAX_VALUE - 8，默认对元素使用自然顺序排序，也可指定比较器&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;DelayQueue&lt;/td&gt;
&lt;td&gt;无界，支持延时获取，不允许take或poll移除未过期元素，size=过期元素 + 非过期元素&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SynchronousQueue&lt;/td&gt;
&lt;td&gt;有界，一个线程的插入必须等待另一个线程的删除后才能完成，反之亦然，不能被迭代，容量可理解为只有1，支持公平和非公平模式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LinkedTransferQueue&lt;/td&gt;
&lt;td&gt;底层是链表，无界，生产者会一直阻塞直到所添加到队列的元素被某一个消费者所消费，主要用于线程间消息的传递&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;LinkedBlockingDeque&lt;/td&gt;
&lt;td&gt;底层是链表，双向队列，无界&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;2常用方法&#34;&gt;2.常用方法&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作&lt;/th&gt;
&lt;th&gt;操作失败时会抛异常&lt;/th&gt;
&lt;th&gt;操作后会返回特殊值&lt;/th&gt;
&lt;th&gt;操作时会阻塞&lt;/th&gt;
&lt;th&gt;超时退出返回特殊值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;插入&lt;/td&gt;
&lt;td&gt;add(e)&lt;/td&gt;
&lt;td&gt;offer(e)&lt;/td&gt;
&lt;td&gt;put(e)&lt;/td&gt;
&lt;td&gt;offer(e, time, unit)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;移除 / 获取&lt;/td&gt;
&lt;td&gt;remove()&lt;/td&gt;
&lt;td&gt;poll()&lt;/td&gt;
&lt;td&gt;take()&lt;/td&gt;
&lt;td&gt;poll(time, unit)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;3原理&#34;&gt;3.原理&lt;/h3&gt;
&lt;h4 id=&#34;arrayblockingqueue&#34;&gt;ArrayBlockingQueue&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 把数组当成环形队列使用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 在执行插入或获取操作前会上锁，上的是同一把锁，方法执行完解锁，允许中断
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ReentrantLock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 在take方法中，如果数组长度为0，则调用await()方法进行等待，否则就获取第一个元素，调用singal()方法唤醒等待线程生产
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Condition&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;notEmpty&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 在put方法中，往数组中添加一个元素，更新索引，再调用singal()方法唤醒等待线程消费，如果数组满了，则调用await()方法进行等待
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Condition&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;notFull&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;linkedblockingqueue&#34;&gt;LinkedBlockingQueue&lt;/h4&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 整体分为读锁和写锁，而不像ArrayBlockingQueue只使用一个锁，原因是LinkedBlockingQueue底层是链表的，只需要关心头尾两个节点就行了，头节点加读锁，尾节点加写锁，使用的是不同的锁，因此读写时是不阻塞的；另外，由于节点是链表实例，在高并发下也会影响GC，而ArrayBlockingQueue是数组，不用包多一层
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// take操作时上读锁，队列为空则等待，不为空时则移除并获取，再不为空则唤醒其他消费线程，解开读锁，允许中断
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 然后判断出消费元素之前队列是满的(此时是临界状态，但刚又被消费了一次)，则加写锁，唤醒其他生产线程，解写锁，不允许中断
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ReentrantLock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;takeLock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ReentrantLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 读锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Condition&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;notEmpty&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;takeLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;newCondition&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// put操作时上写锁，队列满则等待，不满时则插入，插入后还不满则唤醒其他生产线程，解开写锁，允许中断
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 然后判断入队前只有一个元素(此时的该元素是刚刚加的)，则加读锁，唤醒其他消费线程，解读锁，不允许中断
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ReentrantLock&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;putLock&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ReentrantLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;// 写锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Condition&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;notFull&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;putLock&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;newCondition&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其实ArrayBlockingQueue也可以像LinkedBlockingQueue使用读写锁，但此时的count和index就需要使用AtomicInteger来保证线程安全，加之数组不像链表那样还要构建节点，使用读写锁带来的收益不是特别大，所以没有使用了。&lt;/p&gt;
&lt;h3 id=&#34;参考&#34;&gt;参考&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/4028efdbfc35&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;java阻塞队列详解&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;aqs&#34;&gt;AQS&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;AbstractQueuedSynchronized的缩写，全名：抽象队列同步器，基本是JUC包中各个同步组件的底层基础了&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内置一个 &lt;code&gt;volatile int state&lt;/code&gt; 记录同步状态；&lt;/p&gt;
&lt;p&gt;还有一个&lt;code&gt;双端队列（遵循FIFO）&lt;/code&gt;用于存放资源堵塞的线程，被阻塞的线程加入队尾，队列头结点释放锁时，唤醒后面结点&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AQS提供了一些同步组件，如下面提到的方法，使我们能制作自定义同步组件，公平锁和非公平锁是通过FairSync类和NonFairSync内部类实现的，独占式和共享式就是实现了这两个类的tryAcquire - tryRelease方法或tryAcquireShared-tryReleaseShared，像ReentrantLock是独占式就只实现了tryAcquire - tryRelease方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AQS内部有两种队列，一种是同步队列，用于锁的获取和释放时使用；一种是等待队列，用于Condition类，每个Condition对应一个队列&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;AQS内控制线程阻塞和唤醒使用的是Unsafe类里native方法，如park、unpark方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;同步方式&#34;&gt;同步方式&lt;/h3&gt;
&lt;h4 id=&#34;独占式如reentrantlock&#34;&gt;独占式：如ReentrantLock&lt;/h4&gt;
&lt;p&gt;获取：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用入口方法acquire&lt;/li&gt;
&lt;li&gt;调用模版方法tryAcquire(arg)尝试获取锁，若成功则返回，若失败则走下一步&lt;/li&gt;
&lt;li&gt;将当前线程构造成一个Node节点，并利用CAS将其加入到同步队列到尾部，然后该节点对应到线程进入自旋状态&lt;/li&gt;
&lt;li&gt;自旋时，首先判断其前驱节点释放为头节点&amp;amp;是否成功获取同步状态，两个条件都成立，则将当前线程的节点设置为头节点，如果不是，则利用&lt;code&gt;LockSupport.park(this)&lt;/code&gt;将当前线程挂起，不然它一直循环 ,等待被前驱节点唤醒(释放锁的时候)&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;释放：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用入口方法release&lt;/li&gt;
&lt;li&gt;调用模版方法&lt;code&gt;tryRelease&lt;/code&gt;释放同步状态&lt;/li&gt;
&lt;li&gt;获取当前节点的下一个节点&lt;/li&gt;
&lt;li&gt;利用&lt;code&gt;LockSupport.unpark(currentNode.next.thread)&lt;/code&gt;唤醒后继节点，之后重复上面 获取 第4步&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;共享式如semaphorecountdownlatch&#34;&gt;共享式：如Semaphore，CountDownLatch&lt;/h4&gt;
&lt;p&gt;获取：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用入口方法acquireShared&lt;/li&gt;
&lt;li&gt;进入tryAcquireShared(arg)模版方法获取同步状态，如果返回值&amp;gt;=0，则说明同步状态(state)有剩余，获取锁成功直接返回&lt;/li&gt;
&lt;li&gt;如果tryAcquireShared(arg)返回值&amp;lt;0，说明获取同步状态失败，向队列尾部添加一个共享类型的Node节点，随即该节点进入自旋状态&lt;/li&gt;
&lt;li&gt;自旋时，首先检查 (前驱节点是否为头节点 &amp;amp; tryAcquireShared()是否&amp;gt;=0)  (即成功获取同步状态)&lt;/li&gt;
&lt;li&gt;如果是，则说明当前节点可执行，同时把当前节点设置为头节点，并且唤醒所有后继节点&lt;/li&gt;
&lt;li&gt;如果否，则利用&lt;code&gt;LockSupport.unpark(this)&lt;/code&gt;挂起当前线程，等待被前驱节点唤醒&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;释放：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;调用releaseShared(arg)模版方法释放同步状态&lt;/li&gt;
&lt;li&gt;如果释放成，则遍历整个队列，利用&lt;code&gt;LockSupport.unpark(nextNode.thread)&lt;/code&gt;唤醒所有后继节点&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;区别&#34;&gt;区别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;独占式每次释放锁只唤醒后继结点；共享式每次释放锁会唤醒所有后继结点，使它们同时获取同步状态&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;独占锁的同步状态值为1，同一时刻只能有一个线程成功获取同步状态；共享锁的同步状态&amp;gt;1，取值由上层同步组件确定&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;公平锁和非公平锁是分别重写tryAcquire()和tryRelease()方法实现，是两套方案，独占模式和共享模式都可以有公平锁非公平锁的实现&lt;/p&gt;
&lt;p&gt;公平锁，当线程请求到来时先会判断同步队列是否存在结点，如果存在先执行同步队列中的结点线程，当前线程将封装成node加入同步队列等待（新加入的线程获取锁，如果队列不为空，加入队尾，执行队头的线程）&lt;/p&gt;
&lt;p&gt;非公平锁，当线程请求到来时，不管同步队列是否存在线程结点，直接尝试获取同步状态，获取成功直接访问共享资源（新加入的线程获取锁，直接与队列中的头结点竞争，不成功在加入队列）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;condition&#34;&gt;Condition&lt;/h3&gt;
&lt;p&gt;一个Lock可以创建多个Condition，每个Condition对应一个等待队列，单向，有头尾两个结点，遵循 FIFO&lt;/p&gt;
&lt;p&gt;当一个线程调用了await()相关的方法，那么该线程将会释放锁，并构建一个Node节点封装当前线程的相关信息加入到等待队列中进行等待，直到被唤醒、中断、超时才从队列中移出&lt;/p&gt;
&lt;p&gt;只有独占式才有Condition、等待队列这些东西，共享式没有&lt;/p&gt;
&lt;p&gt;await()：将当前线程封装成结点加入到等待队列中，释放同步状态以唤醒同步队列的后继结点，判断当前结点是否在同步队列中，不是就挂起当前线程，此时仍然在自旋中，等待被唤醒&lt;/p&gt;
&lt;p&gt;singal()：判断当前线程是否持有锁，没有则抛异常，有的话唤醒等待队列的头结点，如果为null则继续唤醒后面的结点，唤醒的意思是移除等待队列中的头结点，加入到同步队列中，如果该结点的前驱结点结束或者Node.SIGNAL状态设置失败，唤醒它，解除await()方法中的自旋，等待获取锁&lt;/p&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://juejin.im/entry/59756e5051882566d86d8a5d&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入剖析基于并发AQS的重入锁(ReetrantLock)及其Condition实现原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/54297968?utm_source=wechat_session&amp;amp;utm_medium=social&amp;amp;utm_oi=632939468966072320&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;(JDK)ReetrantLock手撕AQS&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://tech.meituan.com/2019/12/05/aqs-theory-and-apply.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;从ReentrantLock的实现看AQS的原理及应用&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;原子操作类&#34;&gt;原子操作类&lt;/h2&gt;
&lt;p&gt;多线程下，java 自增自减操作是线程不安全的，因此JUC包才提供了线程安全的原子操作类&lt;/p&gt;
&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;CAS + 自旋保证&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qfycc92/article/details/46489553&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;AtomicInteger源码分析——基于CAS的乐观锁实现&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;reentrantlock&#34;&gt;ReentrantLock&lt;/h2&gt;
&lt;h3 id=&#34;原理-1&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.blogjava.net/zhanglongsr/articles/356782.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ReentrantLock源码之一lock方法解析(锁的获取)&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;无同步方案&#34;&gt;无同步方案&lt;/h1&gt;
&lt;h2 id=&#34;cas&#34;&gt;CAS&lt;/h2&gt;
&lt;p&gt;Compare-and-Swap, 是一种算法，CAS 指令需要有 3 个操作数，分别是内存地址 V、旧的预期值 A 和新值 B。当执行操作时，只有当 V 的值等于 A，才将 V 的值更新为 B。&lt;/p&gt;
&lt;h2 id=&#34;threadlocalt&#34;&gt;ThreadLocal&amp;lt;T&amp;gt;&lt;/h2&gt;
&lt;p&gt;是java.lang包中的一个类，使用 ThreadLocal 维护变量时，其为每个使用该变量的线程提供独立的变量副本，把共享数据的可见范围限制在同一个线程之内，所以每一个线程都可以独立的改变自己的副本，而不会影响其他线程对应的副本。&lt;/p&gt;
&lt;p&gt;注意：ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static修饰。这个变量是针对一个线程内所有操作共享的，所以设置为静态变量，所有此类实例共享此静态变量  ，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量&lt;/p&gt;
&lt;h3 id=&#34;原理-2&#34;&gt;原理&lt;/h3&gt;
&lt;p&gt;每个线程内部都会维护一个 静态的ThreadLocalMap对象，该对象里有一个Entry（K-V 键值对）&lt;strong&gt;数组&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Entry的Key是一个ThreadLocal实例，Value是一个线程特有对象。之所以key是一个ThreadLocal实例，是因为在同一线程内可以有多个ThreadLocal，而一个线程只有一个ThreadLocalMap，所以以一个ThreadLocal对应一个要保存的value就比较合适了&lt;/p&gt;
&lt;p&gt;Entry的作用即是：为其属主线程建立起一个ThreadLocal实例与一个线程特有对象之间的对应关系；&lt;/p&gt;
&lt;p&gt;Entry对Key的引用是弱引用；Entry对 Value的引用是强引用；&lt;/p&gt;
&lt;p&gt;ThreadLocalMap不同于HashMap，其解决哈希冲突不使用拉链法，而是使用线性探测法，当出现哈希冲突时，由于key是弱引用，还会有不同的逻辑进行插入&lt;/p&gt;
&lt;p&gt;每次对ThreadLocal做get、set操作时，以get方法为例，先通过Thread.currentThread()获得当前线程，在获取该线程对象里的ThreadLocalMap，以当前对象为key(当前线程的ThreadLoacl)在ThreadLocalMap中找到value，强转返回&lt;/p&gt;
&lt;p&gt;ThreadLocal本身有探测式清理和启发式清理过期的key，但在一些场景 (尤其是使用线程池) 下，由于 ThreadLocal.ThreadLocalMap 的底层数据结构导致 ThreadLocal 有内存泄漏的情况，应该尽可能在每次使用 ThreadLocal 后手动调用 remove()，以避免出现 ThreadLocal 经典的内存泄漏甚至是造成自身业务混乱的风险，因为ThreadLocal里的key是弱引用，当释放掉对threadlocal对象的强引用后，map里面的value没有被回收，但却永远不会被访问到了&lt;/p&gt;
&lt;p&gt;详细的可参考&lt;a class=&#34;link&#34; href=&#34;https://snailclimb.gitee.io/javaguide/#/docs/java/Multithread/ThreadLocal?id=threadlocalset%e6%96%b9%e6%b3%95%e6%ba%90%e7%a0%81%e8%af%a6%e8%a7%a3&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;threadlocalset方法源码详解&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;参考-1&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CyC2018/CS-Notes/并发&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/zhengbin/p/6505971.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;过期的suspend()挂起、resume()继续执行线程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq838642798/article/details/65441415&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ReenTrantLock可重入锁（和synchronized的区别）总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/weixin_40792878/article/details/81369385&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;ReentrantLock锁和Synchronized锁的异同点&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/44185603&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java程序员开发岗面试知识点解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/chengxiao/p/7141160.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java并发包基石-AQS详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/zhangdong2012/article/details/79983404&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java并发-AQS及各种Lock锁的原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/daydaynobug/p/6752837.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java并发之AQS详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.cnblogs.com/chenpi/p/5614290.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java并发编程JUC总结&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;阿里巴巴Java开发手册1.40&lt;/p&gt;
&lt;p&gt;Java并发编程实战&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Java IO</title>
        <link>http://nixum.cc/p/java-io/</link>
        <pubDate>Tue, 22 Sep 2020 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/java-io/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;bio&#34;&gt;BIO&lt;/h1&gt;
&lt;p&gt;特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;BIO是同步阻塞的，以流的形式处理，基于字节流和字符流&lt;/li&gt;
&lt;li&gt;每个请求都需要创建独立的线程，处理Read和Write&lt;/li&gt;
&lt;li&gt;并发数较大时，就算是使用了线程池，也需要创建大量的线程来处理&lt;/li&gt;
&lt;li&gt;连接建立后，如果处理线程被读操作阻塞了，那就阻塞了，只能等到读完才能进行其他操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以基于TCP协议的Socket，编写服务端Demo&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;com.nixum.bio&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.io.InputStream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.io.PrintWriter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.net.ServerSocket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.net.Socket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.util.Date&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.util.concurrent.ExecutorService&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.util.concurrent.Executors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;BIOServer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ExecutorService&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newCachedThreadPool&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Executors&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;newCachedThreadPool&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//创建ServerSocket
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;ServerSocket&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;serverSocket&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ServerSocket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 主线程负责处理监听
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Socket&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;serverSocket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;accept&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 创建线程处理请求
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;newCachedThreadPool&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;execute&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;handler&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;});&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;handler&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Socket&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bytes&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1024&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;];&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;//通过socket获取输入流
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;InputStream&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inputStream&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getInputStream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;//循环的读取客户端发送的数据
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;read&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;inputStream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bytes&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
          &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;接收到的请求是：&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bytes&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
          &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 响应给客户端
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;PrintWriter&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PrintWriter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getOutputStream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;服务端接收到请求了，响应时间：&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Date&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;flush&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;printStackTrace&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;finally&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 关闭连接
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;socket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;printStackTrace&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;客户端Demo：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;com.atguigu.bio&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.io.BufferedReader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.io.InputStreamReader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.io.PrintStream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.net.Socket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.util.Scanner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;BIOClient&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;Socket&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;client&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Socket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;127.0.0.1&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;Scanner&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;scan&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Scanner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;in&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;PrintStream&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PrintStream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getOutputStream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;BufferedReader&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bufferReader&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BufferedReader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;InputStreamReader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;client&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getInputStream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()));&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;scan&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;hasNext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 键盘输入，并发送请求
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;scan&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;exit&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
          &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;flush&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 接收服务端的响应
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bufferReader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;readLine&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;client&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;nio&#34;&gt;NIO&lt;/h1&gt;
&lt;p&gt;特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;同步非阻塞，通过缓冲区进行缓冲增加处理的灵活性，当某一线程里&lt;strong&gt;没有数据可用&lt;/strong&gt;时，则去处理其他事情，保证线程不阻塞&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由三个部分组成：Channel、Buffer、Selector&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;数据总是从Channel读到Buffer中，或从Buffer写到Channel中，事件 + Selector监听Channel，实现一个线程处理多个操作。每一个Channel会对应一个Buffer、一个Selector对应多个Channel，Selector通过事件决定使用哪个Channel&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;buffer&#34;&gt;Buffer&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;存储数据时使用，本质是一个数组&lt;/li&gt;
&lt;li&gt;清除时本质只是把下列各个属性恢复到初始状态，数据没有被正常的擦除，而是由后面的数据覆盖&lt;/li&gt;
&lt;li&gt;将数据读入Buffer后，需要调用flip方法进行反转后才能将Buffer里的数据写出来&lt;/li&gt;
&lt;li&gt;可以put各种类型的数据进byteBuffer后，flip后，需要按顺序和类型进行get操作，否则会抛异常&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;重要属性&#34;&gt;重要属性&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 下一个要读或写的位置索引
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;position&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 缓冲区的当前终点，&amp;lt;= limit，读写时位置索引不能超出limit
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;limit&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 缓冲区容量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;capacity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 标记，标记后用于重新恢复到的位置
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mark&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;常用子类&#34;&gt;常用子类&lt;/h3&gt;
&lt;p&gt;每个基本类型都有对应的Buffer，比如CharBuffer、IntBuffer、DoubleBuffer、ByteBuffer（最常用）&lt;/p&gt;
&lt;h2 id=&#34;channel&#34;&gt;Channel&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;作用类似流，但流是单线的，只能读或只能写，而Channel是双向的，可以同时进行读写&lt;/li&gt;
&lt;li&gt;可异步&lt;/li&gt;
&lt;li&gt;通常与Buffer配合使用，也可以使用Buffer数组，当一个buffer存满时会取下一个buffer取处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;常用子类-1&#34;&gt;常用子类&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;FileChannel专门处理文件相关的数据（从FileIn/OutputStream的getChannel()方法得到）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ServerSocketChannel和SocketChannel用于处理TCP连接的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;DatagramChannel用于处理UDP连接的数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;读写文件的Demo，比如从一个文件里读出数据并写入另一个文件&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;com.nixum.nio&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.io.FileInputStream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.io.FileOutputStream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.nio.ByteBuffer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.nio.channels.FileChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;CopyFileAToB&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;FileInputStream&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileInputStream&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FileInputStream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;first.txt&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;FileChannel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;readFileChannel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileInputStream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;FileOutputStream&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileOutputStream&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FileOutputStream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;second.txt&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;FileChannel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;writeFileChannel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileOutputStream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 只设置成1024的容量，通过循环 + clear覆盖重写
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;ByteBuffer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;byteBuffer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ByteBuffer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;allocate&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1024&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;byteBuffer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;clear&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;read&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;readFileChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;byteBuffer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;read&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;break&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 写操作前需要先flip
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;byteBuffer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;flip&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;writeFileChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;byteBuffer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// close
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;fileInputStream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;fileOutputStream&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;selector&#34;&gt;Selector&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一个线程处理多个连接，就是靠Selector，Channel需要事先注册到Selector上，Selector根据事件选择Channel进行处理。实际上是一个发布订阅模型，通过事件触发&lt;/li&gt;
&lt;li&gt;只有真正有读写事件时才会进行读写，就不用为每个连接都创建一个线程了&lt;/li&gt;
&lt;li&gt;避免多线程上下文切换的开销&lt;/li&gt;
&lt;li&gt;selectionKey，可以理解为触发selector的事件，有4种，OP_ACCEPT：有新连接产生，一般用于服务端建立连接、OP_CONNECT：连接已建立，一般用于客户端建立连接、OP_READ：读操作、OP_WRITE：写操作&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NIO基本使用Demo，服务端，也可以不使用Selector，但这样就跟BIO没什么差别了&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;80
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;com.nixum.nio&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.net.InetSocketAddress&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.nio.ByteBuffer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.nio.channels.*&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.util.Iterator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.util.Set&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;NIOServer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ServerSocketChannel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;serverSocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Selector&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NIOServer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;serverSocketChannel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ServerSocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;selector&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Selector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;serverSocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;socket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;InetSocketAddress&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;port&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 需要显式设置为非阻塞
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;serverSocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;configureBlocking&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 注册serverSocketChannel，触发事件为 OP_ACCEPT，用于建立连接
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;serverSocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;register&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SelectionKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;OP_ACCEPT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;printStackTrace&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 等待1s获取事件，这样一次性可以获取多个事件进行处理，如果没有则继续
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;select&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1000&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;这1秒内没有收到数据&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;continue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 监听到事件发生， 获取发生的事件集合
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;Set&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SelectionKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;selectionKeys&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;selectedKeys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;Iterator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SelectionKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keyIterator&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;selectionKeys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;iterator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;

      &lt;span class=&#34;c1&#34;&gt;// 判断事件的类型
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;keyIterator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;hasNext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;SelectionKey&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keyIterator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 触发的是OP_ACCEPT事件
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;isAcceptable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
          &lt;span class=&#34;n&#34;&gt;connectionHandler&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;serverSocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 触发OP_READ事件
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;isReadable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
          &lt;span class=&#34;n&#34;&gt;readHandler&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 将处理完的事件集合移除，防止重复操作
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;keyIterator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 处理完事件集合
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;connectionHandler&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Selector&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ServerSocketChannel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;serverSocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 建立连接
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;SocketChannel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socketChannel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;serverSocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;accept&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 将SocketChannel 设置为非阻塞
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;socketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;configureBlocking&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 建立连接后，将socketChannel注册到selector，初始化一个Buffer用来装数据，发送OP_READ给selector，当selector收到OP_READ事件后，就会使用该socketChannel处理该Buffer
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;socketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;register&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;selector&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SelectionKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;OP_READ&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ByteBuffer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;allocate&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1024&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;readHandler&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SelectionKey&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 获取处理该事件的channel
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;SocketChannel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;channel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;channel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 获取该channel关联的Buffer
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;ByteBuffer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ByteBuffer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;attachment&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 将channel里的数据读到buffer里
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;channel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;read&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;接收到请求是：&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;array&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()));&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PORT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;NIOServer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;server&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NIOServer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PORT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;server&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;run&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;客户端，这里没有使用selector，直接使用socketChannel连接：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;com.nixum.nio&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.net.InetSocketAddress&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.nio.ByteBuffer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;java.nio.channels.SocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;NIOClient&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;SocketChannel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;socketChannel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;open&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;socketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;configureBlocking&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;InetSocketAddress&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;inetSocketAddress&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;InetSocketAddress&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;127.0.0.1&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;socketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;connect&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inetSocketAddress&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 这里的例子是为了说明如果连接和处理是异步的，非阻塞的
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;while&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;socketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;finishConnect&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;当连接还没完成时，会循环打印，但此时也在执行连接，请稍等&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 如果要使用selector，则在此处将socketChannel注册进selector，剩下处理跟上面类似
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;str&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;hello, world&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ByteBuffer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ByteBuffer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;wrap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;str&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getBytes&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 根据str的大小wrap一个buffer
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 发送请求
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;socketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;buffer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;线程模型&#34;&gt;线程模型&lt;/h1&gt;
&lt;h2 id=&#34;传统阻塞io模型&#34;&gt;传统阻塞IO模型&lt;/h2&gt;
&lt;p&gt;典型的BIO例子，有一个ServiceSocket在监听端口，一个线程处理一个连接，监听端口、建立连接，read操作、业务处理、write操作这一整个过程都是阻塞的&lt;/p&gt;
&lt;h2 id=&#34;reactor模型&#34;&gt;Reactor模型&lt;/h2&gt;
&lt;p&gt;reactor其实就是针对传统阻塞IO模型的缺点，将上述操作拆分出来异步处理，通过事件通知，由一个中心进行分发，本质就算IO复用 + 线程池，甚至单线程 + 消息队列也可以&lt;/p&gt;
&lt;h3 id=&#34;1-单reactor单线程&#34;&gt;1. 单Reactor单线程&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%8d%95Reactor%e5%8d%95%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%8d%95Reactor%e5%8d%95%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;单Reactor单线程模型&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;单Reactor单线程模型&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Acceptor实际上也是一个Handler，只是处理的事件不同，当Reactor收到(select)连接事件时调用&lt;/li&gt;
&lt;li&gt;当Reactor收到(select)非连接事件，比如读事件、写事件、处理其他业务的事件等，会起一个handler来处理&lt;/li&gt;
&lt;li&gt;当Handler处理完当前事件后，将下一次要处理的事件和相关参数丢给Reactor进行select和dispatch&lt;/li&gt;
&lt;li&gt;单线程模型，天然是线程安全的，但是当handler处理过慢时就会造成事件堆积，阻塞主线程(Reactor)，处理能力下降，因此要求handler处理尽可能的快。&lt;/li&gt;
&lt;li&gt;异常处理要小心，否则会导致整个线程垮掉&lt;/li&gt;
&lt;li&gt;比如上面NIO的例子就是这个模型，当业务复杂时，也可将handler抽出。不同的Handler类实现不同的业务处理，再配合对象池实现复用&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2-单reactor多线程&#34;&gt;2. 单Reactor多线程&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%8d%95Reactor%e5%a4%9a%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%8d%95Reactor%e5%a4%9a%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;单Reactor多线程模型&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;单Reactor多线程模型&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在单Reactor单线程模型的基础上，因为Handler的处理流程相对固定，就将比较耗时的业务处理包装成任务交由线程池处理，加快Handler的处理速度&lt;/li&gt;
&lt;li&gt;实际上如果只是在Handler处将业务逻辑交给线程池去做，再同步等待结果，只是一种伪异步，本质上Handler还是要等任务执行完才能执行send操作。优化的方法是先将Handler存起来，把业务处理提交给线程池后，就结束handler的执行了，这样就能把主线程释放出来，处理其他事件。当线程池里的任务执行完，只需将结果、handlerId、事件交由Reactor，Reactor根据事件和HandlerId找到对应的Handler去响应结果就可以了。&lt;/li&gt;
&lt;li&gt;由于业务处理使用了多线程，需要注意共享数据的问题，处理起来会比较复杂，线程安全只存在于Reactor所在的线程&lt;/li&gt;
&lt;li&gt;Reactor需要处理的事件变多，高并发下容易出现性能瓶颈&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;3-主从reactor多线程&#34;&gt;3. 主从Reactor多线程&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%a4%9aReactor%e5%a4%9a%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%a4%9aReactor%e5%a4%9a%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;多Reactor多线程模型&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;多Reactor多线程模型&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在单Reactor多线程模型的基础上，将Handler下沉处理，通过子Reactor来提高并发处理能力。Acceptor处理连接事件后，将连接分配给SubReactor处理，例如一个连接对应一个SubReactor，SubReactor负责处理连接后的业务处理，可以把这层理解为单Reactor多线程模型的Reactor&lt;/li&gt;
&lt;li&gt;由于又多了一层，线程处理更加复杂，同一Reactor下才能保证线程安全，不同Reactor间要注意数据共享问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;netty&#34;&gt;Netty&lt;/h1&gt;
&lt;p&gt;对NIO的包装，简化NIO的使用；实现客户端重连、闪断、半包读写、失败缓冲、网络拥塞和异常流处理；基于主从Reactor多线程模型，事件驱动&lt;/p&gt;
&lt;h2 id=&#34;server端线程模型&#34;&gt;Server端线程模型&lt;/h2&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/netty%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/netty%e7%ba%bf%e7%a8%8b%e6%a8%a1%e5%9e%8b.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;Netty线程模型&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Netty线程模型&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;demo&#34;&gt;Demo&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;BossGroup专门处理连接，WorkerGroup专门处理读写&lt;/li&gt;
&lt;li&gt;NioEventLoop是一个无限循环的线程，不断的处理事件，每一个NioEventLoop有一个selector，用于监听事件&lt;/li&gt;
&lt;li&gt;NioEventLoop内部串行化设计，负责消息的读取 -&amp;gt; 解码 -&amp;gt; 处理 -&amp;gt; 编码 -&amp;gt; 发送&lt;/li&gt;
&lt;li&gt;一个NioEventLoopGroup包含多个NioEventLoop，每个NioEventLoop包含一个Selector，一个taskQueue&lt;/li&gt;
&lt;li&gt;Selector可以注册监听多个NioChannel，每个NioChannel只会绑定在唯一的NioEventLoop上，每个NioChannel都绑定有一个自己的ChannelPipeline&lt;/li&gt;
&lt;li&gt;注意如果在一次连接中多次调用ChannelHandlerContext的writeAndFlush响应数据回去时，每次writeAndFlush写出去的数据会整合在一起后才响应回去，即TCP的粘包，接收端只会接收到合并后的数据包，需要特殊处理去拆包&lt;/li&gt;
&lt;li&gt;netty中的I/O操作是异步的，如 bind、wirte、connect方法都是返回一个ChannelFeture，可以使用ChannelFeture的sync方法将异步改为同步，或者调用其他方法来判断其状态和结果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;服务端&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;com.nixum.netty&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.bootstrap.ServerBootstrap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.ChannelFuture&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.ChannelFutureListener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.ChannelInitializer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.ChannelOption&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.EventLoopGroup&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.nio.NioEventLoopGroup&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.socket.SocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.socket.nio.NioServerSocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;NettyServer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    
  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PORT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  
    &lt;span class=&#34;c1&#34;&gt;// 一个BossGroup线程池处理连接请求，设置了一个线程
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;EventLoopGroup&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bossGroup&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NioEventLoopGroup&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 一个WorkerGroup线程池进行业务处理，默认设置的线程数是 CPU核数 * 2
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;EventLoopGroup&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;workerGroup&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NioEventLoopGroup&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;

    &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 创建服务端的启动对象，配置参数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;ServerBootstrap&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bootstrap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ServerBootstrap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;

      &lt;span class=&#34;c1&#34;&gt;// 初始化设置
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;bootstrap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;bossGroup&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;workerGroup&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 设置两个线程组
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;               &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;channel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;NioServerSocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 指定NioSocketChannel为传输channel
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;               &lt;span class=&#34;c1&#34;&gt;// .localAddress(new InetSocketAddress(PORT)) // 可以在这里设置监听端口或者设置初始化配置后使用bind()方法设置
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;               &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;option&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ChannelOption&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;SO_BACKLOG&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;128&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 设置线程队列得到连接个数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;               &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;childOption&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ChannelOption&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;SO_KEEPALIVE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//设置保持活动连接状态
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;               &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;handler&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 该handler对应bossGroup, childHandler对应 workerGroup
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;               &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;childHandler&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ChannelInitializer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                 &lt;span class=&#34;c1&#34;&gt;// 当一个连接被接收时，给channelPipeline添加一个Handler
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                 &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
                 &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;initChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SocketChannel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                   &lt;span class=&#34;c1&#34;&gt;// 可以使用一个集合管理 SocketChannel，在推送消息时，可以将业务加入到各个channel 对应的 NIOEventLoop 的 taskQueue 或者 scheduleTaskQueue
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                   &lt;span class=&#34;c1&#34;&gt;// 给workGroup的eventLoop对应的channel设置handler
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                   &lt;span class=&#34;n&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;pipeline&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;addLast&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NettyServerHandler&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
                 &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
               &lt;span class=&#34;o&#34;&gt;});&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;服务器 is ready...&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 同步阻塞等待直到绑定完成，并监听端口
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;ChannelFuture&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bootstrap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;bind&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;PORT&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 设置监听器，监听连接事件
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;cf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;addListener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ChannelFutureListener&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;operationComplete&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ChannelFuture&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;future&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
          &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;cf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;isSuccess&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;监听端口 &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PORT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; 成功&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
          &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;监听端口 &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PORT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; 成功&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
          &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;});&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 获取cfChannel的CloseFuture，并阻塞当前线程直到其完成
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;cf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;channel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;closeFuture&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;finally&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;bossGroup&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;shutdownGracefully&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;workerGroup&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;shutdownGracefully&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;服务端业务处理器NettyServerHandler&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;com.nixum.netty&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.buffer.ByteBuf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.buffer.Unpooled&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.Channel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.ChannelHandlerContext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.ChannelInboundHandlerAdapter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.ChannelPipeline&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.util.CharsetUtil&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// netty通过一系列的Handler来实现业务处理，用户自定义Handler需要继承ChannelInboundHandlerAdapter才能使用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;NettyServerHandler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ChannelInboundHandlerAdapter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;    读取客户端发送的请求
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;    ChannelHandlerContext ctx: 上下文对象, 含有管道pipeline, 通道channel, 地址
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;    Object msg: 就是客户端发送的数据 默认Object
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;  */&lt;/span&gt;
  &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;channelRead&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ChannelHandlerContext&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 这里假设有需要执行一个非常耗时的任务
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;cm&#34;&gt;/*
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;    // 解决方案1: 用户程序自定义的普通任务
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;    ctx.channel().eventLoop().execute(() -&amp;gt; {
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;      try {
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;        Thread.sleep(5 * 1000);
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;        ctx.writeAndFlush(Unpooled.copiedBuffer(&amp;#34;hello, 客户端2&amp;#34;, CharsetUtil.UTF_8));
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;      } catch (Exception e) {
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;        System.out.println(&amp;#34;发生异常&amp;#34; + e.getMessage());
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;      }
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;    });
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;    // 解决方案2: 用户自定义定时任务 -&amp;gt; 该任务是提交到 scheduleTaskQueue中
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;    ctx.channel().eventLoop().schedule(() -&amp;gt; {
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;      try {
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;        Thread.sleep(5 * 1000);
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;        ctx.writeAndFlush(Unpooled.copiedBuffer(&amp;#34;hello, 客户端~(&amp;gt;^ω^&amp;lt;)喵4&amp;#34;, CharsetUtil.UTF_8));
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;      } catch (Exception e) {
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;        System.out.println(&amp;#34;发生异常&amp;#34; + e.getMessage());
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;      }
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;    }, 5, TimeUnit.SECONDS);
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;	*/&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;Channel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;channel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;channel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 将 msg对象转成一个ByteBuf，这里ByteBuf是Netty提供的，不是NIO的ByteBuffer.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;ByteBuf&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ByteBuf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;客户端发送消息是: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;toString&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CharsetUtil&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;UTF_8&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;客户端地址: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;channel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;remoteAddress&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;c1&#34;&gt;//数据读取完毕，一般在这里需要对要发送的数据进行编码
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;channelReadComplete&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ChannelHandlerContext&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 将数据写入到缓存，并刷新, 响应给客户端
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;writeAndFlush&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Unpooled&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;copiedBuffer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello, 客户端&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CharsetUtil&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;UTF_8&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;c1&#34;&gt;//处理异常, 一般是需要关闭通道
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;exceptionCaught&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ChannelHandlerContext&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Throwable&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cause&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;客户端：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;com.nixum.netty&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.bootstrap.Bootstrap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.ChannelFuture&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.ChannelInitializer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.EventLoopGroup&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.nio.NioEventLoopGroup&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.socket.SocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.socket.nio.NioSocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;NettyClient&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;EventLoopGroup&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;group&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NioEventLoopGroup&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;try&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 创建客户端启动对象，这里使用的是BootStrap
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;Bootstrap&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bootstrap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Bootstrap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;

      &lt;span class=&#34;c1&#34;&gt;// 初始化设置
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;bootstrap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//设置线程组
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;               &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;channel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;NioSocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 设置客户端通道的实现类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;               &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;handler&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ChannelInitializer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SocketChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                 &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
                 &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;initChannel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;SocketChannel&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                   &lt;span class=&#34;c1&#34;&gt;// 添加Handler
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                   &lt;span class=&#34;n&#34;&gt;ch&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;pipeline&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;addLast&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NettyClientHandler&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
                 &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
               &lt;span class=&#34;o&#34;&gt;});&lt;/span&gt;

      &lt;span class=&#34;c1&#34;&gt;// 启动客户端去连接服务器端阻塞直至成功
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;ChannelFuture&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;channelFuture&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bootstrap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;connect&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;127.0.0.1&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;8080&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 同上
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;channelFuture&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;channel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;closeFuture&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;finally&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;group&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;shutdownGracefully&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;客户端业务处理Handler&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kn&#34;&gt;package&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;com.nixum.netty&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.buffer.ByteBuf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.buffer.Unpooled&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.ChannelHandlerContext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.channel.ChannelInboundHandlerAdapter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;io.netty.util.CharsetUtil&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;NettyClientHandler&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ChannelInboundHandlerAdapter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;

  &lt;span class=&#34;c1&#34;&gt;// 当通道就绪就会触发该方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;channelActive&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ChannelHandlerContext&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;writeAndFlush&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Unpooled&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;copiedBuffer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;hello, server&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CharsetUtil&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;UTF_8&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;c1&#34;&gt;//当通道有读取事件时，会触发
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;channelRead&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ChannelHandlerContext&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ByteBuf&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ByteBuf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;msg&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;服务器回复的消息: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;buf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;toString&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;CharsetUtil&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;UTF_8&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;服务器的地址: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;channel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;remoteAddress&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;c1&#34;&gt;// 异常时的处理
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;exceptionCaught&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ChannelHandlerContext&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Throwable&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cause&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Exception&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;cause&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;printStackTrace&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ctx&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;close&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;核心组件&#34;&gt;核心组件&lt;/h2&gt;
&lt;h3 id=&#34;serverbootstrap和bootstrap&#34;&gt;ServerBootstrap和Bootstrap&lt;/h3&gt;
&lt;p&gt;服务引导类，通过它设置配置（链式调用）和启动服务，ServerBootstrap用于服务端，Bootstap用于客户端&lt;/p&gt;
&lt;h3 id=&#34;channelchannelpipelinechannelhandlercontext和channelhandler&#34;&gt;Channel、ChannelPipeline、ChannelHandlerContext和ChannelHandler&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Channel：网络通信的组件，提供异步网络I/O操作，操作都是异步的，会返回一个ChannelFuture实例，通过注册在ChannelFuture上的监听器进行回调操作。NioServerSocketChannel用于TCP服务端、NioSocketChannel用于TCP客户端，NioDatagramChannel用于UDP连接&lt;/li&gt;
&lt;li&gt;ChannelHandler：是一个接口，通过实现该接口来注册到ChannelPipeline上进行使用。一般使用其出站和入站的两个适配器如ChannelOutboundHandlerAdapter和ChannelInboundHandlerAdapter或者SimpleChannelInboundHandler和SimpleChannelOutboundHandler&lt;/li&gt;
&lt;li&gt;ChannelPipeline：保存ChannelHandler的队列，像是责任链模式
&lt;ul&gt;
&lt;li&gt;每一个Channel对应一个ChannelPipeline，一个ChannelPipeline维护了一个由ChannelHandlerContext组成的双向链表，每一个ChannelHandlerContext关联一个ChannelHandler&lt;/li&gt;
&lt;li&gt;入站事件会从链表的head往后传递到最后一个入站handler，出站事件会从链表tail往前传递到最前一个出战handler，两种类型的handler互不干扰&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ChannelHandlerContext：上下文，包含一个ChannelHandler，绑定ChannelPipeline和Channel的信息&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;eventloopgroup&#34;&gt;EventLoopGroup&lt;/h3&gt;
&lt;p&gt;包含一组EventLoop，默认设置的EventLoop线程数是 CPU核数 * 2，每个EventLoop维护一个Selector&lt;/p&gt;
&lt;h2 id=&#34;一般流程&#34;&gt;一般流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;BossGrop本质上是一个NioEventGroup，只包含一个NioEventLoop事件循环的线程。WorkGroup本质上也是一个NioEventGroup，但它包含了 CPU*2 个NioEventEventLoop来处理连接后的业务逻辑。&lt;/li&gt;
&lt;li&gt;NioEventLoop是一个死循环，不断的处理事件和消息队列的任务。&lt;/li&gt;
&lt;li&gt;初始化时将BossGrop和WorkGroup注册到ServerBootstrap并进行相应的配置(如Channel、ChannelHandler)，之后通过bind()方法绑定端口和ServerSocketChannel后启动。&lt;/li&gt;
&lt;li&gt;BossGroup轮询Accept事件，获取事件后接受连接，创建一个新的NioSocketChannel，绑定ChannelPipeline，为ChannelPipeline添加ChannelHandler，注册到WorkGroup上，发送Read事件。&lt;/li&gt;
&lt;li&gt;WorkGroup中一个EventLoop轮询Read事件，调用Channel的ChannelPipeline进行处理。&lt;/li&gt;
&lt;li&gt;ChannelPipeline中每个节点是一个Context，用Context包装Handler，由Context组成双向链表，节点间通过AbstractChannelHandlerContext 类内部的 fire 系列方法 进行传递，入站方法叫inbound，从head节点开始，出站方法叫outbound，由tail节点开始。&lt;/li&gt;
&lt;li&gt;对于耗时的方法，一般丢给线程池处理，如上面Demo中的例子&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考：&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000006824196&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java NIO 的前生今世 之四 NIO Selector 详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/052035037297&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入浅出NIO之Channel、Buffer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/aspirant/p/8630283.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java NIO：IO与NIO的区别&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.bilibili.com/video/BV1DJ411m7NR&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;尚硅谷Netty教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;&#34; &gt;netty in action&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Java List Map</title>
        <link>http://nixum.cc/p/java-list-map/</link>
        <pubDate>Mon, 18 Feb 2019 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/java-list-map/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;以下笔记如没指定版本，都是基于JDK1.8&lt;/p&gt;
&lt;h1 id=&#34;collection&#34;&gt;Collection&lt;/h1&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/collection%e7%b1%bb%e5%9b%be.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/collection%e7%b1%bb%e5%9b%be.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;javaCollection类图简版&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;javaCollection类图简版&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;set&#34;&gt;Set&lt;/h2&gt;
&lt;h3 id=&#34;hashset&#34;&gt;HashSet&lt;/h3&gt;
&lt;h4 id=&#34;1基本&#34;&gt;1.基本&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;底层是HashMap，因此初始容量，默认负载因子、扩容倍数这些都和HashMap一样&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于HashSet只需要key，因此value统一使用静态不可变的Object对象来装，即所有key共享这一个对象&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;transient&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;PRESENT&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;HashSet&lt;strong&gt;允许存入null&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;不是线程安全的&lt;/li&gt;
&lt;li&gt;不保证插入元素的顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;list&#34;&gt;List&lt;/h2&gt;
&lt;h3 id=&#34;arraylist&#34;&gt;ArrayList&lt;/h3&gt;
&lt;h4 id=&#34;1基本-1&#34;&gt;1.基本&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;底层：Object数组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认大小：10 （调用空参构造方法时）&lt;/p&gt;
&lt;p&gt;最大是Integer.MAX_VALUE - 8（2^31 - 1，一些虚拟器需要在数组前加个头标签，所以减去 8 ）&lt;/p&gt;
&lt;p&gt;调用此构造方法时，&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Collection&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;E&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中要注意的是，里面有这样一句话&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// c.toArray might (incorrectly) not return Object[] (see 6260652)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;elementData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[].&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;elementData&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Arrays&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;copyOf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;elementData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[].&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果传入的是 参数c 是由 List&lt;!-- raw HTML omitted --&gt; asList = Arrays.asList(&amp;ldquo;aaa&amp;rdquo;,&amp;ldquo;bbb&amp;rdquo;); 这样来的，那么这个asList.toArray()是一个String[].class类，而不是Object[].class，原因是Arrays的asList()方法返回的是内部类Arrays&amp;amp;ArrayList，其toArray()方法与ArrayList的toArray()方法不一样&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不是线程安全，因此一般在单线程中使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;允许存入null对象，size也会计入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;每次扩容原来的 1.5 倍，如果扩容后仍然不够用，则采用满足够用时的数量&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&#34;2扩容&#34;&gt;2.扩容&lt;/h4&gt;
&lt;p&gt;因为ArrayList是底层是数组，当add操作时会使用 ensureCapacityInternal() 方法保证容量，根据size与数组的长度进行比较，如果size比数组长度大时，使用 grow() 方法进行扩容&lt;/p&gt;
&lt;p&gt;在 grow(int minCapacity) 方法中的 int newCapacity = oldCapacity + (oldCapacity &amp;raquo; 1); 新容量的大小为原来的1.5倍，之后使用这个新容量，调用 Arrays.copyOf(elementData, newCapacity) 把原数组整个复制到新数组中，可以看到，复制的时候代价是很大的&lt;/p&gt;
&lt;p&gt;如果扩容之后的容量仍然不够，则将容量扩充至当前需要的数量&lt;/p&gt;
&lt;p&gt;比如 List&lt;!-- raw HTML omitted --&gt; list = new ArrayList&amp;lt;&amp;gt;();，此时ArrayList类里的size是0，但是Object数组长度是10&lt;/p&gt;
&lt;p&gt;ArrayList类里：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;E&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ensureCapacityInternal&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// Increments modCount!!
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;elementData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ensureCapacityInternal&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minCapacity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;elementData&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DEFAULTCAPACITY_EMPTY_ELEMENTDATA&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;minCapacity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Math&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;max&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DEFAULT_CAPACITY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minCapacity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ensureExplicitCapacity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;minCapacity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ensureExplicitCapacity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minCapacity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 记录数组修改(增加或删除或调整内部数组的大小)的次数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;n&#34;&gt;modCount&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++;&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 判断是否需要扩容
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;minCapacity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elementData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;grow&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;minCapacity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 扩容
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;grow&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minCapacity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// overflow-conscious code
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;oldCapacity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elementData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newCapacity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;oldCapacity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;oldCapacity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 相当于 old + (old / 2)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;newCapacity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minCapacity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;newCapacity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minCapacity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;newCapacity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MAX_ARRAY_SIZE&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;newCapacity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hugeCapacity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;minCapacity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// minCapacity is usually close to size, so this is a win:
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;n&#34;&gt;elementData&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Arrays&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;copyOf&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;elementData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newCapacity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;3删除&#34;&gt;3.删除&lt;/h4&gt;
&lt;p&gt;删除指定下标的值时，调用 System.arraycopy() 将 index+1 后面的元素都复制到 index 位置上，不需要遍历数组，时间复杂度为 O(N)，可以看出，删除元素的代价也是非常高的。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;E&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;rangeCheck&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;modCount&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;E&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;oldValue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elementData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;

    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;numMoved&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;numMoved&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;arraycopy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;elementData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;elementData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;
                         &lt;span class=&#34;n&#34;&gt;numMoved&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;elementData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[--&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// clear to let GC do its work
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;oldValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;同理的remove(Object o)（但是需要遍历数组）、removeAll()都是差不多的操作&lt;/p&gt;
&lt;h4 id=&#34;4读取和修改&#34;&gt;4.读取和修改&lt;/h4&gt;
&lt;p&gt;修改：直接修改数组对应下标的值&lt;/p&gt;
&lt;p&gt;读取：直接获取数组对应下标的值&lt;/p&gt;
&lt;p&gt;注意到两个方法都有 checkForComodification(); 的判断，该方法的判断主要是提示并发修改异常&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;E&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;E&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;rangeCheck&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;checkForComodification&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;E&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;oldValue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;elementData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;offset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;elementData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;offset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;e&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;oldValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;E&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;rangeCheck&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;checkForComodification&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;elementData&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;offset&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h4 id=&#34;5fail-fast&#34;&gt;5.Fail-Fast&lt;/h4&gt;
&lt;p&gt;一种错误检查机制，因为ArrayList不是线程安全的，因此当多线程修改ArrayList对象时，或者在迭代操作中修改ArrayList对象或者序列化操作中，会进行Fail-Fast检查。&lt;/p&gt;
&lt;p&gt;检查的原理就是使用 全局变量 modCount 来检查，modCount 用来记录 ArrayList 内数组修改(增加、删除或调整内部数组的大小)的次数，当比较前后的modCount不一致时，抛出ConcurrentModificationException异常&lt;/p&gt;
&lt;p&gt;单线程中，如果需要在迭代中remove元素，应该使用迭代器迭代，并且使用迭代器提供的remove()（里面也是调用了ArrayList的remove方法，只是有修改modCount的值）方法，而不是ArrayList的remove方法，多线程的情况下只能使用线程安全的集合类了&lt;/p&gt;
&lt;h4 id=&#34;6序列化&#34;&gt;6.序列化&lt;/h4&gt;
&lt;p&gt;ArrayList的底层Object数组被 transient 修饰，该关键字声明数组默认不会被序列化&lt;/p&gt;
&lt;p&gt;之后通过重写writeObject() 和 readObject() 将数组里的元素取出，进行序列化&lt;/p&gt;
&lt;p&gt;之所以这么做是因为ArrayList的自动扩容机制，数组内元素实际数量可能会比数组长度小，如果一整个序列化的话会浪费空间，通过手动序列化的方式，只序列化实际存储的元素，而不是整个数组&lt;/p&gt;
&lt;p&gt;类实现Serializable接口，序列化时会使用 ObjectOutputStream 的 writeObject() 将对象转换为字节流并输出。而 writeObject() 方法在传入的对象存在 writeObject() 的时候会去反射调用该对象的 writeObject() 来实现序列化。&lt;/p&gt;
&lt;h4 id=&#34;7与vector的区别&#34;&gt;7.与Vector的区别&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Vector实现方式跟ArrayList类似，也是基于数组实现，默认大小也是10，但它是线程安全的&lt;/li&gt;
&lt;li&gt;Vecotr扩容是扩容到原来的2倍，ArrayList是1.5倍&lt;/li&gt;
&lt;li&gt;Vecotr的线程安全是因为其方法都使用了 synchronized 关键字进行修饰同步，效率比ArrayList差，这也是不推荐使用Vector的原因，保证线程安全可以使用 juc 包里其他类&lt;/li&gt;
&lt;li&gt;当需要线程安全的ArrayList时，不使用Vector，而是使用 CopyOnWriteArrayList 类 或者 Collections.synchronizedList(List&lt;!-- raw HTML omitted --&gt; list);&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;linkedlist&#34;&gt;LinkedList&lt;/h3&gt;
&lt;h4 id=&#34;1基本-2&#34;&gt;1.基本&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;底层是链表，且是双向链表&lt;/li&gt;
&lt;li&gt;采用链表，因此插入、删除效率高(但需要知道被删除节点)，查找效率低，不支持随机查找，而ArrayList底层是数组，因此支持随机查找，查找效率高，但是插入，删除效率低&lt;/li&gt;
&lt;li&gt;LinkedList底层是双向链表的缘故，可以当成队列使用，创建队列Queue或者Deque时，采用LinkedList作为实现&lt;/li&gt;
&lt;li&gt;不是线程安全的&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;copyonwritearraylist&#34;&gt;CopyOnWriteArrayList&lt;/h3&gt;
&lt;h4 id=&#34;1基本-3&#34;&gt;1.基本&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;线程安全的ArrayList，基本使用同ArrayList&lt;/li&gt;
&lt;li&gt;底层是Object数组，但是有 volatile 修饰，还有一把可重入锁 ReentrantLock 保证线程安全&lt;/li&gt;
&lt;li&gt;保证线程安全的原理是 读写分离，读的时候使用 全局变量里的Object数组，每次写的时候加锁，在方法里创建一个新数组，将全局变量里的Object数组 通过Arrays.copyOf复制 给方法里的新数组，之后进行写操作，完了再把全局变量的Object数组指向新数组。由于存在复制操作，因此add()、set()、remove()的开销很大&lt;/li&gt;
&lt;li&gt;读操作不能读取实时性的数据，因为写操作的数据可能还未同步&lt;/li&gt;
&lt;li&gt;适合读多写少的场景&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;map&#34;&gt;Map&lt;/h1&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Map%e7%b1%bb%e5%9b%be.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/Map%e7%b1%bb%e5%9b%be.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;Map类图&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;Map类图&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;hashmap&#34;&gt;HashMap&lt;/h2&gt;
&lt;h3 id=&#34;1基本-4&#34;&gt;1.基本&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;底层：一个Node类型的数组，而1.7的是Entry 类型的，不过基本也差不多&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;transient&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;table&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Node类是HashMap里的一个内部类&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Entry&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hash&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;		&lt;span class=&#34;c1&#34;&gt;// key的hash码
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;K&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;		&lt;span class=&#34;c1&#34;&gt;// 对应的链表
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;数组中的每个位置称为一个桶，一个桶存放一条链表，同一个桶的HashCode一样&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;默认容量是16，最大容量是2^30，即数组长度&lt;/p&gt;
&lt;p&gt;默认的填充因子是0.75&lt;/p&gt;
&lt;p&gt;桶的个数，即数组的长度总是 2的n次幂&lt;/p&gt;
&lt;p&gt;当桶上链表的结点数大于 8 时，链表转红黑树，小于 6 时，红黑树转链表&lt;/p&gt;
&lt;p&gt;桶的个数，即数组长度少于 64 时，先扩容，大于64时，链表转红黑树，也就是说，它是先检查链表结点数，如果大于8，再检查数组长度，再决定是否转红黑树&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;两个变量：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 临界值,衡量数组是否需要扩增的一个标准，threshold=容量x填充因子，键值对个数超过这个阈值，扩容2倍
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;threshold&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 填充因子,控制数组存放数据的疏密程度
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;loadFactor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;每次扩容为原来的 2 倍&lt;/li&gt;
&lt;li&gt;允许key=null，此时将该元素放入Node类型数组下标为0处&lt;/li&gt;
&lt;li&gt;不是线程安全的，支持fast-fail机制&lt;/li&gt;
&lt;li&gt;不保证插入顺序&lt;/li&gt;
&lt;/ul&gt;
&lt;ul&gt;
&lt;li&gt;基本结构：&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;1.8之前，数组的每一个元素中存放一条链表：&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/1.7HashMap.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/1.7HashMap.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;1.8之前的HashMap&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;1.8之前的HashMap&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;1.8，数组中的每一个元素存放一条链表，当链表的长度超过8（默认）之后，将链表转换成红黑树，以减少搜索时间&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/1.8HashMap.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/1.8HashMap.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;1.8HashMap&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;1.8HashMap&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;2创建过程&#34;&gt;2.创建过程&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;构造方法：除留余数法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;哈希冲突解决方法：拉链法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;map&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;首先创建一个Map，调用空参构造方法，此时只是设置了默认的填充因子，Node数组还没有初始化；除了public HashMap(Map&amp;lt;? extends K, ? extends V&amp;gt; m) 这个构造方法外，其他的构造方法基本都是只设置了填充因子和容量，并没有对数组初始化，当第一次调用put方法时，才对数组进行内存分配，完成初始化，延迟加载&lt;/p&gt;
&lt;p&gt;其中一个可以指定容量和填充因子的构造方法中，&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;initialCapacity&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;loadFactor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果传入的容量不是 2的n次幂，HashMap总会保证其数组的容量为2的n次幂，使用下面方法，原因是为了加快取模的运算速度，具体解释看下一节&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 用于保证容量为2的n次，原理是求出一个数的掩码 + 1，即可得到大于该数的最小2的n次
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;tableSizeFor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MAXIMUM_CAPACITY&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MAXIMUM_CAPACITY&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当第一次调用put方法时，对数组(桶)进行判断，如果为空，则为数组分配内存，完成初始化，之后再根据key的情况，加入到HashMap中&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;key111&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;value111&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;对put方法的解析具体请看&lt;a class=&#34;link&#34; href=&#34;https://juejin.im/post/5ab0568b5188255580020e56&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;集合框架源码学习之HashMap(JDK1.8)&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&#34;3确定键值对所在的桶的下标&#34;&gt;3.确定键值对所在的桶的下标&lt;/h3&gt;
&lt;p&gt;当向map中put进 key-value 时，对key采用哈希 + 除留余数法，确定该键值对所在的桶的下标&lt;/p&gt;
&lt;p&gt;首先计算key的hash值，之后对数组的容量取模，得到的余数就是桶的下标&lt;/p&gt;
&lt;p&gt;JDK1.7&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;hash&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;hashSeed&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;		&lt;span class=&#34;c1&#34;&gt;// hashSeed的值受容量和resize方法而定
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;instanceof&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;sun&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;misc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Hashing&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;stringHash32&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;^=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;hashCode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;^=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;20&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;^&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;^&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;^&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;indexFor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// assert Integer.bitCount(length) == 1 : &amp;#34;length must be a non-zero power of 2&amp;#34;;
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;但是这里并不直接采用取模%操作， 而是使用了位运算，因为位运算的代价比求模运算小的多，因此在进行这种计算时用位运算的话能带来更高的性能&lt;/p&gt;
&lt;p&gt;而取模(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;amp;)操作，这也解释了为什么容量每次都是2的n次幂&lt;/p&gt;
&lt;p&gt;在JDK1.8中，此操作被简化了，也取消了indexFor(int h, int length)方法，确定桶下标直接 hash &amp;amp; (length-1)&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;hash&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;?&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;hashCode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;^&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// ^ 按位异或
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;当计算得到该键值对所在桶的下标后，判断该桶是否为空，如果为空，将此键值对插入到桶中&lt;/p&gt;
&lt;p&gt;当容量未达到阈值，且容量未变，此时出现新键值对，其key计算得到的桶的下标所在位置已经有结点了，则通过拉链法来解决冲突&lt;/p&gt;
&lt;p&gt;先判断新的键值对的key的hash值与头结点的key的hash值是否一致，且key是否相等，如果这两项均满足，则说明该新的key与头结点的一样，将value覆盖掉原来的结点，如果不相等，则&lt;/p&gt;
&lt;p&gt;在JDK1.7中，使用头插法加入链表，在多线程中，头插法可能会导致hashMap扩容时造成死循环，因此在1.8修复这个问题了&lt;/p&gt;
&lt;p&gt;在JDK1.8中，使用尾插法加入链表，当然还有一系列判断是否需要将链表转换为红黑树，具体条件看上面已说明&lt;/p&gt;
&lt;h3 id=&#34;4扩容&#34;&gt;4.扩容&lt;/h3&gt;
&lt;p&gt;当加入到HashMap中的元素越来越多时，碰撞的概率也越来越高，链表的长度变长，查找效率降低，此时就需要对数组进行扩容。HashMap根据键值对的数量，来调整数组长度，保证查找效率&lt;/p&gt;
&lt;p&gt;在两种情况下，HashMap会进行扩容&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当put操作时，数组大小超过阈值 threshold（容量 x 负载因子），JDK1.7、1.8都是&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;K&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;V&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;[]&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;resize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;；&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;扩容时，将扩容到原来的2倍（newThr = oldThr &amp;laquo; 1），之后进行一次重新的hash分配。&lt;/p&gt;
&lt;p&gt;创建新数组，遍历整个旧的hashMap，重新计算每个键值对的hash值以及对应的桶下标，&lt;strong&gt;扩展后Node对象的位置要么在原位置，要么移动到原偏移量两倍的位置&lt;/strong&gt;，之后将旧hashMap中的结点加入到新的数组中&lt;/p&gt;
&lt;p&gt;HashMap 使用了一个特殊的机制，降低重新计算桶下标的操作。&lt;/p&gt;
&lt;p&gt;假设原数组长度 capacity 为 16，扩容之后 new capacity 为 32：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;capacity&lt;/span&gt;     &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;00010000&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;capacity&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;00100000&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;对于一个 Key，&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;它的哈希值如果在第 5 位上为 0，那么取模得到的结果和之前一样；&lt;/li&gt;
&lt;li&gt;如果为 1，那么得到的结果为原来的结果 +16。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;5与hashtable的区别&#34;&gt;5.与HashTable的区别&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;HashMap不是线程安全的，HashTable是线程安全的(因为其方法使用了synchronized修饰来保证同步，效率较差)&lt;/li&gt;
&lt;li&gt;HashMap允许插入key为null的键值对，而HashTable不允许&lt;/li&gt;
&lt;li&gt;如果不指定容量，HashMap默认容量是16，每次扩容为原来的 2 倍；HashTable默认容量是11，每次扩容为原来的 2n+1 倍&lt;/li&gt;
&lt;li&gt;jdk1.8后对HashMap链表的改变，HashTable没有&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;concurrenthashmap&#34;&gt;ConcurrentHashMap&lt;/h2&gt;
&lt;h3 id=&#34;1基本-5&#34;&gt;1.基本&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;线程安全的HashMap，使用方法同HashMap&lt;/li&gt;
&lt;li&gt;不允许存入key为null的键值对&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;2线程安全的底层原理jdk17和jdk18的实现不一样&#34;&gt;2.线程安全的底层原理，JDK1.7和JDK1.8的实现不一样&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;JDK1.7&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;JDK1.7 采用分段锁（segment）机制，每个分段锁维护几个桶，多个线程可以同时访问不同分段锁上的桶，并发度指segment的个数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认的分段锁是16，segment的数量一经指定就不会再扩了；每个segment里面的HashEntry数组的最小容量是2，每次扩容 2 倍&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;也是延迟初始化，当第一次put的时候，执行第一次hash取模定位segment的位置，如果segment没有初始化，因为put可能出现并发操作，则通过CAS赋值初始化，之后执行第二次hash取模定位HashEntry数组的位置，通过继承 ReentrantLock的tryLock() 方法尝试去获取锁，如果获取成功就直接插入相应的位置，如果已经有线程获取该segment的锁，那当前线程会以自旋的方式去继续的调用 tryLock() 方法去获取锁，超过指定次数就挂起，等待唤醒&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;size（统计键值对数量）操作：因为存在并发的缘故，size的可能随时会变，ConcurrentHashMap采用的做法是先采用不加锁的模式，尝试计算size的大小，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的，尝试次数是 3 次，如果超过了 3 次，则会对segment加锁，锁住对segment的操作，之后再统计个数&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/1.7concurrentHashMap.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/1.7concurrentHashMap.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;1.7concurrentHashMap&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;1.7concurrentHashMap&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JDK1.8
&lt;ul&gt;
&lt;li&gt;采用CAS和synchronized来保证并发安全，更接近HashMap&lt;/li&gt;
&lt;li&gt;synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发&lt;/li&gt;
&lt;li&gt;扩容的时候由于只有一个table数组，将在多线程下各个线程都会帮忙扩容，加快扩容速度&lt;/li&gt;
&lt;li&gt;size操作：在扩容和addCount()方法就进行处理，而不像1.7那样要等调用的时候才计算&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;红黑树的特性&lt;/strong&gt;:
（1）每个节点要么是黑色，要么是红色。
（2）根节点是黑色。
（3）每个叶子节点（NIL）是黑色。（注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点）
（4）如果一个节点是红色的，则它的子节点必须是黑色的。
（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。&lt;/p&gt;
&lt;p&gt;是一种二叉平衡树，但是平衡不是非常严格，因此结点的旋转次数少，插入、删除效率高，插入、删除、搜索都是时间复杂度都是O(log2 n)&lt;/p&gt;
&lt;p&gt;插入和删除时，先理解为二叉搜索树的插入和删除，然后再进行变色，优先变色，变色后仍无法达到上面那五个特性才开始旋转，来达到上面的特性，插入时节点一般是红色&lt;/p&gt;
&lt;p&gt;参考：&lt;a class=&#34;link&#34; href=&#34;https://baijiahao.baidu.com/s?id=1663270991795039269&amp;amp;wfr=spider&amp;amp;for=pc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;红黑树插入和删除&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;使用stream处理集合&#34;&gt;使用Stream处理集合&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.ibm.com/developerworks/cn/java/j-lo-java8streamapi/index.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java 8 中的 Streams API 详解&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/nayitian/p/3266090.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java：集合，Collection接口框架图&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CyC2018/CS-Notes/java容器.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/liqing-weikeyuan/p/7922306.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;c.toArray might not return Object[]?&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/ITtangtang/p/3948555.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java集合&amp;mdash;ArrayList的实现原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://juejin.im/post/5ab0568b5188255580020e56&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;集合框架源码学习之HashMap(JDK1.8)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/xiaoxi/p/7233201.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JDK1.8 HashMap源码分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/leesf456/p/5547853.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;【JUC】JDK1.8源码分析之CopyOnWriteArrayList（六）&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.cnblogs.com/skywang12345/p/3624343.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;红黑树(一)之 原理和算法详细介绍&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Spring和SpringBoot</title>
        <link>http://nixum.cc/p/spring%E5%92%8Cspringboot/</link>
        <pubDate>Wed, 17 Apr 2019 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/spring%E5%92%8Cspringboot/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;springboot&#34;&gt;SpringBoot&lt;/h1&gt;
&lt;h2 id=&#34;spring-和-spring-boot区别&#34;&gt;Spring 和 Spring Boot区别&lt;/h2&gt;
&lt;p&gt;Spring Boot实现了自动配置，降低了项目搭建的复杂度。它主要是为了解决使用Spring框架需要进行大量的配置太麻烦的问题，所以它并不是用来替代Spring的解决方案，而是和Spring框架紧密结合用于提升Spring开发者体验的工具。同时它集成了大量常用的第三方库配置(例如Jackson, JDBC, Mongo, Redis, Mail等等)，做到零配置即用。内置Tomcat作为Web服务器，不像之前还要把服务部署到Tomcat在进行启动。&lt;/p&gt;
&lt;h2 id=&#34;springboot整个启动流程&#34;&gt;SpringBoot整个启动流程&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;构建SpringApplication对象，执行其run方法&lt;/li&gt;
&lt;li&gt;加载properties/yaml等配置文件&lt;/li&gt;
&lt;li&gt;创建ApplicationContext（也可以称为Bean、IOC容器）&lt;/li&gt;
&lt;li&gt;将扫描到的Bean或者xml中的bean，先解析成BeanDefinition，注册到ApplicationContext中的BeanFactory中（即自动配置过程，也是IOC容器的refresh方法执行过程）&lt;/li&gt;
&lt;li&gt;实例化Bean，进行依赖注入，（AOP也是在此处实现，创建代理实例加入IOC容器）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/SpringBoot%e5%90%af%e5%8a%a8%e6%b5%81%e7%a8%8b.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/SpringBoot%e5%90%af%e5%8a%a8%e6%b5%81%e7%a8%8b.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;SpringBoot启动流程&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;SpringBoot启动流程&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;参考&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/trgl/p/7353782.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SpringBoot启动流程解析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/lay2017/p/11478237.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SpringBoot启动流程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;springboot自动配置流程&#34;&gt;SpringBoot自动配置流程&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;自动配置流程只是SpringBoot启动中的一个环节，该环节只是在告诉Spring要在哪里找到Bean的声明。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;启动类main方法为入口，main方法所在的类会被**@SpringBootApplication**修饰， 通过main方法里执行**SpringApplication.run(Application.class, args)**进行启动，Spring启动时会解析出@SpringBootApplication注解，进行Bean的加载和注入。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;@SpringBootApplication里包含了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;@SpringBootConfiguration&lt;/strong&gt;：作用类似于**@Configuration**，JavaConfig配置类，相当一个xml文件，配合@Bean注解让IOC容器管理声明的Bean&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;@ComponentScan&lt;/strong&gt;：配上包路径，用于扫描指定包及其子包下所有类，如扫描@Component、@Server、@Controller等，并注入到IOC容器中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;@EnableAutoConfiguration&lt;/strong&gt;：自动配置的核心注解，主要用于找出所有自动配置类。该注解会使用**@Import(EnableAutoConfigurationImportSelector.class**)帮助SpringBoot应用将所有符合条件的@Configuration配置都加载到当前SpringBoot创建并使用的IoC容器。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;EnableAutoConfigurationImportSelector&lt;/strong&gt;类里有个SpringFactoriesLoader工厂加载器，通过里面的loadFactoryNames方法，传入&lt;strong&gt;工厂类名称&lt;/strong&gt;和&lt;strong&gt;对应的类加载器&lt;/strong&gt;，加载该类加载器搜索路径下的指定文件&lt;strong&gt;spring.factories文件&lt;/strong&gt;，传入的工厂类为接口，而文件中对应的类则是接口的实现类，或最终作为实现类，得到这些类名集合后，通过&lt;strong&gt;反射&lt;/strong&gt;获取这些类的类对象、构造方法，最终生成实例。&lt;/p&gt;
&lt;p&gt;因此只要在maven中加入了所需依赖，根据&lt;strong&gt;spring.factories&lt;/strong&gt;文件里的key-value，能够在类路径下找到对应的class文件，就会触发自动配置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;自定义starter&#34;&gt;自定义starter&lt;/h2&gt;
&lt;p&gt;实际上就是编写自动配置类，会使用到一系列配置注解，如@Configuration、@EnableConfigurationProperties、@Component、@Bean、@ConditionOnXX、@AutoConfigureOrder等，让IOC容器加载我们自定义的Bean进去；&lt;/p&gt;
&lt;p&gt;另外就是必须在META-INF文件夹下创建spring.factories，告知Spring在哪找到配置类。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;org.springframework.boot.autoconfigure.EnableAutoConfiguration=[自定义配置类的全限定名称]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;自定义Starter可以理解为一个Jar包，该Jar包在Maven或Gradle注册后，服务启动时，IOC容器会去自动加载。&lt;/p&gt;
&lt;p&gt;自定义Starter内也可以使用配置文件，设定默认配置的key-value，当本项目里有配置的key与starter里定义的配置key重复时可以被替换&lt;/p&gt;
&lt;h2 id=&#34;contextloaderlistener&#34;&gt;ContextLoaderListener&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/weknow619/p/6341395.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;【Spring】浅谈ContextLoaderListener及其上下文与DispatcherServlet的区别&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;作为Spring启动入口&lt;/li&gt;
&lt;li&gt;实现了ServletContextListener 接口，监听ServletContext，如果 ServletContext 发生变化（如服务器启动时ServletContext 被创建，服务器关闭时 ServletContext 将要被销毁）时，执行监听器里的方法&lt;/li&gt;
&lt;li&gt;为IOC容器提供环境，扫描包，将带有注解的Bean加入到容器用于依赖注入，或者加载xml文件，将xml注册的bean加入容器用于依赖注入&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;常用注解&#34;&gt;常用注解&lt;/h1&gt;
&lt;h2 id=&#34;controller与restcontroller&#34;&gt;@Controller与@RestController&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;@Controller 默认是返回视图，即方法的return返回的是视图层的路径，只有+@ResponseBody才会返回Json格式的数据&lt;/li&gt;
&lt;li&gt;@RestController实际上是@Controller + @ResponseBody组合，默认返回json格式的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;autowired与resource&#34;&gt;@Autowired与@Resource&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;@Autowired 注解，修饰类成员变量、方法及构造方法，完成自动装配的工作，默认按 byType 自动注入。只有一个required属性，默认是true，表示必须注入，不能为null&lt;/p&gt;
&lt;p&gt;@Autowired 自动注入时，Spring 容器中匹配的候选 Bean 数目必须有且仅有一个。因为它是按类型注入的，如果有多个同类型的Bean会导致出错，此时可以配合@Qualifier来规避这种情况，通过 @Qualifier(&amp;ldquo;实例名称&amp;rdquo;) 指定注入bean的名称，消除歧义，此时与 @Resource指定name属性作用相同。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@Resource 的作用相当于 @Autowired，只不过 @Autowired 按 byType 自动注入，面@Resource 默认按 byName 自动注入，该注解有两个属性，name和type，分别代表通过名称查找bean和通过类型查找bean。&lt;/p&gt;
&lt;p&gt;此外@Resource还有其他属性，如lookup、shareable、mappedName等&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;component与bean&#34;&gt;@Component与@Bean&lt;/h2&gt;
&lt;p&gt;两者都是用于标记，被标记的实例会被Spring管理&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;@Component只能作用类，配合@ComponentScan注解让Spring启动时进行扫描，当扫描到@Component修饰的类时会进行实例化和依赖注入&lt;/p&gt;
&lt;p&gt;@Component是一个比较通用的语义，@Service、@Repository的作用与@Component相同的，只是语义不同，修饰的类所在的层次不同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@Bean只能作用于方法，通过方法来实例化Bean，Bean的名称为方法的名称（如果有前缀get会自动忽略），交由IOC容器管理，通常与@Configuration配合使用，等价于xml文件中的&lt;!-- raw HTML omitted --&gt;配置，方法名相当于&lt;!-- raw HTML omitted --&gt;中的id，需要唯一&lt;/p&gt;
&lt;p&gt;@Bean的方式初始化bean会更加灵活，因为可以在方法内部进行逻辑处理，比如利用配置文件 + 工厂模式实例化不同的bean&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;configuration与configurationproperties&#34;&gt;@Configuration与@ConfigurationProperties&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;@Configuration作用于类，相当于加载bean的xml文件，一般配合@Bean注解使用，让IOC容器管理我们声明的bean&lt;/li&gt;
&lt;li&gt;@ConfigurationProperties用于读取key-value的那种配置文件，如properties、yaml等，类似于@Value，主要用于配置文件的字段注入，有属性prefix表示前缀，key为属性名称，将配置文件里的配置绑定到类的属性上。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;springbootapplication与componentscan与import&#34;&gt;@SpringBootApplication与@ComponentScan与@Import&lt;/h2&gt;
&lt;p&gt;两者都用于告知Spring在哪里找到bean，只是扫描的路径不同&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;@SpringBootApplication作用与main方法所在的类，用于启动IOC容器，默认会扫描该类所在包及其子包下，进行Bean的实例化和管理&lt;/p&gt;
&lt;p&gt;@SpringBootApplication实际上包含了三个注解，@ComponentScan、@EnableAutoConfiguration、@SpringBootConfiguration，详情见上面SpringBoot启动流程。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@ComponentScan(&amp;ldquo;包路径&amp;rdquo;)，用于扫描指定包及其子包下的类，哪些需要交由IOC容器管理，一般用于扫描@SpringBootApplication扫描不到的包。在非SpringBoot项目下，必须使用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@Import，相当于xml中的&lt;!-- raw HTML omitted --&gt;，主要是导入Configuration类，作用类似@ComponentScan，只不过@ComponentScan是通过扫描找到，范围广，@Import是直接指定某个Config类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@ImportResource(&amp;ldquo;classpath*:xml文件&amp;rdquo;)，则是直接导入指定的xml文件&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;ioc和di&#34;&gt;IOC和DI&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;控制反转&lt;/strong&gt;：实际上就是把开发人员对程序执行流程的控制，反转到由程序自己来执行，代表性的例子就是 模板方法设计模式，实际上是一种设计思想，就像spring把依赖注入给抽成框架，由框架来自动创建对象、管理对象生命周期、注入等，开发者只需要关注类间的关系即可&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;依赖注入&lt;/strong&gt;：实际上就是对类成员初始化，并不在类内部进行，而是在外部初始化后通过构造方法、参数等方式才传递给类，就像spring那几种注入方式：构造器注入、set方法注入、注解注入&lt;/p&gt;
&lt;h2 id=&#34;bean的作用域&#34;&gt;Bean的作用域&lt;/h2&gt;
&lt;p&gt;Spring中的bean默认都是单例的，对于一些公共属性，在多线程下并不安全，spring支持将bean设置为其他作用域&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prototype：多例，使用时才创建，每次获取的bean都不是同一个&lt;/li&gt;
&lt;li&gt;request：每次请求创建新bean，request结束，bean销毁&lt;/li&gt;
&lt;li&gt;session：每次请求创建新bean，仅在当前HTTP session内有效&lt;/li&gt;
&lt;li&gt;globalSession：基于 portlet 的 web 应用，现在很少用了&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;注入方式&#34;&gt;注入方式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;setter注入&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;构造器注入，无法解决循环依赖问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自动装配：xml下使用“autowire”属性，有no、byName、byType、constructor、autodetect方式可选&lt;/p&gt;
&lt;p&gt;注解注入：@Resource默认是使用byName进行装配，@Autowired默认使用byType。&lt;/p&gt;
&lt;p&gt;byName和byType指的是依赖注入时寻找bean的方式。@Resource和@Autowired都可以修饰属性、setter方法、构造器，此时表示的是以哪种方式进行注入&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;bean加载流程&#34;&gt;Bean加载流程&lt;/h2&gt;
&lt;p&gt;初始化IOC容器（工厂入货）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;读取xml文件 / 扫描包类上的注解&lt;/li&gt;
&lt;li&gt;解析成BeanDefinition，创建了Bean的定义类&lt;/li&gt;
&lt;li&gt;注册到BeanFactory，此时的工厂里只保存了类创建所需要的各种信息还没有真正的实例化Bean对象&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;依赖注入（工厂出货）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化IOC容器&lt;/li&gt;
&lt;li&gt;初始化Bean（没有设置Lazy-init）&lt;/li&gt;
&lt;li&gt;反射创建Bean实例&lt;/li&gt;
&lt;li&gt;注入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;详细源码分析，参考&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/ITtangtang/p/3978349.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring: 源码解读Spring IOC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://segmentfault.com/a/1190000015221968&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring  IOC源码分析&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;具体例子，参考&lt;a class=&#34;link&#34; href=&#34;https://yikun.github.io/2015/05/29/Spring-IOC%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring IOC核心源码学习&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;三级缓存解决循环依赖&#34;&gt;三级缓存解决循环依赖&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;第一级缓存：单例缓存池singletonObjects，存放完全初始化完的实例或者AOP实例对象，此时已经完成注入，直接可用了。&lt;/li&gt;
&lt;li&gt;第二级缓存：早期提前暴露的对象缓存earlySingletonObjects，用于检测循环引用，与singletonFactories互斥，如果一级缓存获取不到，则在此层获取实例，如果获取不到，且允许去三级缓存获取，则从三级缓存中获取，并remove加入二级缓存。一般用于存放完成了部分依赖注入的Bean。&lt;/li&gt;
&lt;li&gt;第三级缓存：singletonFactories单例对象工厂缓存，存放初始化不完全的实例（还有依赖没注入），如果到了三级缓存都获取不到，就会进行初始化，并加入。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当出现循环依赖的对象注入时，会利用这三级缓存来解决问题，但是Spring只能解决Setter方法的注入，无法解决构造器注入，原因是如果通过构造器注入，需要先准备好需要注入的属性&lt;/p&gt;
&lt;p&gt;假如现在有类A，持有属性B，类B，持有属性A&lt;/p&gt;
&lt;p&gt;通过构造器注入：初始化A，此时需要B，那初始化B，此时需要A，但是A因为构造器注入需要先有B，此时无法完成初始化。&lt;/p&gt;
&lt;p&gt;通过Setter方法注入：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化A，会先依次从三级缓存中获取A实例，获取不到，说明A还未初始化，初始化A产生实例，将实例A加入singletonFactories中。&lt;/li&gt;
&lt;li&gt;对A进行依赖注入，发现需要注入B，依次从三级缓存里获取B实例，到了第三层都获取不到，说明还未初始化，初始化B产生实例，加入singletonFactories，对B进行依赖注入，发现需要注入A，依次从三级缓存里获取A实例，在singletonFactories获取到还未初始化完全的实例A，从singletonFactories中remove，加入到earlySingletonObjects，注入到B中，此时B完全初始化完成，从earlySingletonObjects中remove，将B加入到singletonObjects中。&lt;/li&gt;
&lt;li&gt;回到对A进行依赖注入部分，由于B刚刚初始化完成加入了singletonObjects，所以A获取到B，进行注入，A初始化完全，加入singletonObjects中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;总结&lt;/strong&gt;：Spring在实例化一个bean的时候，先实例化该bean，然后递归的实例化其所依赖的所有bean，直到某个bean没有依赖其他bean，此时就会将该实例返回，然后反递归的将获取到的bean设置为各个上层bean的属性中。&lt;/p&gt;
&lt;p&gt;实际上，看起来earlySingletonObjects会有点多余，这一层的缓存主要是扩展时使用。&lt;/p&gt;
&lt;h2 id=&#34;bean的生命周期&#34;&gt;Bean的生命周期&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Spring 容器可以管理 singleton 作用域下 bean 的生命周期，在此作用域下，Spring 能够精确地知道bean何时被创建，何时初始化完成，以及何时被销毁；prototype 作用域的bean，Spring只负责创建，之后就不再管理，只能由开发人员通过代码控制&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;关于xxxAware类型的接口，Aware之前的名字表示IOC容器可以获得什么资源，Aware方法都是在初始化阶段前被调用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;生命周期执行过程，&lt;strong&gt;总结为：实例化 -&amp;gt; 属性赋值 -&amp;gt; 初始化 -&amp;gt; 销毁&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;实例化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Bean容器找到配置文件中Spring Bean的定义。&lt;/li&gt;
&lt;li&gt;Bean容器利用反射创建一个Bean的实例（对scope为singleton且非懒加载的bean实例化，此处会&lt;strong&gt;触发AOPCreator解析@Aspect类&lt;/strong&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;属性赋值&lt;/strong&gt; - 依赖注入&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果涉及到一些属性值 利用set方法设置一些属性值。&lt;/li&gt;
&lt;li&gt;如果Bean实现了BeanNameAware接口，调用setBeanName()方法，传入Bean的名字，相当于xml中&lt;!-- raw HTML omitted --&gt;中的id或name。&lt;/li&gt;
&lt;li&gt;如果Bean实现了BeanClassLoaderAware接口，调用setBeanClassLoader()方法，传入ClassLoader对象的实例。&lt;/li&gt;
&lt;li&gt;如果Bean实现了BeanFactoryAware接口，调用setBeanFactory()方法，传入beanFactory对象的实例，可以通过beanFactory获取其他Bean。&lt;/li&gt;
&lt;li&gt;与上面的类似，如果实现了其他*Aware接口，就调用相应的方法，比如实现了ApplicationContextAware接口，就可以获取上下文，作用同BeanFactory，只是能获取到其他数据。&lt;/li&gt;
&lt;li&gt;如果Bean实现了BeanPostProcessor接口，执行postProcessBeforeInitialization()方法（需手动实现该方法，&lt;strong&gt;利用该方法实现AOP，在此处创建代理类&lt;/strong&gt;）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;初始化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。作用同xml配置中的init-method配置一样，用于指定初始化方法，但是先于init-method方法执行。&lt;/li&gt;
&lt;li&gt;如果Bean在xml配置文件中&lt;!-- raw HTML omitted --&gt;的init-method属性，执行指定的方法进行初始化。&lt;/li&gt;
&lt;li&gt;如果Bean实现了BeanPostProcessor接口，执行postProcessAfterInitialization()方法（需手动实现该方法，&lt;strong&gt;利用该方法实现AOP，在此处创建代理类&lt;/strong&gt;）&lt;/li&gt;
&lt;li&gt;此时bean已经准备就绪，可以被应用程序使用了，他们将一直驻留在应用上下文中，直到该应用上下文被销毁&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;销毁&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当要销毁Bean的时候，如果Bean实现了DisposableBean接口，执行destroy()方法。&lt;/li&gt;
&lt;li&gt;当要销毁Bean的时候，如果Bean在xml配置文件中的&lt;!-- raw HTML omitted --&gt;的destroy-method属性，执行指定的方法进行销毁。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考：&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/3944792a5fff&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring Bean生命周期&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/1dec08d290c1&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring Bean生命周期&lt;/a&gt;：这篇写得不错&lt;/p&gt;
&lt;h2 id=&#34;applicationcontext与beanfactory的区别&#34;&gt;ApplicationContext与BeanFactory的区别&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;ApplicationContext与BeanFactory类似，BeanFactory只提供最基本的Bean对象创建与获取，ApplicationContext指的是上下文，包含BeanFactory的功能（实现了BeanFactory接口），同时也提供了其他额外的功能，比如事件机制、监听、拦截器、资源访问等。&lt;/li&gt;
&lt;li&gt;BeanFactory采用延迟加载来注入Bean，只有在使用到某个Bean的时候才会实例化，ApplicationContext则在容器启动时，就实例化Bean，常驻在容器内，也可以为Bean配置Lazy-init=true来让Bean延迟实例化。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ioc模拟&#34;&gt;IOC模拟&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/weilu2/p/spring_ioc_analysis_principle_bsici_on_reflection_annotation.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring——原理解析-利用反射和注解模拟IoC的自动装配&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://zhuanlan.zhihu.com/p/144627581&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;根据 Spring 源码写一个带有三级缓存的 IOC&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;aop&#34;&gt;AOP&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;切面Aspect：指代理类，声明切点和通知&lt;/li&gt;
&lt;li&gt;切点PointCut：指要把切面的通知在被代理类的方法的位置，即表达式execution（值的格式为 [方法的访问修饰符] [被代理类的全限定名称]和其方法名(方法参数)]），切点可以有多个，配合通知使用&lt;/li&gt;
&lt;li&gt;通知Advice：代理类的增强方法，通知分为前置通知、环绕通知、后置通知、后置返回通知、后置异常通知&lt;/li&gt;
&lt;li&gt;连接点JoinPoint：被代理类的方法&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;基本原理&#34;&gt;基本原理&lt;/h2&gt;
&lt;p&gt;AOP基于代理模式，代理分为三种代理：静态代理，JDK动态代理，CGLib代理&lt;/p&gt;
&lt;h3 id=&#34;静态代理&#34;&gt;静态代理&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 接口
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 代理类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;BProxy&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;BProxy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{}&lt;/span&gt;
    
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;BProxy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 为被代理类进行一系列前置操作
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 为被代理类进行一系列后置操作
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 被代理类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 具体的处理逻辑
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;BProxy&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bProxy&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BProxy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;bProxy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;好处：在不修改目标对象的功能的前提下，增添新方法
缺点：每个对象都需要有代理对象，导致有很多代理类；接口增加方法，所有的实现类都要改&lt;/p&gt;
&lt;h3 id=&#34;jdk动态代理&#34;&gt;JDK动态代理&lt;/h3&gt;
&lt;p&gt;动态代理是为了解决上述问题，通过反射 + 多态的方式，动态为一个一个类设置代理，只有知道那个类的接口才可以。利用 JDK java.lang.reflect包里的InvocationHandler接口，代理方法具体逻辑写在invoke方法里&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;代理对象的执行方法&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;！&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;InvocationHandler&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// proxy：动态产生的代理对象，method：被代理类要执行的方法，args：方法所需参数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;invoke&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;proxy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Method&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Throwable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;还有java.lang.reflect包中的Proxy类的newProxyInstance方法,，他是静态的，作用是为被代理类构建代理类，并返回，在这个动态生成的代理类中已经织入了InvocationHandler，而它又持有被代理类，对代理对象的所有接口方法调用都会转发到InvocationHandler.invoke()方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;该方法将会为被代理类生成代理类&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;代理类执行与被代理类的接口时&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;会执行invocationHandler的方法&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;！&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;newProxyInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ClassLoader&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;loader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 被代理类的类加载器，如上面B类的类加载器
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                                      &lt;span class=&#34;n&#34;&gt;Class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;?&amp;gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;interfaces&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 被代理类的接口数组
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                                      &lt;span class=&#34;n&#34;&gt;InvocationHandler&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 上面实现了InvocationHandler接口的实例
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IllegalArgumentException&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;具体例子&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ProxyFactory&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 被代理类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ProxyFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 匿名内部类的方式重写invoke方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getProxyInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 返回代理类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Proxy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;newProxyInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getClassLoader&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt;
				&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getInterfaces&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt;
				&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;InvocationHandler&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
					&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
					&lt;span class=&#34;c1&#34;&gt;//当代理者(接口)执行接口里的方法的时候就会调用此方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;					&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;invoke&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;proxy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Method&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
							&lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Throwable&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
						&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;为被代理类进行一系列前置操作&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
						&lt;span class=&#34;c1&#34;&gt;//执行实现了该接口的类中的方法，被代理类的方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;						&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;returnValue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;invoke&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
						&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;为被代理类进行一系列后置操作&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
						&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;returnValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//返回的是调用方法后的结果
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;					&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
				&lt;span class=&#34;o&#34;&gt;});&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// B b = new B();也是可以的
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bProxy&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ProxyFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getProxyInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 必须转接口类型
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 调用该接口里的方法都会被代理
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;bProxy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;好处：只需写一次该接口的代理类就可以为以后许多实现了此接口的被代理类进行代理，一次编写，处处使用
缺点：只针对一个接口实现的代理，只能针对接口写代理类&lt;/p&gt;
&lt;h3 id=&#34;cglib代理&#34;&gt;CGLIB代理&lt;/h3&gt;
&lt;p&gt;CGLIB代理就可以直接代理普通类，不需要接口了&lt;/p&gt;
&lt;p&gt;原理：直接读取被代理类的字节码，通过继承的方式实现，在内存中&lt;strong&gt;构建被代理类的子类对象&lt;/strong&gt;从而实现对目标对象的功能扩展&lt;/p&gt;
&lt;p&gt;具体例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ProxyFactory&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MethodInterceptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ProxyFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;//给目标对象创建代理对象
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getProxyInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;Enhancer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;en&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Enhancer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;//设置父类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;n&#34;&gt;en&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setSuperclass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getClass&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;//设置回调函数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;n&#34;&gt;en&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setCallback&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;//创建子类代理
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;en&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;create&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;//object 为CGLib动态生成的代理实例
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;//Method 为上文实体类所调用的被代理的方法引用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;//Object[] 方法的参数列表
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;//MethodProxy 为生成的代理类对方法的代理引用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;intercept&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;obj&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Method&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MethodProxy&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;proxy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;throws&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Throwable&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;为被代理类进行一系列前置操作&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;returnValue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;invoke&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;c1&#34;&gt;//或者写成 Object returnValue1 = proxy.invokeSuper(obj, args);
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;为被代理类进行一系列后置操作&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;returnValue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// B类的所有非final方法，包括它的父类都会被代理
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bProxy&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CGlibProxy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getProxyInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;bProxy&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id=&#34;springboot中的实现&#34;&gt;SpringBoot中的实现&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;SpringBoot中提供@EnableAspectJAutoProxy开启对AOP的支持，其中属性proxyTargetClass=true时使用cglib，为false使用JDK的动态代理，默认为false&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;@EnableAspectJAutoProxy注解主要是使用AspectJAutoProxyRegistrar类将AOP处理工具注册到Bean中。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在这个AOP处理工具中有一个AnnotationAwareAspectJAutoProxyCreator类，该类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现了一系列Aware接口，使用BeanFactory：使得Bean可以管理&lt;/li&gt;
&lt;li&gt;实现了order接口：用于设置切面的优先级&lt;/li&gt;
&lt;li&gt;继承了ProxyConfig：该类封装了代理的通用逻辑，cglib或JDK动态代理开关配置等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Bean加载完AnnotationAwareAspectJAutoProxyCreator类后，会解析开发者定义的切面类、切点、通知，在BeanFactory中找到被代理类，结合通知进行封装，创建出代理类。由于被代理类可被设置多重代理，在创建代理类时，会根据切面的优先级，不断套在被代理类上，形成拦截器链。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;执行代理类的方法时，就会调用方法拦截器链，进行方法增强。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;AOP的实现会在创建Bean实例对象前触发@Aspect切面对象，获得Advisor。生成Bean实例对象之后，才会再次触发对该Bean实例对象做代理增强，增强的Advisor来自之前的解析结果。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/JinXYan/article/details/89302126&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SpringAOP详细介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/fighterandknight/article/details/51209822&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Spring 源码分析Aop&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;事务&#34;&gt;事务&lt;/h1&gt;
&lt;h2 id=&#34;spring事务传播行为&#34;&gt;Spring事务传播行为&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;PROPERGATION_MANDATORY：方法必须运行在事务中，如果当前事务不存在，抛异常&lt;/li&gt;
&lt;li&gt;PROPAGATION_NESTED：当前事务存在，则该方法运行在嵌套事务中&lt;/li&gt;
&lt;li&gt;PROPAGATION_NEVER：方法不能运行事务中，否则抛异常&lt;/li&gt;
&lt;li&gt;PROPAGATION_REQUIRED：当前方法必须运行在事务中，如果当前存在事务，该方法运行其中，否则创建新事务&lt;/li&gt;
&lt;li&gt;PROPAGATION_REQUIRES_NEW：当前方法必须运行在事务中，如果当前存在事务，则该事务在方法运行期间被挂起&lt;/li&gt;
&lt;li&gt;PROPAGATION_SUPPORTS：当前方法不需要运行在事务中，但如果存在事务，也可运行在事务中&lt;/li&gt;
&lt;li&gt;PROPAGATION_NOT_SUPPORTED：当前方法不能运行在事务中，如果存在事务，则挂起该方法&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title>SpringMVC</title>
        <link>http://nixum.cc/p/springmvc/</link>
        <pubDate>Fri, 15 Feb 2019 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/springmvc/</guid>
        <description>&lt;h1 id=&#34;springmvc工作原理&#34;&gt;SpringMVC工作原理&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://github.com/Nixum/JavaGuide/blob/master/%E4%B8%BB%E6%B5%81%E6%A1%86%E6%9E%B6/SpringMVC%20%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E8%AF%A6%E8%A7%A3.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;SpringMVC工作原理详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;流程图看链接里的即可&lt;/p&gt;
&lt;p&gt;简单来说各个组件的作用&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;前端控制器DispatcherServlet&lt;/strong&gt;：请求的入口，可以看成是中央处理器、转发器，负责调度其他组件，接收请求，完成响应&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理器映射器HandlerMapping&lt;/strong&gt;：根据请求的url查找Handler，找到url对应的controller类，返回一条执行链，其中就包含拦截器和处理器（具体的controller类）；有配置文件方式，实现接口方式，注解方式等方式实现映射&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理器适配器HandlerAdapter&lt;/strong&gt;：HandlerMapping找到对应的controller类后，再根据url找到对应的执行方法&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;处理器Handler&lt;/strong&gt;：具体的处理方法，也就是我们所写具体的Controller类&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;视图解析器View resolver&lt;/strong&gt;：根据逻辑View名称，找到对应的View，根据处理器返回的ModelAndView，将数据渲染到View上&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;视图View&lt;/strong&gt;：例如jsp，freemarker之类的视图模板&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;拦截器在什么时候执行？&lt;/p&gt;
&lt;p&gt;拦截器，是属于HandlerMapping级别的，可以有多个HandlerMapping ，每个HandlerMapping可以有自己的拦截器，拦截器可以设置优先级。一个请求交给一个HandlerMapping时，这个HandlerMapping先找有没有处理器来处理这个请求，如何找到了，就执行拦截器，执行完拦截后，交给目标处理器。如果没有找到处理器，那么这个拦截器就不会被执行。&lt;/p&gt;
&lt;p&gt;实现HandlerInterceptor接口或者继承HandlerInterceptor，重写&lt;strong&gt;boolean preHandle()、void postHandle()、void afterCompletion()方法&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;preHandle() 方法：该方法会在控制器方法前执行，其返回值表示是否中断后续操作。&lt;/p&gt;
&lt;p&gt;当其返回值为true时，表示继续向下执行；当其返回值为false时，会中断后续的所有操作（包括调用下一个拦截器和控制器类中的方法执行等）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;postHandle()方法：该方法会在控制器方法调用之后，且解析视图之前执行。可以通过此方法对请求域中的模型和视图做出进一步的修改。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;afterCompletion()方法：该方法会在整个请求完成，即视图渲染结束之后执行。可以通过此方法实现一些资源清理、记录日志信息等工作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;spring-security&#34;&gt;Spring Security&lt;/h1&gt;
&lt;p&gt;简单工作流程&lt;/p&gt;
&lt;p&gt;请求(包含用户名，密码之类)——&amp;gt;登陆信息封装成一个Authentication对象——&amp;gt;AuthenticationManager，调用authenticate ()方法处理——&amp;gt;该方法会将对象传递给一系列AuthenticationAdapter（一系列Filter），每一个AuthenticationAdapter会调用它们配置的UserDetailsService处理&lt;/p&gt;
</description>
        </item>
        <item>
        <title>Java SE</title>
        <link>http://nixum.cc/p/java-se/</link>
        <pubDate>Mon, 18 Feb 2019 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/java-se/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;一面向对象&#34;&gt;一、面向对象&lt;/h1&gt;
&lt;p&gt;面向对象的特征：
抽象(注意与当前目标有关的，选择一部分，暂时不用部分细节，分为过程抽象、数据抽象)
&lt;strong&gt;继承&lt;/strong&gt;：联结类的层次模型、允许和鼓励类的重用，派生类可以从它的基类那里继承方法和实例变量，进行修改和新增使其更适合
&lt;strong&gt;封装&lt;/strong&gt;：封装是把过程和数据包围起来，对数据的访问只能通过已定义的界面，这些对象通过一个受保护的接口访问其他对象
&lt;strong&gt;多态&lt;/strong&gt;：允许不同类的对象对同一消息作出响应，包括参数化多态性和包含多态性，灵活、抽象、行为共享、代码共享，解决程序函数同名问题&lt;/p&gt;
&lt;h1 id=&#34;二基础类型及其包装类型&#34;&gt;二、基础类型及其包装类型&lt;/h1&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;基本类型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;boolean&lt;/th&gt;
&lt;th&gt;byte&lt;/th&gt;
&lt;th&gt;char&lt;/th&gt;
&lt;th&gt;short&lt;/th&gt;
&lt;th&gt;int&lt;/th&gt;
&lt;th&gt;float&lt;/th&gt;
&lt;th&gt;long&lt;/th&gt;
&lt;th&gt;double&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;包装类型&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Boolean&lt;/td&gt;
&lt;td&gt;Byte&lt;/td&gt;
&lt;td&gt;Character&lt;/td&gt;
&lt;td&gt;Short&lt;/td&gt;
&lt;td&gt;Integer&lt;/td&gt;
&lt;td&gt;Float&lt;/td&gt;
&lt;td&gt;Long&lt;/td&gt;
&lt;td&gt;Double&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;位数&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;16&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;32&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;字节数&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;&lt;/td&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;字符集&lt;/p&gt;
&lt;p&gt;unicode是字符集，一种标准，UTF-8、UTF-16、GBK之类的是编码方式，是字符集的具体实现&lt;/p&gt;
&lt;p&gt;UTF-16：定长,固定2字节， UTF-8：变长,中文占3字节,英文占1字节&lt;/p&gt;
&lt;p&gt;char可以保存一个中文字符&lt;/p&gt;
&lt;p&gt;java中采用unicode编码，无论中文、英文都是占2个字节&lt;/p&gt;
&lt;p&gt;java虚拟机中使用UTF-16编码方式&lt;/p&gt;
&lt;p&gt;java的字节码文件(.class)文件采用的是UTF-8编码，但是在java 运行时会使用UTF-16编码。&lt;/p&gt;
&lt;p&gt;参考&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/worm0527/article/details/70833531&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java中的UTF-8、UTF-16编码字符所占字节数&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;自动转换的顺序，&lt;/p&gt;
&lt;p&gt;由高到低：btye, short, char(这三个之间无法自动转换，只能强转) &amp;mdash;&amp;gt; int &amp;mdash;&amp;gt; long &amp;mdash;&amp;gt; float &amp;mdash;&amp;gt; double&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么 占8字节的long 转占 4字节float 不需要强转转化？&lt;/p&gt;
&lt;p&gt;因为底层实现方式不同，浮点数在内存中的32位不是简单地转化为十进制，而是通过公式计算得到，最大值要比long的范围大&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;装箱和拆箱&#34;&gt;装箱和拆箱&lt;/h2&gt;
&lt;p&gt;以 int 和 Integer 为例&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;装箱的时候自动调用的是 Integer 的 valueOf(int) 方法，Integer a = 1; 就会触发调用valueOf(int)方法&lt;/p&gt;
&lt;p&gt;拆箱的时候自动调用的是Integer的 intValue() 方法&lt;/p&gt;
&lt;p&gt;parseInt(&amp;quot;&amp;quot;)方法是将字符串转化为基本类型&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，装箱时，即调用 valueOf() 方法时，会先去缓存池里找，看看该值是否在缓存池的范围中，如果是，多次调用时会取得同一对象的引用，属于同一对象，如果不在缓存池中，则使用new Integer()&lt;/p&gt;
&lt;p&gt;使用new Integer()初始化的，无论传入的数是否在缓存池的范围内，都是重新分配内存初始化的，属于不同对象&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;23&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;23&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// true
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;23&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;23&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;a1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// false
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;128&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;128&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; 
&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// false
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;基本类型缓存池，其他类型没有&lt;/p&gt;
&lt;p&gt;boolean：true、false&lt;/p&gt;
&lt;p&gt;short ： -128 ~127&lt;/p&gt;
&lt;p&gt;int ： -128 ~127&lt;/p&gt;
&lt;p&gt;char ： \u0000 ~ \u007F&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;equals 和 == 对于 装箱和拆箱&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;== ：比较的是两个包装类型的，同包装类型，比较两者的引用，判断是否指向同一对象；不同包装类型用==比较会出现编译错误&lt;/p&gt;
&lt;p&gt;比较时两者都是基本类型，无论类型是否一样，都是比较数值&lt;/p&gt;
&lt;p&gt;比较时一个是包装类型，一个是基本类型，无论值的范围是否在缓存池内，则将自动拆箱，比较基本类型&lt;/p&gt;
&lt;p&gt;比较时有算术运算，自动拆箱，运算，比较数值&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;equals：看具体类型的equals方法，一般先比较类型，类型不一样直接返回false，类型一样再比较数值&lt;/p&gt;
&lt;p&gt;比较时传入基本类型，会进行装箱，之后进行equals比较&lt;/p&gt;
&lt;p&gt;比较时有算术运算，自动拆箱，运算，之后根据运算完后的类型再装箱（可能会向上转型），之后再进行equals比较&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;运算与转型&#34;&gt;运算与转型&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;从低位类型到高位类型自动转换；从高位类型到低位类型需要强制类型转换&lt;/li&gt;
&lt;li&gt;算术运算中，基本就是先转换为高位数据类型，再参加运算，结果也是最高位的数据类型&lt;/li&gt;
&lt;li&gt;short、byte、char计算时都会提升为int&lt;/li&gt;
&lt;li&gt;采用 +=、*= 等缩略形式的运算符，系统会自动强制将运算结果转换为目标变量的类型&lt;/li&gt;
&lt;li&gt;当运算符为自动递增运算符（++）或自动递减运算符（&amp;ndash;）时，如果操作数为 byte，short 或 char类型不发生改变&lt;/li&gt;
&lt;li&gt;被final修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型自动转化&lt;/li&gt;
&lt;li&gt;三元运算符？，：两边是基本类型会做自动类型提升&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; 
&lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;127&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//这种写法是可以的，会变成 a = (byte) (a+b) 
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;而&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;；&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;；&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;则会因为没有类型转化而出错&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;int无法转成byte&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 会出错，a在运算时为自动提升为int
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;如果是final修饰&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;、&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;那么byte&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;就不会编译错误&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;三string&#34;&gt;三、String&lt;/h1&gt;
&lt;h2 id=&#34;1基本&#34;&gt;1.基本&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;底层：private final char value[];&lt;/p&gt;
&lt;p&gt;value数组被final修饰，因此当它初始化之后就不能再引用其它数组&lt;/p&gt;
&lt;p&gt;String 内部没有改变 value 数组的方法，因此可以保证 String 不可变&lt;/p&gt;
&lt;p&gt;String类的方法都不是在原来的字符串上进行操作，而是重新生成新的字符数组&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类本身被 final 修饰，使它不可被继承&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;String类的 “+&amp;quot;  本质是使用StringBuilder的append方法，最终返回new的string&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JDK9之前底层使用char数组，JDK9底层改为使用byte数组+coder标识符，主要是因为有些字符集并不需要使用到2个字节的char，不需要用到2个字节的char&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;2不可变的好处&#34;&gt;2.不可变的好处&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;可以缓存 hash 值&lt;/p&gt;
&lt;p&gt;因为 String 的 hash 值经常被使用，例如 String 用做 HashMap 的 key。不可变的特性可以使得 hash 值也不可变，因此只需要进行一次计算。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;String Pool 的需要&lt;/p&gt;
&lt;p&gt;如果一个 String 对象已经被创建过了，那么就会从 String Pool 中取得引用。只有 String 是不可变的，才可能使用 String Pool。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;安全&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;String 经常作为参数，String 不可变性可以保证参数不可变。例如在作为网络连接参数的情况下如果 String 是可变的，那么在网络连接过程中，String 被改变，改变 String 对象的那一方以为现在连接的是其它主机，而实际情况却不一定是。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不可变得特性使得它天生是线程安全的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;3字符串常量池string-pool&#34;&gt;3.字符串常量池（String Pool）&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;一般用于缓存字符串字面量和符号引用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;String的intern方法可以把相应的字符串缓存起来，保存在永久代中，但是一般永久代空间有限，且只有FullGC才会进行垃圾回收（JDK8后移永久代移到了元空间中，默认大小也增加了），所以需要谨慎使用该方法&lt;/p&gt;
&lt;h2 id=&#34;4stringbuffer和stringbuilder&#34;&gt;4.StringBuffer和StringBuilder&lt;/h2&gt;
&lt;p&gt;StringBuffer是线程安全的，因为大部分方法都用了synchronized关键字修饰，而StringBuilder没有，所以是非线程安全的，两者在功能上是等价的，性能上，StringBuilder比StringBuffer好。&lt;/p&gt;
&lt;p&gt;3和4具体参考&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/xiaoxi/p/6036701.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入理解Java中的String&lt;/a&gt;，这篇文章写得相当详细了&lt;/p&gt;
&lt;h1 id=&#34;四equalshashcodeclone&#34;&gt;四、equals()、hashCode()、clone()&lt;/h1&gt;
&lt;h2 id=&#34;equals&#34;&gt;equals()&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;在不重写的情况下，Object类下的 equals() 方法比较的是两个对象的引用，即判断两个对象是否是同一个对象，此时等价于 ==&lt;/li&gt;
&lt;li&gt;重写的情况下，看具体类重写后的equals方法，像String类的 equals 方法是先判断是否是String类型，再比较字符的内容&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;hashcode&#34;&gt;hashCode()&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;作用是返回对象的int类型的哈希码，一般用于当索引，例如，在HashMap里，加入一对键值对，HashMap会先计算key的哈希值，取模，找到对应桶的下标&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;hashCode()一般会和equals()有联系，例如，HashMap在找到要加入的键值对所在对应的桶，桶内的键值对的哈希码肯定是一样，为了判断该键值对是否重复出现，将使用key的equals进行比较&lt;/p&gt;
&lt;p&gt;为什么有了equals()还要hashCode方法，有了hashCode方法还要equals方法？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;因为equals方法的实现比较复杂，效率较低，hashCode只需计算hash值就能进行对比，效率高&lt;/li&gt;
&lt;li&gt;hashCode方法不一定可靠，不同对象生成的hashCode可能一样，所以需要equals方法&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;hashCode() 与 equals() 的相关规定&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果两个对象相等，则hashcode一定也是相同的&lt;/li&gt;
&lt;li&gt;两个对象相等,对两个对象分别调用equals方法都返回true&lt;/li&gt;
&lt;li&gt;两个对象有相同的hashcode值，它们也不一定是相等的&lt;/li&gt;
&lt;li&gt;因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖&lt;/li&gt;
&lt;li&gt;hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;clone&#34;&gt;clone()&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;clone分为深拷贝和浅拷贝&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;浅拷贝：对象的属性是基本类型的，直接复制一份；属性是引用类型的（如数组、对象），复制引用，也就是拷贝过后的两个对象里引用类型的属性，都是指向同一个对象&lt;/p&gt;
&lt;p&gt;Object类里的clone方法就是浅拷贝&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;深拷贝：对象里的属性无论是基本类型还是引用类型，都是重新复制一份，即会为拷贝对象里的引用属性重新开辟内存空间，不再是和被拷贝对象指向同一个对象&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Object里的clone()方法被protected 修饰，一般类如果不重写的话是调用不了的，如果要重写的话，需要实现Cloneable接口，不然会抛出CloneNotSupportedException异常，之后可以通过super.clone()调用Object类中的原clone方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;关键字&#34;&gt;关键字&lt;/h1&gt;
&lt;h2 id=&#34;final和static&#34;&gt;final和static&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;final关键字主要用在三个地方：变量、方法、类。&lt;/li&gt;
&lt;/ul&gt;
&lt;ol&gt;
&lt;li&gt;修饰变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象，final修饰的变量一定要初始化，要不就直接初始化，不然就需要在每个构造方法里初始化，或者在代码块里初始化，代码块里的初始化和构造方法里的初始化只能二选一，否则会造成赋值重复&lt;/li&gt;
&lt;li&gt;修饰类，表明这个类不能被继承，final类中的所有成员方法都会被隐式地指定为final方法&lt;/li&gt;
&lt;li&gt;修饰方法，表明该方法不能被子类重写&lt;/li&gt;
&lt;/ol&gt;
&lt;ul&gt;
&lt;li&gt;声明为static成员不能被序列化&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;instanceof&#34;&gt;instanceof&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;是关键字，也是运算符&lt;/li&gt;
&lt;li&gt;用于判断一个对象是否是 一个类的实例，一个类的子类，一个接口的实现类&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;抽象类和接口&#34;&gt;抽象类和接口&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;抽象类可以有构造方法（但不能实例化），接口没有&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽象类可以有普通成员变量、静态变量或常量，访问类型任意，接口只有静态常量，且默认被public static final修饰&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽象类可以包含非抽象的普通方法，接口中的方法必须是抽象的，不能有非抽象方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽象类中的&lt;strong&gt;抽象方法访问类型&lt;/strong&gt;可以是&lt;strong&gt;public、protected和不写&lt;/strong&gt;，接口中的方法默认是public abstract&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;抽象类中可以包含静态方法(可以调用)，接口不行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JDK1.8之前接口中的方法不能有方法体，且不能被default修饰，但是可以不写访问修饰符，&lt;/p&gt;
&lt;p&gt;1.8之后（包含1.8）接口中的方法可以有方法体，表示默认方法体，但需要用default修饰&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;JDK1.8之前接口中的方法不能用static修饰，1.8之后（包含1.8）才可以使用static修饰，才可以通过接口名调用静态方法&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;继承&#34;&gt;继承&lt;/h1&gt;
&lt;h2 id=&#34;重写与重载&#34;&gt;重写与重载&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;重写（Override）&lt;/p&gt;
&lt;p&gt;继承中，子类重写父类方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;子类方法的&lt;strong&gt;访问权限&lt;/strong&gt;必须&lt;strong&gt;大于等于&lt;/strong&gt;父类方法；&lt;/li&gt;
&lt;li&gt;子类方法的返回类型必须是&lt;strong&gt;父类方法返回类型或为其子类型&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;子类抛出的&lt;strong&gt;异常&lt;/strong&gt;比父类的&lt;strong&gt;小或者相等&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于静态方法重写&lt;/p&gt;
&lt;p&gt;static方法不能被子类重写，子类如果定义了和父类完全相同的static方法，Son.staticmethod()或new Son().staticmethod()都是调用子类的，如果是Father.staticmethod()或Father f = new Son(); f.staticmethod()调用的是父类的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;重载（Overload）&lt;/p&gt;
&lt;p&gt;存在于同一个类中，指一个方法与已经存在的方法名称上相同，但是&lt;strong&gt;参数类型、个数、顺序&lt;/strong&gt;至少有一个不同&lt;/p&gt;
&lt;p&gt;注意，返回值不同，其它都相同不算是重载。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;初始化顺序&#34;&gt;初始化顺序&lt;/h2&gt;
&lt;p&gt;（括号内的按出现先后进行初始化）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;父类（静态变量、静态代码块）&lt;/li&gt;
&lt;li&gt;子类（静态变量、静态代码块）&lt;/li&gt;
&lt;li&gt;父类（实例变量、普通代码块）&lt;/li&gt;
&lt;li&gt;父类（构造函数）&lt;/li&gt;
&lt;li&gt;子类（实例变量、普通代码块）&lt;/li&gt;
&lt;li&gt;子类（构造函数）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在构造方法中，this()和super()调用构造方法时，只能放在第一行，且不能同时出现&lt;/p&gt;
&lt;h1 id=&#34;内部类&#34;&gt;内部类&lt;/h1&gt;
&lt;h2 id=&#34;基础&#34;&gt;基础&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;内部类是指在一个外部类的内部再定义一个类。内部类作为外部类的一个成员，并且依附于外部类而存在的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内部类可为静态，可用protected和private修饰（而外部类只能使用public和缺省的包访问权限）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内部类主要有以下几类：成员内部类、局部内部类、静态内部类、匿名内部类&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;成员内部类&#34;&gt;成员内部类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;在外部类里想调用内部类里的方法和变量，只能通过new的形式创建内部类实例才可以使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内部类调用外部类的方法，无论静态非静态，直接调用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内部类里的成员可以和外部类的成员的名字相同，直接使用的时候调用的是内部的，内部类调用外部类同名变量需要加上外部类名，如果没有同名变量就可以直接使用，不需要加外部类名&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在其他地方想要调用有内部类的类的内部类方法，需要实例化一个外部类，再使用外部类的实例变量实例化内部类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以被abstarct修饰，但无法实例化&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不能有静态成员、方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Inner&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;outin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Inner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;outin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;inner_f1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;局部内部类&#34;&gt;局部内部类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;局部内部类调用外部类的方法，直接调用&lt;/li&gt;
&lt;li&gt;外部类调用内部类方法，初始化外部类实例，调用有局部内部类的方法&lt;/li&gt;
&lt;li&gt;局部内部类 可以看成是 方法里的成员变量，只能在该方法里实例化&lt;/li&gt;
&lt;li&gt;局部内部类 对于同名变量的访问方式同成员内部类&lt;/li&gt;
&lt;li&gt;方法外的外部类的成员变量可以直接访问，但只能访问内部类所在方法里的final修饰的变量&lt;/li&gt;
&lt;li&gt;不能被static还有访问控制符修饰，可以被abstract、final修饰&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;静态内部类&#34;&gt;静态内部类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;静态内部类中可以定义静态或者非静态的成员或方法&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;静态内部类只能访问外部类的静态成员，不能访问外部类的非静态的成员&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;外部类方法访问内部类静态成员，直接 内部类名.静态成员变量&lt;/p&gt;
&lt;p&gt;访问内部非静态成员，实例化内部类，在调用&lt;/p&gt;
&lt;p&gt;说白了，静态属于整个类的，不属于某个对象的，可以直接使用，不依赖外部类，可以直接调用，或者实例化外部类里的静态类&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Inner&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;outin&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Outer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Inner&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;outin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;staticInner_f1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;		&lt;span class=&#34;c1&#34;&gt;// 或者直接调用 Outer.Inner.staticInner_f1()
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;outin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;inner_f1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;			&lt;span class=&#34;c1&#34;&gt;// 不能直接 Outer.Inner.inner_f1()
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;print&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;outin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;staticField&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;outin&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;field&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 同理只能 Outer.Inner.staticField, 不能Outer.Inner.field；
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;不可以只实例化外部类，再使用这个实例去实例化内部类或者调用内部类里的成员，这点跟成员内部类是不一样的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;匿名内部类&#34;&gt;匿名内部类&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;匿名内部类不能有构造方法&lt;/li&gt;
&lt;li&gt;无法被访问控制符、static修饰&lt;/li&gt;
&lt;li&gt;匿名内部类不能定义任何静态成员、方法和类&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;匿名都没类名了，构造方法，静态成员之类的没办法调用了&lt;/p&gt;
&lt;p&gt;参考&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/ITtangtang/p/3980460.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入理解java内部类&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;反射和内省&#34;&gt;反射和内省&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;反射：可以在运行时动态获取类信息或者动态调用类方法；JVM运行的时候，读入类的字节码到 JVM 中，对该类的属性、方法、构造方法进行获取和调用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;类加载一次之后会在JVM中缓存，但是如果是&lt;strong&gt;不同的类加载器&lt;/strong&gt;去加载&lt;strong&gt;同一个class&lt;/strong&gt;则会多次加载。&lt;/p&gt;
&lt;p&gt;两个类相等需要类本身相等，并且使用同一个类加载器进行加载。这是因为每一个类加载器都拥有一个独立的类名称空间。&lt;/p&gt;
&lt;p&gt;这里的相等，包括类的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果为 true，也包括使用 instanceof 关键字做对象所属关系判定结果为 true。&lt;/p&gt;
&lt;p&gt;反射慢是因为Java是静态语言，如果在JVM运行时才进行加载，进行参数和方法的解析，此时的JVM无法对反射加载的类进行优化，还有就是类加载需要经过验证，判断是否对JVM有害，反射加载验证会比平时在装载期的时间长，但是总的来说影响不大&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;内省：针对JavaBean，只能对Bean的属性进行操作；加载类，得到它的属性，对属性进行get/set，是对反射的一层封装&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;枚举&#34;&gt;枚举&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;使用enum定义的枚举类默认继承了java.lang.Enum，而不是继承Object类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;枚举类可以实现一个或多个接口&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用enum定义、非抽象的枚举类默认使用final修饰，不可以被继承，定义的Enum类默认被final修饰，无法被其他类继承&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;枚举类的所有实例都必须放在第一行展示，不需使用new 关键字，不需显式调用构造器。&lt;/p&gt;
&lt;p&gt;自动添加public static final修饰&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;枚举类的构造器只能是私有的&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;枚举类也能定义属性和方法，可以是静态和非静态的&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考 &lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/sister/p/4700702.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;java浅谈枚举类&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;具体例子&lt;/p&gt;
&lt;p&gt;反编译之后会发现，SPRING、SUMMER、FALL这些是静态常量(public static final 修饰)，而且是在静态代码块里初始化的，同时还附带有public static Season[] values()方法和public static Season valueOf(String s)方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Season&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 调用无参构造器、括号里的变量称为自定义变量，可以有多个，要跟构造方法对应
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;SPRING&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 调用有参构造器
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;SUMMER&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;夏天&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;),&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 默认调用无参构造器
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;FALL&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;；&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;c1&#34;&gt;// 默认是private的
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;Season&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Season&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// ----------------------------------------------------    
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果在enum中定义了抽象方法,每个实例都要重写该方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;whatSeason&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    
    &lt;span class=&#34;c1&#34;&gt;// 调用无参构造器
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;SPRING&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 方法无法调用enum类里的非静态变量，只能调用非静态变量
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;whatSeason&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;chun&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;},&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 调用有参构造器
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;SUMMER&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;夏天&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;whatSeason&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;xia&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;},&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 默认调用无参构造器
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;FALL&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;whatSeason&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;qiu&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;};&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;原理参考&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/javazejian/article/details/71333103&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入理解java类型&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;泛型&#34;&gt;泛型&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;泛型会类型擦除，那它如何保证类型的正确？&lt;/p&gt;
&lt;p&gt;java编译器是通过先检查代码中泛型的类型，然后再进行类型擦除，在进行编译的&lt;/p&gt;
&lt;p&gt;只能在编译期保证类型相同&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;泛型被擦除，统一使用原始类型Object，泛型类型变量最后都会被替换为原始类型，那为什么我们使用的时候不需要强转转换?&lt;/p&gt;
&lt;p&gt;比如ArrayList，它会帮我们进行强转转换，它会做了一个checkcast操作，检查什么类型，之后进行强转&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;类型擦除与多态导致冲突，如何解决&lt;/p&gt;
&lt;p&gt;比如本意是进行重写，实现多态。可是类型擦除后，只能变为了重载。这样，类型擦除就和多态有了冲突，JVM采用桥方法解决此问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;泛型擦除的优点&lt;/p&gt;
&lt;p&gt;类型安全，编译器会帮我们检查、消除强制类型转换，提高代码可读性、为未来版本的 JVM 的优化带来可能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;List&amp;lt;?&amp;gt;、List&lt;!-- raw HTML omitted --&gt;、List、List&amp;lt;? super T&amp;gt;、List&amp;lt;? extends T&amp;gt;的区别&lt;/p&gt;
&lt;p&gt;List&amp;lt;? super T&amp;gt;：T的父类，包括T，表示范围&lt;/p&gt;
&lt;p&gt;List&amp;lt;? extends T&amp;gt;：T的子类，包括T，表示范围&lt;/p&gt;
&lt;p&gt;List&amp;lt;?&amp;gt; 表示任意类型，如果没明确，就是Object或者任意类，与List、List&lt;!-- raw HTML omitted --&gt;一样，表示 点&lt;/p&gt;
&lt;p&gt;List 也可表示范围&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考 &lt;a class=&#34;link&#34; href=&#34;https://cloud.tencent.com/developer/article/1033693&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;10 道 Java 泛型面试题&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;参考&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/xll1025/p/6489088.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;java泛型（二）、泛型的内部原理：类型擦除以及类型擦除带来的问题&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;注解&#34;&gt;注解&lt;/h1&gt;
&lt;h1 id=&#34;序列化和反序列化&#34;&gt;序列化和反序列化&lt;/h1&gt;
&lt;p&gt;序列化：将对象转换为字节序列，用于将保存在JVM内存中的对象持久化，保存到文件或者网络传输&lt;/p&gt;
&lt;p&gt;反序列化：将字节序列还原成对象&lt;/p&gt;
&lt;p&gt;与JSON的比较，两者都可以用于网络传输，JSON更使用web方面、应用方面，易读，需要将JSON解析才能还原成对象，而序列化反序列化是JAVA提供的，由JVM来还原，应用范围会更广一些&lt;/p&gt;
&lt;p&gt;除此之外也有其他协议，如基于XML文本协议(基于SOAP规范)：WebService、Burlap，二进制协议：Hessian，Hessian生成的字节流简凑、跨平台、高性能比JDK的序列化反序列化优秀&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/dolphin0520/p/3780005.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入剖析Java中的装箱和拆箱&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%9F%BA%E7%A1%80.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CyC2018/CS-Notes/java基础.md&lt;/a&gt;
&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/xiaoxi/p/6036701.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入理解Java中的String&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>MyBatis</title>
        <link>http://nixum.cc/p/mybatis/</link>
        <pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/mybatis/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;orm&#34;&gt;ORM&lt;/h1&gt;
&lt;p&gt;普通JDBC使用sql的prepareStatement + sql + 占位符 + 参数的方式执行sql语句&lt;/p&gt;
&lt;p&gt;ORM其实就是在先编写类与数据库表字段的映射，可以是xml配置，也可以是注解配置，之后再使用JDBC执行sql时，通过对类的反射获得其属性的值和对应的字段名，拼接sql+占位符+属性值，执行sql语句&lt;/p&gt;
&lt;h1 id=&#34;mybatis&#34;&gt;MyBatis&lt;/h1&gt;
&lt;p&gt;#{}和${}区别&lt;/p&gt;
&lt;p&gt;#{}：预编译，底层是PrepareStatement ，可防止SQL注入&lt;/p&gt;
&lt;p&gt;${}：参数替换，不能防止SQL注入&lt;/p&gt;
&lt;h2 id=&#34;dao接口与mapper的映射&#34;&gt;dao接口与mapper的映射&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;通过动态代理实现&lt;/li&gt;
&lt;li&gt;实际上XML在定义Mapper的时候就相当于在编写dao类了，dao接口类相当于编写调用入口&lt;/li&gt;
&lt;li&gt;XML中的配置信息会被存放在Configuration类中，SqlSessionFactoryBuilder会读取Configuration类中的信息创建SqlSessionFactory，之后由SqlSessionFactory创建sqlSession&lt;/li&gt;
&lt;li&gt;在启动时先扫描并加载所有定义Mapper的XML，解析XML，根据XML中的namespace找到对应的接口，为这些接口生成对应的代理工厂MapperProxyFactory。&lt;/li&gt;
&lt;li&gt;sqlSession.getMapper时，会通过传入的类/接口名（即被代理类）找到对应的MapperProxyFactory，生成代理类MapperProxy，并注入sqlSession，MapperProxy实现InvocationHandler接口进行代理，通过MapperMethod执行SQL，MapperMethod使用注入的sqlSession和解析XML中配置的SQL语句得到的参数，调用对应的executor执行SQL&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;缓存&#34;&gt;缓存&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;一级缓存的作用域是同一个SqlSession&lt;/strong&gt;，在同一个sqlSession中两次执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。当一个sqlSession结束后该sqlSession中的一级缓存也就不存在了。Mybatis&lt;strong&gt;默认开启一级缓存&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;二级缓存是mapper级别的缓存&lt;/strong&gt;，多个SqlSession去操作同一个Mapper的sql语句，多个SqlSession去操作数据库得到数据会存在二级缓存区域，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。不同的sqlSession两次执行相同namespace下的sql语句且向sql中传递参数也相同即最终执行相同的sql语句，第一次执行完毕会将数据库中查询的数据写到缓存（内存），第二次会从缓存中获取数据将不再从数据库查询，从而提高查询效率。Mybatis默认没有开启二级缓存需要在setting全局参数中配置开启二级缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/qq_40645822/article/details/101844675&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;MyBatis的通俗理解：SqlSession.getMapper()源码分析&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>常见的业务场景解决方案整理</title>
        <link>http://nixum.cc/p/%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%95%B4%E7%90%86/</link>
        <pubDate>Fri, 14 May 2021 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/%E5%B8%B8%E8%A7%81%E7%9A%84%E4%B8%9A%E5%8A%A1%E5%9C%BA%E6%99%AF%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E6%95%B4%E7%90%86/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;系统设计的思路&#34;&gt;系统设计的思路&lt;/h1&gt;
&lt;p&gt;缓存、异步、多线程、分片、高可用、扩容、分布式集群、并发、锁不锁、对持久化、内存的要求、量大的就想办法把量过滤或者拆小，分治处理、对数据库的写操作量很大时，可以考虑时间窗口合并&lt;/p&gt;
&lt;h1 id=&#34;api协议设计&#34;&gt;API协议设计&lt;/h1&gt;
&lt;p&gt;其实分成了API和协议两部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一般API会符合Restful规范，由行为 + 资源组合而成；&lt;/li&gt;
&lt;li&gt;协议一般就包含了请求/响应头和响应/请求体的内容，参数结构化，比如参数类型是Hash，就不要存成String，值是Hash的序列化后的字符串；&lt;/li&gt;
&lt;li&gt;响应结果要统一，尽量不要因为参数的不同而返回不同类型的响应结构，个人比较喜欢的做法是，在网络层面，如果接口没有问题，统一返回HTTP code是200，响应体里分为&lt;code&gt;code、msg、data&lt;/code&gt;来表示业务响应；&lt;/li&gt;
&lt;li&gt;需要考虑认证和安全相关，比如是否需要签名、票据、token等&lt;/li&gt;
&lt;li&gt;多服务之间，保证风格一致；&lt;/li&gt;
&lt;li&gt;考虑幂等；&lt;/li&gt;
&lt;li&gt;加入版本控制，加在URL上，或者请求头有个字段标识；&lt;/li&gt;
&lt;li&gt;接口职责单一，一个接口只干一件事；&lt;/li&gt;
&lt;li&gt;考虑兼容性；&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;解决多重if-else嵌套问题&#34;&gt;解决多重if-else嵌套问题&lt;/h1&gt;
&lt;p&gt;比如有下面这种代码，优化if-else问题&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Handle&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
       &lt;span class=&#34;kd&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;error&lt;/span&gt;
       &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Operation1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
             &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Operation2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
                    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Operation3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
                           &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Operation4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(){&lt;/span&gt;
                                 &lt;span class=&#34;c1&#34;&gt;// do
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;                           &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                                 &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;OPERATION4FAILED&lt;/span&gt;
                           &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
                    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                           &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;OPERATION3FAILED&lt;/span&gt;
                    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
             &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;OPERATION2FAILED&lt;/span&gt;
             &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
       &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
             &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;OPERATION1FAILED&lt;/span&gt;
       &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
       &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;err&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;或者&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;func Handle() error {
       var err error
       if Operation1(){
             // do something
       } else if Operation2() {
       		// do something
       } else if Operation3() {
       		// do something
       } else if Operation4() {
       		// do something
       } else {
             err = OPERATION1FAILED
       }
       return err
}
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;解决方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分析条件，对于互斥的条件，可以使用表驱动，key是入参，value是方法&lt;/li&gt;
&lt;li&gt;短路条件，尽量平铺 if-else 判断，比如 把 if-else 拆分，提前返回&lt;/li&gt;
&lt;li&gt;使用switch-case&lt;/li&gt;
&lt;li&gt;比如对于多重嵌套的if-else，嵌套条件必须同时成立，可以使用责任链设计模式，将多个条件封装成方法，装进数组或链表中，遍历判断&lt;/li&gt;
&lt;li&gt;策略模式 + 工厂模式，抽象一个公共接口，所有条件判断封装成对象，实现这个接口；定义工厂方法，根据参数获取对应的策略对象，执行对应的判断函数，返回判断后的结果&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;防止表单重复提交&#34;&gt;防止表单重复提交&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;场景&lt;/strong&gt;：用户点击下单页面，跳转至下单页面，提交订单，此时有可能网络原因或者用户点击多次，导致订单重复提交。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解决&lt;/strong&gt;：用户跳转至下单页前，会先获取订单号(也作为订单表主键)，将订单号绑定在下单页，利用数据库主键唯一的特性，让创建订单的操作变成幂等性。&lt;/p&gt;
&lt;p&gt;也可以前端在同一个页面发送订单创建请求时，为页面生成一个requestId，重复下单后端即可通过这个id判重；&lt;/p&gt;
&lt;p&gt;订单创建接口，也可以对参数进行排序后MD5的方式判重；&lt;/p&gt;
&lt;p&gt;订单场景还好，如果是IM场景，因为每个用户发送信息都比较频繁，如果都每条信息都创建一个请求id，可能每太必要，后端可以对每条信息+user_id进行MD5，判重，但需要处理用户真的重复发送的情况；&lt;/p&gt;
&lt;p&gt;还有一种处理方式，为每条消息生成一个时间戳，服务端处理时判断上下两条消息的时间差&lt;/p&gt;
&lt;h1 id=&#34;解决aba问题&#34;&gt;解决ABA问题&lt;/h1&gt;
&lt;p&gt;**场景：**类似MySQL的丢失更新，比如有操作1，操作2先后对记录A进行更新，操作1的响应丢失导致重试，此时操作2已经更新成功，操作1重试时会覆盖操作2的更新。&lt;/p&gt;
&lt;p&gt;**解决：**通过版本号解决，订单表增加一列作版本号，版本号可以使用递增序列、时间戳等，通过比较版本号来确定操作的先后顺序，更新成功时也需要更新版本号。&lt;/p&gt;
&lt;h1 id=&#34;流量大数据量大的商品详情页数据存储&#34;&gt;流量大、数据量大的商品详情页数据存储&lt;/h1&gt;
&lt;p&gt;**场景：**一般商品详情页都是访问量最大的页面，比如用户做商品对比、查看商品详情都需要，另外就是商品详情页一般涉及很多数据，如下，且后端存储的sku量也是巨大的，直接分多张表去存虽然可以实现，但是性能就一般了。&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;商品
├── 基本信息
│    ├── 标题、副标题
│    ├── 价格：原价、促销价
│    └── 颜色、规格等
├── 商品参数
├── 商品介绍
├── 图片视频
来自其他系统的
├── 促销信息
├── 推荐商品
├── 评论、评价
├── 配送信息
└── 店铺信息
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;**解决：**分析不同的数据特性，比如有些数据是热点的、相对固定的、不常被修改的、需求变化不大的等各种维度去划分，进行不同存储。动态数据、实时数据还是照旧，该怎么处理怎么处理，其他的可以：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;套一层缓存在数据库外面，查询数据先缓存后数据库&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;针对每个不同的spu有不同的商品属性，则可以使用NoSQL来解决&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;针对图片、视频等数据，使用对象存储、CDN解决，比如AWS S3，直接通过其提供的API进行访问，将这部分的压力转移到云服务厂商&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;将相对固定的数据静态化，比如商品介绍，其包含了大量的文字、图片、视频等，可直接将这一部分保存成HTML文件中，访问时直接返回HTML文件，保存成HTML还可以配合CDN进行加速&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;查询方面的优化&#34;&gt;查询方面的优化&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;可以起一个SQL检查脚本，检查执行时间过长的SQL，如果超过指定时间的，进行记录和kill，再进行优化，把慢SQL解决掉，避免多个执行时间过长的SQL拖垮整个数据库。&lt;/li&gt;
&lt;li&gt;主从分离，读写分离，服务降级&lt;/li&gt;
&lt;li&gt;分析SQL执行和访问量间的关系，数据库CPU利用率变化&lt;/li&gt;
&lt;li&gt;MySQL单次查询扫描的数据量控制在千万级别内，单次扫描的数据量在百万级别是可以接受，理论上查询都应该使用索引，避免全表扫描&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;对象存储原理&#34;&gt;对象存储原理&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;本质是一个规模很大的分布式Key-value集群，外加一个保存集群节点信息、文件信息和映射关系(统称为元数据)的节点集群，在最外层再加上一个Gateway来对外提供服务即可。&lt;/li&gt;
&lt;li&gt;针对图片、视频等大文件，在存储时会将其拆分成多个大小相等的块Block，一般是几十KB到几MB，便于管理，也可以分散到不同节点，提升并行读写性能。&lt;/li&gt;
&lt;li&gt;由于分成的块太小，数量多，一般也不是直接进行管理的，而是将一些块进行聚合，放到容器里，类似分片的概念，主从复制时，也是直接复制这些块即可，不用再复制多日志&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;跨系统数据实时同步&#34;&gt;跨系统数据实时同步&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;采用Bin Log + MQ的方式，将上游数据实时同步到下游其他系统的数据库中，为了确保数据一致性，必须顺序读取Bin Log，因此MQ的主题也必须设置为只有一个分区，才能保证Bin Log有序。&lt;/li&gt;
&lt;li&gt;当下游系统想要扩展消费能力时，不可盲目增加同步线程数和MQ主题分区，由于Bin Log的顺序性，要确保多线程消费时，不会对数据产生影响，所以可以将具有因果一致性的Bin Log发布给同一主题分区，才可以多线程同步消费。具体可参考MySQL 5.6版本后多线程处理Bin Log的做法。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;不停机情况下更换数据库&#34;&gt;不停机情况下更换数据库&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;利用Bin Log或者复制状态机理论，增加一个新库和同步服务。先将旧库上的数据快照同步到新库，对于旧库的新数据，使用同步服务进行同步复制&lt;/li&gt;
&lt;li&gt;改造旧服务，增加双写新旧两个库的功能，添加功能开关，使其能够只写旧库、只写新库、同步双写的功能&lt;/li&gt;
&lt;li&gt;开关打至只写旧服务，利用同步服务同步数据，等改造后的旧服务能稳定运行，验证新旧两个库的数据是否一致；一致之后将改造后的旧服务的开关打至同步双写，关闭同步服务，此时仍然以数据写至旧库为主，写新库失败则进行人工干预，此外，双写时可能会存在数据不一致，此时需要针对这一小段时期上线数据对比与补偿服务，验证和补充新旧数据不一致问题；待最终稳定后，才将开关打至只写新服务，实现数据库替换的平滑过渡。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;海量数据处理&#34;&gt;海量数据处理&lt;/h1&gt;
&lt;p&gt;针对的是埋点数据、日志数据、访问数据、点击数据、监控数据等，一般采用先存储后计算的方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Kafka存储，上游系统将海量数据采集后发给KafKa，利用Kafka无限消息堆积和超高吞吐，存储数据，再由下游系统进行订阅消费即可。这种方案适合短时间的海量数据处理。关键词：分布式流数据存储。&lt;/li&gt;
&lt;li&gt;HDFS存储 + Hive查询 或者 ES查询&lt;/li&gt;
&lt;li&gt;针对监控数据，可以使用时序数据库，例如Prometheus&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;大文件在有限内存内排序&#34;&gt;大文件在有限内存内排序&lt;/h1&gt;
&lt;p&gt;多路归并排序：将所有原文件按照内存最大大小读取并进行排序，输出到新的、多个的文件中，然后对这些新的已排序的小文件进行归并排序。&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/GarrettWale/p/14478347.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;https://www.cnblogs.com/GarrettWale/p/14478347.html&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;库存&#34;&gt;库存&lt;/h1&gt;
&lt;p&gt;这里仅讨论分布式场景下的&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;库存字段设置为无符号整型，这样在扣到负数时会报错，不过得看具体的数据库实现&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;悲观锁，利用数据库的锁机制：比如MySQL的 &lt;code&gt;for update&lt;/code&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;k&#34;&gt;begin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;-- 开启事务
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;select&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inventory&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;from&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;product&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;where&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sku_id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;-- 获取并设置排他锁
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;product&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inventory&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inventory&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;扣减数量&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;where&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sku_id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;commit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;-- 提交事务
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;但这种方案会把压力转移到数据库，吞吐量并不高。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;乐观锁，版本号 + cas + 自旋，也可以利用数据库的能力实现&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;k&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;product&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inventory&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inventory&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;扣减数量&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;  &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;where&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sku_id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;and&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inventory&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;扣减数量&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;或者&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;k&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;product&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inventory&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;case&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;when&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inventory&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;扣减数量&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;then&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inventory&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;扣减数量&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inventory&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;end&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果要解决ABA问题，还需要先查询版本号，获取到版本号后，在应用层自旋，执行以下语句&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-sql&#34; data-lang=&#34;sql&#34;&gt;&lt;span class=&#34;k&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;product&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;set&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inventory&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;inventory&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;err&#34;&gt;扣减数量&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;where&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sku_id&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;and&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;k&#34;&gt;version&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;w&#34;&gt; &lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;7&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&lt;span class=&#34;w&#34;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;如果更新数据库层面有重试机制，那在set的时候就不能使用&lt;code&gt;inventory = inventory - 扣减数量&lt;/code&gt;这种方案了，因为这种操作是不幂等的，重试会导致重复扣减，所以得先计算出扣减完之后的inventory值，在set才能保证更新时幂等。&lt;/p&gt;
&lt;p&gt;没办法在开启事务后，通过&lt;code&gt;select语句 + in share mode + update语句&lt;/code&gt;来实现，虽然 &lt;code&gt;in share mode&lt;/code&gt;不会阻塞其他请求的读请求，但是会导致第二个在更新的时候有问题，比如阻塞或者更新错误，除非加上库存余量判断，但是如果加上更新余量的判断，还不如一开始就直接使用这个去扣减库存。&lt;/p&gt;
&lt;p&gt;在这个场景下，使用这两种锁的差别，像排他锁，比较严格，锁的条数会比较多，可能会影响其他请求的读写，而共享锁，虽然锁完不影响读，适合读多写少的场景，但是也可能会导致业务方面的问题。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;（建议使用，其他方案都不建议，数据库方案是性能比较差，分布式锁方案是可靠性比较差）库存扣减主要是包含两部分，超卖校验、扣减数据的持久化，因此，可以分离这两部分，只要超卖校验能通过，直接改库即可，可以利用Redis单线程操作并发安全的能力，把库存存在Redis中实现校验。&lt;/p&gt;
&lt;p&gt;比如每次扣减库存时，对存在Redis中的数据进行decrby扣减（或者先查询后扣减，需要使用Lua脚本保证原子），如果返回的数量大于0，说明库存够，之后可以同步或异步把值更新到数据库即可，但要注意的是，本方案不支持回滚；&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-lua&#34; data-lang=&#34;lua&#34;&gt;&lt;span class=&#34;n&#34;&gt;lua脚本的方案&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，预先将脚本存到&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redis&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，调用时只需传入返回的&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;sha1的值即可&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;，无需每次都传一遍&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lua脚本&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;-- 查询活动库存，其中KEYS[1]为传入的参数1，即库存key&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;local&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c_s&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redis.call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;get&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KEYS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;-- 判断活动库存是否充足，其中KEYS[2]为传入的参数2，即当前抢购数量&lt;/span&gt;
&lt;span class=&#34;kr&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;not&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;c_s&lt;/span&gt; &lt;span class=&#34;ow&#34;&gt;or&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tonumber&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;c_s&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tonumber&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KEYS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;then&lt;/span&gt;
   &lt;span class=&#34;kr&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;span class=&#34;kr&#34;&gt;end&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;-- 如果活动库存充足，则进行扣减操作。其中KEYS[2]为传入的参数2，即当前抢购数量&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;redis.call&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;decrby&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;KEYS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;KEYS&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;])&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分布式锁实现，应用层对sku_id上分布式锁，再进行库存判断&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;库存读通过Redis缓存 + MySQL bin log + 定时任务更新 来解决，库存写通过在 先查出库存值 + 一秒内窗口合并 + 优先级队列(用于处理大数值库存扣减)  + version乐观锁扣减库存 + 重试，合并失败的时候就会按时间窗口内按顺序扣减 实现；时间窗口设计，主要解决时间窗口内数据库频繁操作对缓存的影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;实际库存和冻结库存，不过这个属于业务上的处理，从实际库存转移到冻结库存仍然有可能出现超卖的情况，这种一般是为了解决在下订单直接扣库存，可能会导致被恶意下单，或者在支付时扣库存扣失败了但是订单仍然存在，属于用户体验上的问题了，所以才衍生出在下订单时将实际库存值扣减，加到冻结库存，支付时才真正的减库存，否则在过期时再把冻结库存补回实际库存，本质上是TCC。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;秒杀&#34;&gt;秒杀&lt;/h1&gt;
&lt;p&gt;秒杀主要是要解决两个问题：并发读 和 并发写，还有就是针对意外有一些兜底的方案，比如高可用，另外就是针对这种高并发的场景，最好的做法就是削减请求数，在业务流程的前端尽可能的拦截流量、削峰来达到降低后端的压力。&lt;/p&gt;
&lt;h2 id=&#34;架构原则&#34;&gt;架构原则&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;响应的数据要尽量少：比如返回的HTML页面、接口数据，因为涉及到编码、序列化、反序列化、数据库的操作等，会比较消耗资源；&lt;/li&gt;
&lt;li&gt;请求数要尽量少：请求数一多就会产生很多连接，一个请求可以获取完所有数据，就不要分多次获取，像一些CSS文件和JS文件可以合并获取；&lt;/li&gt;
&lt;li&gt;请求经过的服务或者依赖的服务要尽量少：请求每经过一个服务，都会增加不可靠性，也会产生网络连接，消耗资源；依赖服务支持被降级，以此减少对主流程的影响；&lt;/li&gt;
&lt;li&gt;避免单点，支持动态扩容：服务最好是无状态设计，方便迁移到不同配置的机器，也方便动态扩容数量；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;针对秒杀场景：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将秒杀服务独立，避免对其他服务的影响&lt;/li&gt;
&lt;li&gt;对热点数据（如库存、商品）进行缓存，提高读性能&lt;/li&gt;
&lt;li&gt;秒杀答题，防止秒杀器抢单；限流保护，对后端进行保护&lt;/li&gt;
&lt;li&gt;对秒杀页面进行动静分离，用户刷新仅刷新部分模块&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;动静分离方案&#34;&gt;动静分离方案&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;静态数据可以缓存到CDN、用户浏览器、服务端缓存，甚至可以以URL为key，缓存整个HTTP响应；&lt;/p&gt;
&lt;p&gt;缓存静态数据时要注意几个点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分离跟浏览器相关的数据，比如是否已登录、登录的身份等，这些数据可以通过请求获取&lt;/li&gt;
&lt;li&gt;分离时间，服务端输出的时间也通过动态请求获取&lt;/li&gt;
&lt;li&gt;异步化地域因素，页面上跟地域相关的数据也通过动态请求获取&lt;/li&gt;
&lt;li&gt;去掉cookie，缓存的静态数据不能包含有cookie&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态数据处理有两种方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ESI方案：服务端渲染，由服务端将静态数据与动态数据结合完成之后返回给客户端&lt;/li&gt;
&lt;li&gt;CSI方案：前端渲染，前端ajax请求获取json数据，再进行整合呈现&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缓存的存储：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;本机内存：好处是没有网络、序列化等带来的损耗，坏处是缓存管理不便，会加大服务的内存使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;统一的Cache层：好处是管理方便，减少多应用接入Cache的成本，共享内存也能最大化利用到内存，坏处是会带来网络损耗，Cache机器的宕机会导致缓存不可用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;CDN：使用CDN要注意几个问题：比如缓存失效时间问题，数据分散到不同地区的CDN带来的命中率问题，还有就是当数据有更新时，如何快速分发到不同地区的CDN；&lt;/p&gt;
&lt;p&gt;一般来说，只有那些靠近访问量比较集中的地区，离主站比较远，CDN节点到主站的网络比较稳定的CDN节点才适合放缓存数据，像商品详情的数据，就适合放到CDN的二级Cache，让用户请求先回源CDN的二级Cache，没命中再回源主站获取数据比较合适&lt;/p&gt;
&lt;p&gt;使用CDN有几个好处，可以把整个页面缓存在用户浏览器中，强制刷新页面也会请求CDN，所以静态数据比较适合放到CDN上面&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;热点数据-与-缓存&#34;&gt;热点数据 与 缓存&lt;/h2&gt;
&lt;p&gt;热点分为 热点操作 和 热点数据，热点数据又分为静态热点数据和动态热点数据&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;静态热点数据&lt;/p&gt;
&lt;p&gt;指能够被提前预测的数据，比如提前得知要秒杀的商品，或者分析用户行为、订单记录、购物车记录、TopN被搜索的商品等，判断哪些有可能是热点商品，给这些商品打上标签；&lt;/p&gt;
&lt;p&gt;对于静态热点数据，可以直接缓存&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;动态热点数据&lt;/p&gt;
&lt;p&gt;指不能被提前预测，在系统运行过程中临时产生的数据，比如某商品因为某条短视频火了，导致它在短时间内被大量抢购，这种商品的发现一般是异步分析，通过分析商品被访问的路径的次数，提前识别哪些商品的访问量高，来给这些商品打上标签；&lt;/p&gt;
&lt;p&gt;对于动态热点数据，由于其临时性，可以采用LRU，或者对动态热点数据缓存分片解决；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于这些热点数据，可以把它们与普通的数据进行隔离，比如系统隔离，将参加秒杀活动的请求导向不同的域名，指向不同的集群，处理这些热点数据的服务独立部署（但实际上不会把整套系统都部署，这样成本太大，独立部署这些服务后，对于公共服务就需要有能区分请求分发的逻辑了，比如根据商品id，知道它是秒杀商品，就能把它转发给专门处理秒杀的服务）；数据隔离，为这些热点数据单独设立Cache层和数据库等，避免影响普通业务流程。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;流量削峰&#34;&gt;流量削峰&lt;/h2&gt;
&lt;p&gt;流量削峰主要是为了让服务端处理变得更加平稳，节省服务器的资源，通过延缓用户请求的发出，减少和过滤一些无效的请求，避免后端服务一下子处理很多请求。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;消息队列，FIFO处理请求；请求序列化成文件，再按顺序读取；这里排队主要是针对服务间请求的排队，而不是用户请求直接经过消息队列。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;用户操作延缓：比如购买时增加答题机制，验证码等，通过将发起请求的操作拉长，避免短时间内大量请求；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;分层过滤&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;将动态请求的读数据缓存在Web端，过滤掉无效的数据；&lt;/li&gt;
&lt;li&gt;对请求进行校验，如判断用户是否具有秒杀资格、商品状态是否正常、秒杀活动是否结束、请求是否非法，判断对用户是否限购等；&lt;/li&gt;
&lt;li&gt;对读数据不做强一致校验，减少因校验产生的瓶颈问题；&lt;/li&gt;
&lt;li&gt;对写数据进行基于时间的合理分片，过滤掉过期的失效请求；&lt;/li&gt;
&lt;li&gt;对写数据进行限流保护，将超出系统承载能力的请求过滤掉；&lt;/li&gt;
&lt;li&gt;对写数据进行强一致校验，比如库存，只保留有效数据；&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;秒杀中的减库存&#34;&gt;秒杀中的减库存&lt;/h2&gt;
&lt;p&gt;减库存一般有三种模式：下单成功减库存；支付成功时减库存；下单预扣库存，支付真正减库存；&lt;/p&gt;
&lt;p&gt;下单成功减库存方式逻辑比较简单，性能也比较占优势，如果是追求极致性能的秒杀活动可以选择这种模式。&lt;/p&gt;
&lt;p&gt;秒杀活动中，库存是一个热点数据，交易的各个环节都涉及到对库存的查询，针对读请求，可以不需要那么精确，把库存数据放到缓存里可以大大提升查询性能，对库存的处理主要是难在写操作。&lt;/p&gt;
&lt;p&gt;如果没有复杂的sku库存和总库存的联动关系，扣库存逻辑完全可以在缓存里执行，如果要用到事务，还是得在数据库中执行。&lt;/p&gt;
&lt;p&gt;为了避免对数据库中其他正常业务逻辑的影响，一般会把秒杀商品独立成库，针对商品id进行分表分库，尽量减少锁带来的影响，关键服务独立部署，对于无需独立部署的服务，可以根据商品id进行hash分组转发到独立部署的服务，避免影响其他业务。&lt;/p&gt;
&lt;p&gt;然后就是要解决并发锁的问题，一种是在应用层，按照商品维度设置队列顺序执行，减少同一台机器对数据库同一行记录进行操作的并发度，同时也能控制单个商品占用数据库的连接数，防止热点商品占用太多数据库连接；另一种是在数据库层面排队，对单行记录做并发排队。&lt;/p&gt;
&lt;p&gt;剩下的就跟上面库存的方案差不多了&lt;/p&gt;
&lt;h2 id=&#34;兜底方案&#34;&gt;兜底方案&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;服务降级：比如当秒杀的TPS达到设定的量级之后，成交记录的获取展示从20条降级到只展示5条，不相干的业务服务临时不展示，只保证核心业务线的正常流转&lt;/li&gt;
&lt;li&gt;限流、熔断&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;短链&#34;&gt;短链&lt;/h1&gt;
&lt;p&gt;本质上就是给长网址发号，映射成短网址，访问时通过301跳转；&lt;/p&gt;
&lt;p&gt;短码一般都由&lt;code&gt;[a-zA-Z0-9]&lt;/code&gt;这62个字符组成，一般不超过8位，6位的短码就可以有&lt;code&gt;(26+26+10)^6 = 56800235584，568亿&lt;/code&gt;个了。&lt;/p&gt;
&lt;p&gt;短码生成方案：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;利用数据库生成自增id，但因为有序，容易被遍历出来，不过可以通过对生成的自增id做签名或者62位进制生成最后的短码解决；&lt;/p&gt;
&lt;p&gt;或者使用多个Redis自增，只要将自增的步长设置成不一样就不会产生冲突了，只是要维护数据的持久化和奔溃恢复；&lt;/p&gt;
&lt;p&gt;或者发号器预生成一批序号，预生成主要是解决冲突问题，来一个长网址就分配一个；&lt;/p&gt;
&lt;p&gt;或者直接UUID、雪花算法生成短码；&lt;/p&gt;
&lt;p&gt;或者利用数据库唯一索引，自己通过随机数生成短码实现；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;摘要算法生成，比如对长网址直接md5，哈希等，不过要解决冲突，比如利用数据库唯一索引，冲突的时候可以在原始字符串上加上预定义的字符串，重新哈希存入判断，直到插入即可；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;常用的方案是使用 自增id + 进制转换的方式进行，可以直接数据库自增，也可以用发号器生成id、分布式id等；&lt;/p&gt;
&lt;p&gt;生成短码之后，将 原始长网址、短码、短网址、有效时间 存入数据库，之后根据映射进行跳转即可；&lt;/p&gt;
&lt;p&gt;提升查询性能就上缓存，全量保存不太现实，可以只保存最近一段时间的，然后LRU淘汰即可；&lt;/p&gt;
&lt;p&gt;长链转短链可以一对一也可以一对多，一对一的话可以判断库里是否存在时可以使用布隆过滤器；&lt;/p&gt;
&lt;p&gt;关于跳转：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;301是永久重定向，302是临时重定向。短地址一经生成就不会变化，所以用301是符合http语义的。同时浏览器会对301请求进行缓存，可以减轻服务器压力。&lt;/p&gt;
&lt;p&gt;使用301有利于SEO， Google，百度等搜索引擎，搜索的时候会直接展示真实地址，但此时就无法统计到短地址被点击的次数了，也无法收集用户的Cookie，User Agent 等信息，这些信息可以用来做很多有意思的大数据分析，也是短网址服务商的主要盈利来源，如果需要利用这些信息，就得使用302。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;海量数据计数&#34;&gt;海量数据计数&lt;/h1&gt;
&lt;p&gt;比如点赞数、评论数、转发数、浏览量、粉丝数、关注数等&lt;/p&gt;
&lt;p&gt;以微博为例，存储时可以根据微博Id进行分库分表，比如哈希划分或者时间戳划分，如果存储结构为 微博Id、点赞数、评论数、转发数、浏览量等，虽然一次查询可以查出，但是在写入的时候，由于各个字段的计算是独立计算的，写入时就会有锁竞争，导致写入性能不佳；&lt;/p&gt;
&lt;p&gt;写入时可以使用MQ削峰，慢慢消费计数，更新数据；&lt;/p&gt;
&lt;p&gt;仅依靠数据库+缓存的方式能承载的量比较有限，也可能产生数据不一致，倒不如直接使用多节点Redis来实现计数 + 查询，主从保证高可用；&lt;/p&gt;
&lt;p&gt;计数仍然会存在存储问题，对于热点数据，直接Redis内存即可，对于非热点数据或时间救援的数据，可直接使用磁盘；定制Redis数据结构，设计存储空间更小的结构；&lt;/p&gt;
&lt;p&gt;对于未读计数：比如一系统通知列表，记录全量用户未读数，如果全量用户，每个用户都去计算未读数是多少，那效率太差了，正确的做法是：因为这个列表对所有用户共享，所有用户都能看到这一份系统通知数据，不同的人最近看到的消息不同，所以每个人就会有不同的计数，因此可以通过记录每个人看过的最后一条消息的ID，推断出该ID之后还有多少消息未读；&lt;/p&gt;
&lt;p&gt;用户红点计数方案：判断用户是否点过某一个页面或功能，可以为每一个用户存储一个时间戳，代表最近点过这个红点的时间，用户点了这个红点，就更新这个时间戳，然后我们再记录一个全局时间戳，通过这个全局时间戳与用户点击的时间戳比较，判断是否要展示红点；&lt;/p&gt;
&lt;p&gt;基于关系的信息流未读方案：通用计数器记录每一个用户发布的博文数，在Redis中记录一个人所有关注人的博文数快照，当用户点击未读消息时重置未读数为0时，将他关注所有人的博文数更新到快照中，此时，他关注的所有人的博文数减去快照中的博文数就是他信息流的未读数了，不过此方案会存在一点误差。&lt;/p&gt;
&lt;h2 id=&#34;计数器redis实现&#34;&gt;计数器Redis实现&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;记录和更新&lt;/p&gt;
&lt;p&gt;使用hash记录计数值，key为&lt;code&gt;计数器名称:时间精度&lt;/code&gt;，field是一个时间戳，表示当前时间片开始时间（&lt;code&gt;计算方式 当前时间 / 时间精度 * 时间精度&lt;/code&gt;），hash value是计数值；命令：&lt;code&gt;hincrby counter:5 1682045703000 1&lt;/code&gt;，表示统计5秒内的计数&lt;/p&gt;
&lt;p&gt;因为要保存所有的时间精度，又需要保证不会重复，所以使用zset用于清除旧数据，key为随便起，是一个定值，value为时间精度+计数器名称，socre为0，命令：&lt;code&gt;zadd countSort 0 counter:5&lt;/code&gt;，socre设置为0是为了让zset只根据value按字母序排列，方便后续获取&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;查询：&lt;code&gt;hgetall 计数器名称:时间精度&lt;/code&gt;，然后排序遍历，即可获取各个时间片的计数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;清除旧值&lt;/p&gt;
&lt;p&gt;设定一个异步任务，对于每秒更新一次或每5秒更新一次的计数器，异步任务可以按每分钟的频率清除旧数据，从而保证只存储一定的数量，避免bigkey问题&lt;/p&gt;
&lt;p&gt;比如分页遍历 zset，根据value，查 hash，然后移除hash里失效时间范围内的元素；由于存在覆盖问题，如果要保证计数正确，需要使用lua脚本，保证整个过程原子，如果不care，直接程序处理即可。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;存储统计数据redis实现&#34;&gt;存储统计数据Redis实现&lt;/h2&gt;
&lt;p&gt;场景：统计前一小时和当前一小时内的数据的最值&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;记录和更新&lt;/p&gt;
&lt;p&gt;使用 两个string 记录当前小时数、值和上一个小时值，比如 上一个时间是 12:23 ，存储命令就是 &lt;code&gt;set lastHour 12&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;使用两个zset保存临时的统计数据，使用zset并非为了按socre进行排序，而是要对这两个zset做并集和聚合运算，使用redis的内置函数，使用命令&lt;code&gt;zunionstore + 聚合函数，比如max()、min()&lt;/code&gt;；&lt;/p&gt;
&lt;p&gt;将两个临时保存统计数据的zset做一定的运算后得到最终结果zset，然后删除临时的两个zset；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;feed流&#34;&gt;feed流&lt;/h1&gt;
&lt;h2 id=&#34;推模式---写扩散&#34;&gt;推模式 - 写扩散&lt;/h2&gt;
&lt;p&gt;用户发送一条微博，主动将这条微博推送给他的粉丝，即，为该用户和其粉丝insert一条微博数据，粉丝查看微博时，直接一条sql即可查询得到；因为写入压力和存储压力问题，比较适合粉丝数有限的场景；&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;存在的问题&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果用户的粉丝很多，尽管可以异步或消息队列为其粉丝写入微博数据，仍然会存在一定的延迟，可能出现该用户发了微博之后，其部分粉丝要延迟很久才能看到数据；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于全平台可见的微博，如果全量为所有用户都insert一条微博数据，数据量太大，如果每个用户下还有分组，写入量就更大了，写入性能会收到很大的影响，存储成本很高；&lt;/p&gt;
&lt;p&gt;尽管只需要维护id的关系映射，但还是架不住量多，微博的展示还是根据id去数据库或缓存里查询；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果发生删除微博、用户取关操作，对应的微博需要删除，也会产生大量写操作；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决方案&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;写入时通过消息队列消费，并行写入，加快写入速度；&lt;/li&gt;
&lt;li&gt;存储时使用压缩率高的数据库/存储引擎，比如MySQL的TokuDB(其使用分形树索引，可以将数据的随机写入转成顺序写入，写入速度快，压缩率高，但是删除和查询的性能差写)；&lt;/li&gt;
&lt;li&gt;写入时分库分表减少压力；定期清理时间太久的数据，转移到其他表中，减少存储压力；&lt;/li&gt;
&lt;li&gt;如果发生删除微博、用户取关操作，对应的微博需要删除，压力也会比较大，只能先判断用户是否取关或微博是否删除来判断是否展示即可，尽量减少多余的写操作；&lt;/li&gt;
&lt;li&gt;读取时通过缓存读取；&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;拉模式---读扩散&#34;&gt;拉模式 - 读扩散&lt;/h2&gt;
&lt;p&gt;用户主动拉取其关注列表，查询所有人的微博，再将这些微博按发布时间倒叙排列聚合，形成信息流。&lt;/p&gt;
&lt;p&gt;相比推模式，拉模式解决了写入延迟以及存储问题&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;存在的问题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对查询出的微博做聚合时成本比较高；&lt;/li&gt;
&lt;li&gt;查询数据量大，导致缓存查询带宽压力大；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;解决方案：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分析用户行为，比如如果大部分用户只查看最近5天的数据，就可以只缓存最近5天的微博id，用于查询聚合；&lt;/li&gt;
&lt;li&gt;分散缓存节点，设置多级缓存，查不到再查主缓存&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;推拉结合模式&#34;&gt;推拉结合模式&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于大V用户，发布微博时，使用推模式，但是不再推送到全量用户，而是给大V用户维护一个定长的活跃粉丝列表 以及 在线用户，只推送 或 优先推送 给这类用户，活跃粉丝列表和用户在线状态会进行定时更新；从而达到可控的推送延迟，不过同时因为要维护活跃粉丝列表和用户状态，又需要更多的存储成本；&lt;/p&gt;
&lt;p&gt;不活跃用户，非在线用户只有上线后主动拉取消息；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;普通用户使用拉模式即可；&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;弹幕&#34;&gt;弹幕&lt;/h1&gt;
&lt;p&gt;用户进入视频 / 直播间 页面，拉取正在观看视频的用户列表，接收持续发布的弹幕消息，自己发消息。&lt;/p&gt;
&lt;p&gt;弹幕要分清是需要实时还是可接受延迟，是直播的时候用，还是视频、录播的时候用，这涉及到弹幕信息要不要保存，一般来说，客户端接收弹幕信息有以下两种方案：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;客户端轮询&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;用户在前端写入消息，消息发往服务端，为消息赋完序号后，直接丢给kafka，下游服务消费kafa的消息，将消息存入Redis（以Zadd的方式写入，score消息的小队时间）；&lt;/p&gt;
&lt;p&gt;前端每2s向后端发起轮询，后端查询Redis返回；&lt;/p&gt;
&lt;p&gt;但是客户端轮询的方式，始终对服务端的压力较大，一般采用websocket长连接的方式进行推送弹幕信息。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Websocket&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;此方案最佳，CDN + 长连接(websocket) 广播给用户，原理跟聊天室差不多；&lt;/p&gt;
&lt;p&gt;与上面的方案差不多，只是把前端轮询部分替换成了由后端与前端建立长连接后进行推送。&lt;/p&gt;
&lt;p&gt;常见直播弹幕方案，由于需要实时：用户把弹幕信息发送到弹幕处理服务，对敏感词等进行处理，接收处理后将弹幕信息发送给Kafka等消息队列，使用发布订阅的方式，消费弹幕消息的消费者服务有多种，比如是弹幕存储服务，持久化弹幕数据；比如有长连接服务，消费弹幕消息，根据弹幕消息数据判断弹幕要推送到哪个直播间，量大的时候，长连接服务需要设置分片，控制每台长连接服务与客户端的连接；如果弹幕消息处理不过来，就随机丢，控制客户端接收弹幕接收数量，或者长连接服务限流控制推送给客户端的弹幕数量。&lt;/p&gt;
&lt;h2 id=&#34;消息的已读未读&#34;&gt;消息的已读未读&lt;/h2&gt;
&lt;p&gt;先已读未读发送在两个人对话或者多人群里面，当然两个人也可以理解成一个群，一个群对应一个bitmap。在这个群里面，所有人都要对这条消息存在已读未读的情况，即一个群对应多条消息，每条消息对应多个人，每条消息对每个人存在已读未读状态。&lt;/p&gt;
&lt;p&gt;数据量小的，直接DB操作即可；&lt;/p&gt;
&lt;p&gt;消息量大的，使用Redis的bitmap实现，前面的set可以用来判断哪个用户进群没进群：&lt;/p&gt;
&lt;p&gt;第一种：一个群对应一个set，key是群id，value是userId，每个用户对应一个bitmap，key是群id+userId，offset是消息的id，value表示已读未读，或者只记录已读；&lt;/p&gt;
&lt;p&gt;第二种：一个群对应一个set，key是群id，value是userId，每条消息对应一个bitmap，key是群id+消息id，offset是userId，value表示已读未读，或者只记录已读；这种内存消耗会少一点&lt;/p&gt;
&lt;p&gt;当id作为bitmap的offset时，需要保证平均散落，比如进行哈希后再放到offset里，防止只用到了一部分的offset。&lt;/p&gt;
&lt;h1 id=&#34;ip与数字的转换&#34;&gt;IP与数字的转换&lt;/h1&gt;
&lt;p&gt;ipv4本质上是32位的二进制字符串，一个int整数刚好是4个字节32位，所以一个int整数可以表示一个ipv4地址。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ip地址 = 第一段左移24位 + 第二段左移16位 + 第三段左移 8位 + 第四段 = 第一段 * 256 * 256 * 256 + 第二段 * 256 * 256 + 第三段 * 256 + 第四段&lt;/code&gt;，范围是 0 ~ 4,294,967,295（2^32 - 1）&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// ip字符串转整型：
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;
&lt;span class=&#34;nx&#34;&gt;ips&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strings&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Split&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ip&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;part&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;range&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ips&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;partInt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strconv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Atoi&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;part&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;partInt&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 整型转ip字符串：
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strconv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Itoa&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;24&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0xff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strconv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Itoa&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0xff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strconv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Itoa&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0xff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;.&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;strconv&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Itoa&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;mh&#34;&gt;0xff&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;根据IP查询国家（比如给定一批数据是 {开始的ip, 结束ip, 国家}），使用Redis做缓存，实现方案：&lt;/p&gt;
&lt;p&gt;使用Redis的zset结构，key是定值，比如叫ip2Country，score是IP转数字，value是国家二字码+一定的标识（需要加标识是因为zset的value是唯一），比如如果ip是开始ip，标识就加begin，结束ip就加end，如果一个国家会对应多条IP起始范围，则标识还要加上数字&lt;/p&gt;
&lt;p&gt;但是这种方案有个缺点，就是无法处理ip范围重叠的情况，所以最好还是DB存，存ip的字符串，还有转成数字后的开始ip和结束ip&lt;/p&gt;
&lt;p&gt;存储时：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;比如有一条数据是 2.255.1.40, 5.2.255.255, CN
即ip在以 2.255.1.40 开始，以 5.2.255.255 结束 范围内，对应的国家二字码是 CN
转成数字就是 50266408, 84082687, CN

存到redis时，对应的命令就是
zadd ip2Country 50266408 begin_1_CN
zadd ip2Country 84082687 end_1_CN
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;查询时：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;比如有ip 2.255.1.41，转成数字是 50266409，查询redis时，使用命令
zrevrangebyscore ip2Country 50266409 0 LIMIT 0 1   
# 后面的LIMIT很关键，这个命令时间复杂度是 O(log(N)+M)， N是zset的总数量，M是查询到的结果集的数量

该命令表示查询 key为ip2Country的zset，socre从高到低排列，返回socre从0到50266409范围内的元素的第一个元素，所以会返回最接近且小于等于 50266409 的元素，然后进行判断：
1. 如果返回值为空，说明没找到对应的ip范围
2. 如果是start开头，说明找到了对应的国家二字码
3. 如果是end开头，说明没找到对应的ip范围 
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;扫码登录&#34;&gt;扫码登录&lt;/h1&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/PC%e7%ab%af%e6%89%ab%e7%a0%81%e7%99%bb%e5%bd%95.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/PC%e7%ab%af%e6%89%ab%e7%a0%81%e7%99%bb%e5%bd%95.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;极客时间 - 后端存储实战&lt;/p&gt;
&lt;p&gt;极客时间 - 秒杀系统设计&lt;/p&gt;
</description>
        </item>
        <item>
        <title>其他</title>
        <link>http://nixum.cc/p/%E5%85%B6%E4%BB%96/</link>
        <pubDate>Tue, 22 Sep 2020 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/%E5%85%B6%E4%BB%96/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;quartz&#34;&gt;Quartz&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;分为三个部分：e&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Job&amp;amp;Detial(任务)：定时任务的执行方法，与Trigger配套的&lt;/li&gt;
&lt;li&gt;Trigger(触发器)：规定什么时候触发，与Job&amp;amp;Detail配套的&lt;/li&gt;
&lt;li&gt;Scheduler(调度器)：单例，把Trigger丢里面由调度器调度，只需要一个Scheduler，配置不同的Trigger；可以理解成类似线程池的东西&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;原理：ScheduledThreadPoolExecutor线程池 + 通过Object类的wait()和notify()或者Condition类的await()\signal()进行等待和唤醒、锁保证线程安全 来进行调度&lt;/p&gt;
&lt;p&gt;Scheduler有两个调度线程：regular Scheduler Thread（执行常规调度）和Misfire Scheduler Thread（执行错失的任务），Regular Thread 轮询所有Trigger，如果有将要触发的Trigger（用wait和notifyAll实现），则从任务线程池中获取一个空闲线程，然后执行与改Trigger关联的job；Misfire Thraed则是扫描所有的trigger，查看是否有错失的，如果有的话，根据一定的策略进行处理&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认是并发的，即如果当前任务没有完成，会自动开一个任务执行&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;注意在分布式集群的情况下，多台机子有相同的定时任务，会出错，此时通过共享数据库的方式实现&lt;/p&gt;
&lt;p&gt;Quartz的解决方案：&lt;/p&gt;
&lt;p&gt;quartz集群分为水平集群和垂直集群，水平集群即将定时任务节点部署在不同的服务器，其最大的问题就是时钟同步问题，若时钟不能同步，则会导致集群中各个节点状态紊乱，造成不可预知的后果；垂直集群则是集群各节点部署在同一台服务器，时钟同步自然不是问题，但存在单点故障问题，服务器宕机会严重影响服务的可用性&lt;/p&gt;
&lt;p&gt;在各个节点会上报任务，存到数据库中，执行时会从数据库中取出触发器来执行，如果触发器的名称和执行时间相同，则只有一个节点去执行此任务。&lt;/p&gt;
&lt;p&gt;如果此节点执行失败，则此任务则会被分派到另一节点执行，中途也会自动检查失效的定时调度，发现不成功的，其他节点立马接过来继续完成定时任务。Quartz有11个定时任务调度表&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/Dorae/p/9357180.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Quartz原理解密&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/scgyus/article/details/79360316&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;深入解读Quartz的原理&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/xlxxcc/article/details/52104463&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Quartz 2.2 的实现原理和运行过程&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;其他定时器&#34;&gt;其他定时器&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Timer：这是java自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。使用这种方式可以让你的程序按照某一个频度执行，但不能在指定时间运行。一般用的较少。单线程，任务一多会阻塞；一个任务出异常其他任务都受影响；受系统时间影响&lt;/li&gt;
&lt;li&gt;ScheduledExecutorService：也jdk自带的一个类；是基于线程池设计的定时任务类,每个调度任务都会分配到线程池中的一个线程去执行,也就是说,任务是并发执行,互不影响。线程池+延时队列DelayedQueue(数组、最小堆, 最近要执行的任务放在堆顶) 实现，如果堆顶任务时间未到就阻塞（通过自旋+condition.await\signal实现）。不受系统时间影响&lt;/li&gt;
&lt;li&gt;Spring 中的 @Schedule  注解&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;参考：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/u013332124/article/details/79603943&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java 定时任务实现原理详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.jianshu.com/p/587901245c95&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Java优先级队列DelayedWorkQueue原理分析&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;cors&#34;&gt;CORS&lt;/h1&gt;
&lt;p&gt;浏览器的同源政策的同源指的是：协议相同、域名相同、端口相同，如果非同源，有三种行为会受到限制：Cookie、LocalStorage和IndexDB无法读取；DOM无法获得、AJAX请求不能发送。&lt;/p&gt;
&lt;p&gt;前后端分离的场景下，由于浏览器的同源策略，导致浏览器内的请求不同的源的后端是会失败，常见的解决跨域方法是使用CORS，现在常见的web框架都支持CORS，开启即可。&lt;/p&gt;
&lt;p&gt;解决跨域的方法除了CORS，还有jsonp，不过已经很少使用了，jsonp本质是利用浏览器允许加载不同源的js文件即&lt;!-- raw HTML omitted --&gt;标签等，将跨域请求&lt;!-- raw HTML omitted --&gt;标签里，返回一段可执行的js代码，其中包含了请求结果，通常是json格式，前端通过返回的js代码执行回调获取结果。&lt;/p&gt;
&lt;p&gt;详情见 &lt;a class=&#34;link&#34; href=&#34;http://www.ruanyifeng.com/blog/2016/04/cors.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;跨域资源共享 CORS 详解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;对于跨域产生的问题，如CSRF跨域请求攻击的解决方案，可参考：&lt;a class=&#34;link&#34; href=&#34;https://tech.meituan.com/2018/10/11/fe-security-csrf.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;美团:如何防止csrf&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;session和cookie&#34;&gt;session和cookie&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先HTTP是无状态的，因此需要通过session、cookie来达到记录用户状态的目的。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传统的session、cookie：session存用户信息，保存在服务端中，cookie里存session对应的sessionId，保存在客户端中，用于找到对应的session，每次请求都会带上该cookie来表示此用户。&lt;/p&gt;
&lt;p&gt;如果客户端禁用掉cookie，可以使用LocalStorage存储，每次请求都以参数的形式传递；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cookie可设置长时间保持，session有效时间通常比较短，安全性上来将，cookie存储在客户端，容易被窃取，session存储在服务段，相对安全；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于现在实例的部署不可能只部署一个，一般都是集群部署，因此session不可以只存在一个实例的内存中，因此引入Redis来存用户的登录信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;现在一般使用 token + Redis来实现 cookie - session 机制，本质上差不多，前端的cookie更多的是存token的信息而已，token也可以存在LocalStorage或sessionStorage中，发送请求时一般是把token的值放在请求头中，而不会把cookie发给后端，这样可以避免当用户禁用cookie导致功能不可用，还有CSRF问题。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;jwt&#34;&gt;JWT&lt;/h1&gt;
&lt;p&gt;JWT = JSON WEB TOKEN&lt;/p&gt;
&lt;h2 id=&#34;原理&#34;&gt;原理&lt;/h2&gt;
&lt;p&gt;JWT实际上是一个token(令牌)，分为三部分：Header(头部)、Payload(负载)、Signature(签名)。&lt;/p&gt;
&lt;p&gt;Header(头部) ：两部分组成，记录令牌类型和JWT的签名算法，一般是HMACSHA256。&lt;/p&gt;
&lt;p&gt;Payload(负载)： 记录用户登录信息(官方规范默认是不加密的，分为官方字段和私有字段）。&lt;/p&gt;
&lt;p&gt;Signature(签名) ：记录将 Header、Payload和服务端的密钥组合起来，使用Header(头部)里规定的方式加密。&lt;/p&gt;
&lt;p&gt;比如header里保存的加密方式是HMACSHA256，&lt;code&gt;签名 Signature = HMACSHA256(base64URL(header) + &amp;quot;.&amp;quot; + base64URL(payload) + &amp;quot;.&amp;quot; + 保存在后端的密钥)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;最后的JWT = &lt;code&gt;base64URL(Header) + &amp;quot;.&amp;quot; + base64URL(Payload) + &amp;quot;.&amp;quot; + Signature&lt;/code&gt;，后端收到该JWT后验证该签名是否正确，来判断JWT里的用户信息是否可靠。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;base64&lt;/strong&gt;：64指的是A-Z,a-z，0-9，+，/，将待转换的字符串转成二进制流，每3个8位转成4个6位，6位的二进制数转成十进制，根据码表找到对应的字符，以=号做后缀，凑齐位数&lt;/p&gt;
&lt;p&gt;一般是为了解决一些字符编码的问题，将非ASCII字符转化为ASCII字符，还有就是可以对数据做简单加密，base64URL在base64的基础上增加对一些符号的编解码，比如把&amp;quot;-&amp;ldquo;替换成&amp;rdquo;+&amp;quot;，使得它可以出现在url中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;HMACSHA256&lt;/strong&gt;：摘要算法，一般用于验证签名是否一致&lt;/p&gt;
&lt;h2 id=&#34;使用&#34;&gt;使用&lt;/h2&gt;
&lt;p&gt;可以存储在浏览器的本地缓存localStorage或者cookie中，发送请求的时候放在cookie里，或者放在请求头中&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;JWT的目的是让服务器不保存任何session数据，让后端变成无状态的，因此没办法主动废弃某个token，一旦签发了JWT，在到期之前就会始终有效，如果想要实现这种功能，必然需要在后端保存JWT，就违背了JWT的设计初衷了。&lt;/li&gt;
&lt;li&gt;要让JWT实现 续签 和 主动过期功能，必定需要在后端保存JWT
&lt;ul&gt;
&lt;li&gt;jwt主动过期问题，使用黑名单即可；分成两点，客户端要求失效，服务端记录token到黑名单；用户重置密码，服务端记录uid-time键值对，在此之前的token全部失效；客户端把保存的jwt删掉是没用的，此时的jwt依然有效，只是客户端没记录而已&lt;/li&gt;
&lt;li&gt;jwt续签问题，一种解决方式是jwt中存储过期时间，服务端设置刷新时间，请求时判断是否在过期时间或刷新时间，在刷新时间内进行token刷新，失效token记入黑名单；&lt;/li&gt;
&lt;li&gt;而黑名单过大问题，可以采用记录UID-刷新时间方式解决，判断jwt签发时间，jwt签发时间小于UID-刷新时间的记为失效&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;个人认为JWT的生成方式本身是有一套规范的，在实际使用过程中也可以对他进行改动，本质上还是一个签名校验而已，一般会对JWT进行魔改，比如使用Header(头部)里的加密方式加密Signature(签名)，Signature(签名)加密Header(头部) 和Payload(负载) 这两部分，服务器里的私钥解密Payload(负载)，得到需要的登录信息，不通过简单的base64URL编码，不对外暴露，签名算法或者签名里的密钥的方式可以改成其他等。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JWT参考：&lt;a class=&#34;link&#34; href=&#34;https://learnku.com/articles/17883&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;JWT 超详细分析&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&#34;cas模型---sso单点登录&#34;&gt;CAS模型 - SSO(单点登录)&lt;/h1&gt;
&lt;p&gt;可参考：&lt;a class=&#34;link&#34; href=&#34;https://blog.csdn.net/javaloveiphone/article/details/52439613&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;CAS实现单点登录SSO执行原理探究&lt;/a&gt;，讲得算是比较明白，这里是总结基于CAS模式改的单点登录模式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;第一次访问时，由于没有访问的token，会引导至登录&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/sso-first-access.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/sso-first-access.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;第一次访问&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;第一次访问&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;再次访问Web-1时，由于前端已存了token，直接使用token进行请求即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;已登录Web-1时去访问Web-2，会通过后端认证中心实现单点登录&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/sso-second-access.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/sso-second-access.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;第二次访问&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;第二次访问&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这里在总结一下关于GrantTicket和ServiceTicket，跟CAS模型中提到的TGT、ST、PGT这些东西是类似的，本质是作为验证的票据，图中的GrantTicket、ServiceTicket、token含义如下&lt;/p&gt;
&lt;p&gt;GrantTicket：全局会话票据，保存在登录页，通过GrantTicket才能换取ServiceTicket；&lt;/p&gt;
&lt;p&gt;ServiceTicket表示访问资源的一次性票据，根据ServiceTicket换取token，换取后失效；&lt;/p&gt;
&lt;p&gt;token：登录凭证&lt;/p&gt;
&lt;p&gt;GT、ST和token都是保存在Redis中的，他们在Redis中的存储结构如下&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;key：TOKEN_${Token的值}
value:
{
    &amp;quot;createTime&amp;quot;: 1565961654807,
    &amp;quot;accountId&amp;quot;: &amp;quot;123&amp;quot;,
    // 用户其他信息
    &amp;quot;grantTicket&amp;quot;: ${GrantTicket的值}  // token关联GT，用于注销时实现全局注销
}

key：GRANT_TICKET_${GrantTicket的值}
value:
{
    &amp;quot;createTime&amp;quot;: 1565961654807,
    &amp;quot;accountId&amp;quot;: &amp;quot;123&amp;quot;,
}

key：SERVICE_TICKET_${ServiceTicket的值}
value:
{
    &amp;quot;createTime&amp;quot;: 1565961654807,
    &amp;quot;grantTicket&amp;quot;: ${GrantTicket的值} // ST关联GT，用于判断该ST是否有效，换取token后删除
}

// token与grantTicket的记录，注销时，根据token中关联的GT，找到所有与之关联的token，进行删除，这里推荐使用Redis的scan命令进行分段查询，原因是Redis是单线程的，如果数据量太大使用keys命令遍历太久，阻塞Redis接收其他命令
key：{grantTicket}-{token}
value：无
&lt;/code&gt;&lt;/pre&gt;&lt;h1 id=&#34;基于oauth20的第三方登录&#34;&gt;基于OAuth2.0的第三方登录&lt;/h1&gt;
&lt;p&gt;可参考：&lt;a class=&#34;link&#34; href=&#34;https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;理解OAuth 2.0&lt;/a&gt;，这样基本就入门了，这里是总结项目中如何接入，一般在集成facebook和google的第三方登录也是类似的流程机制，这里只用到了access_token，对于refresh_token，是用来延长access_token的过期时间的，减少短时间内的重复登录，这里就没有涉及到了&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%9f%ba%e4%ba%8eoauth2%e7%9a%84%e7%ac%ac%e4%b8%89%e6%96%b9%e7%99%bb%e5%bd%95%e6%b5%81%e7%a8%8b.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%9f%ba%e4%ba%8eoauth2%e7%9a%84%e7%ac%ac%e4%b8%89%e6%96%b9%e7%99%bb%e5%bd%95%e6%b5%81%e7%a8%8b.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;基于OAuth2的第三方登录&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;基于OAuth2的第三方登录&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;为什么要后端要根据code + clientId + secret换成access_token，再根据access_token换用户个人信息？&lt;/p&gt;
&lt;p&gt;为什么后端不直接code + clientId + secret换用户个人信息呢？&lt;/p&gt;
&lt;p&gt;主要还是为了安全，防止中间人攻击&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;重定向的参数是带在url里的，是直接暴露在客户端的，如果直接返回access_token就不安全，因此才多了code这一层，为了降低code被拦截泄漏后的风险，code的过期时间一般都很短，且是一次性的；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;另外就是后端对于外部的请求都是不信任的，因此接收到的参数(code)首先还要配合凭证去验证其合法性，对于验证通过后获得的access_token也有更多的操作空间，由后端持有，不会暴露出去&lt;/p&gt;
&lt;p&gt;像上图那种登录方案，后端只需要用户个人信息换完token就算完事了，所以看起来好像直接使用code + clientId + secret换用户个人信息就行，但是如果此时需要再获取用户的其他信息，就没有没办法再用code去换了，只能要求用户再次登录，此时如果有access_token就显得多么重要了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;压测&#34;&gt;压测&lt;/h1&gt;
&lt;p&gt;总结一下做过的压测，压测工具jmetter，利用jmette可以多线程并发请求和可以实时查看简易报告的能力&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;先对被压测服务的接口针对不同场景编写压测用例，设定好TPS的起始和目标值，作为压测计划&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;画压测机器部署关系图，部署压测环境&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于被压测的服务，一般会mock掉与该服务相关关联的服务，比如该服务还连了数据库，该接口请求依赖一些独立部署的中间件，或者依赖其他服务，则会对这些相关的依赖用桩来代替，用于维持通信，以减少这些额外服务的影响。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般一台机器只部署一个服务，特别是被压测服务，此外还要注意被压测服务所在的机器上网络设置相关的参数，比如TCP最大连接数、回收策略之类的设置&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编写压测脚本，压测脚本越简单越好，尽量让压测工具不影响被压测服务，&lt;strong&gt;脚本最重要的几个设置&lt;/strong&gt;： 发起请求时的并发线程数、响应的断言、TPS数，其他那些花里胡哨的输出树状图，饼图啊那些都不用配了，用最简单的报告输出即可&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;部署完后，将脚本配置放到jmeter的机器上，启动压测&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;nohup java -jar bin/ApacheJMeter.jar -n -t jmetter脚本路径/config.jmx &amp;gt; test.out &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;输出到当前目录下的test.out文件里，这里启动是使用默认参数启动，如果对jmetter的JVM设置有要求，也可以在启动时指定JVM参数，如&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;nohup java -server -XX:+HeapDumpOnOutOfMemoryError -Xms512m -Xmx512m -XX:+UseG1GC -XX:MaxGCPauseMillis=250 -XX:G1ReservePercent=20 -Djava.security.egd=file:/dev/urandom -jar bin/ApacheJMeter.jar -n -t jmetter脚本路径/config.jmx &amp;gt; test.out &amp;amp;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;压测开启后可以打开test.out文件查看压测报告&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般是按照TPS从小往大压，小的TPS压，在正常延时的情况下可以先判断程序是否有问题，比如内存泄漏，内存溢出，没问题了再逐步往大了压。如果先从大往小压，延时又上不去，此时判断不了是程序内部问题还是过大的TPS导致。压测时间一般最少压一天&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;输出压测报告&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;一般有如下几个点要注意，这些点到时也要输出到压测报告上&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;监控点&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;jmetter端的TPS、延时、错误率&lt;/td&gt;
&lt;td&gt;观察TPS是否符合预期、延时是否达到预期且稳定、错误率要为0。&lt;strong&gt;当程序正常时降低RT的手段&lt;/strong&gt;：减少不必要的日志输出、业务逻辑算法是否还有优化空间，是否有IO占用或者频繁序列化反序列化、内部队列是否阻塞&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;被压测服务的gc&lt;/td&gt;
&lt;td&gt;fgc，ygc不要太频繁，一般来说&lt;strong&gt;fgc 一小时要小于3~4次&lt;/strong&gt;；&lt;strong&gt;ygc一分钟要小于3~4次为佳&lt;/strong&gt;。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;jmetter端的CPU、内存使用率等&lt;/td&gt;
&lt;td&gt;注意jmetter端的CPU是否过高或波动很大，避免影响压测结论&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;被压测服务端的CPU、磁盘、内存使用率等&lt;/td&gt;
&lt;td&gt;如果cpu过高，如果连续达到90以上，基本上是内存泄漏导致了频繁的fgc；磁盘的占用情况，注意生成的日志是否把磁盘占满了&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;使用 &lt;code&gt;jstat -gcutil [pid] [时间间隔，每几秒打印] [打印次数]&lt;/code&gt;查看GC情况&lt;/p&gt;
&lt;p&gt;当被压测端的gc不正常时，应尽量保存事发环境&lt;/p&gt;
&lt;p&gt;​	1、收集内存使用基本情况统计：&lt;code&gt;jmap -heap [pid] &amp;gt; [文件名，如heap.log]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​	2、收集线程堆栈运行信息：&lt;code&gt;jstack [pid] &amp;gt; [文件名，如stack.log]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​	3、收集内存详细使用信息，生成dump内存快照：&lt;code&gt;jmap -dump:format=b,file=[文件名，如heap.dump] [pid]&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一般使用eclipse mat工具进行内存快照的分析，排查出内存泄漏的问题。&lt;/p&gt;
&lt;p&gt;mat的使用参见：&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/yueshutong/p/9824772.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;Eclipse MAT内存分析工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;一般压测脚本的模板：&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-xml&#34; data-lang=&#34;xml&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&amp;lt;?xml version=&amp;#34;1.0&amp;#34; encoding=&amp;#34;UTF-8&amp;#34;?&amp;gt;&lt;/span&gt;
&lt;span class=&#34;nt&#34;&gt;&amp;lt;jmeterTestPlan&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;version=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;1.2&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;properties=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;3.2&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;jmeter=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;3.2 r1790748&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;lt;hashTree&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;lt;TestPlan&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;guiclass=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;TestPlanGui&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;testclass=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;TestPlan&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;testname=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;测试计划&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;enabled=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;c&#34;&gt;&amp;lt;!-- 一般写压测计划中的序号+名称 --&amp;gt;&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;TestPlan.comments&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;lt;boolProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;TestPlan.functional_mode&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;false&lt;span class=&#34;nt&#34;&gt;&amp;lt;/boolProp&amp;gt;&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;lt;boolProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;TestPlan.serialize_threadgroups&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;false&lt;span class=&#34;nt&#34;&gt;&amp;lt;/boolProp&amp;gt;&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;lt;elementProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;TestPlan.user_defined_variables&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;elementType=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Arguments&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;guiclass=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ArgumentsPanel&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;testclass=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Arguments&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;testname=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;用户定义的变量&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;enabled=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;collectionProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Arguments.arguments&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;lt;/elementProp&amp;gt;&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;TestPlan.user_define_classpath&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;lt;/TestPlan&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;lt;hashTree&amp;gt;&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;lt;ThreadGroup&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;guiclass=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ThreadGroupGui&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;testclass=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ThreadGroup&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;testname=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Thread Group&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;enabled=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ThreadGroup.on_sample_error&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;continue&lt;span class=&#34;nt&#34;&gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;elementProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ThreadGroup.main_controller&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;elementType=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;LoopController&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;guiclass=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;LoopControlPanel&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;testclass=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;LoopController&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;testname=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;循环控制器&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;enabled=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;boolProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;LoopController.continue_forever&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;false&lt;span class=&#34;nt&#34;&gt;&amp;lt;/boolProp&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;intProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;LoopController.loops&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;-1&lt;span class=&#34;nt&#34;&gt;&amp;lt;/intProp&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;/elementProp&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ThreadGroup.num_threads&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;500&lt;span class=&#34;nt&#34;&gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;                                             &lt;span class=&#34;c&#34;&gt;&amp;lt;!-- 发起请求时的并发线程数，这里设置为500个并发线程，表示使用这么多的线程数来达到下面设置的TPS数 --&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ThreadGroup.ramp_time&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;8&lt;span class=&#34;nt&#34;&gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;longProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ThreadGroup.start_time&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;1509332694000&lt;span class=&#34;nt&#34;&gt;&amp;lt;/longProp&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;longProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ThreadGroup.end_time&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;1509332694000&lt;span class=&#34;nt&#34;&gt;&amp;lt;/longProp&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;boolProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ThreadGroup.scheduler&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;false&lt;span class=&#34;nt&#34;&gt;&amp;lt;/boolProp&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ThreadGroup.duration&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ThreadGroup.delay&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;lt;/ThreadGroup&amp;gt;&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;lt;hashTree&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;HTTPSamplerProxy&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;guiclass=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HttpTestSampleGui&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;testclass=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HTTPSamplerProxy&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;testname=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;click http request&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;enabled=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;elementProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HTTPsampler.Arguments&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;elementType=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Arguments&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;guiclass=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HTTPArgumentsPanel&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;testclass=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Arguments&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;testname=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;用户定义的变量&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;enabled=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;lt;collectionProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Arguments.arguments&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;/&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;/elementProp&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HTTPSampler.domain&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;192.168.1.123&lt;span class=&#34;nt&#34;&gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;         &lt;span class=&#34;c&#34;&gt;&amp;lt;!-- 此处为被压测服务的host --&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HTTPSampler.port&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;12345&lt;span class=&#34;nt&#34;&gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;                    &lt;span class=&#34;c&#34;&gt;&amp;lt;!-- 此处为被压测服务的port --&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HTTPSampler.protocol&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;http&lt;span class=&#34;nt&#34;&gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HTTPSampler.contentEncoding&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HTTPSampler.path&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;${__StringFromFile(/home/urls.log,,,)}&lt;span class=&#34;nt&#34;&gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;  &lt;span class=&#34;c&#34;&gt;&amp;lt;!-- 发起的http请求uri从文件读取，文件路径 --&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HTTPSampler.method&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;GET&lt;span class=&#34;nt&#34;&gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;boolProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HTTPSampler.follow_redirects&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;false&lt;span class=&#34;nt&#34;&gt;&amp;lt;/boolProp&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;boolProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HTTPSampler.auto_redirects&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;false&lt;span class=&#34;nt&#34;&gt;&amp;lt;/boolProp&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;boolProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HTTPSampler.use_keepalive&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&#34;nt&#34;&gt;&amp;lt;/boolProp&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;boolProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HTTPSampler.DO_MULTIPART_POST&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;false&lt;span class=&#34;nt&#34;&gt;&amp;lt;/boolProp&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HTTPSampler.embedded_url_re&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HTTPSampler.implementation&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;Java&lt;span class=&#34;nt&#34;&gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HTTPSampler.connect_timeout&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;HTTPSampler.response_timeout&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;/HTTPSamplerProxy&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;hashTree/&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;ResponseAssertion&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;guiclass=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;AssertionGui&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;testclass=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ResponseAssertion&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;testname=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Response Assertion&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;enabled=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;collectionProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Asserion.test_strings&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;49586&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;200&lt;span class=&#34;nt&#34;&gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;                                       &lt;span class=&#34;c&#34;&gt;&amp;lt;!-- http请求的响应断言，要求返回的http code为200才判定为成功 --&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;/collectionProp&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;stringProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Assertion.test_field&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;Assertion.response_code&lt;span class=&#34;nt&#34;&gt;&amp;lt;/stringProp&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;boolProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Assertion.assume_success&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;false&lt;span class=&#34;nt&#34;&gt;&amp;lt;/boolProp&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;intProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Assertion.test_type&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;8&lt;span class=&#34;nt&#34;&gt;&amp;lt;/intProp&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;/ResponseAssertion&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;hashTree/&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;ConstantThroughputTimer&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;guiclass=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;TestBeanGUI&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;testclass=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;ConstantThroughputTimer&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;testname=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Constant Throughput Timer&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;enabled=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;intProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;calcMode&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;1&lt;span class=&#34;nt&#34;&gt;&amp;lt;/intProp&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;doubleProp&amp;gt;&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;lt;name&amp;gt;&lt;/span&gt;throughput&lt;span class=&#34;nt&#34;&gt;&amp;lt;/name&amp;gt;&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;lt;value&amp;gt;&lt;/span&gt;30000.0&lt;span class=&#34;nt&#34;&gt;&amp;lt;/value&amp;gt;&lt;/span&gt;          &lt;span class=&#34;c&#34;&gt;&amp;lt;!-- 1分钟内发起的请求数，换算为tps为500 --&amp;gt;&lt;/span&gt;
            &lt;span class=&#34;nt&#34;&gt;&amp;lt;savedValue&amp;gt;&lt;/span&gt;0.0&lt;span class=&#34;nt&#34;&gt;&amp;lt;/savedValue&amp;gt;&lt;/span&gt;
          &lt;span class=&#34;nt&#34;&gt;&amp;lt;/doubleProp&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;/ConstantThroughputTimer&amp;gt;&lt;/span&gt;
        &lt;span class=&#34;nt&#34;&gt;&amp;lt;hashTree/&amp;gt;&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;lt;/hashTree&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;lt;/hashTree&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;lt;WorkBench&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;guiclass=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;WorkBenchGui&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;testclass=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;WorkBench&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;testname=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;工作台&amp;#34;&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;enabled=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;true&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;
      &lt;span class=&#34;nt&#34;&gt;&amp;lt;boolProp&lt;/span&gt; &lt;span class=&#34;na&#34;&gt;name=&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;WorkBench.save&amp;#34;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;&amp;gt;&lt;/span&gt;true&lt;span class=&#34;nt&#34;&gt;&amp;lt;/boolProp&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;lt;/WorkBench&amp;gt;&lt;/span&gt;
    &lt;span class=&#34;nt&#34;&gt;&amp;lt;hashTree/&amp;gt;&lt;/span&gt;
  &lt;span class=&#34;nt&#34;&gt;&amp;lt;/hashTree&amp;gt;&lt;/span&gt;
&lt;span class=&#34;nt&#34;&gt;&amp;lt;/jmeterTestPlan&amp;gt;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;调优&#34;&gt;调优&lt;/h1&gt;
&lt;p&gt;参考：https://tech.meituan.com/2016/12/02/performance-tunning.html&lt;/p&gt;
&lt;h1 id=&#34;布隆过滤器&#34;&gt;布隆过滤器&lt;/h1&gt;
&lt;p&gt;本质上是基于hash的概率性数据结构，是一个很长的二进制数组，主要用于判断元素可能存在集合中，或者一定不在集合中。&lt;/p&gt;
&lt;h2 id=&#34;原理-1&#34;&gt;原理&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;有一个长度为m的bit数组，初始每个bit都是0，另外还有k个hash函数；&lt;/li&gt;
&lt;li&gt;当加入一个元素时，先调用k个hash函数得到k个结果，将这k个结果与bit数组长度取模得到k个数组下标，将这k个数组下标对应的值置为 1；&lt;/li&gt;
&lt;li&gt;查询元素时，同样经过上面步骤的计算，最终得到k个数组下标，判断这些下标对应的值是否为1，如果为1，说明元素可能存在，如果有一个不为1，说明元素一定不存在，返回结果；&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;误判率计算&#34;&gt;误判率计算&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;涉及到3个重要的参数：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;m&lt;/code&gt;表示bit数组的长度&lt;/li&gt;
&lt;li&gt;&lt;code&gt;k&lt;/code&gt;表示散列函数的个数&lt;/li&gt;
&lt;li&gt;&lt;code&gt;n&lt;/code&gt;表示插入的元素个数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;布隆过滤器中，一个元素插入后，某个bit为0的概率是&lt;code&gt;(1 − 1/m)^k&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;n元素插入后，某个bit为0的概率是&lt;code&gt;(1 − 1/m)^(n*k)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;false positive的概率是&lt;code&gt;(1−(1−1/m)^n*k)^k&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;因为需要的是&lt;code&gt;k&lt;/code&gt;个不同的bit被设置成1，概率是大约是&lt;code&gt;(1−e^(−k*n/m))^k&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;实现&#34;&gt;实现&lt;/h2&gt;
&lt;p&gt;可以基于redis实现，但这里只给出go版本的实现，支持并发安全&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mod7&lt;/span&gt;       &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;3&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;bitPerByte&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;8&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Filter&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;       &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RWMutex&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;concurrent&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 长度之所以要取2的指数是因为要将取模操作优化成与操作， % 等于 &amp;amp;(2^n-1)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;uint64&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// bit array of m bits, m will be ceiling to power of 2
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;uint64&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// number of inserted elements
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;log2m&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint64&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// log_2 of m
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;uint64&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// the number of hash function
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;keys&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// byte array to store hash value
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Filter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;log2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Ceil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;math&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Log2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;float64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))))&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;filter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Filter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;          &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;log2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;log2m&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;log2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;          &lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;       &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;log2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;concurrent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;race&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;concurrent&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;sync&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;RWMutex&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;filter&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Filter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Add&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Filter&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;concurrent&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;baseHash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;uint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;k&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;loc&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;location&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;slot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mod&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;location&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;loc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;slot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mod&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// location returns the bit position in byte array
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// &amp;amp; (f.m - 1) is the quick way for mod operation
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Filter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;location&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;uint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;slot&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;bitPerByte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;m&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;mod&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;h&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mod7&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;slot&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;mod&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// baseHash returns the murmur3 128-bit hash
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;baseHash&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint64&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;a1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// to grab another bit of data
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;hasher&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;murmur3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;New128&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;hasher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// #nosec
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;hasher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sum128&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;hasher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;a1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// #nosec
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;v3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v4&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;hasher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sum128&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;uint64&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;v1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;v4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;淘汰算法&#34;&gt;淘汰算法&lt;/h1&gt;
&lt;h2 id=&#34;lru&#34;&gt;LRU&lt;/h2&gt;
&lt;p&gt;java实现，非线程安全&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;  1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 95
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 96
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 97
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 98
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 99
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;100
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;101
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;102
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;103
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;104
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;105
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;106
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;107
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;108
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;109
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;110
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;111
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;112
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;113
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;114
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;115
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 注意每一次对节点有操作对需要同时操作 nodeMap和lruQueue
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// LRU本质是利用 hashMap 和 双向链表 实现
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;LRUCache&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;

  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DoubleLinkedList&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lruQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;LRUCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;LRUCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;nodeMap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;lruQueue&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DoubleLinkedList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;


  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 获取后直接放到到最前的位置
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 如果包含，则放到最前
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;containsKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;lruQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;));&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;lruQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;addFirst&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;newNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 记得更新map
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 如果满了，则移除最后一个
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;size&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lruQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;last&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lruQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;removeLast&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;last&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;newNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;lruQueue&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;addFirst&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;newNode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Node&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;pre&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

  &lt;span class=&#34;c1&#34;&gt;// 封装双向链表方法，构建时要注意前后节点指向和空指针问题
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;DoubleLinkedList&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;addFirst&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;head&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;++;&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;head&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;pre&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;head&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;removeLast&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;pre&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;pre&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;head&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--;&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;result&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Node&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;--;&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;pre&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;pre&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;head&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;pre&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;pre&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;tail&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;pre&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;golang实现，非并发安全，下面这种写法是平铺了双向链表，链表的长度通过map的长度计算得到&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;LRUCache&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Node&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt;     &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Node&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt;     &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Node&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;cap&lt;/span&gt;      &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Node&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Node&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;pre&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Node&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewLRUCache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;capacity&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;LRUCache&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;LRUCache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;cap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;capacity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LRUCache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;existNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;exist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;exist&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;existNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;addFirst&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;existNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;existNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LRUCache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Put&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;existNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;exist&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;exist&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;existNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;existNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;addFirst&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;existNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;newNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;newNode&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;addFirst&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;newNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cap&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;c1&#34;&gt;// 一定要先delete，如果先remove，会导致找不回tail的key进行delete，
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;nb&#34;&gt;delete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LRUCache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;addFirst&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pre&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pre&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LRUCache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// n的next和pre要置为null，防止内存泄漏
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;head&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pre&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;lru&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;tail&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pre&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pre&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
        &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pre&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pre&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt;
    &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pre&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pre&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;关于并发安全，最简单的实现就是在调用Get和Put方法时加读写锁，但是这种做法锁的粒度比较大，每次会锁住整个底层的双向链表和map，导致在高并发情况下吞吐量不高，优化的思路就是对map分片，通过分片上锁来减小锁的粒度，然后再双向链表节点的操作上进行优化。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;capacity&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;LRUCache&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;shards&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LRUCacheShard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;256&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;256&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;shards&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%02x&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LRUCacheShard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;Cap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;capacity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;Keys&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Element&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
			&lt;span class=&#34;nx&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(),&lt;/span&gt;
		&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;LRUCache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;shards&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;shards&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LRUCache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;shard&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;GetShard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;shard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;RLock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;shard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;RUnlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;err&#34;&gt;……&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LRUCache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Put&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  	&lt;span class=&#34;nx&#34;&gt;shard&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;GetShard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;shard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Lock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;defer&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;shard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Unlock&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;err&#34;&gt;……&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LRUCache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;GetShard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;shard&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LRUCacheShard&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;hasher&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;sha1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;hasher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Write&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;([]&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;byte&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
  &lt;span class=&#34;nx&#34;&gt;shardKey&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;fmt&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sprintf&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;%x&amp;#34;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;hasher&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Sum&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
  &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;c&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;shards&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;shardKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其中，在Get方法中，如果存在，还需要修改key所在节点的位置，直接调put即可，当然这种方式的粒度还是比较大，再次优化的思路是对map的操作还是得上锁，但对双向链表的操作无需上锁，双向链表移动节点和删除节点可以同时操作，可以通过两个channel实现，&lt;a class=&#34;link&#34; href=&#34;https://github.com/halfrost/LeetCode-Go/blob/master/template/CLRUCache.go&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;参考&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;lfu&#34;&gt;LFU&lt;/h2&gt;
&lt;p&gt;java实现，非线程安全&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 频次最少使用
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 设定容量，每次get key会修改使用次数和使用时间，当满容量时，移除次数最少的那个
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 如果有多个key的使用次数一样，则移除使用时间最旧的那个
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;LFUCache&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;

    &lt;span class=&#34;n&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keyValMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key2FreqMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// key和使用频率的映射
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;c1&#34;&gt;// 用LinkHashSet来模拟使用时间，使用LinkHashSet还有一个目的是便于根据key进行删除
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;Map&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LinkedHashSet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;freq2KeysMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 使用频率和key的映射
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minFreq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;LFUCache&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;keyValMap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;key2FreqMap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;freq2KeysMap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HashMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;cap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;minFreq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(!&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;keyValMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;containsKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;increaseFreq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keyValMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;cap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;keyValMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;containsKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;keyValMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;increaseFreq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;cap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keyValMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;size&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;removeMinFreqKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;keyValMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;key2FreqMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;freq2KeysMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;putIfAbsent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LinkedHashSet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;());&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;freq2KeysMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;minFreq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;increaseFreq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;freq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;key2FreqMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;key2FreqMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;put&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;freq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;freq2KeysMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;freq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;freq2KeysMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;putIfAbsent&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;freq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LinkedHashSet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;());&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;freq2KeysMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;freq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;freq2KeysMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;freq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;isEmpty&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;freq2KeysMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;freq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;freq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;minFreq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;minFreq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++;&lt;/span&gt;
            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;removeMinFreqKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;LinkedHashSet&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keys&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;freq2KeysMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;get&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;minFreq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;delKey&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;keys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;iterator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;keys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;keys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;isEmpty&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;())&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;freq2KeysMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;minFreq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
            &lt;span class=&#34;c1&#34;&gt;// 这里无需更新 minFreq 的值，因为该方法是在插入新key时使用，此时minFreq一定是1
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;keyValMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
        &lt;span class=&#34;n&#34;&gt;key2FreqMap&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;remove&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;delKey&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;golang实现，非并发安全，利用 优先级队列（最小堆） + map实现，使用的是go自带的heap数据结构，通过Item数组结构实现&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;  1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 95
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 96
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 97
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 98
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 99
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;100
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;101
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;102
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;103
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;104
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;105
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;container/heap&amp;#34;&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;LFUNode&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
  	&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt;   &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;freq&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 用于优先级，key的使用频率
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 用于当freq相同时的比较淘汰，总的获取次数，类似时间戳的概念
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 最小堆中元素的下标，用于重建最小堆.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PriorityQueue&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LFUNode&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PriorityQueue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PriorityQueue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Less&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;bool&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 优先根据使用频率排列，相等时才使用count，从小到大排序
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;PriorityQueue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Swap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;],&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;j&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PriorityQueue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{})&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LFUNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;append&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PriorityQueue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Pop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{}&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;nil&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 防止内存泄露
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// pop时重置下标保证安全
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;old&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;n&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 更新最小堆里的元素
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;PriorityQueue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LFUNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;frequency&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;frequency&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;heap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Fix&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// ==========================================
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;LFUCache&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;cap&lt;/span&gt;      &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;       &lt;span class=&#34;nx&#34;&gt;PriorityQueue&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LFUNode&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;counter&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewLFUCache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;capacity&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;LFUCache&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;LFUCache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;       &lt;span class=&#34;nx&#34;&gt;PriorityQueue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{},&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;  &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LFUNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;capacity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;cap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;capacity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LFUCache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LFUCache&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Put&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 如果存在，增加 frequency，再调整堆
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 如果不存在且缓存满了，需要删除。在 hashmap 和 pq 中删除。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cap&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;heap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Pop&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LFUNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;delete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 新建结点，在 hashmap 和 pq 中添加。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LFUNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;val&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;   &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;   &lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;count&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;counter&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;heap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;pq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;另一个版本实现，利用go本身提供的双向链表，但是由于go没泛型，在类型推断方面导致整体性能不会很高&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;LFUCache2&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;       &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Element&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;freq2NodeList&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;List&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;cap&lt;/span&gt;           &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;min&lt;/span&gt;           &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;       &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;     &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;freq&lt;/span&gt;      &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;NewLFUCache2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;capacity&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;LFUCache2&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;LFUCache2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Element&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;freq2NodeList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;    &lt;span class=&#34;nb&#34;&gt;make&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;),&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;cap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;      &lt;span class=&#34;nx&#34;&gt;capacity&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;      &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LFUCache2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;currentNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq2NodeList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Remove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;currentNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq2NodeList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq2NodeList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;newList&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq2NodeList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;newNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;newList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;PushFront&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;newNode&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;currentNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;min&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq2NodeList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;-&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;currentNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;func&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;LFUCache2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Put&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 如果存在，更新访问次数
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;currentValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;currentNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;currentValue&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;currentNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Get&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 如果不存在且缓存满了，需要删除
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cap&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;len&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;currentList&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq2NodeList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;min&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;backNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;currentList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Back&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
		&lt;span class=&#34;nb&#34;&gt;delete&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;backNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.(&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;*&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;).&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;currentList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;Remove&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;backNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 新建结点，插入到 2 个 map 中
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;min&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;currentNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;node&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;       &lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;     &lt;span class=&#34;nx&#34;&gt;value&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;freq&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;:&lt;/span&gt;      &lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;_&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq2NodeList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;ok&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq2NodeList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;list&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;New&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
	&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;newList&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;freq2NodeList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;newNode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;newList&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nf&#34;&gt;PushFront&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;currentNode&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
	&lt;span class=&#34;nx&#34;&gt;lfu&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;nodeMap&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;key&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;]&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;newNode&lt;/span&gt;
&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h1 id=&#34;参考&#34;&gt;参考&lt;/h1&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://liangyaopei.github.io/2020/07/29/bloom-filter/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;布隆过滤器原理及golang实现&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://halfrost.com/lru_lfu_interview/&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;LRU / LFU 的青铜与王者&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>设计模式</title>
        <link>http://nixum.cc/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</link>
        <pubDate>Tue, 22 Sep 2020 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;p&gt;只记录常用设计模式&lt;/p&gt;
&lt;h1 id=&#34;设计模式六大原则&#34;&gt;设计模式六大原则&lt;/h1&gt;
&lt;ol&gt;
&lt;li&gt;单一职责原则(SRP)：一个类只负责一个功能领域中的相应职责，就一个类而言，应该只有一个引起它变化的原因。&lt;/li&gt;
&lt;li&gt;开闭原则(OCP)：一个软件实体应当对扩展开放，对修改关闭。即软件实体应尽量在不修改原有代码的情况下进行扩展。&lt;/li&gt;
&lt;li&gt;里氏代换原则(LSP)：所有引用基类（父类）的地方必须能透明地使用其子类的对象。&lt;/li&gt;
&lt;li&gt;依赖倒转原则(DIP)：抽象不应该依赖于细节，细节应当依赖于抽象。换言之，要针对接口编程，而不是针对实现编程。如 控制反转和依赖注入&lt;/li&gt;
&lt;li&gt;接口隔离原则(ISP)：使用多个专门的接口，而不使用单一的总接口，即客户端不应该依赖那些它不需要的接口。&lt;/li&gt;
&lt;li&gt;迪米特法则(LoD)：一个软件实体应当尽可能少地与其他实体发生相互作用。&lt;/li&gt;
&lt;/ol&gt;
&lt;h1 id=&#34;常见设计模式&#34;&gt;常见设计模式&lt;/h1&gt;
&lt;p&gt;创建型模式是将创建和使用代码解耦&lt;/p&gt;
&lt;p&gt;结构型模式是将不同功能代码解耦&lt;/p&gt;
&lt;p&gt;行为型模式是将不同的行为代码解耦&lt;/p&gt;
&lt;h2 id=&#34;创建型&#34;&gt;创建型&lt;/h2&gt;
&lt;h3 id=&#34;单例模式&#34;&gt;单例模式&lt;/h3&gt;
&lt;p&gt;主要解决：一个全局使用的类被频繁创建和销毁，数据在应用上只保持一份，解决资源访问冲突的问题，就可以使用单例模式&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt;  1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;  9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 95
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 96
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 97
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 98
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 99
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;100
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;101
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;102
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;103
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;104
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;105
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;cm&#34;&gt;/** 1.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 懒汉模式,线程不安全，只有在调用方法的时候才实例化,好处是没用到该类时就不实例化，节约资源
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;LazyInstance&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LazyInstance&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;singleton&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;LazyInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//        if (singleton != null)
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;//            throw new RuntimeException();
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;cm&#34;&gt;/** 1.1
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;     * 想要线程安全只需在方法上加上synchronized关键字，缺点是，多线程访问时锁的操作耗时
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;     */&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LazyInstance&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;singleton&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;singleton&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;LazyInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;singleton&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/** 2.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 饿汉模式，直接实例化，线程安全，缺点是丢失了延迟实例化造成资源浪费
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;HungryInstance&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HungryInstance&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;singleton&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HungryInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;   &lt;span class=&#34;c1&#34;&gt;//加不加final都可以
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;HungryInstance&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;singleton&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/** 3.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 双重锁,可在多线程下使用
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;DoubleCheckedLocking&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;

    &lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;     * 注意变量要声明volatile,也需要两次if判断,否则可能因为指令重排序导致在多线程情况下不安全,这个比较难测试
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;     * singleton = new Singleton()不是原子操作，而分为了三个步骤
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;     * 1. 给 singleton 分配内存
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;     * 2. 调用 Singleton 的构造函数来初始化成员变量，形成实例
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;     * 3. 将singleton对象指向分配的内存空间（执行完这步 singleton才是非 null了）
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;     * 由于有一个『instance已经不为null但是仍没有完成初始化』的中间状态，而这个时候，
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;     * 如果有其他线程刚好运行到第一层if (instance ==null)这里，这里读取到的instance已经不为null了，
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;     * 所以就直接把这个中间状态的instance拿去用了，就会产生问题。这里的关键在于线程T1对instance的写操作没有完成，
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt;     * 线程T2就执行了读操作 **/&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;volatile&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DoubleCheckedLocking&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;singleton&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DoubleCheckedLocking&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;singleton&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
            &lt;span class=&#34;kd&#34;&gt;synchronized&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DoubleCheckedLocking&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;class&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;singleton&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
                    &lt;span class=&#34;n&#34;&gt;singleton&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DoubleCheckedLocking&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
                &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
            &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;singleton&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/**4.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 静态内部类模式，利用的是JVM对静态内部类的加载机制
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 因为静态内部类只有被调用的时候才会被初始化，相当于延时的机制，且JVM能保证只初始化一次
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 相当与结合了懒汉模式和饿汉模式的优点吧
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;StaticInnerClassMode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;StaticInnerClassInstance&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StaticInnerClassMode&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SINGLETON&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StaticInnerClassMode&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StaticInnerClassMode&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StaticInnerClassInstance&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;SINGLETON&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/**5.
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 枚举类创建单例,利用JVM的机制,保证只实例化一次,同时可防止反射和反序列化操作破解
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;enum&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;EnumMode&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;SINGLETON&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;method&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;cm&#34;&gt;/**
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 除了枚举类可防止反射和反序列化操作破解外，其他四种方法都会被反射和反序列化破解
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 1，阻止反射破解
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 在空构造方法里，判断singleton是否为空，如果不为空，则抛出RuntimeException，
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 因为反射需要通过class.getInstance()调用空参构造方法实例化对象，如果此时抛出异常，则会终止程序，
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 如果在懒汉模式里使用就会发现会抛出异常
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; * 2.阻止反序列化破解
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *  实现Serializable接口，定义readResolve()方法返回对象，具体原理不太清楚
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *  在反序列化的时候用readResolve()中返回的对象直接替换在反序列化过程中创建的对象
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *  private Object readResolve() throws ObjectStreamException {
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *     return instance;
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; *  }
&lt;/span&gt;&lt;span class=&#34;cm&#34;&gt; */&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;简单工厂模式&#34;&gt;简单工厂模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;创建型模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主要解决接口选择问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行，还有另一种工厂需要用到单例，通过在静态代码块里先初始化好对象，然后+key放到map里&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;util.Calendar、util.ResourceBundle、text.NumberFormat、nio.charset.Charset、util.EnumSet、DI容器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用场景：当有一段需要通过if-else的代码来判断初始化哪些对象的时候，就可考虑&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;优点：调用者只需要知道名字就能创建对象，不关心对象的具体实现；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缺点：数量太多会导致 if-else 膨胀，每次有新的对象要加入工厂需要需改工厂方法，不符合开闭原则&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e5%b7%a5%e5%8e%82%e6%a8%a1%e5%bc%8f.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;工厂模式例子类图&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;工厂模式例子类图&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 接口
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Shape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 实体,工厂生产的产品
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Circle&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;circle draw&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Rectangle&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Rectangle draw&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 工厂
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ShapeFactory&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    
   &lt;span class=&#34;c1&#34;&gt;//使用 getShape 方法获取形状类型的对象, 生产产品的方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shapeType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shapeType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
         &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;        
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shapeType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;CIRCLE&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)){&lt;/span&gt;
         &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Circle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shapeType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;RECTANGLE&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)){&lt;/span&gt;
         &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Rectangle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 例子
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;FactoryPatternDemo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 创建工厂
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;ShapeFactory&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shapeFactory&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ShapeFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;//获取 Circle 的对象，并调用它的 draw 方法， 接口装载子类对象
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shape1&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shapeFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;CIRCLE&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;shape1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// circle draw
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;//获取 Rectangle 的对象，并调用它的 draw 方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shape2&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shapeFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;RECTANGLE&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;shape2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;//Rectangle draw
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;工厂模式&#34;&gt;工厂模式&lt;/h3&gt;
&lt;p&gt;优点：调用方不需要负责对象的创建，明确了各个类的职责；如果有新对象增加，只需要增加一个具体的类和具体的工厂即可；解决简单工厂有大量 if-else 问题；&lt;/p&gt;
&lt;p&gt;缺点：每次有新对象都要写一套 类 和 工厂类，每个类都要有对应的工厂类，代码量很大；&lt;/p&gt;
&lt;p&gt;感觉跟简单工厂模式的差别就是工厂模式是先创建对象工厂，再创建对象，简单工厂模式是直接通过工厂创建对象，前者需要知道对象工厂的名字，后者需要对象名字；&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;AnimalFactory&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 可以获取任何的宠物
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;n&#34;&gt;Animal&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;createAnimal&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;CatFactory&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AnimalFactory&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// 创建猫
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Animal&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;createAnimal&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Cat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;DogFactory&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AnimalFactory&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 创建狗
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Animal&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;createAnimal&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Dog&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// ------------
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Animal&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 所有的动物都会吃东西
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;eat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Cat&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Animal&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 猫喜欢吃鱼
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;eat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;猫吃鱼&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Dog&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Animal&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
	&lt;span class=&#34;c1&#34;&gt;// 狗喜欢吃肉
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	&lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
	&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;eat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
		&lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;狗吃肉&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
	&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 例子
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;FactoryPatternDemo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
       &lt;span class=&#34;c1&#34;&gt;// 需要事先知道要用什么工厂，工厂只生产一种对象
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;       &lt;span class=&#34;n&#34;&gt;AnimalFactory&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DogFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
       &lt;span class=&#34;n&#34;&gt;Animal&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;f&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;createAnimal&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
       &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;eat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
       
       &lt;span class=&#34;n&#34;&gt;AnimalFactory&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ff&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CatFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
       &lt;span class=&#34;n&#34;&gt;Animal&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aa&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ff&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;createAnimal&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
       &lt;span class=&#34;n&#34;&gt;aa&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;eat&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;抽象工厂模式&#34;&gt;抽象工厂模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;与工厂模式类似，也创建型模式&lt;/li&gt;
&lt;li&gt;工厂方法是一个工厂，根据传入参数生产不同实例，而抽象工厂则加多一层工厂获取。抽象工厂属于大工厂，根据传入参数产生工厂实例，在通过这个工厂，传入参数获取对象实例&lt;/li&gt;
&lt;li&gt;跟工厂模式的差别，抽象工厂模式先通过抽象工厂生产工厂，再通过工厂生产对象&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;91
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Rectangle&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Inside Rectangle::draw() method.&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Square&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Inside Square::draw() method.&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// ---------------
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Color&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fill&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Red&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Color&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fill&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Inside Red::fill() method.&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Green&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Color&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fill&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Inside Green::fill() method.&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// -------------
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;AbstractFactory&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Color&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getColor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;color&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ShapeFactory&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AbstractFactory&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shapeType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shapeType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
         &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;        
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shapeType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;CIRCLE&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)){&lt;/span&gt;
         &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Circle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;shapeType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;RECTANGLE&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)){&lt;/span&gt;
         &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Rectangle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Color&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getColor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;color&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ColorFactory&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AbstractFactory&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;shapeType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Color&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getColor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;color&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;color&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
         &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;        
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;color&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;RED&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)){&lt;/span&gt;
         &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Red&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;color&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;GREEN&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)){&lt;/span&gt;
         &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Green&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;FactoryProducer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AbstractFactory&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;choice&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;choice&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;SHAPE&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)){&lt;/span&gt;
         &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ShapeFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;choice&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;COLOR&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)){&lt;/span&gt;
         &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ColorFactory&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;建造者模式&#34;&gt;建造者模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;其实就是链式调用，主要为了&lt;strong&gt;解决构造方法参数过多&lt;/strong&gt;，且需要校验的情况下，如果参数过多且需要校验，使用构造方法或者set方法来实例化对象不太方便，同时，使用建造者模式还可以把对象处理成初始化后属性不可变得对象&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工厂模式是用来创建不同但是相关类型的对象&lt;/strong&gt;（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式是用来创建一种类型的复杂对象，可以通过设置不同的可选参数，“定制化”地创建不同的对象&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;81
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ResourcePoolConfig&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxTotal&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxIdle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minIdle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ResourcePoolConfig&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Builder&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;maxTotal&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;maxTotal&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;maxIdle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;maxIdle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;minIdle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;minIdle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;//...省略getter方法...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 建议此处把builder设置为内部类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Builder&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// default value
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DEFAULT_MAX_TOTAL&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DEFAULT_MAX_IDLE&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;8&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DEFAULT_MIN_IDLE&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxTotal&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DEFAULT_MAX_TOTAL&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxIdle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DEFAULT_MAX_IDLE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minIdle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DEFAULT_MIN_IDLE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ResourcePoolConfig&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;StringUtils&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;isBlank&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;...&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maxIdle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxTotal&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;...&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;minIdle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxTotal&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minIdle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxIdle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;...&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ResourcePoolConfig&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Builder&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;setName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;StringUtils&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;isBlank&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;))&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;...&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Builder&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;setMaxTotal&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxTotal&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maxTotal&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;...&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;maxTotal&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxTotal&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Builder&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;setMaxIdle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxIdle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maxIdle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;...&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;maxIdle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maxIdle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Builder&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;setMinIdle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minIdle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;minIdle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
        &lt;span class=&#34;k&#34;&gt;throw&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IllegalArgumentException&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;...&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;minIdle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;minIdle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 调用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;FactoryPatternDemo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
 
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   		&lt;span class=&#34;c1&#34;&gt;// 这段代码会抛出IllegalArgumentException，因为minIdle&amp;gt;maxIdle
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ResourcePoolConfig&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;config&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ResourcePoolConfig&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;Builder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;dbconnectionpool&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setMaxTotal&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;16&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setMaxIdle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setMinIdle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;12&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
        &lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;build&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;原型模式&#34;&gt;原型模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;其实就是拷贝，把对于那些创建成本较大(比如创建要进行复杂计算、IO读取等)且同一类但不同对象得对象，利用原有对象进行拷贝，来达到创建新对象的目的&lt;/li&gt;
&lt;li&gt;常见方式有序列化再反序列化，或者递归遍历对象里的字段进行创建和赋值，深拷贝或者浅拷贝，这里要注意浅拷贝和深拷贝问题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;结构型&#34;&gt;结构型&lt;/h2&gt;
&lt;h3 id=&#34;代理模式&#34;&gt;代理模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构型模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过代理类扩展被代理类的能力，代理类和被代理类实现同一接口，重写其中的方法，在代理类中传入被代理类的实例，在两者相同的方法中，调用被代理类的该方法，同时可以处理其他逻辑，达到扩展的能力&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;1、和适配器模式的区别：适配器模式主要是两个代表不同维度的接口，它们的实现通过组合的方式扩展原来的功能，而代理模式是代理类和被代理类实现相同的接口，通过代理类调用被代理类相同的方法来达到对代理类补充的作用。&lt;/p&gt;
&lt;p&gt;2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;下面的例子属于静态代理，其他代理请看&lt;a class=&#34;link&#34; href=&#34;https://github.com/Nixum/Java-Note/raw/master/Spring.md&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;动态代理和CGLIB代理&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e4%bb%a3%e7%90%86%e6%a8%a1%e5%bc%8f.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;代理模式例子&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;代理模式例子&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 代理类和被代理类的接口
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Image&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;display&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 被代理类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;RealImage&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Image&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;RealImage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;fileName&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;loadFromDisk&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;display&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Displaying &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;loadFromDisk&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Loading &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 代理类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ProxyImage&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Image&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RealImage&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;realImage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ProxyImage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;fileName&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; 
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ProxyImage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;RealImage&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;realImage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;realImage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;realImage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;display&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;realImage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;==&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
         &lt;span class=&#34;c1&#34;&gt;// 可以选择在这里延迟加载 或者 在构造方法的时候加载 被代理类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;         &lt;span class=&#34;n&#34;&gt;realImage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RealImage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 在调用被代理类同名方法前后做其他操作
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;realImage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;display&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 使用时
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ProxyPatternDemo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;Image&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;image&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ProxyImage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;test_10mb.jpg&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt; 
      &lt;span class=&#34;c1&#34;&gt;// 图像将从磁盘加载
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;display&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt; 		&lt;span class=&#34;c1&#34;&gt;// Loading test_10mb.jpg /n Displaying test_10mb.jpg
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 图像不需要从磁盘加载
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;image&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;display&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;  	&lt;span class=&#34;c1&#34;&gt;// Displaying test_10mb.jpg
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;装饰器模式&#34;&gt;装饰器模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构型模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;装饰类向被装饰类添加新功能，同时又不改变其结构，作为现被装饰类的包装，继承的一种代替，主要解决多层次继承的问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;装饰类和被装饰类可以独立发展，不会相互耦合&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;跟代理模式很像，本质上代码差别不大，只是意图不太一样。&lt;/p&gt;
&lt;p&gt;区别：&lt;strong&gt;装饰器可以一层一层装饰，每次装饰可以增强或扩展被装饰者的功能&lt;/strong&gt;，功能是相关的，是对功能的增强。外部是知道具体的被装饰者的（对装饰器传入被装饰对象），然后不断通过装饰达到对原有功能的增强。&lt;/p&gt;
&lt;p&gt;而&lt;strong&gt;代理模式是一层&lt;/strong&gt;，代理类控制被代理类，控制被代理对象的访问，外部并不关心被代理的对象是谁（被代理类是在代理类内部进行构造，不从外部传入），只知道通过代理对象可以实现对被代理对象的功能补充，是&lt;strong&gt;对代理对象的功能补充，直接加强&lt;/strong&gt;。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;最典型的例子就是IO类了，每个io类都继承了in/outputStream(带了默认实现)，同时又持有in/outputStream，调用的本质还是在调持有的in/outputStream方法的基础上进行增强&lt;/p&gt;
&lt;p&gt;题外话，为啥BufferedInputStream不直接继承InputStream，而是继承FileInputStream？&lt;/p&gt;
&lt;p&gt;原因是如果BufferInputStream继承并同时持有inputStream，由于BufferedInputStream只对部分方法增加buffer功能，对那些不需要增强的方法的调用就需要显式调用持有的inputStream，而如果先通过FileInputStream继承并组合InputStream，并调用持有的inputStream的默认实现，就不用写这部分多余的代码了&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e8%a3%85%e9%a5%b0%e6%a8%a1%e5%bc%8f.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e8%a3%85%e9%a5%b0%e6%a8%a1%e5%bc%8f.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;装饰模式例子&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;装饰模式例子&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;接口Shape表示形状，它的实现类是圆Circle类，统一的抽象装饰类ShapeDecorator，带有Shape类的引用，其 实现的装饰类RedShapeDecorator通过传入具体的形状实例，来对共同的方法做增强&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 接口，作为被装饰类的接口
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 实现类，作为被装饰类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Circle&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; 
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Shape: Circle&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 接口的抽象装饰类，对非增强方法带有默认实现
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ShapeDecorator&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decoratedShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;c1&#34;&gt;// 每一个装饰器都需要一个被装饰引用，因此需要一个抽象父类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ShapeDecorator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decoratedShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;decoratedShape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decoratedShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; 
   &lt;span class=&#34;c1&#34;&gt;// 装饰器类单独使用的默认方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;decoratedShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;  
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 装饰类，装饰成红色
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;RedShapeDecorator&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ShapeDecorator&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;RedShapeDecorator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decoratedShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;kd&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;decoratedShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;     
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; 
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;decoratedShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;         
      &lt;span class=&#34;n&#34;&gt;setRedBorder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;decoratedShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;setRedBorder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decoratedShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Border Color: Red&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 装饰类，加深颜色
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;DarkRedShapeDecorator&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ShapeDecorator&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;DarkRedShapeDecorator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decoratedShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;kd&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;decoratedShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;     
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; 
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;decoratedShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;         
      &lt;span class=&#34;n&#34;&gt;setDarkRedBorder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;decoratedShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;setDarkRedBorder&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;decoratedShape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Border Color: DarkRed&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 调用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;DecoratorPatternDemo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
 
      &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;circle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Circle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt; 
      &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redCircle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RedShapeDecorator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;circle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;darkRedCircle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DarkRedShapeDecorator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;redCircle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
       
      &lt;span class=&#34;n&#34;&gt;circle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;		&lt;span class=&#34;c1&#34;&gt;// Shape: Circle
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;redCircle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;		&lt;span class=&#34;c1&#34;&gt;// Border Color: Red
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;darkRedCircle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// Border Color: DarkRed
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;适配器模式&#34;&gt;适配器模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;结构型模式&lt;/li&gt;
&lt;li&gt;接口适配器使得实现了不同接口的类可以通过适配器的选择而工作，主要是规避接口不兼容的问题，本质是使用一组类和接口充当适配器，包在被适配的类和接口上，具体又是实现或组合&lt;/li&gt;
&lt;li&gt;典型例子：Arrays#asList()，Collections#list()，Collections#enumeration()&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e9%80%82%e9%85%8d%e5%99%a8%e6%a8%a1%e5%bc%8f.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e9%80%82%e9%85%8d%e5%99%a8%e6%a8%a1%e5%bc%8f.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;适配器模式&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;适配器模式&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;有两个接口AdvancedMediaPlayer和MediaPlayer，它们都有不同的作用，但它们的作用又很相似，AdvancedMediaPlayer可以播放vlc格式或者mp4格式，而MediaPlayer只能单纯的播放，多接口适配&lt;/p&gt;
&lt;p&gt;如果想要让MediaPlayer能播放不同格式的音乐，就需要适配了，适配器实现MediaPlayer接口，根据传入的参数来判断需要实例化哪种播放器，并在播放方法里执行相应播放器的播放方法&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;89
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;90
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;91
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;92
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;93
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;94
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;95
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// AdvancedMediaPlayer接口
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;AdvancedMediaPlayer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; 
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;playVlc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;playMp4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// AdvancedMediaPlayer实现类 VlcPlayer
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;VlcPlayer&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AdvancedMediaPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;playVlc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Playing vlc file. Name: &amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;      
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; 
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;playMp4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;//什么也不做
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// AdvancedMediaPlayer实现类 Mp4Player
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Mp4Player&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AdvancedMediaPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;playVlc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;//什么也不做
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;playMp4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Playing mp4 file. Name: &amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;      
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// MediaPlayer接口
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MediaPlayer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;play&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;audioType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// MediaPlayer适配器，实现了从 AdvancedMediaPlayer接口 到 MediaPlayer接口 的转换
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;MediaAdapter&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MediaPlayer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
 
   &lt;span class=&#34;n&#34;&gt;AdvancedMediaPlayer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;advancedMusicPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
 
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;MediaAdapter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;audioType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;audioType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;vlc&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
         &lt;span class=&#34;n&#34;&gt;advancedMusicPlayer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;VlcPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;       
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;audioType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;mp4&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)){&lt;/span&gt;
         &lt;span class=&#34;n&#34;&gt;advancedMusicPlayer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Mp4Player&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;  
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
 
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;play&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;audioType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;audioType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;vlc&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)){&lt;/span&gt;
         &lt;span class=&#34;n&#34;&gt;advancedMusicPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;playVlc&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;audioType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;mp4&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)){&lt;/span&gt;
         &lt;span class=&#34;n&#34;&gt;advancedMusicPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;playMp4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 适配器使用类，从而不用关心 被适配接口 的具体实现类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;AudioPlayer&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MediaPlayer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;n&#34;&gt;MediaAdapter&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mediaAdapter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt; 
 
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;play&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;audioType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;    
      &lt;span class=&#34;c1&#34;&gt;//播放 mp3 音乐文件的内置支持
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;audioType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;mp3&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)){&lt;/span&gt;
         &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Playing mp3 file. Name: &amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;         
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; 
      &lt;span class=&#34;c1&#34;&gt;//mediaAdapter 提供了播放其他文件格式的支持
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;audioType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;vlc&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;||&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;audioType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;equalsIgnoreCase&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;mp4&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)){&lt;/span&gt;
         &lt;span class=&#34;n&#34;&gt;mediaAdapter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MediaAdapter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;audioType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
         &lt;span class=&#34;n&#34;&gt;mediaAdapter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;play&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;audioType&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileName&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
         &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Invalid media. &amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;
            &lt;span class=&#34;n&#34;&gt;audioType&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34; format not supported&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;   
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 调用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;AdapterPatternDemo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;AudioPlayer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;audioPlayer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AudioPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
 
      &lt;span class=&#34;n&#34;&gt;audioPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;play&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;mp3&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;beyond the horizon.mp3&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;	
      &lt;span class=&#34;c1&#34;&gt;// Playing mp3 file. Name: beyond the horizon.mp3
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;       
      &lt;span class=&#34;n&#34;&gt;audioPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;play&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;mp4&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;alone.mp4&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// Playing mp4 file. Name: alone.mp4
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;       
      &lt;span class=&#34;n&#34;&gt;audioPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;play&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;vlc&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;far far away.vlc&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// Playing vlc file. Name: far far away.vlc
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;       
      &lt;span class=&#34;n&#34;&gt;audioPlayer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;play&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;avi&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;mind me.avi&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
       &lt;span class=&#34;c1&#34;&gt;// Invalid media. avi format not supported
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;其他例子，以下例子来自极客时间-设计模式之美，都是单接口适配&lt;/p&gt;
&lt;p&gt;1、封装外部sdk接口&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;CD&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//这个类来自外部sdk，我们无权修改它的代码
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;staticFunction1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//... }
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;uglyNamingFunction2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//... }
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;tooManyParamsFunction3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;paramA&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;paramB&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//... }
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;lowPerformanceFunction4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//... }
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;使用适配器模式进行重构&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ITarget&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fucntion3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ParamsWrapperDefinition&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;paramsWrapper&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;//...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 注意：适配器类的命名不一定非得末尾带Adaptor
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;CDAdaptor&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CD&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ITarget&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;//...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
     &lt;span class=&#34;kd&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;staticFunction1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
  
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;kd&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;uglyNamingFucntion2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
  
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ParamsWrapperDefinition&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;paramsWrapper&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
     &lt;span class=&#34;kd&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;tooManyParamsFunction3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;paramsWrapper&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getParamA&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(),&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;...);&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
  
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;function4&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//...reimplement it...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;2、统一多个类的接口&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ASensitiveWordsFilter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// A敏感词过滤系统提供的接口
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;//text是原始文本，函数输出用***替换敏感词之后的文本
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;filterSexyWords&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;// ...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;BSensitiveWordsFilter&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// B敏感词过滤系统提供的接口
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;CSensitiveWordsFilter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// C敏感词过滤系统提供的接口
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;mask&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;RiskManagement&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ASensitiveWordsFilter&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aFilter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ASensitiveWordsFilter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BSensitiveWordsFilter&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bFilter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BSensitiveWordsFilter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CSensitiveWordsFilter&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cFilter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;CSensitiveWordsFilter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
  
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;filterSensitiveWords&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maskedText&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aFilter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;filterSexyWords&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;maskedText&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;bFilter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maskedText&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;maskedText&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;cFilter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maskedText&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;***&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maskedText&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 使用适配器模式进行改造
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ISensitiveWordsFilter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 统一接口定义
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ASensitiveWordsFilterAdaptor&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ISensitiveWordsFilter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ASensitiveWordsFilter&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aFilter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maskedText&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aFilter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;filterSexyWords&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;maskedText&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;aFilter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;filterPoliticalWords&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maskedText&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maskedText&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;//...省略BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;RiskManagement&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; 
  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ISensitiveWordsFilter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filters&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&amp;gt;();&lt;/span&gt;
 
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;addSensitiveWordsFilter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ISensitiveWordsFilter&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;filters&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
  
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;filterSensitiveWords&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maskedText&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;text&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ISensitiveWordsFilter&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filters&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;maskedText&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;filter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;maskedText&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
    &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;maskedText&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;3、替换依赖的外部系统&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;o&#34;&gt;/&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;外部系统A&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;IA&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;//...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fa&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;A&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IA&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;//...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fa&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;//... }
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 在我们的项目中，外部系统A的使用示例
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Demo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IA&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Demo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;IA&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;c1&#34;&gt;//...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;Demo&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Demo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;A&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 将外部系统A替换成外部系统B
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;BAdaptor&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;implemnts&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;IA&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;BAdaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;B&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;fa&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
    &lt;span class=&#34;c1&#34;&gt;//...
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;fb&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
  &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 借助BAdaptor，Demo的代码中，调用IA接口的地方都无需改动，
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;// 只需要将BAdaptor如下注入到Demo即可。
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Demo&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;d&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Demo&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BAdaptor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;B&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()));&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;桥接模式&#34;&gt;桥接模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;结构型模式&lt;/li&gt;
&lt;li&gt;抽象与实现分离，桥接接口类和抽象类，实现解耦，这里其实并不一定是要抽象类，抽象类只是代表一组现实的抽象，即一个类存在两个（或多个）独立变化的维度，通过组合的方式，让这两个（或多个）维度可以独立进行扩展&lt;/li&gt;
&lt;li&gt;典型例子：JDBC，仅修改Class.forName(&amp;ldquo;com.mysql.jdbc.Driver&amp;rdquo;)，即可把驱动换成别的数据库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JDBC的做法是提供Driver接口，数据库厂商实现该接口提供不同的数据库能力，并调用DriverManager进行注册，后续通过DriverManager获取connection并进行CRUD操作，都由DriverManager委派给具体的Driver做&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e6%a1%a5%e6%8e%a5%e6%a8%a1%e5%bc%8f.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e6%a1%a5%e6%8e%a5%e6%a8%a1%e5%bc%8f.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;桥接模式例子&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;桥接模式例子&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;桥接接口类和抽象类，接口类实现上色，抽象类实现形状，在抽象类中引入接口，通过不同的组合实现不同的功能&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 桥接实现接口， 连接 画 和 上色
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;DrawAPI&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;drawCircle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;radius&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 不同实现类，红色
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;RedCircle&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DrawAPI&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;drawCircle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;radius&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Drawing Circle[ color: red, radius: &amp;#34;&lt;/span&gt;
         &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;radius&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;, x: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;, &amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;]&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 使用 DrawAPI 接口创建抽象类 Shape
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DrawAPI&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;drawAPI&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Shape&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;DrawAPI&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;drawAPI&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;drawAPI&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;drawAPI&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;  
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// Shape不同得实现类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Circle&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;radius&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
    
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;Circle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;radius&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DrawAPI&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;drawAPI&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;kd&#34;&gt;super&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;drawAPI&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;x&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;y&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;radius&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;radius&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; 
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;drawAPI&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;drawCircle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;radius&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;x&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;y&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 调用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;BridgePatternDemo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;Shape&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;redCircle&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Circle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;100&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;RedCircle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;());&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;redCircle&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;draw&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// Drawing Circle[ color: red, radius: 10, x: 100, 100]
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;代理模式桥接模式装饰器模式适配器模式的区别&#34;&gt;代理模式、桥接模式、装饰器模式、适配器模式的区别&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;**代理模式：**代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同。&lt;/p&gt;
&lt;p&gt;**桥接模式：**桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变。&lt;/p&gt;
&lt;p&gt;**装饰器模式：**装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用。&lt;/p&gt;
&lt;p&gt;**适配器模式：**适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实这几种设计模式在代码层面上是很相似的，本质只是设计意图的不同，应对的场景不同&lt;/p&gt;
&lt;h3 id=&#34;门面外观模式&#34;&gt;门面(外观)模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;结构型模式&lt;/li&gt;
&lt;li&gt;本质是对接口的组合，比如有子系统或者子模块提供了b、c、d接口，都是些职责比较单一的接口，可以在上层提供一个大而全的接口，使用到了b、c、d接口提供的功能，简化了调用者的调用关系处理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;组合模式&#34;&gt;组合模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;结构型模式&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;本质是多叉树，根节点和子节点继承或实现同一个接口，以方便递归处理树形结构的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主要处理树形结构数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;享元模式&#34;&gt;享元模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;结构型模式&lt;/li&gt;
&lt;li&gt;享元，即共享单元，一般是通过复用不可变对象达到节省内存的作用，通过map + 工厂模式来达到复用的目的，但是对于GC并不友好，如果该对象并不常用，也可以使用弱引用或软引用相关的hashMap来存储，方便垃圾回收&lt;/li&gt;
&lt;li&gt;典型例子：java中的Integer类，对于多个-128~127的包装类型对象，底层的内存地址是同一个，Integer类里有个IntegerCache内部类，相当于享元对象的工厂，缓存着-128~127之间的数据，类似的，如 Long、 Short、 Byte包装类型也用到了这种方法；还有String类的字符串常量池，会缓存string字面量，String类也提供了intern方法方便我们将字符串存入常量池&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;行为型&#34;&gt;行为型&lt;/h2&gt;
&lt;h3 id=&#34;责任链模式&#34;&gt;责任链模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;行为型模式&lt;/li&gt;
&lt;li&gt;每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推，即：将所有接受者连成一条链，请求沿着这条链传递，直到有对象处理&lt;/li&gt;
&lt;li&gt;典型例子：servlet filter、spring interceptor、logger&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e8%b4%a3%e4%bb%bb%e9%93%be%e6%a8%a1%e5%bc%8f.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e8%b4%a3%e4%bb%bb%e9%93%be%e6%a8%a1%e5%bc%8f.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;责任链模式例子&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;责任链模式例子&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;这是模拟日志级别打印的例子：日志抽象类规定每个结点的日志等级和需要重写的方法，参数传递处理的方法，可以看成一个链表上结点的抽象；具体的类实现该抽象类重写共同方法当成每一个结点，最后将这些结点连成链即可&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;72
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;73
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;74
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;75
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;76
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;77
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;78
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;79
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;80
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;81
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;82
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;83
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;84
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;85
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;86
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;87
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;88
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;89
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 创建抽象的记录器类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;AbstractLogger&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
 
   &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
 
   &lt;span class=&#34;c1&#34;&gt;// 责任链中的下一个元素
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AbstractLogger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nextLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
 
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;setNextLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;AbstractLogger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nextLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;nextLogger&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;nextLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;c1&#34;&gt;// 判断是否由当前结点处理或者交由下个结点处理
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;logMessage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 根据leve判断
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;level&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
         &lt;span class=&#34;n&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;nextLogger&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
         &lt;span class=&#34;n&#34;&gt;nextLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;logMessage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt; 
   &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 日志等级
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;LoggerLevel&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;INFO&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;DEBUG&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ERROR&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 记录类的实现类，链上的结点
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ConsoleLogger&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AbstractLogger&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; 
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ConsoleLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;level&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;    
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Standard Console::Logger: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;FileLogger&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AbstractLogger&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;FileLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;level&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;    
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;File::Logger: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ErrorLogger&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AbstractLogger&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;ErrorLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;level&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;level&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;write&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;    
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Error Console::Logger: &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;message&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 创建链
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ChainPatternDemo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   
   &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;AbstractLogger&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getChainOfLoggers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 创建每一个结点，设定每个结点的level
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;AbstractLogger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;errorLogger&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ErrorLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LoggerLevel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;ERROR&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;AbstractLogger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;fileLogger&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;FileLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LoggerLevel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;DEBUG&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;AbstractLogger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;consoleLogger&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ConsoleLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LoggerLevel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;INFO&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
 	  &lt;span class=&#34;c1&#34;&gt;// 形成链
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;errorLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setNextLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;fileLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;fileLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setNextLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;consoleLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
 	  &lt;span class=&#34;c1&#34;&gt;// 返回头结点
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;errorLogger&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;  
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
 
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;AbstractLogger&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;loggerChain&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;getChainOfLoggers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 每个结点根据创建来的参数来判断是否执行或者交由下一个结点
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;loggerChain&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;logMessage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LoggerLevel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;INFO&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;This is an information.&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 输出： Standard Console::Logger: This is an information.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;loggerChain&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;logMessage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LoggerLevel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;DEBUG&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;This is an debug level information&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 输出：
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;c1&#34;&gt;// File::Logger: This is an debug level information.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	  &lt;span class=&#34;c1&#34;&gt;// Standard Console::Logger: This is an debug level information.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;loggerChain&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;logMessage&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;LoggerLevel&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;ERROR&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;This is an error information.&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;// 输出：
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	  &lt;span class=&#34;c1&#34;&gt;// Error Console::Logger: This is an error information.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	  &lt;span class=&#34;c1&#34;&gt;// File::Logger: This is an error information.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	  &lt;span class=&#34;c1&#34;&gt;// Standard Console::Logger: This is an error information.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;迭代器模式&#34;&gt;迭代器模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;行为型模式&lt;/li&gt;
&lt;li&gt;用于顺序访问集合对象的元素，不需要知道集合对象的底层表示，不会暴露该对象的内部表示，迭代器内部使用游标记录当前位置信息，每个迭代器独享游标信息，这样当我们创建不同的迭代器对不同的容器进行遍历的时候就不会互相影响&lt;/li&gt;
&lt;li&gt;针对复杂的数据结构，比如树、图的遍历，使用迭代器模式会更加有效&lt;/li&gt;
&lt;li&gt;对于迭代过程中通过对容器增加或删除元素会有问题， java使用fail-fast机制，即遍历每个元素的时候会比较modCount的值和调用迭代器时的expectedModCount的值比较来实现fail-fast，达到报错的目的。此外，如果想要删除，需要通过迭代器来删除才可以，java中使用lastRet变量来记录上一个游标，以保证在删除当前元素后，游标能正确指向。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e8%bf%ad%e4%bb%a3%e5%99%a8%e6%a8%a1%e5%bc%8f.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e8%bf%ad%e4%bb%a3%e5%99%a8%e6%a8%a1%e5%bc%8f.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;迭代器模式例子&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;迭代器模式例子&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 迭代器接口
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Iterator&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;hasNext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 集合接口
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;interface&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Container&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Iterator&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getIterator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 包含有迭代器的集合
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;NameRepository&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Container&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;names&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Robert&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;John&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;,&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Julie&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Lora&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;};&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Iterator&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getIterator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NameIterator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;c1&#34;&gt;// 内部类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;NameIterator&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;implements&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Iterator&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
      &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;boolean&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;hasNext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
         &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;names&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;true&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
         &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
         &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;false&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
      &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
      &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Object&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
         &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;hasNext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()){&lt;/span&gt;
            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;names&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;index&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;++];&lt;/span&gt;
         &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
         &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;     
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 调用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;IteratorPatternDemo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
       
      &lt;span class=&#34;n&#34;&gt;NameRepository&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;namesRepository&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;NameRepository&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 创建集合
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Iterator&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iter&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;namesRepository&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getIterator&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;iter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;hasNext&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();){&lt;/span&gt;
         &lt;span class=&#34;n&#34;&gt;String&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;iter&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;next&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
         &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Name : &amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;name&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;  
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;访问者模式&#34;&gt;访问者模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;行为型&lt;/li&gt;
&lt;li&gt;允许一个或者多个操作应用到一组对象上，解耦操作和对象本身，比如对于多种文件类型，可以使用多种不同的执行器作用在不同的文件上&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;备忘录模式快照&#34;&gt;备忘录模式（快照）&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;行为型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一般栈来保存副本，入栈的元素都会叠加上一个元素的内容，以此来实现顺序撤销和恢复功能&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;主要是用来防丢失、撤销、恢复&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;状态模式&#34;&gt;状态模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;行为型&lt;/li&gt;
&lt;li&gt;状态 -&amp;gt; 事件 -&amp;gt; 动作 -&amp;gt; 状态改变 或者 状态 -&amp;gt; 事件 -&amp;gt; 状态改变 -&amp;gt; 动作&lt;/li&gt;
&lt;li&gt;分支逻辑法 或者 查表法 或 通过将分支判断抽成类来实现上述 当状态接收到事件后进行业务逻辑动作后改变状态&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;观察者模式&#34;&gt;观察者模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;行为型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在一对多关系中，当一个对象被修改时，则会自动通知它的依赖对象&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;典型例子：消息队列的发布/订阅模型&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;硬要说的话，观察者模式和发布订阅模式还是有一定差别的&lt;/p&gt;
&lt;p&gt;观察者是当被观察者有状态发生改变时，通知观察者；而发布订阅是发布者把消息丢到消息队列，消息队列根据消息发给对应的订阅者，区别就是有没有第三方存在，消息的双方知不知道彼此的存在&lt;/p&gt;
&lt;p&gt;发布订阅：&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e8%a7%82%e5%af%9f%e8%80%85%e6%a8%a1%e5%bc%8f.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;观察者模式例子&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;观察者模式例子&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;43
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;44
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;45
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;46
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;47
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;48
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;49
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;50
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;51
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;52
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;53
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;54
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;55
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;56
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;57
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;58
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;59
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;60
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;61
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;62
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;63
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;64
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;65
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;66
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;67
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;68
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;69
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;70
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;71
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 被观察者，当状态发生改变时，通知观察者
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Subject&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;c1&#34;&gt;// 观察者队列
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Observer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;observers&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ArrayList&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Observer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;&amp;gt;();&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;	&lt;span class=&#34;c1&#34;&gt;// 状态
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt; 
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;getState&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;c1&#34;&gt;// 状态改变时通知观察者
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;setState&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;state&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;state&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;notifyAllObservers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;c1&#34;&gt;// 绑定观察者
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;attach&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Observer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;observer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;observers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;add&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;observer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;      
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;c1&#34;&gt;// 通知观察者，执行观察者方法
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;notifyAllObservers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Observer&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;observer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;observers&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
         &lt;span class=&#34;n&#34;&gt;observer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;  
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 观察者抽象类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Observer&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;protected&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Subject&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;subject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 观察者实现类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;BinaryObserver&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Observer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt; 
   &lt;span class=&#34;c1&#34;&gt;// 绑定被观察者
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;BinaryObserver&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Subject&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;subject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;subject&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;subject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;subject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;attach&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;c1&#34;&gt;// 执行观察者类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Binary String:&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;toBinaryString&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;subject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getState&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;));&lt;/span&gt; 
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 观察者实现类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;OctalObserver&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Observer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;c1&#34;&gt;// 绑定被观察者
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;OctalObserver&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Subject&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;subject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;){&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;subject&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;subject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;;&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;subject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;attach&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;c1&#34;&gt;// 执行观察者类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;update&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
     &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Octal String:&amp;#34;&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Integer&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;toOctalString&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;subject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;getState&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()));&lt;/span&gt; 
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;

&lt;span class=&#34;c1&#34;&gt;// 调用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;ObserverPatternDemo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;Subject&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;subject&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Subject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;OctalObserver&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;subject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
      &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;BinaryObserver&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;subject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
 
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;First state change: 15&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;   
      &lt;span class=&#34;n&#34;&gt;subject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setState&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;15&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;		&lt;span class=&#34;c1&#34;&gt;// Octal String: 17 /n Binary String: 1111
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Second state change: 10&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;  
      &lt;span class=&#34;n&#34;&gt;subject&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;setState&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;		&lt;span class=&#34;c1&#34;&gt;//Octal String: 12 /n Binary String: 1010
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;模板方法&#34;&gt;模板方法&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;行为型&lt;/li&gt;
&lt;li&gt;一个抽象类抽取一些通用方法合并成新方法并用final修饰作为模板，它的子类继承此抽象类，通过重写通用方法，来实现不一样的模板方法&lt;/li&gt;
&lt;li&gt;典型例子：JUC包里的AQS和其子类、util.Collections#sort()、InputStream#skip()、InputStream#read()、servlet、junit&lt;/li&gt;
&lt;li&gt;模板方法与回调的区别：回调的作用与模板方法类似，都是通过自由替换某个方法来实现不同的功能，但回调基于组合关系，而模板方法基于继承关系，同步回调类似模板方法，异步回调类似观察者模式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e6%a8%a1%e6%9d%bf%e6%96%b9%e6%b3%95.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/%e6%a8%a1%e6%9d%bf%e6%96%b9%e6%b3%95.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;模板方法例子&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;模板方法例子&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;div class=&#34;chroma&#34;&gt;
&lt;table class=&#34;lntable&#34;&gt;&lt;tr&gt;&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code&gt;&lt;span class=&#34;lnt&#34;&gt; 1
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 2
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 3
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 4
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 5
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 6
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 7
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 8
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt; 9
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;10
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;11
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;12
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;13
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;14
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;15
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;16
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;17
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;18
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;19
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;20
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;21
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;22
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;23
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;24
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;25
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;26
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;27
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;28
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;29
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;30
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;31
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;32
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;33
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;34
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;35
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;36
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;37
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;38
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;39
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;40
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;41
&lt;/span&gt;&lt;span class=&#34;lnt&#34;&gt;42
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class=&#34;lntd&#34;&gt;
&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-java&#34; data-lang=&#34;java&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 抽象模板类
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Game&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;c1&#34;&gt;// 给子类重写
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;initialize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;startPlay&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;abstract&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;endPlay&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
    
   &lt;span class=&#34;c1&#34;&gt;//模板
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;final&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;play&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(){&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;//初始化游戏
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;initialize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;//开始游戏
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;startPlay&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;c1&#34;&gt;//结束游戏
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;n&#34;&gt;endPlay&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 子类继承并重写
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;Cricket&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;extends&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Game&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;endPlay&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Cricket Game Finished!&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;initialize&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Cricket Game Initialized! Start playing.&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
   &lt;span class=&#34;nd&#34;&gt;@Override&lt;/span&gt;
   &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;startPlay&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;System&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;out&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;println&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#34;Cricket Game Started. Enjoy the game!&amp;#34;&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;);&lt;/span&gt;
   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;c1&#34;&gt;// 调用
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;TemplatePatternDemo&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
   &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;nf&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;args&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;{&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;Game&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;game&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Cricket&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
      &lt;span class=&#34;n&#34;&gt;game&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;na&#34;&gt;play&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;();&lt;/span&gt;
	  &lt;span class=&#34;c1&#34;&gt;// Cricket Game Initialized! Start playing.
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	  &lt;span class=&#34;c1&#34;&gt;// Cricket Game Started. Enjoy the game!
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;	  &lt;span class=&#34;c1&#34;&gt;// Cricket Game Finished!    
&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;   &lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;span class=&#34;o&#34;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id=&#34;策略模式&#34;&gt;策略模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;行为型&lt;/li&gt;
&lt;li&gt;通过定义一个通用策略接口 + 一组策略的实现，由调用者在运行时动态选择某一策略完成业务逻辑，常用搭配是 策略 + 工厂模式，根据不同类型选择不同策略&lt;/li&gt;
&lt;li&gt;常用的场景是使用策略模式来避免膨胀的分支判断，缺点是策略类会变多，另外，使用查表法也可避免膨胀的分支判断&lt;/li&gt;
&lt;li&gt;主要解决：将不同算法封装成策略，根据条件选择合适的策略&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;命令模式&#34;&gt;命令模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;行为型&lt;/li&gt;
&lt;li&gt;将函数方法封装成对象，类似c语言的函数指针，数据驱动，将事件和数据封装成对象（命令），最后执行，有点像策略模式，但是命令模式更侧重将行为请求者和实现者解耦&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;解释器模式&#34;&gt;解释器模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;行为型&lt;/li&gt;
&lt;li&gt;针对某种语言制定对应的语法，在代码中的体现是，对某种模式的解析抽成方法，降低代码复杂度&lt;/li&gt;
&lt;li&gt;典型例子：后缀表达式的解析、sql解析、正则表达式解析&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;中介模式&#34;&gt;中介模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;行为型&lt;/li&gt;
&lt;li&gt;引入中间层，将原来多对多的关系转换为一对多的关系，解耦对象间的关系，类似观察者模式，区别在于观察者模式中，数据的流向、对象间的关系是单向的，观察者就是观察者、被观察者就是被观察者，不会轻易改变，而中介模式是由一个中间对象来处理各个对象间的关系，类似数据总线&lt;/li&gt;
&lt;li&gt;典型例子：聊天室&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于EventBus，个人认为它不是中介模式，硬要说话，处理事件的中心类，也算是中介，但是主要是发送事件的对象和处理事件的对象并没有很直接的关系，事件处理者仅关心接收到的是什么事件，并不关心事件是由谁发出的&lt;/p&gt;
&lt;h1 id=&#34;领域驱动模型-ddd&#34;&gt;领域驱动模型 DDD&lt;/h1&gt;
&lt;p&gt;贫血模型，面向过程，业务逻辑和实体分开，实体仅声明需要的属性，业务逻辑的处理发生在service类，实体只用来存数据，比如各种vo、bo、do&lt;/p&gt;
&lt;p&gt;领域驱动模型是一种面向对象的模型、充血模型，更多是用在微服务、业务复杂的场景&lt;/p&gt;
&lt;p&gt;具体表现在 业务逻辑的处理是发生在实体类里，而不是发生在service类里，service类只是对各种vo、bo、do转换成需要的领域对象，对它们进行调度，执行它们的方法来完成业务，service甚至可以不感知领域对象的属性变化，与controller和dao层打交道，解耦流程性代码和业务代码，负责非功能性或者与第三方系统交互的工作，比如分布式事务、邮件、消息、rpc调用等，使得领域对象方法和属性复用性提高，业务更加内聚&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.cnblogs.com/dolphin0520/p/3919839.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;设计模式六大原则&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;http://www.runoob.com/design-pattern/design-pattern-tutorial.html&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;菜鸟|设计模式&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>UML</title>
        <link>http://nixum.cc/p/uml/</link>
        <pubDate>Thu, 11 Jul 2019 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/uml/</guid>
        <description>&lt;p&gt;[TOC]&lt;/p&gt;
&lt;h1 id=&#34;类图&#34;&gt;类图&lt;/h1&gt;
&lt;p&gt;类图中的关系其实有多种版本的表示方法，这里仅总结自己常用的画法&lt;/p&gt;
&lt;h2 id=&#34;访问作用域&#34;&gt;访问作用域&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;+ : public&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;- : private&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;# : protocted&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;关系&#34;&gt;关系&lt;/h2&gt;
&lt;h3 id=&#34;1-依赖dependency&#34;&gt;1. 依赖（dependency）&lt;/h3&gt;
&lt;p&gt;依赖关系是五种关系中耦合最小的一种关系。&lt;/p&gt;
&lt;p&gt;依赖在代码中主要体现为类A的某个成员函数的返回值、形参、局部变量或静态方法的调用，则表示类A引用了类B。&lt;/p&gt;
&lt;p&gt;A &amp;mdash;-&amp;gt; B ： A use B （虚线+箭头）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/UML-use.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/UML-use.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;A use B&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;A use B&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;2-关联association&#34;&gt;2. 关联（Association）&lt;/h3&gt;
&lt;p&gt;在程序代码中，具有关联关系的类常常被声明为类的引用类型的成员变量。&lt;/p&gt;
&lt;p&gt;因为 关联 是 依赖 的更详细说明， 关联 是专门描述成员属性的关系，所以依赖中所有涉及成员属性的地方更适合使用：关联、聚合、组合&lt;/p&gt;
&lt;p&gt;单向关联：&lt;/p&gt;
&lt;p&gt;A ——————&amp;gt; B ： A has B （实心线 + 箭头）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/UML-association.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/UML-association.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;A has B&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;A has B&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;3-聚合aggregation&#34;&gt;3. 聚合（Aggregation）&lt;/h3&gt;
&lt;p&gt;聚合是关联的一种特殊形式，暗含整体/部分关系，但是对方却不是唯一属于自己的那种关系。 用来表示集体与个体之间的关联关系，例如班级与学生之间存在聚合关系。&lt;/p&gt;
&lt;p&gt;A &amp;lt;&amp;gt;—————— B :   A是集体，B是个体 （实线 + 空心菱形）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/UML-aggregation.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/UML-aggregation.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;A是集体，B是个体&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;A是集体，B是个体&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;4-组合composition&#34;&gt;4. 组合（Composition）&lt;/h3&gt;
&lt;p&gt;组合又叫复合，用来表示个体与组成部分之间的关联关系。 在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也不存在，整体对象和成员对象之间具有同生共死的关系。&lt;/p&gt;
&lt;p&gt;A &amp;lt;#&amp;gt;———— B： A是整体，B是部分  （实线线 + 实心菱形）&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/UML-composition.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/UML-composition.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;A是整体，B是部分&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;A是整体，B是部分&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h3 id=&#34;5-泛化&#34;&gt;5. 泛化&lt;/h3&gt;
&lt;h4 id=&#34;51-继承generalization&#34;&gt;5.1 继承（Generalization）&lt;/h4&gt;
&lt;p&gt;A ——————|&amp;gt; B : A继承了B  （实心线 + 空心三角箭头），A is B&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/UML-generalization.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/UML-generalization.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;A继承了B&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;A继承了B&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h4 id=&#34;52-实现implementation&#34;&gt;5.2. 实现（Implementation）&lt;/h4&gt;
&lt;p&gt;A &amp;mdash;&amp;mdash;&amp;mdash;&amp;mdash;&amp;ndash;|&amp;gt; B : A实现了接口B （虚心线 + 空心三角箭头）， A like B&lt;/p&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/UML-implementation.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/UML-implementation.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;A实现了接口B&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;A实现了接口B&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;PS：为了方便，继承和接口实现也都可以用实线加空心三角箭头&lt;/p&gt;
</description>
        </item>
        <item>
        <title>git</title>
        <link>http://nixum.cc/p/git/</link>
        <pubDate>Tue, 26 Feb 2019 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/git/</guid>
        <description>&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/git_flow.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/git_flow.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;git流程&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;git流程&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;常用命令&#34;&gt;常用命令&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;git init&lt;/p&gt;
&lt;p&gt;将一个普通文件夹变成git仓库，此时文件夹下多出.git文件夹，表示可以使用git管理，此时这个文件夹称为git工作区&lt;/p&gt;
&lt;p&gt;或者&lt;/p&gt;
&lt;p&gt;使用git clone url(github上的仓库链接)将仓库从github上下载下来&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;当对工作区内的文件做出修改后&#34;&gt;当对工作区内的文件做出修改后&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;git add 文件名&lt;/p&gt;
&lt;p&gt;表示将该文件的修改加入到暂存区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git add .&lt;/p&gt;
&lt;p&gt;(注意后面有个 . )表示将当前目录下的所有文件的修改都加入到暂存区&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git commit -m &amp;ldquo;备注信息&amp;rdquo;&lt;/p&gt;
&lt;p&gt;表示将暂存区的修改提交到当前分支，提交之后暂存区清空&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git push -u origin master&lt;/p&gt;
&lt;p&gt;将分支上的修改更新到github上&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;撤回修改&#34;&gt;撤回修改&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;git log 查看提交记录，获取commit id&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git reset &amp;ndash; 文件名 或者 commitId&lt;/p&gt;
&lt;p&gt;使用当前分支上的修改覆盖暂存区，用来撤销最后一次 git add files&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git checkout &amp;ndash; 文件名&lt;/p&gt;
&lt;p&gt;使用暂存区的修改覆盖工作目录，用来撤销本地修改&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;删除&#34;&gt;删除&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;git rm 文件名&lt;/p&gt;
&lt;p&gt;删除暂存区和分支上的文件，同时工作区也不需要这个文件，之后commit保存到分支&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;git rm -r &amp;ndash;cached 文件夹名&lt;/p&gt;
&lt;p&gt;删除暂存区的修改，之后再commit保存到分支，如果不小心提交了不想提交的文件到分支上，此时想删除刚刚不小心提交的文件同时保留工作目录的文件时使用&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;更新&#34;&gt;更新&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;git pull origin master&lt;/p&gt;
&lt;p&gt;更新线上修改到本地分支&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;查看状态&#34;&gt;查看状态&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;git status&lt;/p&gt;
&lt;p&gt;可以查看本地和分支哪些文件有修改&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;几个容易混淆的命令&#34;&gt;几个容易混淆的命令&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;git rebase 和 git merge&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;效果都是合并，merge时可以看到被merge的分支以及其提交记录，不破坏被merge分支的代码提交记录；rebase是直接把两个分支合并，被合并的分支就像在原来的分支上开发一样，不会新增提交记录到目标分支，形成线性提交的历史记录。&lt;/p&gt;
&lt;p&gt;合并代码到公共分支的时候使用git merge&lt;/p&gt;
&lt;p&gt;合并代码到个人/功能分支时使用git rebase&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git pull 和 git fetch&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;效果都是更新远程仓库到本地，fetch是将远程仓库的内容拉到本地，用户检查只会再决定是否合并；pull是将远程仓库的内容拉到本地后直接合并，pull = fetch + merge&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;git reset 和 git revert&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;效果都是撤销，reset回退版本会丢失回退前的提交信息，revert则不会，revert会重新创建一个新的提交，新的提交内容是指定的commitId对应的内容，原有的提交得到保留。&lt;/p&gt;
&lt;h3 id=&#34;其他常用命令&#34;&gt;其他常用命令&lt;/h3&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/git_command.png&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/git_command.png&#34;
			
			
			
			loading=&#34;lazy&#34;
			alt=&#34;git命令&#34;&gt;
	&lt;/a&gt;
	
	&lt;figcaption&gt;git命令&lt;/figcaption&gt;
	
&lt;/figure&gt;&lt;/p&gt;
&lt;h2 id=&#34;参考&#34;&gt;参考&lt;/h2&gt;
&lt;p&gt;&lt;a class=&#34;link&#34; href=&#34;https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;廖雪峰 git教程&lt;/a&gt;&lt;/p&gt;
</description>
        </item>
        <item>
        <title>README</title>
        <link>http://nixum.cc/p/readme/</link>
        <pubDate>Tue, 12 Feb 2019 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/readme/</guid>
        <description>&lt;h1 id=&#34;readme&#34;&gt;README&lt;/h1&gt;
&lt;p&gt;&lt;figure 
	&gt;
	&lt;a href=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/cover%5c_book.jpg&#34; &gt;
		&lt;img src=&#34;https://github.com/Nixum/Java-Note/raw/master/picture/cover%5c_book.jpg&#34;
			
			
			
			loading=&#34;lazy&#34;
			&gt;
	&lt;/a&gt;
	
&lt;/figure&gt;\&lt;/p&gt;
&lt;p&gt;为了更好的阅读体验，可前往 &lt;a class=&#34;link&#34; href=&#34;http://nixum.cc&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;个人bolg&lt;/a&gt;、&lt;a class=&#34;link&#34; href=&#34;https://nixum.gitbook.io/note/readme&#34;  target=&#34;_blank&#34; rel=&#34;noopener&#34;
    &gt;gitbook&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;目录&#34;&gt;目录&lt;/h2&gt;
&lt;h3 id=&#34;java&#34;&gt;Java&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Java SE&lt;/li&gt;
&lt;li&gt;JUC&lt;/li&gt;
&lt;li&gt;Java IO&lt;/li&gt;
&lt;li&gt;JVM&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;go&#34;&gt;Go&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Go SE&lt;/li&gt;
&lt;li&gt;Go Goroutine和GC&lt;/li&gt;
&lt;li&gt;Go Context和Channel&lt;/li&gt;
&lt;li&gt;Go Sync&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;框架&#34;&gt;框架&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Spring&lt;/li&gt;
&lt;li&gt;SpringMVC&lt;/li&gt;
&lt;li&gt;MyBatis&lt;/li&gt;
&lt;li&gt;Gin&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;数据存储&#34;&gt;数据存储&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;MySQL&lt;/li&gt;
&lt;li&gt;MongoDB&lt;/li&gt;
&lt;li&gt;Redis&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;微服务与云原生&#34;&gt;微服务与云原生&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Kubernetes&lt;/li&gt;
&lt;li&gt;容器&lt;/li&gt;
&lt;li&gt;etcd 与 ZooKeeper&lt;/li&gt;
&lt;li&gt;微服务&lt;/li&gt;
&lt;li&gt;分布式相关&lt;/li&gt;
&lt;li&gt;RPC与异步设计&lt;/li&gt;
&lt;li&gt;其他&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;消息队列&#34;&gt;消息队列&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;消息队列基本原理&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;计算机网络&#34;&gt;计算机网络&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;网络&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;操作系统&#34;&gt;操作系统&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;操作系统&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;设计模式&#34;&gt;设计模式&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;设计模式&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;工具&#34;&gt;工具&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;git&lt;/li&gt;
&lt;li&gt;UML图&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        <item>
        <title></title>
        <link>http://nixum.cc/p/</link>
        <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
        
        <guid>http://nixum.cc/p/</guid>
        <description>&lt;h1 id=&#34;table-of-contents&#34;&gt;Table of contents&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;README.md&#34; &gt;公告&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;English%20Learning.md&#34; &gt;英语学习总结&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;Gin.md&#34; &gt;Gin框架原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;Git.md&#34; &gt;git&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;Go%20Context%e5%92%8cChannel.md&#34; &gt;Go Context和Channel&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;Go%20Sync%e5%8c%85.md&#34; &gt;Go Sync包相关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;Go%20goroutine%e5%92%8cGC.md&#34; &gt;Go Goroutine和GC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;Go.md&#34; &gt;Go&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;JUC.md&#34; &gt;Java并发&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;JVM.md&#34; &gt;JVM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;Java%20IO.md&#34; &gt;Java IO&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;Java-List-Map.md&#34; &gt;Java List Map&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;JavaSE.md&#34; &gt;Java SE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;Kubernetes.md&#34; &gt;Kubernetes和Istio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;MongoDB.md&#34; &gt;MongoDB&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;MyBatis.md&#34; &gt;MyBatis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;MySQL.md&#34; &gt;MySQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;README%20%281%29.md&#34; &gt;README&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;RPC%e4%b8%8e%e5%bc%82%e6%ad%a5%e8%ae%be%e8%ae%a1.md&#34; &gt;RPC与异步设计&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;Redis.md&#34; &gt;Redis&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;Spring.md&#34; &gt;Spring和SpringBoot&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;SpringMVC.md&#34; &gt;SpringMVC&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;UML%e5%9b%be.md&#34; &gt;UML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;etcd%e5%92%8cZookeeper.md&#34; &gt;etcd和ZooKeeper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;%e4%b8%9a%e5%8a%a1%e5%9c%ba%e6%99%af%e8%a7%a3%e5%86%b3%e6%96%b9%e6%a1%88.md&#34; &gt;常见的业务场景解决方案整理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;%e5%85%b6%e4%bb%96.md&#34; &gt;其他&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;%e5%88%86%e5%b8%83%e5%bc%8f%e7%9b%b8%e5%85%b3.md&#34; &gt;分布式相关&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;%e5%ae%b9%e5%99%a8.md&#34; &gt;容器&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;%e5%b7%a5%e4%bd%9c%e5%9b%9b%e5%b9%b4%e6%80%bb%e7%bb%93.md&#34; &gt;毕业后四年工作总结 - 第一阶段结束&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;%e5%be%ae%e6%9c%8d%e5%8a%a1.md&#34; &gt;微服务&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f.md&#34; &gt;操作系统&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;%e6%b6%88%e6%81%af%e9%98%9f%e5%88%97.md&#34; &gt;消息队列&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;%e7%bd%91%e7%bb%9c.md&#34; &gt;网络&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;%e8%ae%be%e8%ae%a1%e6%a8%a1%e5%bc%8f.md&#34; &gt;设计模式&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;Algorithm/README.md&#34; &gt;Algorithm&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;Algorithm/SwordToOffer/README.md&#34; &gt;SwordToOffer&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;Algorithm/SwordToOffer/src/README.md&#34; &gt;src&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;Algorithm/SwordToOffer/src/main/README.md&#34; &gt;main&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;Algorithm/SwordToOffer/src/main/java/README.md&#34; &gt;java&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a class=&#34;link&#34; href=&#34;Algorithm/SwordToOffer/src/main/java/backtracking/README.md&#34; &gt;backtracking&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
</description>
        </item>
        
    </channel>
</rss>
