<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='go 数组、slice、map原理、内存对齐'><title>Go</title>

<link rel='canonical' href='http://nixum.cc/p/go/'>

<link rel="stylesheet" href="/scss/style.min.92530ae6146419b2553c7da1866a1ac352d4c1a4d2f985110524bd60c6094d8c.css"><meta property='og:title' content='Go'>
<meta property='og:description' content='go 数组、slice、map原理、内存对齐'>
<meta property='og:url' content='http://nixum.cc/p/go/'>
<meta property='og:site_name' content='Nixum Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='Go' /><meta property='article:tag' content='Go slice和map原理' /><meta property='article:published_time' content='2020-11-07T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2020-11-07T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="Go">
<meta name="twitter:description" content="go 数组、slice、map原理、内存对齐">
    <link rel="shortcut icon" href="/img/favicon.ico" />

<script async src="https://www.googletagmanager.com/gtag/js?id=G-2D1N64V8VB"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-2D1N64V8VB', { 'anonymize_ip': false });
}
</script>

    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>









        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/go/" >
                Go
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/go/">Go</a>
    </h2>

    
    <h3 class="article-subtitle">
        go 数组、slice、map原理、内存对齐
    </h3>
    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Nov 07, 2020</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    11 minute read
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <p>[TOC]</p>
<p><strong>以下基于go.1.14</strong></p>
<h1 id="函数内联优化">函数内联优化</h1>
<p>函数内联优化：在A函数中调用了B函数，内联后，B函数的代码直接在A函数内原地展开，代替这个函数实现，当有多次调用时，就会多次展开</p>
<p>go在编译时会自动判断函数是否可以内联，当函数内包含以下内容时不会被内联：闭包调用，select，for，defer，go关键字创建的协程等。</p>
<p>内联的好处：因为函数调用被内联了，可以减少栈帧的创建，减少读写寄存器的读取，减少参数和函数的拷贝，提升性能</p>
<p>缺点：堆栈panic显示的行数可能不准确、增加编译出来的包的大小</p>
<p>编译时使用<code>go build -gcflags=&quot;-m -m&quot; main.go</code>可以知道编译器的内联优化策略，</p>
<p>go编译时默认会使用内联优化，使用<code>go build --gcflags=&quot;-l&quot; main.go</code>可禁掉全局内联，如果传递两个或以上-l，则会打开内联；</p>
<h1 id="defer">defer</h1>
<ul>
<li>
<p><strong>多个defer是栈的关系，以链表的形式挂在G上，先进后出</strong>，即在一个函数中，写在前面的defer会比写在后面的defer调用得晚，先进后出的原因是后面定义的函数可能会依赖前面的资源，如果前面的先执行导致依赖没了，会影响后面的执行，导致出错；</p>
</li>
<li>
<p>defer和return同时出现时，先return后defer，defer可以修改到return里的变量；</p>
</li>
<li>
<p>return 是非原子性的，需要两步，执行前首先要为返回值赋值，然后 return 将返回值返回调用处。</p>
<p><strong>defer 和 return 的执行顺序是：1. 先为返回值赋值；2. 然后执行 defer；3. 然后 return 到函数调用处</strong></p>
<p>要注意defer + 函数 的场景，如果是函数调用，并且使用的变量是传参进去的，那得看入参类型；如果是闭包调用，引用了外边的变量（不管是不是指针），那就是引用</p>
<p>当返回值没有声明变量时，会内置一个隐式的变量来接收return的赋值</p>
</li>
<li>
<p>panic被触发时，控制权就交给了defer</p>
<p>遇到panic时，会先遍历此协程内的defer链表，并执行defer，如果在执行过程中遇到recover，则停止panic，返回recover处继续往下执行，如果没遇到recover，则遍历完本协程的defer链表后，向stderr抛出panic信息；</p>
</li>
<li>
<p>执行defer过程中出现panic，此时的panic会覆盖它之前的panic，直至被捕获或抛出；</p>
</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">test1</span><span class="p">())</span> <span class="c1">// 0 0
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">test2</span><span class="p">())</span> <span class="c1">// 3 3
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">test21</span><span class="p">())</span> <span class="c1">// 0 3
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">test3</span><span class="p">())</span> <span class="c1">// 0 4
</span><span class="c1"></span>	<span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">test4</span><span class="p">())</span> <span class="c1">// 0 5
</span><span class="c1"></span>    <span class="c1">// 注意返回值是否已经声明了变量
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">test5</span><span class="p">())</span> <span class="c1">// 1 0
</span><span class="c1"></span>    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nf">test51</span><span class="p">())</span> <span class="c1">// 1 1
</span><span class="c1"></span>	<span class="k">return</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">test1</span><span class="p">()</span> <span class="p">(</span><span class="nx">v</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">)</span> <span class="c1">// 0
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">v</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">test2</span><span class="p">()</span> <span class="p">(</span><span class="nx">v</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">)</span> <span class="c1">// 3
</span><span class="c1"></span>	<span class="p">}()</span>
	<span class="k">return</span> <span class="mi">3</span>
<span class="p">}</span>
<span class="c1">// test2 和 test21 的差异在于闭包
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">test21</span><span class="p">()</span> <span class="p">(</span><span class="nx">v</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 相当于调用fmt.Print方法，然后把v传值进去，此时 v=0，v已经赋值给了fmt.Print方法的入参了
</span><span class="c1"></span>    <span class="c1">// 类似 test4()
</span><span class="c1"></span>	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">)</span> <span class="c1">// 0
</span><span class="c1"></span>	<span class="k">return</span> <span class="mi">3</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">test3</span><span class="p">()</span> <span class="p">(</span><span class="nx">v</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">v</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">)</span> <span class="c1">// 0
</span><span class="c1"></span>	<span class="nx">v</span> <span class="p">=</span> <span class="mi">3</span>
	<span class="k">return</span> <span class="mi">4</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">test4</span><span class="p">()</span> <span class="p">(</span><span class="nx">v</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">(</span><span class="nx">n</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="nx">n</span><span class="p">,</span> <span class="s">&#34; &#34;</span><span class="p">)</span> <span class="c1">// 0
</span><span class="c1"></span>	<span class="p">}(</span><span class="nx">v</span><span class="p">)</span>
	<span class="k">return</span> <span class="mi">5</span>
<span class="p">}</span>

<span class="c1">// 区分 test51, 区别在于返回值是否声明了变量名，当返回值没有声明变量时，return会把值赋值给一个隐式的变量，之后随便i怎么改，都不影响其返回值
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">test5</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">i</span> <span class="kt">int</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">i</span><span class="o">++</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34; &#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="c1">// 1
</span><span class="c1"></span>	<span class="p">}()</span>
	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">test51</span><span class="p">()</span> <span class="p">(</span><span class="nx">i</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
		<span class="nx">i</span><span class="o">++</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Print</span><span class="p">(</span><span class="s">&#34; &#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span> <span class="c1">// 1
</span><span class="c1"></span>	<span class="p">}()</span>
	<span class="k">return</span> <span class="nx">i</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="内存对齐">内存对齐</h1>
<p>CPU读取数据时不会一个字节一个字节去读取，而是一块一块，块的大小可以是2、4、6、8、16字节，块大小称为内存访问粒度。32位CPU一次读取4个字节，64位CPU一次读取8个字节。</p>
<p>如果未进行内存对齐，会导致CPU进行两次内存访问，并且需要花费额外的时钟周期来处理对齐及运算，如果对齐了内存，一次读取就能访问完成，内存对齐可能会耗费额外的空间，但是可以加快读取效率，标准的空间换时间做法。</p>
<p>以32位CPU对齐为例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Part1</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">a</span> <span class="kt">bool</span>
	<span class="nx">b</span> <span class="kt">int32</span>
	<span class="nx">c</span> <span class="kt">int8</span>
	<span class="nx">d</span> <span class="kt">int64</span>
	<span class="nx">e</span> <span class="kt">byte</span>
<span class="p">}</span>
<span class="c1">// 乍一看按每个类型所占字节数去算，算出来的内存占用是15个字节，但实际上是32字节
</span></code></pre></td></tr></table>
</div>
</div><p>对齐规则：</p>
<blockquote>
<ul>
<li>结构体的成员变量，第一个成员变量的偏移量为 0。往后的每个成员变量的对齐值必须为编译器默认对齐长度（<code>#pragma pack(n)</code>）或当前成员变量类型的长度（<code>unsafe.Sizeof</code>），取最小值作为当前类型的对齐值。其偏移量必须为对齐值的整数倍</li>
<li>结构体本身，对齐值必须为编译器默认对齐长度（<code>#pragma pack(n)</code>）或结构体的所有成员变量类型中的最大长度，取最大数的最小整数倍作为对齐值</li>
<li>结合以上两点，可得知若编译器默认对齐长度（<code>#pragma pack(n)</code>）超过结构体内成员变量的类型最大长度时，默认对齐长度是没有任何意义的</li>
</ul>
</blockquote>
<p>对齐过程：</p>
<table>
<thead>
<tr>
<th>成员变量</th>
<th>类型</th>
<th>偏移量</th>
<th>自身占用</th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>bool</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>b</td>
<td>int32</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>c</td>
<td>int8</td>
<td>8</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>9</td>
<td>7</td>
</tr>
<tr>
<td>d</td>
<td>int64</td>
<td>16</td>
<td>8</td>
</tr>
<tr>
<td>e</td>
<td>byte</td>
<td>24</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>25</td>
<td>7</td>
</tr>
<tr>
<td>总占用大小</td>
<td>-</td>
<td>-</td>
<td>32</td>
</tr>
</tbody>
</table>
<p>内存布局：axxx|bbbb|cxxx|xxxx|dddd|dddd|e，之后要保证整个结构体进行字节对齐，发现它不是2^n，可得出最近一个数是32。</p>
<p>对结构体内字段顺序进行调整后，可以发现算出来的大小会不一样</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Part2</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">e</span> <span class="kt">byte</span>
	<span class="nx">c</span> <span class="kt">int8</span>
	<span class="nx">a</span> <span class="kt">bool</span>
	<span class="nx">b</span> <span class="kt">int32</span>
	<span class="nx">d</span> <span class="kt">int64</span>
<span class="p">}</span>
<span class="c1">// 调整字段顺序后，算出来的大小是16，原因是整个结构体本身不需要额外对齐
</span></code></pre></td></tr></table>
</div>
</div><table>
<thead>
<tr>
<th>成员变量</th>
<th>类型</th>
<th>偏移量</th>
<th>自身占用</th>
</tr>
</thead>
<tbody>
<tr>
<td>e</td>
<td>byte</td>
<td>0</td>
<td>1</td>
</tr>
<tr>
<td>c</td>
<td>int8</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>a</td>
<td>bool</td>
<td>2</td>
<td>1</td>
</tr>
<tr>
<td>字节对齐</td>
<td>无</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>b</td>
<td>int32</td>
<td>4</td>
<td>4</td>
</tr>
<tr>
<td>d</td>
<td>int64</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>总占用大小</td>
<td>-</td>
<td>-</td>
<td>16</td>
</tr>
</tbody>
</table>
<p>内存布局：ecax|bbbb|dddd|dddd</p>
<h1 id="数组">数组</h1>
<ul>
<li>声明时必须指定固定长度，因为编译时需要知道数组长度以便分配内存，如<code>var arr1 [5]int</code>，或者<code>var arr2 = [5]int{1,2,3}, 其余数字为0</code></li>
<li>数组<strong>长度最大是2Gb</strong></li>
<li>当数组类型是整形时，所有元素都会被自动初始化为0，即声明完数组，<strong>数组会被设置类型的默认值</strong></li>
<li>可以使用new()来创建，如<code>var arr3 = new([3]int)</code>，arr3的类型是<code>*[3]int</code>，arr1、arr2的类型是<code>[5]int</code></li>
<li>函数的参数可以是[5]int, 表明入参是数组，如果是[]int，表明入参是slice。类型[3]int和[5]int是两种不同的类型。</li>
<li><strong>数组是值类型</strong>，赋值和传参会进行拷贝，函数内部的修改不会影响原始数组。</li>
<li>如果数组中的元素个数小于或等于4个，所有变量会直接在栈上初始化；当数组元素大于4个，变量就会在静态存储区初始化然后拷贝到栈上。</li>
</ul>
<h1 id="切片slice">切片Slice</h1>
<h2 id="数据结构">数据结构</h2>
<p>slice本质是一个结构体，所以它是值类型是不难理解的，它仅仅只是对数组的一种包装，且该结构体不包含任何函数，任何对slice的处理都是go的内置函数来处理的。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">Slice</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">ptr</span>   <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> 	<span class="c1">// 指向数组的指针
</span><span class="c1"></span>	<span class="nx">len</span>   <span class="kt">int</span>               <span class="c1">// 切片长度
</span><span class="c1"></span>	<span class="nx">cap</span>   <span class="kt">int</span>               <span class="c1">// 切片容量
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="基本">基本</h2>
<ul>
<li>
<p>创建时无需指定长度，如 <code>slice1 := []int{1,2,3}, 此时长度和容量均为3</code></p>
</li>
<li>
<p>从数组上截取<code>arr1 := [5]int; var slice2 []int = arr1[1:3], 此时长度2，容量5，且对slice2的修改会影响arr1</code>。</p>
</li>
<li>
<p>可以使用make([]type, len, cap)来创建，len必填，cap非必填，如果cap不填，初始cap=len。如<code>slice4 := make(int[], 5, 10)，长度5，容量10</code>。</p>
</li>
<li>
<p>可以使用new来创建，比如 <code>new([100]int)[0:50]</code> 效果等同于 <code>make([]int, 50, 100)</code>，或者 <code>slice := *new([]int) 为空切片</code></p>
</li>
<li>
<p>空切片：<code>slice := make([]int, 0) 或 slice := []int{}</code>，nil切片：<code>var slice *[]int 或 slice := *new([]int)</code>；两者的区别在于，空切片会指向一个内存地址，但它没有分配任何的内存空间；nil切片是直接指向nil。</p>
<p>打印时，两者的结果均为<code>[], len=0， cap=0</code>，但nil切片与nil比较的结果为true，空切片与nil的比较结果为false。</p>
</li>
<li>
<p>切片是对数组的一个连续片段的引用，对于<strong>切片底层数组是引用类型</strong>，作为函数参数时，虽然是传切片的值，但是底层数组传递指针，函数内部的修改会影响原始数组</p>
</li>
<li>
<p>一个数组可以创建多个slice，一个slice也可以创建多个slice，但是新老slice会共用底层数组，新老slice的修改都会互相影响。但是如果新slice经过append，使得slice底层数组扩容了，此时slice引用了新的数组，此时新老slice就不会互相影响了。</p>
<p>语法：<code>ns = slice1[起始下标:结束下标(不包括):cap容量]</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">slice</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">}</span>
<span class="nx">s</span> <span class="o">:=</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">1</span><span class="p">]</span> <span class="c1">// s = [1]
</span><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span> <span class="c1">// s = [1, 2], len=2, cap=2
</span><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">]</span> <span class="c1">// s = [1, 2], len=2, cap=5
</span><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="nx">slice</span><span class="p">[:</span><span class="mi">0</span><span class="p">]</span> <span class="c1">// s=[], len=0, cap=0
</span></code></pre></td></tr></table>
</div>
</div></li>
</ul>
<p>使用new()和make()的区别</p>
<blockquote>
<p>看起来二者没有什么区别，都在堆上分配内存，但是它们的行为不同，适用于不同的类型。</p>
<p>new (T) 为每个新的类型 T 分配一片内存，初始化为 0 并且返回类型为 *T 的内存地址：这种函数 返回一个指向类型为 T，值为 0 的地址的指针，它<strong>适用于值类型，如数组和结构体</strong>；它相当于 &amp;T{}。
make(T) 返回一个类型为 T 的初始值，它只<strong>适用于 3 种内建的引用类型：切片、map 和 channel</strong>。</p>
</blockquote>
<ul>
<li>range遍历的注意点：将slice的每个元素赋值给v时，发生了一次拷贝，无法通过修改v来修改slice。如果是slice是指针结构体类型，还是能修改的。也就是说如果slice是指针类型，通过range遍历append时要注意</li>
</ul>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go">	<span class="nx">arr2</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span>
	<span class="nx">newArr</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="kt">int</span><span class="p">{}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">arr2</span> <span class="p">{</span>
		<span class="nx">newArr</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">newArr</span><span class="p">,</span> <span class="o">&amp;</span><span class="nx">v</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">v</span> <span class="o">:=</span> <span class="k">range</span> <span class="nx">newArr</span> <span class="p">{</span>
		<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;%v &#34;</span><span class="p">,</span> <span class="o">*</span><span class="nx">v</span><span class="p">)</span> <span class="c1">// 打印3 3 3，因为是v指向了同一个指针
</span><span class="c1"></span>	<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="扩容">扩容</h2>
<h3 id="原理">原理</h3>
<p>当使用append()函数向slice追加元素，会根据slice的容量判断是否需要扩容。另外，因为slice是值传递，append()函数不会修改传入的slice，返回是重新对底层数组、长度、容量做包装，返回新slice。</p>
<ol>
<li>如果slice容量够用，则直接把新元素追加进去，长度 + 1，返回原slice</li>
<li>原slice容量不够，将slice扩容，得到新的slice</li>
<li>将新元素追加到新slice，长度 + 1，返回新slice</li>
</ol>
<p>另外，<strong>copy函数拷贝</strong>两个slice时，会将源slice拷贝到目标slice，<strong>如果目标slice的长度&lt;源slice，不会发生扩容</strong>。</p>
<p>Demo：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="nx">data</span> <span class="o">:=</span> <span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="kt">int</span><span class="p">{}</span>
<span class="nx">slice</span> <span class="o">:=</span> <span class="nx">data</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">8</span><span class="p">]</span>
<span class="nx">slice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span><span class="c1">// slice=? data=?
</span><span class="c1"></span><span class="nx">slice</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">slice</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">12</span><span class="p">)</span><span class="c1">// slice=? data=?
</span><span class="c1"></span><span class="nx">结果</span><span class="err">：</span>
<span class="c1">// 第一次append后结果
</span><span class="c1"></span><span class="nx">slice</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">9</span><span class="p">]</span>
<span class="nx">data</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">9</span> <span class="mi">0</span><span class="p">]</span>
<span class="c1">// 第二次append后结果
</span><span class="c1"></span><span class="nx">slice</span> <span class="p">=</span> <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">9</span> <span class="mi">10</span> <span class="mi">11</span> <span class="mi">12</span><span class="p">]</span>
<span class="nx">data</span> <span class="p">=</span>  <span class="p">[</span><span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span> <span class="mi">0</span>  <span class="mi">0</span>   <span class="mi">0</span> <span class="mi">0</span> <span class="mi">9</span> <span class="mi">0</span><span class="p">]</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="扩容策略">扩容策略</h3>
<p>扩容实际上包括两部分：计算容量的规则 和 内存对齐</p>
<ol>
<li>
<p>如果<strong>期望容量大于当前容量的两倍</strong>就会使用期望容量，期望容量指的是把元素加进去后的容量，一般发生在append 多个的时候，如 append(arr, 1, 2, 3, 4)。</p>
</li>
<li>
<p>如果当前切片的长度小于 1024，扩容两倍。</p>
</li>
<li>
<p>如果当前切片的长度大于 1024 就会每次增加 25% 的容量，即扩容1.25倍，直到新容量大于期望容量。</p>
</li>
<li>
<p>此时只是确定切片的大致容量，之后会判断切片中元素所占字节大小，如果字节大小是1、2、8的倍数时，会进行内存对齐，这个操作之后，扩容后的容量可能会 &gt; 原容量的两倍 或 1.25倍。</p>
<p>内存对齐主要是为了提高内存分配效率，减少内存碎片。</p>
</li>
</ol>
<p>PS：go 18以前还是用 1024 来判断要扩容的大小，18之后使用256，长度小于256，扩容两倍；长度大于256时，规则为 <code>原长度 += (原长度 + 3*256) / 4</code></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 此时期望容量是2 + 3 = 5 &gt; 旧容量的两倍 2 * 2 = 4，期望容量为5，占40个字节，不是2^n次，so触发内存对齐，向上取整为48字节，此时新容量为 48 / 8 = 6。
</span><span class="c1"></span><span class="nx">s1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int64</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">s1</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;len=%d, cap=%d\n&#34;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">s1</span><span class="p">),</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s1</span><span class="p">))</span>  <span class="c1">// len=5, cap=6
</span><span class="c1"></span>
<span class="c1">// 第一次append，扩容，拷贝旧数据到新数组，容量增长两倍；
</span><span class="c1">// 第二次append，没有产生新数组，只将元素进行追加；
</span><span class="c1">// 第三次append，扩容，拷贝旧数据到新数组，容量增长两倍；
</span><span class="c1"></span><span class="nx">s</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">}</span>
<span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;len=%d, cap=%d\n&#34;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>  <span class="c1">// len=3, cap=4
</span><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;len=%d, cap=%d\n&#34;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>  <span class="c1">// len=4, cap=4
</span><span class="c1"></span><span class="nx">s</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">s</span><span class="p">,</span> <span class="mi">6</span><span class="p">)</span>
<span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">&#34;len=%d, cap=%d\n&#34;</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="nx">s</span><span class="p">),</span><span class="nb">cap</span><span class="p">(</span><span class="nx">s</span><span class="p">))</span>  <span class="c1">// len=5, cap=8
</span></code></pre></td></tr></table>
</div>
</div><h1 id="map">Map</h1>
<h2 id="数据结构-1">数据结构</h2>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span><span class="lnt">78
</span><span class="lnt">79
</span><span class="lnt">80
</span><span class="lnt">81
</span><span class="lnt">82
</span><span class="lnt">83
</span><span class="lnt">84
</span><span class="lnt">85
</span><span class="lnt">86
</span><span class="lnt">87
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">hmap</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">count</span>     <span class="kt">int</span>    <span class="c1">// 哈希表中元素的数量
</span><span class="c1"></span>    <span class="c1">// flags枚举：1: 可能有迭代器使用buckets，2: 可能有迭代器使用oldbuckets，4: 有协程正在向map中写入key，8:等量扩容
</span><span class="c1"></span>    <span class="nx">flags</span>     <span class="kt">uint8</span>  <span class="c1">// 记录map的状态
</span><span class="c1"></span>    <span class="nx">B</span>         <span class="kt">uint8</span>  <span class="c1">// buckets的数量，len(buckets) = 2^B
</span><span class="c1"></span>	<span class="nx">noverflow</span> <span class="kt">uint16</span> <span class="c1">// 溢出的bucket的个数
</span><span class="c1"></span>	<span class="nx">hash0</span>     <span class="kt">uint32</span> <span class="c1">// 哈希种子，为哈希函数的结果引入随机性。该值在创建哈希表时确定，在构造方法中传入
</span><span class="c1"></span>
	<span class="nx">buckets</span>    <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 桶的地址，指向一个bmap数组，即指向很多个桶
</span><span class="c1"></span>	<span class="nx">oldbuckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="c1">// 扩容时用于保存之前buckets的字段，大小是当前buckets的一半或0.75，非扩容状态下为null
</span><span class="c1"></span>	<span class="nx">nevacuate</span>  <span class="kt">uintptr</span> <span class="c1">// 扩容迁移的进度，小于nevacuate的buckets表示已迁移完成，同时也用来计算下一个要迁移的桶在oldbuckets中的位置
</span><span class="c1"></span>
	<span class="nx">extra</span> <span class="o">*</span><span class="nx">mapextra</span> <span class="c1">// 存储单个桶装满时溢出的数据，溢出桶和正常桶在内存上是连续的, 即 hmap.buckets[i].overflow会关联hmap.extra.overflow
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">mapextra</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 下面这两个字段是为了优化GC扫描而设计的。在map的key和value都不是指针，并且size都小于128字节时使用（即可以被inline），所有hmap.buckets的溢出桶都用这两个字段进行管理，避免gc时扫描整个hmap。
</span><span class="c1"></span>    
    <span class="c1">// 因为 bmap.overflow 是个指针，指向溢出的bucket，而GC时必定会扫描指针，那就会扫描所有bmap，
</span><span class="c1"></span>    <span class="c1">// 当map的key和value都是非指针类型时，为了避免扫描所有buckets，就可以使用extra.overflow来存储溢出的bucket，并把bmap结构体里的overflow指针类型变成unitptr类型（编译期干的），那整个bmap就完全没指针了。
</span><span class="c1"></span>    <span class="c1">// 这样就可以通过extra直接标记整个map的颜色，避免扫描每个bmap的overflow指针；
</span><span class="c1"></span>    <span class="c1">// 另一方面，当 GC 在扫描 hmap 时，通过 extra.overflow 这条路径（指针）就可以将 overflow 的 bucket 正常标记成黑色，从而不会被 GC 错误地回收。
</span><span class="c1"></span>	<span class="nx">overflow</span>    <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>  <span class="c1">// 包含hmap.buckets的overflow的buckets，即保存了所有溢出桶，便于GC扫描
</span><span class="c1"></span>	<span class="nx">oldoverflow</span> <span class="o">*</span><span class="p">[]</span><span class="o">*</span><span class="nx">bmap</span>  <span class="c1">// 包含扩容时的hmap.oldbuckets的overflow的bucket，用于扩容
</span><span class="c1"></span>
    <span class="c1">// 指向空闲的 overflow bucket 的指针，用于预分配
</span><span class="c1"></span>    <span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
<span class="p">}</span>

<span class="c1">// 即桶bucket的结构
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="c1">// 表示一个桶，实际上为len为8的数组，每个桶只能存8个键值对，包含此桶中每个key的哈希值的高8位
</span><span class="c1"></span>    <span class="c1">// 如果tophash[0] &lt; minTopHash，说明前minTopHash个已经被搬迁过
</span><span class="c1"></span>    <span class="c1">// tophash的最低位代表桶的搬迁evacuation状态，最低位0表示在X part，1表示在Y part。
</span><span class="c1"></span>    <span class="nx">tophash</span> <span class="p">[</span><span class="nx">bucketCnt</span><span class="p">]</span><span class="kt">uint8</span> 
<span class="p">}</span>

<span class="c1">// 但由于go没有泛型，哈希表中又可能存储不同类型的键值对，所以键值对所占的内存空间大小只能在编译时推导，
</span><span class="c1">// 无法先设置在结构体中，这些字段是在运行时通过计算内存地址的方式直接访问，这些额外的字段都是编译时动态创建
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">bmap</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">topbits</span>  <span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="kt">uint8</span>    <span class="c1">// 通过tophash找到对应键值对在keys和values数组中的下标，即有8个cell
</span><span class="c1"></span>    <span class="nx">keys</span>     <span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="nx">keytype</span>
    <span class="nx">values</span>   <span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="nx">valuetype</span>
    <span class="nx">pad</span>      <span class="kt">uintptr</span>
    <span class="nx">overflow</span> <span class="kt">uintptr</span> <span class="c1">// 每个桶只能存8个元素，超过8个时会存入溢出桶，溢出桶只是临时方案，溢出过多时会进行扩容
</span><span class="c1"></span><span class="p">}</span>

<span class="c1">// 重要的常量标志
</span><span class="c1"></span><span class="kd">const</span> <span class="p">(</span>
    <span class="c1">// 一个桶中最多能装载的键值对（key-value）的个数为8
</span><span class="c1"></span>    <span class="nx">bucketCntBits</span> <span class="p">=</span> <span class="mi">3</span>
    <span class="nx">bucketCnt</span>     <span class="p">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">bucketCntBits</span>

    <span class="c1">// 触发扩容的装载因子为13/2=6.5
</span><span class="c1"></span>    <span class="nx">loadFactorNum</span> <span class="p">=</span> <span class="mi">13</span>
    <span class="nx">loadFactorDen</span> <span class="p">=</span> <span class="mi">2</span>

    <span class="c1">// 键和值超过128个字节，就会被转换为指针
</span><span class="c1"></span>    <span class="nx">maxKeySize</span>  <span class="p">=</span> <span class="mi">128</span>
    <span class="nx">maxElemSize</span> <span class="p">=</span> <span class="mi">128</span>

    <span class="c1">// 数据偏移量应该是bmap结构体的大小，它需要正确地对齐。
</span><span class="c1"></span>    <span class="c1">// 对于amd64p32而言，这意味着：即使指针是32位的，也是64位对齐。
</span><span class="c1"></span>    <span class="nx">dataOffset</span> <span class="p">=</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nf">Offsetof</span><span class="p">(</span><span class="kd">struct</span> <span class="p">{</span>
        <span class="nx">b</span> <span class="nx">bmap</span>
        <span class="nx">v</span> <span class="kt">int64</span>
    <span class="p">}{}.</span><span class="nx">v</span><span class="p">)</span>


    <span class="c1">// 每个桶（如果有溢出，则包含它的overflow的链接桶）在搬迁完成状态下，要么会包含它所有的键值对，要么一个都不包含（但不包括调用evacuate()方法阶段，该方法调用只会在对map发起write时发生，在该阶段其他goroutine是无法查看该map的）。简单的说，桶里的数据要么一起搬走，要么一个都还未搬。
</span><span class="c1"></span>    <span class="c1">// 当tophash值小于minTopHash时，表示存的是迁移状态，大于minTopHash时，表示的是计算的值。
</span><span class="c1"></span>    <span class="nx">emptyRest</span>      <span class="p">=</span> <span class="mi">0</span> <span class="c1">// 表示cell为空，并且之后的位置也为空，包括overflow，初始化bucket时，就是该状态
</span><span class="c1"></span>    <span class="nx">emptyOne</span>       <span class="p">=</span> <span class="mi">1</span> <span class="c1">// 表示当前是空的cell，但曾经有值，已经被搬迁到新的bucket
</span><span class="c1"></span>    <span class="nx">evacuatedX</span>     <span class="p">=</span> <span class="mi">2</span> <span class="c1">// 键值对已经搬迁完毕，key在新buckets数组的前半部分
</span><span class="c1"></span>    <span class="nx">evacuatedY</span>     <span class="p">=</span> <span class="mi">3</span> <span class="c1">// 键值对已经搬迁完毕，key在新buckets数组的后半部分
</span><span class="c1"></span>    <span class="nx">evacuatedEmpty</span> <span class="p">=</span> <span class="mi">4</span> <span class="c1">// cell为空，整个bucket已经搬迁完毕
</span><span class="c1"></span>    <span class="nx">minTopHash</span>     <span class="p">=</span> <span class="mi">5</span> <span class="c1">// tophash的最小正常值，如果计算出来的tophash小于该值，则加上它避免跟前面几个状态枚举冲突
</span><span class="c1"></span>
    <span class="c1">// flags
</span><span class="c1"></span>    <span class="nx">iterator</span>     <span class="p">=</span> <span class="mi">1</span> <span class="c1">// 可能有迭代器在使用buckets
</span><span class="c1"></span>    <span class="nx">oldIterator</span>  <span class="p">=</span> <span class="mi">2</span> <span class="c1">// 可能有迭代器在使用oldbuckets
</span><span class="c1"></span>    <span class="nx">hashWriting</span>  <span class="p">=</span> <span class="mi">4</span> <span class="c1">// 有协程正在向map写人key
</span><span class="c1"></span>    <span class="nx">sameSizeGrow</span> <span class="p">=</span> <span class="mi">8</span> <span class="c1">// 等量扩容
</span><span class="c1"></span>
    <span class="c1">// 用于迭代器检查的bucket ID
</span><span class="c1"></span>    <span class="nx">noCheck</span> <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="mi">8</span><span class="o">*</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
<span class="p">)</span>
</code></pre></td></tr></table>
</div>
</div><p><figure 
	>
	<a href="https://github.com/Nixum/Java-Note/raw/master/picture/go_map_struct.png" >
		<img src="https://github.com/Nixum/Java-Note/raw/master/picture/go_map_struct.png"
			
			
			
			loading="lazy"
			alt="go map 结构图">
	</a>
	
	<figcaption>go map 结构图</figcaption>
	
</figure></p>
<p>注：一个bmap里key和value是各自存的，而key/value一对对存储，这样的好处是省掉padding字段，节省内存空间，方便内存对齐。</p>
<blockquote>
<p>例如，有这样一个类型的 map：<code>map[int64]int8</code>，如果按照 <code>key/value...</code> 这样的模式存储，那在每一个 key/value 对之后都要额外 padding 7 个字节；而将所有的 key，value 分别绑定到一起，这种形式 <code>key/key/.../value/value/...</code>，则只需要在最后添加 padding，每个 bucket 设计成最多只能放 8 个 key-value 对，如果有第 9 个 key-value 落入当前的 bucket，那就需要再构建一个 bucket ，通过 <code>overflow</code> 指针连接起来。</p>
</blockquote>
<h2 id="基本-1">基本</h2>
<ul>
<li>
<p>创建：<code>m := map[string]int{&quot;1&quot;: 11, &quot;2&quot;: 22}</code>或者 <code>m := make(map[string]int, 10)</code></p>
</li>
<li>
<p>当使用字面量的方式创建哈希表时，如果{}中元素少于或等于25时，编译器会转成make的方式创建，再进行赋值；如果超过了25个，编译时会转成make的方式创建，同时为key和value分别创建两个数组，最后进行循环赋值</p>
</li>
<li>
<p>直接声明 <code>var m map[string]int</code>会创建了一个<strong>nil的map</strong>，此时不能被赋值，但可以取值，虽然不会panic，但会得到零值</p>
</li>
<li>
<p>key不允许为slice、map、func；允许bool、numeric、string、指针、channel、interface、struct及其类型对应的数组；</p>
<p><strong>即key必须支持 == 或 != 运算的类型，如果是结构体，则他们的所有字段都相等，才被认为是相同的key</strong>；</p>
<p>另外，float比较特殊，因为float作为key时，会被转成unit64，再插入key中，可能会有精度问题，导致有时候查询不到，或者查询出来的key不一样；</p>
<p>有个特殊的key值<code>math.NaN</code>，它每次生成的哈希值是不一样的，这会造成m[<code>math.NaN</code>]是拿不到值的，而且多次对它赋值，会让map中存在多个<code>math.NaN</code>的key。</p>
</li>
<li>
<p>map容量最多为 6.5 * 2^B 个元素，6.5是装载因子阈值常量，装载因子 = 哈希表中的元素 / 哈希表总长度，装载因子越大，冲突越多。B最大值是63。</p>
</li>
<li>
<p>拉链法解决哈希冲突（指8个正常位和溢出桶），除留余数法得到桶的位置。</p>
</li>
<li>
<p>key的哈希值的低B位计算获得桶的位置，高8位计算得到tophash的位置，进而找到key的位置。</p>
</li>
<li>
<p>溢出桶也是一个bmap，bmap的overflow会指向下一个溢出桶，所以<strong>溢出桶的结构是链表，但是它们跟正常桶是在一片连续内存上，都在buckets数组里，前2^B个当成正常桶，后2^(B-4)个当作溢出桶</strong>。</p>
</li>
<li>
<p>每个桶存了8个tophash + 8对键值对。</p>
</li>
<li>
<p><strong>扩容判断发生在插入，扩容迁移发生在插入和删除</strong>。</p>
</li>
<li>
<p>map是非线程安全的，扩容不是一个原子操作，通过hmap里的flags字段在并发读写时进行fast-fail。</p>
<p>当 map 对象同时进行加锁的 write 和不加锁的read（比如打印，序列化等）时，会发生panic，因为相当于并发读写。</p>
<p>当map出现并发读写时，不是抛出panic错误，而是fatal错误，fatal错误不可被recover，程序会直接退出；原因是当存在并发读写时，如果被recover了，会导致其他协程出现读取错误的情况。</p>
<p>但在同一个协程里，边遍历边增删，并不会触发并发检测，但是可能会导致漏遍历；</p>
</li>
<li>
<p>map的遍历是无序的，每次遍历出来的结果的顺序都不一样。</p>
</li>
<li>
<p>无法直接对map的value直接取地址：<code>&amp;m[&quot;key&quot;]</code>会无法通过编译，虽然可以使用<code>unsafe.Pointer</code>取地址，但是因为map会扩容，拿到的地址也不一定是之后的地址。</p>
</li>
</ul>
<h2 id="创建初始化">创建初始化</h2>
<p>通过<code>make(map[type]type)</code>，或者<code>make(map[type]type, hint), hint &lt;= 8</code>创建的map，底层会调用<code>makemap_small函数</code>，并直接从堆上进行分配，此时只分配内存空间，不初始化桶，懒加载，只有在第一次插入时才会初始化桶，此时B=0，桶的数量为1。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makemap_small</span><span class="p">()</span> <span class="o">*</span><span class="nx">hmap</span> <span class="p">{</span>
    <span class="nx">h</span> <span class="o">:=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">hmap</span><span class="p">)</span>
    <span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fastrand</span><span class="p">()</span>
    <span class="k">return</span> <span class="nx">h</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>当hint &gt; 8时，则会在运行时调用<code>makemap函数</code>进行创建和初始化，</p>
<ol>
<li>
<p>计算哈希表占用的内存是否溢出或者超出能分配的最大值</p>
</li>
<li>
<p>调用fastrand()获取随机哈希种子</p>
</li>
<li>
<p>根据hint来计算需要的桶的数量来计算B的值（hint是make的第二个参数），用于初始化桶的数量 = 2^B；</p>
</li>
<li>
<p>调用<code>makeBucketArray()</code>分配连续的空间，创建用于保存桶的数组</p>
<p>当桶的数量小于2^4时，由于数据较少，哈希冲突的可能性较小，此时不会创建溢出桶。</p>
<p>当桶的数量大于2^4时，就会额外创建2^(B-4)个溢出桶，溢出桶与普通桶在内存空间上是连续的，使用extra的nextOveflow来做溢出桶，预分配。</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">makemap</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">hint</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="o">*</span><span class="nx">hmap</span> <span class="p">{</span>
<span class="o">...</span>
    <span class="nx">h</span><span class="p">.</span><span class="nx">hash0</span> <span class="p">=</span> <span class="nf">fastrand</span><span class="p">()</span>
	<span class="c1">// 函数内，计算桶的数量
</span><span class="c1"></span>	<span class="nx">B</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
	<span class="c1">//计算得到合适的B
</span><span class="c1"></span>	<span class="k">for</span> <span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">hint</span><span class="p">,</span> <span class="nx">B</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">B</span><span class="o">++</span>
    <span class="p">}</span>
    <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="p">=</span> <span class="nx">B</span>
    <span class="c1">// 如果 B == 0时，就会懒加载
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="kd">var</span> <span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span>
		<span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="p">=</span> <span class="nb">new</span><span class="p">(</span><span class="nx">mapextra</span><span class="p">)</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="nx">nextOverflow</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="o">...</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">B</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// 常量loadFactorNum=13 ，loadFactorDen=2，bucketCnt=8，bucketShift()函数返回2^B
</span><span class="c1"></span>	<span class="k">return</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="nx">bucketCnt</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">loadFactorNum</span><span class="o">*</span><span class="p">(</span><span class="nf">bucketShift</span><span class="p">(</span><span class="nx">B</span><span class="p">)</span><span class="o">/</span><span class="nx">loadFactorDen</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">makeBucketArray</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">b</span> <span class="kt">uint8</span><span class="p">,</span> <span class="nx">dirtyalloc</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="p">(</span><span class="nx">buckets</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">,</span> <span class="nx">nextOverflow</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">base</span> <span class="o">:=</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span><span class="p">)</span>  <span class="c1">// base = 2 ^ B
</span><span class="c1"></span>	<span class="nx">nbuckets</span> <span class="o">:=</span> <span class="nx">base</span>
    <span class="c1">// B &lt; 4时，即桶的数量小于16，认为哈希冲突几率较小，因此不会创建溢出桶
</span><span class="c1"></span>    <span class="c1">// B &gt;= 4时，创建2^(B-4)个溢出桶
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">b</span> <span class="o">&gt;=</span> <span class="mi">4</span> <span class="p">{</span>
		<span class="nx">nbuckets</span> <span class="o">+=</span> <span class="nf">bucketShift</span><span class="p">(</span><span class="nx">b</span> <span class="o">-</span> <span class="mi">4</span><span class="p">)</span>
		<span class="nx">sz</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span> <span class="o">*</span> <span class="nx">nbuckets</span>
		<span class="nx">up</span> <span class="o">:=</span> <span class="nf">roundupsize</span><span class="p">(</span><span class="nx">sz</span><span class="p">)</span>
		<span class="k">if</span> <span class="nx">up</span> <span class="o">!=</span> <span class="nx">sz</span> <span class="p">{</span>
			<span class="nx">nbuckets</span> <span class="p">=</span> <span class="nx">up</span> <span class="o">/</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span>
		<span class="p">}</span>
	<span class="p">}</span>
    <span class="k">if</span> <span class="nx">dirtyalloc</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="c1">// 为null, 会分配一个新的底层数组
</span><span class="c1"></span>		<span class="nx">buckets</span> <span class="p">=</span> <span class="nf">newarray</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="nx">nbuckets</span><span class="p">))</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// 不为null，则它指向的是曾经分配过的底层数组，该底层数组是由之前同样的t和b参数通过makeBucketArray分配的，如果数组不为空，需要把该数组之前的数据清空并复用
</span><span class="c1"></span>		<span class="nx">buckets</span> <span class="p">=</span> <span class="nx">dirtyalloc</span>
		<span class="nx">size</span> <span class="o">:=</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">size</span> <span class="o">*</span> <span class="nx">nbuckets</span>
		<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
			<span class="nf">memclrHasPointers</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="nf">memclrNoHeapPointers</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">size</span><span class="p">)</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="c1">// 如果多申请了桶，将多申请的桶放在nextOverflow里备用
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">base</span> <span class="o">!=</span> <span class="nx">nbuckets</span> <span class="p">{</span>
        <span class="c1">// 先计算出多申请出来的内存地址 nextOverflow
</span><span class="c1"></span>		<span class="nx">nextOverflow</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="nx">base</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
        <span class="c1">// 计算出申请的最后一块bucket的地址
</span><span class="c1"></span>		<span class="nx">last</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">buckets</span><span class="p">,</span> <span class="p">(</span><span class="nx">nbuckets</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
        <span class="c1">// 将最后一个bucket桶的位置指向non-nil值，这样在获取溢出桶时，可以通过nextOverflow指针判断自己是否是最后一个溢出桶，nil说明还有桶，non-nil说明是最后一个桶
</span><span class="c1"></span>		<span class="nx">last</span><span class="p">.</span><span class="nf">setoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nx">buckets</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">buckets</span><span class="p">,</span> <span class="nx">nextOverflow</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="查找与插入">查找与插入</h2>
<p><code>v := m[key]</code>使用函数<code>mapaccess1()</code>进行查找， <code>v, ok := m[key]</code>使用函数<code>mapaccess2()</code>进行查找</p>
<p><code>mapaccess2()</code>也会调用<code>mapaccess1()</code>，只是返回的时候会返回多一个用于表示当前键值对是否存在的布尔值。</p>
<h3 id="key的定位">key的定位</h3>
<ol>
<li>
<p>找buckets数组中的bucket的位置：key经过哈希计算得到哈希值，取出hmap的B值，取哈希值的后B位个bit位，计算后面的B位的值得到桶的位置（实际上这一步就是除留余数法的取余操作）。</p>
<p>比如：一个key经过哈希计算之后，得到的结果是：</p>
<p><code>10010111 | 000011110110110010001111001010100010010110010101010 │ 00110</code></p>
<p>长度为64位，B等于5，取后5位，即拿到00110，值为6，也就是6号桶，buckets[6]</p>
</li>
<li>
<p>确定使用buckets数组还是oldbuckets数组：判断oldbuckets数组中是否为空，不为空说明正处于扩容中，还没完成迁移，则重新计算桶的位置，并在oldbuckets数组找到对应的桶；如果为空，则在buckets数组中找到对应的桶。</p>
</li>
<li>
<p>在桶中找tophash的位置：用key哈希计算得到的哈希值，取高8个bit位 + minTopshash(小于minTopshash值时才需要加)，计算得到此bucket桶中的tophash，即key在桶中的编号，之后在桶中的正常位遍历比较。</p>
</li>
<li>
<p>每个桶是一整片连续的内存空间，先遍历bucket桶中的正常位，与桶中的tophash进行比较，当找到对应的tophash时，根据tophash进行计算得到key，根据key的大小计算得到value的地址，找到value。</p>
</li>
<li>
<p>如果bucket桶中的正常位没找到tophash，且overflow不为空，则继续遍历溢出桶overflow bucket，直到找到对应的tophash，再根据key的大小计算得到value的地址，找到value。</p>
</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// 计算得到bucket桶在buckets数组中的位置
</span><span class="c1"></span><span class="nx">bucket</span> <span class="o">:=</span> <span class="nx">hash</span> <span class="o">&amp;</span> <span class="nf">bucketMask</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">B</span><span class="p">)</span>
<span class="nx">b</span> <span class="o">:=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">h</span><span class="p">.</span><span class="nx">buckets</span><span class="p">)</span> <span class="o">+</span> <span class="nx">bucket</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>

<span class="c1">// 计算得到tophash，miniTopHash用于表示迁移进度，当tophash值小于minTopHash时，表示存的是迁移状态，大于minTopHash时，表示的是计算的哈希值，因此根据hash计算出的结果需要加上minTopHash才表示真正的值。
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">tophash</span><span class="p">(</span><span class="nx">hash</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="kt">uint8</span> <span class="p">{</span>
	<span class="nx">top</span> <span class="o">:=</span> <span class="nb">uint8</span><span class="p">(</span><span class="nx">hash</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="nx">sys</span><span class="p">.</span><span class="nx">PtrSize</span><span class="o">*</span><span class="mi">8</span><span class="o">-</span><span class="mi">8</span><span class="p">))</span>
    <span class="k">if</span> <span class="nx">top</span> <span class="p">&lt;</span> <span class="nx">minTopHash</span> <span class="p">{</span>
        <span class="nx">top</span> <span class="o">+=</span> <span class="nx">minTopHash</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nx">top</span>
<span class="p">}</span>

<span class="c1">// 计算key和value，dataoffset是tophash[8]所占用的大小，所以key的地址就是：bmap的地址 + dataOffset的偏移 + 对应的索引i * key的大小；
</span><span class="c1">// 而value是在所有key之后的，第i个value的递增在加上所有key的偏移即可得出。
</span><span class="c1"></span><span class="nx">k</span> <span class="o">:=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">))</span>
<span class="nx">val</span> <span class="p">=</span> <span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">b</span><span class="p">),</span> <span class="nx">dataOffset</span><span class="o">+</span><span class="nx">bucketCnt</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">keysize</span><span class="p">)</span><span class="o">+</span><span class="nx">i</span><span class="o">*</span><span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">valuesize</span><span class="p">))</span>
</code></pre></td></tr></table>
</div>
</div><p><figure 
	>
	<a href="https://github.com/Nixum/Java-Note/raw/master/picture/go_map_get.png" >
		<img src="https://github.com/Nixum/Java-Note/raw/master/picture/go_map_get.png"
			
			
			
			loading="lazy"
			alt="go map 结构图">
	</a>
	
	<figcaption>go map 结构图</figcaption>
	
</figure></p>
<h3 id="插入">插入</h3>
<p>插入也需要先定位到key的位置后才能进行插入，定位key的操作跟上面是类似的，调用mapassign函数，mapassign入参不用传value，而是通过方法返回key对应的value的指针来进行赋值。</p>
<ol>
<li>
<p>先判断hmap是否为空，是否是并发写入，如果是直接抛错误；修改当前hamp的状态。</p>
</li>
<li>
<p>根据key计算出哈希；还有就是判断bucket桶是否为空，为空则分配bmap数组，。</p>
</li>
<li>
<p><strong>判断 hmap的oldbuckets是否为空，不为空说明当前处于扩容搬迁，则进行搬迁工作（一次最多迁移两个bucket桶），完了再进行之后的流程。</strong></p>
</li>
<li>
<p>根据key的哈希值的低B个bit位，计算得到桶的位置；根据key的哈希值的高8个bit位，计算出tophash。</p>
</li>
<li>
<p>先遍历正常位，从第一个cell开始，比较桶上的每个tophash是否等于计算得到的tophash，如果不等，再判断该tophash是否为空，如果为空，计算key和value的内存地址，进行插入。如果不为空，则遍历下一个cell进行tophash的判断。</p>
</li>
<li>
<p>下一个cell上的tophash与计算的tophash相等，说明发生了哈希冲突，先计算key的地址，找到key，判断key是否相等，如果相等，计算key对应的value地址，将value的值进行更新。</p>
</li>
<li>
<p>如果key不相等，遍历下一个cell的tophash，直到正常位遍历完成，如果此时还不能插入，继续遍历溢出桶，如果溢出桶为空，退出循环。</p>
</li>
<li>
<p>在已有桶和溢出桶都未找到合适的cell插入时，会有两种情况进行判断：</p>
<ol>
<li>
<p>判断当前map的装载因子是否达到默认的6.5，或者当前map的溢出桶数量是否过多，如果是这两种情况之一，则进行扩容，扩容 + 迁移后，继续步骤5上的逻辑（使用了goto关键字）。如果不满足扩容条件，则进行下一种情况的判断</p>
</li>
<li>
<p>此时key还没插入，且正常位已满，还不需要扩容，此时会调用<code>newoverflow()函数</code>。</p>
<p><code>newoverflow()函数</code>使用hmap在<code>extra.nextOverflow</code>中创建好的桶，如果有，遍历这个创建好的桶链表，直到可以放入新的键值对；如果没有，则创建一个桶，增加noverflow计数，将新键值对放入这个桶中，然后将新桶挂载到当前桶overflow字段，成为溢出桶。</p>
<p><code>newoverflow()函数</code>会在一开始判断hmap的<code>extra.nextOverflow</code>是否为空，如果为空会先预分配，不为空则直接将其设置为当前要使用的溢出桶，并把原来的nextOverflow设置为空，目的是充分利用已分配的内存，减少分配次数。</p>
</li>
</ol>
</li>
</ol>
<p><a class="link" href="https://github.com/Nixum/Java-Note/raw/master/source_with_note/go_map_mapassign.go"  target="_blank" rel="noopener"
    >mapassign函数</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">mapassign</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">key</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span><span class="p">)</span> <span class="nx">unsafe</span><span class="p">.</span><span class="nx">Pointer</span> <span class="p">{</span>
    <span class="c1">// ... 一些例行检查，如判空、竞态检查、内存探测、并发读写检查，设置当前hmap的状态flags
</span><span class="c1"></span>    <span class="nx">asign</span><span class="p">:</span>
    	<span class="c1">// 先判断当前是否处于扩容时的搬迁，即h.oldbuckets不为空，先进行搬迁工作
</span><span class="c1"></span>        <span class="c1">// 完了之后，计算出桶的位置，拿到对应的桶；计算tophash
</span><span class="c1"></span>    <span class="nx">bucketloop</span><span class="p">:</span>
    	<span class="c1">// 遍历桶，找到适合插入的位置
</span><span class="c1"></span>    <span class="nx">done</span><span class="p">:</span>
    	<span class="c1">// ... 竞态检查，并发读写检查
</span><span class="c1"></span><span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p><a class="link" href="https://github.com/Nixum/Java-Note/raw/master/source_with_note/go_map_newoverflow.go"  target="_blank" rel="noopener"
    >newoverflow函数</a></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// bmap的overflow(t)方法是返回当前桶的overflow桶的地址
</span><span class="c1">// bmap的setoverflow方法是为bmap的overflow桶赋值下一个桶的地址
</span><span class="c1">// hmap的incrnoverflow()方法是增加hmap的noverflow值，表示溢出桶的数量
</span><span class="c1">// hmap的createOverflow()方法是为hmap的extra.overflow创建新桶
</span><span class="c1"></span>
<span class="kd">func</span> <span class="p">(</span><span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">)</span> <span class="nf">newoverflow</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">b</span> <span class="o">*</span><span class="nx">bmap</span><span class="p">)</span> <span class="o">*</span><span class="nx">bmap</span> <span class="p">{</span>
	<span class="kd">var</span> <span class="nx">ovf</span> <span class="o">*</span><span class="nx">bmap</span>
	<span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="o">&amp;&amp;</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
		<span class="nx">ovf</span> <span class="p">=</span> <span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span>
        <span class="c1">// 如果hmap的extra.nextOverflow桶的没有溢出桶，则进行初始化
</span><span class="c1"></span>		<span class="k">if</span> <span class="nx">ovf</span><span class="p">.</span><span class="nf">overflow</span><span class="p">(</span><span class="nx">t</span><span class="p">)</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">add</span><span class="p">(</span><span class="nx">unsafe</span><span class="p">.</span><span class="nf">Pointer</span><span class="p">(</span><span class="nx">ovf</span><span class="p">),</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucketsize</span><span class="p">)))</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="c1">// 预分配当前桶的溢出桶
</span><span class="c1"></span>			<span class="nx">ovf</span><span class="p">.</span><span class="nf">setoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="kc">nil</span><span class="p">)</span>
			<span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">nextOverflow</span> <span class="p">=</span> <span class="kc">nil</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="nx">ovf</span> <span class="p">=</span> <span class="p">(</span><span class="o">*</span><span class="nx">bmap</span><span class="p">)(</span><span class="nf">newobject</span><span class="p">(</span><span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">))</span>
	<span class="p">}</span>
	<span class="nx">h</span><span class="p">.</span><span class="nf">incrnoverflow</span><span class="p">()</span>
	<span class="k">if</span> <span class="nx">t</span><span class="p">.</span><span class="nx">bucket</span><span class="p">.</span><span class="nx">ptrdata</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">h</span><span class="p">.</span><span class="nf">createOverflow</span><span class="p">()</span>
		<span class="o">*</span><span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">h</span><span class="p">.</span><span class="nx">extra</span><span class="p">.</span><span class="nx">overflow</span><span class="p">,</span> <span class="nx">ovf</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="nx">b</span><span class="p">.</span><span class="nf">setoverflow</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">ovf</span><span class="p">)</span>
	<span class="k">return</span> <span class="nx">ovf</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h2 id="扩容-1">扩容</h2>
<h3 id="扩容条件">扩容条件</h3>
<p><code>!h.growing() &amp;&amp; (overLoadFactor(h.count+1, h.B) || tooManyOverflowBuckets(h.noverflow, h.B))</code></p>
<p>即 在没有正在进行扩容 的情况下，负载因子 &gt; 6.5 或 溢出桶的数量 &gt;= buckets数组的数量</p>
<p>扩容条件的判断发生在<code>mapassign函数</code>，即对map使用put的时候。</p>
<h3 id="扩容策略-1">扩容策略</h3>
<h4 id="增量扩容---降低哈希冲突">增量扩容 - 降低哈希冲突</h4>
<p><code>overLoadFactor函数</code>，该函数返回true，表示哈希表内的元素过多，哈希冲突的概率变大，可能在找到桶，遍历完桶内的元素，还要继续遍历溢出桶链表，此时需要**增量扩容，扩容为原来的两倍 **，降低哈希冲突的概率。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="c1">// count是key的数量
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">overLoadFactor</span><span class="p">(</span><span class="nx">count</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">B</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// loadFactorNum = 13, loadFactorDen = 2, 即count &gt; 8 &amp;&amp; count / (2^B) &gt; 6.5
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">count</span> <span class="p">&gt;</span> <span class="nx">bucketCnt</span> <span class="o">&amp;&amp;</span> <span class="nb">uintptr</span><span class="p">(</span><span class="nx">count</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">loadFactorNum</span> <span class="o">*</span><span class="p">(</span><span class="nf">bucketShift</span><span class="p">(</span><span class="nx">B</span><span class="p">)</span><span class="o">/</span><span class="nx">loadFactorDen</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h4 id="等量扩容---提高桶的利用率防止内存泄漏加快查询效率">等量扩容 - 提高桶的利用率，防止内存泄漏，加快查询效率</h4>
<p><code>tooManyOverflowBuckets函数</code>，该函数返回true，表示由于某一个桶满后，开始使用溢出桶，不断的插入数据到溢出桶，又不断的删除正常桶上的正常位，但此时哈希表的数量又没超阈值，但是空桶太多，溢出桶的数量太多，而每次查找又得先遍历正常位，查找效率变低，此时需要<strong>等量扩容，容量不变，重新迁移键值对</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">tooManyOverflowBuckets</span><span class="p">(</span><span class="nx">noverflow</span> <span class="kt">uint16</span><span class="p">,</span> <span class="nx">B</span> <span class="kt">uint8</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c1">// 如果负载因子太低, 不操作。
</span><span class="c1"></span>    <span class="c1">// 如果负载因子太高，maps的扩容和缩容会使用大量未使用的内存
</span><span class="c1"></span>    <span class="c1">// 太多指的是溢出桶的数量 大于等于 buckets数组的数量
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">B</span> <span class="p">&gt;</span> <span class="mi">15</span> <span class="p">{</span>
        <span class="nx">B</span> <span class="p">=</span> <span class="mi">15</span>
    <span class="p">}</span>
    <span class="c1">// The compiler doesn&#39;t see here that B &lt; 16; mask B to generate shorter shift code.
</span><span class="c1"></span>    <span class="k">return</span> <span class="nx">noverflow</span> <span class="o">&gt;=</span> <span class="nb">uint16</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="nx">B</span><span class="o">&amp;</span><span class="mi">15</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h3 id="触发扩容">触发扩容</h3>
<p>触发扩容条件时，会执行<code>hashGrow函数</code>，<strong>进行新桶的分配，但还未迁移数据</strong>，真正迁移数据在<code>growWork函数</code>中。</p>
<ol>
<li>
<p>首先会判断是增量扩容还是等量扩容，如果是增量扩容，B + 1，即扩容到原来的两倍，如果是等量扩容，B + 0，容量不变</p>
</li>
<li>
<p>将当前buckets数组挂在hmap的oldbuckets字段，当前extra里的溢出桶挂在<code>hmap.extra.oldoverflow</code></p>
</li>
<li>
<p>创建新的buckets数组，容量为新的B值，预创建溢出桶（溢出桶的数量看上面创建初始化逻辑），然后将新的buckets数组挂在buckets字段，新的溢出桶挂在<code>hmap.mapextra.nextOverflow</code>字段上</p>
</li>
</ol>
<p>触发扩容条件，对新桶进行内存分配，只是创建了新的桶，旧数据还在旧桶上，之后还需要完成数据迁移。</p>
<p><a class="link" href="https://github.com/Nixum/Java-Note/raw/master/source_with_note/go_map_hashGrow.go"  target="_blank" rel="noopener"
    >hashGrow函数</a></p>
<h3 id="扩容迁移">扩容迁移</h3>
<p><strong>扩容迁移发生在 mapassign 和 mapdelete 函数中，即进行插入、修改、删除时</strong>，才会调用<code>growWork函数</code>和<code>evacuate函数</code>，完成真正的迁移工作后，才会进行插入、修改或删除。</p>
<p>迁移时是渐进式迁移，一次最多迁移两个bucket桶。</p>
<ol>
<li>在插入、修改或删除中，如果发现oldbuckets数组不为空，表示此时正在扩容中，需要进行扩容迁移，调用<code>growWork函数</code>，<code>growWork函数</code>调用一次<code>evacuate函数</code>，如果调用完成后，hmap的oldbuckets还是非空，则再调用一次<code>evacuate函数</code>，加快迁移进程。</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">growWork</span><span class="p">(</span><span class="nx">t</span> <span class="o">*</span><span class="nx">maptype</span><span class="p">,</span> <span class="nx">h</span> <span class="o">*</span><span class="nx">hmap</span><span class="p">,</span> <span class="nx">bucket</span> <span class="kt">uintptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// 确认搬迁老的 bucket 对应正在使用的 如果当前key映射到老的bucket1，那就搬迁该bucket1
</span><span class="c1"></span>    <span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">bucket</span> <span class="o">&amp;</span> <span class="nx">h</span><span class="p">.</span><span class="nf">oldbucketmask</span><span class="p">())</span>
    <span class="c1">// 再搬迁一个 bucket，以加快搬迁进程
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">h</span><span class="p">.</span><span class="nf">growing</span><span class="p">()</span> <span class="p">{</span>
        <span class="nf">evacuate</span><span class="p">(</span><span class="nx">t</span><span class="p">,</span> <span class="nx">h</span><span class="p">,</span> <span class="nx">h</span><span class="p">.</span><span class="nx">nevacuate</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><ol start="2">
<li>进入<code>evacuate函数</code>：</li>
</ol>
<ul>
<li>
<p>如果是<strong>等量扩容</strong>，B值不变，老bucket桶上的键值计算出来的桶的序号不变，tophash不变，此时会将老桶上的键值对依次地一个个转移到新桶上，使这些键值对在新桶上排列更加紧凑；</p>
</li>
<li>
<p>如果是<strong>增量扩容</strong>，容量变为原来的两倍，B值+1，老bucket桶上的键值计算出来的桶的序号改变，这些键值对计算后的bucket桶的序号可能跟之前一样，也可能是相比原来加上2^B，取决于key哈希值后 老B+1 位的值是0还是1。比如：</p>
<p><code>10010111 | 000011110110110010001111001010100010010110010101010 │ 01010</code>，B=5，bucket的序号是10，增量扩容后为</p>
<p><code>10010111 | 00001111011011001000111100101010001001011001010101 | 001010</code>，B=6，bucket的序号还是10，</p>
<p>另一种情况是</p>
<p><code>10010111 | 000011110110110010001111001010100010010110010101011 │ 01010</code>，B=5，bucket的序号是10，增量扩容后为</p>
<p><code>10010111 | 00001111011011001000111100101010001001011001010101 │ 101010</code>，B=6，bucket的序号是42（10 + 32，即10 + 2 ^5）</p>
<p>tophash不变，原来老bucket桶上的键值对会重新分流到两个新bucket桶上。将老bucket桶上的键值对和其指向的溢出桶上的键值对进行迁移，依次转移到新桶上，每迁移完一个，key在老buckect的tophash设置为evacuatedX或者evacuatedY（tophash的最低位表示迁移到新桶的哪一part，0为x，1为y），hmap的nevacuate计数+1，直到老bucket桶上的键值对迁移完成，最后清空oldbuckets和oldoverflow字段。</p>
<p>这里两个新的桶对应源码里的X part, Y part，因为扩容到原来的 2 倍，桶的数量是原来的 2 倍，前一半桶被称为 X part，后一半桶被称为 Y part。一个 bucket 中的所有key 可能会分流到 2 个桶中，一个位于 X part，一个位于 Y part。所以在搬迁一个 cell 之前，需要计算这个cell要落入到哪一part。</p>
<p>X part 与 Y part的关系：X part + 2 ^ 老B = Y part，之所以要确定key落在哪个区间，是为了方便计算key要插入的内存地址。</p>
</li>
</ul>
<blockquote>
<p>扩容前，B = 2，共有 4 个 buckets，lowbits 表示 hash 值的低位。假设我们不关注其他 buckets 情况，专注在 2 号 bucket。并且假设 overflow 太多，触发了等量扩容。</p>
<p><figure 
	>
	<a href="https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e6%89%a9%e5%ae%b9.png" >
		<img src="https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e6%89%a9%e5%ae%b9.png"
			
			
			
			loading="lazy"
			alt="go map 触发扩容">
	</a>
	
	<figcaption>go map 触发扩容</figcaption>
	
</figure></p>
<p>扩容完成后，overflow bucket 消失了，key 都集中到了一个 bucket，更为紧凑了，提高了查找的效率。</p>
<p><figure 
	>
	<a href="https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e7%ad%89%e9%87%8f%e6%89%a9%e5%ae%b9.png" >
		<img src="https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e7%ad%89%e9%87%8f%e6%89%a9%e5%ae%b9.png"
			
			
			
			loading="lazy"
			alt="go map 等量扩容">
	</a>
	
	<figcaption>go map 等量扩容</figcaption>
	
</figure></p>
<p>假设触发了 2 倍的扩容，那么扩容完成后，老 buckets 中的 key 分裂到了 2 个 新的 bucket。一个在 x part，一个在 y 的 part。依据是 hash 的 lowbits。新 map 中 <code>0-3</code> 称为 x part，<code>4-7</code> 称为 y part。</p>
<p><figure 
	>
	<a href="https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e5%a2%9e%e9%87%8f%e6%89%a9%e5%ae%b9.png" >
		<img src="https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e5%a2%9e%e9%87%8f%e6%89%a9%e5%ae%b9.png"
			
			
			
			loading="lazy"
			alt="go map 增量扩容">
	</a>
	
	<figcaption>go map 增量扩容</figcaption>
	
</figure></p>
</blockquote>
<p><a class="link" href="https://github.com/Nixum/Java-Note/raw/master/source_with_note/go_map_evacuate.go"  target="_blank" rel="noopener"
    >evacuate函数</a></p>
<h2 id="删除">删除</h2>
<p>调用delete函数，无论要删除的key是否存在，delete都不会返回任何结果。删除实际上也是一个key的定位 + 删除的操作，定位到key后，将其键值对置空，hmap的count - 1，tophash置为empty。<strong>删除过程也会检查是否处于扩容状态，如果是，则会触发搬迁</strong>。</p>
<h2 id="遍历">遍历</h2>
<p>对go中的map是无序的，每次遍历出来的顺序都是不一样的，go在每次遍历map时，并不是固定地从0号bucket桶开始遍历，每次都是从一个随机值序号的bucket桶开始遍历，并且是从这个bucket桶的一个随机序号的 正常位开始遍历。</p>
<blockquote>
<ol>
<li>首先从buckets数组中，随机确定一个索引，作为startBucket，然后确定offset偏移量，得到桶中的正常位的位置，作为起始key的地址。</li>
<li>遍历当前bucket及bucket.overflow，判断当前bucket是否正在扩容中，如果是则跳转到3，否则跳转到4。</li>
<li>如果是在扩容中，遍历时会先到当前bucket扩容前的老的bucket桶中遍历那些能迁移到当前桶的key。</li>
</ol>
<p>假如原先的buckets为0，1，那么扩容后的新的buckets为0，1，2，3，此时我们遍历到了buckets[0]， 发现这个bucket正在扩容，那么找到bucket[0]所对应的oldbuckets[0]，遍历里面的key，这时候仅仅遍历那些key经过hash后，可以散列到bucket[0]里面的部分key；同理，当遍历到bucket[2]的时候，发现bucket正在扩容，找到oldbuckets[0]，然后遍历里面可以散列到bucket[2]的那些key。</p>
<ol start="4">
<li>遍历当前这个bucket即可。</li>
<li>继续遍历bucket下面的overflow链表。</li>
<li>如果遍历到了startBucket，说明遍历完了，结束遍历。</li>
</ol>
<p>假设我们有下图所示的一个 map，起始时 B = 1，有两个 bucket，后来触发了扩容（这里不要深究扩容条件，只是一个设定），B 变成 2。并且， 1 号 bucket 中的内容搬迁到了新的 bucket，<code>1 号</code>裂变成 <code>1 号</code>和 <code>3 号</code>；<code>0 号</code> bucket 暂未搬迁。老的 bucket 挂在在 <code>*oldbuckets</code> 指针上面，新的 bucket 则挂在 <code>*buckets</code> 指针上面。</p>
<p><figure 
	>
	<a href="https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e9%81%8d%e5%8e%861.png" >
		<img src="https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e9%81%8d%e5%8e%861.png"
			
			
			
			loading="lazy"
			>
	</a>
	
</figure></p>
<p>这时，我们对此 map 进行遍历。假设经过初始化后，startBucket = 3，offset = 2。于是，遍历的起点将是 3 号 bucket 的 2 号 cell，下面这张图就是开始遍历时的状态：</p>
<p><figure 
	>
	<a href="https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e9%81%8d%e5%8e%862.png" >
		<img src="https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e9%81%8d%e5%8e%862.png"
			
			
			
			loading="lazy"
			>
	</a>
	
</figure></p>
<p>标红的表示起始位置，bucket 遍历顺序为：3 -&gt; 0 -&gt; 1 -&gt; 2，遍历到0号桶时，虽然0号桶此时还没搬迁，但只会遍历0号桶搬迁过后仍然在0号桶的key，即遍历时如果遇到正在扩容，会按照将来扩容完成后新bucket的顺序进行遍历</p>
<p>最终遍历的顺序为:</p>
<p><figure 
	>
	<a href="https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e9%81%8d%e5%8e%863.png" >
		<img src="https://github.com/Nixum/Java-Note/raw/master/picture/go_map_%e9%81%8d%e5%8e%863.png"
			
			
			
			loading="lazy"
			>
	</a>
	
</figure></p>
</blockquote>
<h1 id="参考">参考</h1>
<p><a class="link" href="https://cloud.tencent.com/developer/article/1859042"  target="_blank" rel="noopener"
    >从 map 的 extra 字段谈起</a></p>
<p><a class="link" href="https://learnku.com/docs/the-way-to-go/chapter-description/3611"  target="_blank" rel="noopener"
    >Go入门指南</a></p>
<p><a class="link" href="https://zhuanlan.zhihu.com/p/61121325"  target="_blank" rel="noopener"
    >深入理解Slice底层实现</a></p>
<p><a class="link" href="https://draveness.me/golang/docs/part2-foundation/ch03-datastructure/golang-array-and-slice"  target="_blank" rel="noopener"
    >Go 语言设计与实现</a></p>
<p><a class="link" href="https://studygolang.com/articles/27421"  target="_blank" rel="noopener"
    >Golang源码-Map实现原理分析</a></p>
<p><a class="link" href="https://segmentfault.com/a/1190000020616487"  target="_blank" rel="noopener"
    >Go map原理剖析</a></p>
<p><a class="link" href="https://segmentfault.com/a/1190000023879178"  target="_blank" rel="noopener"
    >年度最佳【golangmap】详解</a></p>
<p><a class="link" href="https://juejin.cn/post/7079964047893856293"  target="_blank" rel="noopener"
    >逐行拆解 Go map 源码</a></p>
<p><a class="link" href="https://zhuanlan.zhihu.com/p/74613114"  target="_blank" rel="noopener"
    >深度解密Go语言之channel</a></p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/go/">Go</a>
        
            <a href="/tags/go-slice%E5%92%8Cmap%E5%8E%9F%E7%90%86/">Go slice和map原理</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    </footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css"integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js"integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8"crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js"integrity="sha384-vZTG03m&#43;2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"crossorigin="anonymous"
                defer="true"
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
    
</article>

    

    <aside class="related-contents--wrapper">
    
    
        <h2 class="section-title">Related contents</h2>
        <div class="related-contents">
            <div class="flex article-list--tile">
                
                    
<article class="">
    <a href="/p/gin%E6%A1%86%E6%9E%B6%E5%8E%9F%E7%90%86/">
        
        

        <div class="article-details">
            <h2 class="article-title">Gin框架原理</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/go-context%E5%92%8Cchannel/">
        
        

        <div class="article-details">
            <h2 class="article-title">Go Context和Channel</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/go-goroutine%E5%92%8Cgc/">
        
        

        <div class="article-details">
            <h2 class="article-title">Go Goroutine和GC</h2>
        </div>
    </a>
</article>
                
                    
<article class="">
    <a href="/p/go-sync%E5%8C%85%E7%9B%B8%E5%85%B3/">
        
        

        <div class="article-details">
            <h2 class="article-title">Go Sync包相关</h2>
        </div>
    </a>
</article>
                
            </div>
        </div>
    
</aside>

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="Nixum/blog"
        issue-term="pathname"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2025 Nixum Blog
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.6.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">

            <section class="widget archives">
                <form action="/search/" class="search-form widget" >
        <p>
            <label>Search</label>
            <input name="keyword" required placeholder="Type something..." />
        
            <button title="Search">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



            </button>
        </p>
    </form>
            </section>

            <section class="widget archives">
                <h2 class="widget-title section-title">Contents</h2>

                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#函数内联优化">函数内联优化</a></li>
    <li><a href="#defer">defer</a></li>
    <li><a href="#内存对齐">内存对齐</a></li>
    <li><a href="#数组">数组</a></li>
    <li><a href="#切片slice">切片Slice</a>
      <ol>
        <li><a href="#数据结构">数据结构</a></li>
        <li><a href="#基本">基本</a></li>
        <li><a href="#扩容">扩容</a>
          <ol>
            <li><a href="#原理">原理</a></li>
            <li><a href="#扩容策略">扩容策略</a></li>
          </ol>
        </li>
      </ol>
    </li>
    <li><a href="#map">Map</a>
      <ol>
        <li><a href="#数据结构-1">数据结构</a></li>
        <li><a href="#基本-1">基本</a></li>
        <li><a href="#创建初始化">创建初始化</a></li>
        <li><a href="#查找与插入">查找与插入</a>
          <ol>
            <li><a href="#key的定位">key的定位</a></li>
            <li><a href="#插入">插入</a></li>
          </ol>
        </li>
        <li><a href="#扩容-1">扩容</a>
          <ol>
            <li><a href="#扩容条件">扩容条件</a></li>
            <li><a href="#扩容策略-1">扩容策略</a>
              <ol>
                <li><a href="#增量扩容---降低哈希冲突">增量扩容 - 降低哈希冲突</a></li>
                <li><a href="#等量扩容---提高桶的利用率防止内存泄漏加快查询效率">等量扩容 - 提高桶的利用率，防止内存泄漏，加快查询效率</a></li>
              </ol>
            </li>
            <li><a href="#触发扩容">触发扩容</a></li>
            <li><a href="#扩容迁移">扩容迁移</a></li>
          </ol>
        </li>
        <li><a href="#删除">删除</a></li>
        <li><a href="#遍历">遍历</a></li>
      </ol>
    </li>
    <li><a href="#参考">参考</a></li>
  </ol>
</nav>
                </div>
            </section>

            <section class="widget archives">
                <h2 class="widget-title section-title">Other Article Tags</h2>
                <section class="widget tagCloud">
    <div class="tagCloud-tags">
        
            <a href="/tags/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/" class="font_size_3">
                主从架构
            </a>
        
            <a href="/tags/javase/" class="font_size_2">
                JavaSE
            </a>
        
            <a href="/tags/%E4%B8%9A%E5%8A%A1/" class="font_size_2">
                业务
            </a>
        
            <a href="/tags/%E6%80%BB%E7%BB%93/" class="font_size_2">
                总结
            </a>
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="font_size_2">
                数据库
            </a>
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%94%81/" class="font_size_2">
                数据库-锁
            </a>
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/" class="font_size_2">
                数据库事务
            </a>
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/" class="font_size_2">
                数据库优化
            </a>
        
            <a href="/tags/%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1/" class="font_size_2">
                系统设计
            </a>
        
            <a href="/tags/%E7%B4%A2%E5%BC%95/" class="font_size_2">
                索引
            </a>
        
            <a href="/tags/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="font_size_2">
                解决方案
            </a>
        
            <a href="/tags/ai/" class="font_size_1">
                AI
            </a>
        
            <a href="/tags/context%E5%8E%9F%E7%90%86/" class="font_size_1">
                context原理
            </a>
        
            <a href="/tags/docker/" class="font_size_1">
                docker
            </a>
        
            <a href="/tags/etcd/" class="font_size_1">
                etcd
            </a>
        
            <a href="/tags/git/" class="font_size_1">
                git
            </a>
        
            <a href="/tags/go/" class="font_size_1">
                Go
            </a>
        
            <a href="/tags/go-channel%E5%8E%9F%E7%90%86/" class="font_size_1">
                Go channel原理
            </a>
        
            <a href="/tags/go-gc/" class="font_size_1">
                Go GC
            </a>
        
            <a href="/tags/go-gin%E5%8E%9F%E7%90%86/" class="font_size_1">
                Go Gin原理
            </a>
        
            <a href="/tags/go-slice%E5%92%8Cmap%E5%8E%9F%E7%90%86/" class="font_size_1">
                Go slice和map原理
            </a>
        
            <a href="/tags/go-sync%E5%8C%85/" class="font_size_1">
                Go sync包
            </a>
        
            <a href="/tags/goroutine/" class="font_size_1">
                Goroutine
            </a>
        
            <a href="/tags/go%E5%B9%B6%E5%8F%91/" class="font_size_1">
                Go并发
            </a>
        
            <a href="/tags/http/" class="font_size_1">
                HTTP
            </a>
        
            <a href="/tags/ioc%E5%92%8Caop/" class="font_size_1">
                IOC和AOP
            </a>
        
            <a href="/tags/istio/" class="font_size_1">
                Istio
            </a>
        
            <a href="/tags/java-bio/" class="font_size_1">
                Java BIO
            </a>
        
            <a href="/tags/java-gc/" class="font_size_1">
                Java GC
            </a>
        
            <a href="/tags/java-nio/" class="font_size_1">
                Java NIO
            </a>
        
            <a href="/tags/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="font_size_1">
                Java内存模型
            </a>
        
            <a href="/tags/java%E5%B9%B6%E5%8F%91/" class="font_size_1">
                Java并发
            </a>
        
            <a href="/tags/java%E9%9B%86%E5%90%88%E7%B1%BB%E5%8E%9F%E7%90%86/" class="font_size_1">
                Java集合类原理
            </a>
        
            <a href="/tags/juc/" class="font_size_1">
                JUC
            </a>
        
            <a href="/tags/jvm/" class="font_size_1">
                JVM
            </a>
        
            <a href="/tags/jwt/" class="font_size_1">
                JWT
            </a>
        
            <a href="/tags/kubernetes/" class="font_size_1">
                Kubernetes
            </a>
        
            <a href="/tags/linux/" class="font_size_1">
                Linux
            </a>
        
            <a href="/tags/mongodb/" class="font_size_1">
                MongoDB
            </a>
        
            <a href="/tags/mysql/" class="font_size_1">
                MySQL
            </a>
        
            <a href="/tags/netty/" class="font_size_1">
                Netty
            </a>
        
            <a href="/tags/orm/" class="font_size_1">
                ORM
            </a>
        
            <a href="/tags/rag/" class="font_size_1">
                RAG
            </a>
        
            <a href="/tags/redis/" class="font_size_1">
                Redis
            </a>
        
            <a href="/tags/rpc/" class="font_size_1">
                RPC
            </a>
        
            <a href="/tags/select%E5%8E%9F%E7%90%86/" class="font_size_1">
                select原理
            </a>
        
            <a href="/tags/session%E5%92%8Ccookie/" class="font_size_1">
                session和cookie
            </a>
        
            <a href="/tags/socket/" class="font_size_1">
                socket
            </a>
        
            <a href="/tags/spring/" class="font_size_1">
                Spring
            </a>
        
            <a href="/tags/spring-security/" class="font_size_1">
                Spring Security
            </a>
        
    </div>
</section>
            </section>

        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>


    </body>
</html>
