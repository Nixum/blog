<!DOCTYPE html>
<html lang="en-us">
    <head><meta charset='utf-8'>
<meta name='viewport' content='width=device-width, initial-scale=1'><meta name='description' content='不好归类的算在这一part'><title>其他</title>

<link rel='canonical' href='http://nixum.cc/p/%E5%85%B6%E4%BB%96/'>

<link rel="stylesheet" href="/scss/style.min.92530ae6146419b2553c7da1866a1ac352d4c1a4d2f985110524bd60c6094d8c.css"><meta property='og:title' content='其他'>
<meta property='og:description' content='不好归类的算在这一part'>
<meta property='og:url' content='http://nixum.cc/p/%E5%85%B6%E4%BB%96/'>
<meta property='og:site_name' content='Nixum Blog'>
<meta property='og:type' content='article'><meta property='article:section' content='Post' /><meta property='article:tag' content='定时任务' /><meta property='article:tag' content='session和cookie' /><meta property='article:tag' content='JWT' /><meta property='article:tag' content='压测调优' /><meta property='article:tag' content='常见业务方案' /><meta property='article:tag' content='布隆过滤器' /><meta property='article:tag' content='淘汰算法' /><meta property='article:published_time' content='2020-09-22T00:00:00&#43;00:00'/><meta property='article:modified_time' content='2021-09-03T00:00:00&#43;00:00'/>
<meta name="twitter:title" content="其他">
<meta name="twitter:description" content="不好归类的算在这一part">
    <link rel="shortcut icon" href="/img/favicon.ico" />

<script async src="https://www.googletagmanager.com/gtag/js?id=G-2D1N64V8VB"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-2D1N64V8VB', { 'anonymize_ip': false });
}
</script>

    </head>
    <body class="
    article-page has-toc
">
    <script>
        (function() {
            const colorSchemeKey = 'StackColorScheme';
            if(!localStorage.getItem(colorSchemeKey)){
                localStorage.setItem(colorSchemeKey, "auto");
            }
        })();
    </script><script>
    (function() {
        const colorSchemeKey = 'StackColorScheme';
        const colorSchemeItem = localStorage.getItem(colorSchemeKey);
        const supportDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches === true;

        if (colorSchemeItem == 'dark' || colorSchemeItem === 'auto' && supportDarkMode) {
            

            document.documentElement.dataset.scheme = 'dark';
        } else {
            document.documentElement.dataset.scheme = 'light';
        }
    })();
</script>
<div class="container main-container flex 
    
        extended
    
">
    
        <div id="article-toolbar">
            <a href="/" class="back-home">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-chevron-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <polyline points="15 6 9 12 15 18" />
</svg>



                <span>Back</span>
            </a>









        </div>
    
<main class="main full-width">
    <article class="main-article">
    <header class="article-header">

    <div class="article-details">
    
    <header class="article-category">
        
            <a href="/categories/%E5%85%B6%E4%BB%96/" >
                其他
            </a>
        
            <a href="/categories/%E6%96%B9%E6%A1%88/" >
                方案
            </a>
        
    </header>
    

    <h2 class="article-title">
        <a href="/p/%E5%85%B6%E4%BB%96/">其他</a>
    </h2>

    
    <h3 class="article-subtitle">
        不好归类的算在这一part
    </h3>
    

    
    <footer class="article-time">
        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <path d="M11.795 21h-6.795a2 2 0 0 1 -2 -2v-12a2 2 0 0 1 2 -2h12a2 2 0 0 1 2 2v4" />
  <circle cx="18" cy="18" r="4" />
  <path d="M15 3v4" />
  <path d="M7 3v4" />
  <path d="M3 11h16" />
  <path d="M18 16.496v1.504l1 1" />
</svg>
                <time class="article-time--published">Sep 22, 2020</time>
            </div>
        

        
            <div>
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



                <time class="article-time--reading">
                    13 minute read
                </time>
            </div>
        
    </footer>
    
</div>
</header>

    <section class="article-content">
    <p>[TOC]</p>
<h1 id="quartz">Quartz</h1>
<ul>
<li>
<p>分为三个部分：e</p>
<ul>
<li>Job&amp;Detial(任务)：定时任务的执行方法，与Trigger配套的</li>
<li>Trigger(触发器)：规定什么时候触发，与Job&amp;Detail配套的</li>
<li>Scheduler(调度器)：单例，把Trigger丢里面由调度器调度，只需要一个Scheduler，配置不同的Trigger；可以理解成类似线程池的东西</li>
</ul>
</li>
<li>
<p>原理：ScheduledThreadPoolExecutor线程池 + 通过Object类的wait()和notify()或者Condition类的await()\signal()进行等待和唤醒、锁保证线程安全 来进行调度</p>
<p>Scheduler有两个调度线程：regular Scheduler Thread（执行常规调度）和Misfire Scheduler Thread（执行错失的任务），Regular Thread 轮询所有Trigger，如果有将要触发的Trigger（用wait和notifyAll实现），则从任务线程池中获取一个空闲线程，然后执行与改Trigger关联的job；Misfire Thraed则是扫描所有的trigger，查看是否有错失的，如果有的话，根据一定的策略进行处理</p>
</li>
<li>
<p>默认是并发的，即如果当前任务没有完成，会自动开一个任务执行</p>
</li>
<li>
<p>注意在分布式集群的情况下，多台机子有相同的定时任务，会出错，此时通过共享数据库的方式实现</p>
<p>Quartz的解决方案：</p>
<p>quartz集群分为水平集群和垂直集群，水平集群即将定时任务节点部署在不同的服务器，其最大的问题就是时钟同步问题，若时钟不能同步，则会导致集群中各个节点状态紊乱，造成不可预知的后果；垂直集群则是集群各节点部署在同一台服务器，时钟同步自然不是问题，但存在单点故障问题，服务器宕机会严重影响服务的可用性</p>
<p>在各个节点会上报任务，存到数据库中，执行时会从数据库中取出触发器来执行，如果触发器的名称和执行时间相同，则只有一个节点去执行此任务。</p>
<p>如果此节点执行失败，则此任务则会被分派到另一节点执行，中途也会自动检查失效的定时调度，发现不成功的，其他节点立马接过来继续完成定时任务。Quartz有11个定时任务调度表</p>
</li>
</ul>
<p>参考</p>
<p><a class="link" href="https://www.cnblogs.com/Dorae/p/9357180.html"  target="_blank" rel="noopener"
    >Quartz原理解密</a></p>
<p><a class="link" href="https://blog.csdn.net/scgyus/article/details/79360316"  target="_blank" rel="noopener"
    >深入解读Quartz的原理</a></p>
<p><a class="link" href="https://blog.csdn.net/xlxxcc/article/details/52104463"  target="_blank" rel="noopener"
    >Quartz 2.2 的实现原理和运行过程</a></p>
<h2 id="其他定时器">其他定时器</h2>
<ul>
<li>Timer：这是java自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。使用这种方式可以让你的程序按照某一个频度执行，但不能在指定时间运行。一般用的较少。单线程，任务一多会阻塞；一个任务出异常其他任务都受影响；受系统时间影响</li>
<li>ScheduledExecutorService：也jdk自带的一个类；是基于线程池设计的定时任务类,每个调度任务都会分配到线程池中的一个线程去执行,也就是说,任务是并发执行,互不影响。线程池+延时队列DelayedQueue(数组、最小堆, 最近要执行的任务放在堆顶) 实现，如果堆顶任务时间未到就阻塞（通过自旋+condition.await\signal实现）。不受系统时间影响</li>
<li>Spring 中的 @Schedule  注解</li>
</ul>
<p>参考：<a class="link" href="https://blog.csdn.net/u013332124/article/details/79603943"  target="_blank" rel="noopener"
    >Java 定时任务实现原理详解</a></p>
<p><a class="link" href="https://www.jianshu.com/p/587901245c95"  target="_blank" rel="noopener"
    >Java优先级队列DelayedWorkQueue原理分析</a></p>
<h1 id="cors">CORS</h1>
<p>浏览器的同源政策的同源指的是：协议相同、域名相同、端口相同，如果非同源，有三种行为会受到限制：Cookie、LocalStorage和IndexDB无法读取；DOM无法获得、AJAX请求不能发送。</p>
<p>前后端分离的场景下，由于浏览器的同源策略，导致浏览器内的请求不同的源的后端是会失败，常见的解决跨域方法是使用CORS，现在常见的web框架都支持CORS，开启即可。</p>
<p>解决跨域的方法除了CORS，还有jsonp，不过已经很少使用了，jsonp本质是利用浏览器允许加载不同源的js文件即<!-- raw HTML omitted -->标签等，将跨域请求<!-- raw HTML omitted -->标签里，返回一段可执行的js代码，其中包含了请求结果，通常是json格式，前端通过返回的js代码执行回调获取结果。</p>
<p>详情见 <a class="link" href="http://www.ruanyifeng.com/blog/2016/04/cors.html"  target="_blank" rel="noopener"
    >跨域资源共享 CORS 详解</a></p>
<p>对于跨域产生的问题，如CSRF跨域请求攻击的解决方案，可参考：<a class="link" href="https://tech.meituan.com/2018/10/11/fe-security-csrf.html"  target="_blank" rel="noopener"
    >美团:如何防止csrf</a></p>
<h1 id="session和cookie">session和cookie</h1>
<ul>
<li>
<p>首先Http是无状态的，因此需要通过session、cookie来达到记录用户状态的目的。</p>
</li>
<li>
<p>传统的session、cookie：session存用户信息，保存在服务端中，cookie里存session对应的sessionId，保存在客户端中，用于找到对应的session，每次请求都会带上该cookie来表示此用户。</p>
</li>
<li>
<p>由于现在实例的部署不可能只部署一个，一般都是集群部署，因此session不可以只存在一个实例的内存中，因此引入Redis来存用户的登录信息</p>
</li>
<li>
<p>现在一般使用 token + Redis来实现 cookie - session 机制，本质上差不多，前端的cookie更多的是存token的信息而已，token也可以存在LocalStorage或sessionStorage中，发送请求时一般是把token的值放在请求头中，而不会把cookie发给后端，这样可以避免当用户禁用cookie导致功能不可用，还有CSRF问题。</p>
</li>
</ul>
<h1 id="jwt">JWT</h1>
<p>JWT = JSON WEB TOKEN</p>
<h2 id="原理">原理</h2>
<p>JWT实际上是一个token(令牌)，分为三部分：Header(头部)、Payload(负载)、Signature(签名)。</p>
<p>Header(头部) ：两部分组成，记录令牌类型和JWT的签名算法，一般是HMACSHA256。</p>
<p>Payload(负载)： 记录用户登录信息(官方规范默认是不加密的，分为官方字段和私有字段）。</p>
<p>Signature(签名) ：记录将 Header、Payload和服务端的密钥组合起来，使用Header(头部)里规定的方式加密。</p>
<p>比如header里保存的加密方式是HMACSHA256，<code>签名 Signature = HMACSHA256(base64URL(header) + &quot;.&quot; + base64URL(payload) + &quot;.&quot; + 保存在后端的密钥)</code></p>
<p>最后的JWT = <code>base64URL(Header) + &quot;.&quot; + base64URL(Payload) + &quot;.&quot; + Signature</code>，后端收到该JWT后验证该签名是否正确，来判断JWT里的用户信息是否可靠。</p>
<p><strong>base64</strong>：64指的是A-Z,a-z，0-9，+，/，将待转换的字符串转成二进制流，每3个8位转成4个6位，6位的二进制数转成十进制，根据码表找到对应的字符，以=号做后缀，凑齐位数</p>
<p>一般是为了解决一些字符编码的问题，将非ASCII字符转化为ASCII字符，还有就是可以对数据做简单加密，base64URL在base64的基础上增加对一些符号的编解码，比如把&quot;-&ldquo;替换成&rdquo;+&quot;，使得它可以出现在url中。</p>
<p><strong>HMACSHA256</strong>：摘要算法，一般用于验证签名是否一致</p>
<h2 id="使用">使用</h2>
<p>可以存储在浏览器的本地缓存localStorage或者cookie中，发送请求的时候放在cookie里，或者放在请求头中</p>
<ul>
<li>JWT的目的是让服务器不保存任何session数据，让后端变成无状态的，因此没办法主动废弃某个token，一旦签发了JWT，在到期之前就会始终有效，如果想要实现这种功能，必然需要在后端保存JWT，就违背了JWT的设计初衷了。</li>
<li>要让JWT实现 续签 和 主动过期功能，必定需要在后端保存JWT
<ul>
<li>jwt主动过期问题，使用黑名单即可；分成两点，客户端要求失效，服务端记录token到黑名单；用户重置密码，服务端记录uid-time键值对，在此之前的token全部失效；客户端把保存的jwt删掉是没用的，此时的jwt依然有效，只是客户端没记录而已</li>
<li>jwt续签问题，一种解决方式是jwt中存储过期时间，服务端设置刷新时间，请求时判断是否在过期时间或刷新时间，在刷新时间内进行token刷新，失效token记入黑名单；</li>
<li>而黑名单过大问题，可以采用记录UID-刷新时间方式解决，判断jwt签发时间，jwt签发时间小于UID-刷新时间的记为失效</li>
</ul>
</li>
<li>个人认为JWT的生成方式本身是有一套规范的，在实际使用过程中也可以对他进行改动，本质上还是一个签名校验而已，一般会对JWT进行魔改，比如使用Header(头部)里的加密方式加密Signature(签名)，Signature(签名)加密Header(头部) 和Payload(负载) 这两部分，服务器里的私钥解密Payload(负载)，得到需要的登录信息，不通过简单的base64URL编码，不对外暴露，签名算法或者签名里的密钥的方式可以改成其他等。</li>
</ul>
<p>JWT参考：<a class="link" href="https://learnku.com/articles/17883"  target="_blank" rel="noopener"
    >JWT 超详细分析</a></p>
<h1 id="cas模型---sso单点登录">CAS模型 - SSO(单点登录)</h1>
<p>可参考：<a class="link" href="https://blog.csdn.net/javaloveiphone/article/details/52439613"  target="_blank" rel="noopener"
    >CAS实现单点登录SSO执行原理探究</a>，讲得算是比较明白，这里是总结基于CAS模式改的单点登录模式</p>
<ul>
<li>第一次访问时，由于没有访问的token，会引导至登录</li>
</ul>
<p><figure 
	>
	<a href="https://github.com/Nixum/Java-Note/raw/master/picture/sso-first-access.png" >
		<img src="https://github.com/Nixum/Java-Note/raw/master/picture/sso-first-access.png"
			
			
			
			loading="lazy"
			alt="第一次访问">
	</a>
	
	<figcaption>第一次访问</figcaption>
	
</figure></p>
<ul>
<li>
<p>再次访问Web-1时，由于前端已存了token，直接使用token进行请求即可</p>
</li>
<li>
<p>已登录Web-1时去访问Web-2，会通过后端认证中心实现单点登录</p>
</li>
</ul>
<p><figure 
	>
	<a href="https://github.com/Nixum/Java-Note/raw/master/picture/sso-second-access.png" >
		<img src="https://github.com/Nixum/Java-Note/raw/master/picture/sso-second-access.png"
			
			
			
			loading="lazy"
			alt="第二次访问">
	</a>
	
	<figcaption>第二次访问</figcaption>
	
</figure></p>
<p>这里在总结一下关于GrantTicket和ServiceTicket，跟CAS模型中提到的TGT、ST、PGT这些东西是类似的，本质是作为验证的票据，图中的GrantTicket、ServiceTicket、token含义如下</p>
<p>GrantTicket：全局会话票据，保存在登录页，通过GrantTicket才能换取ServiceTicket；</p>
<p>ServiceTicket表示访问资源的一次性票据，根据ServiceTicket换取token，换取后失效；</p>
<p>token：登录凭证</p>
<p>GT、ST和token都是保存在Redis中的，他们在Redis中的存储结构如下</p>
<pre tabindex="0"><code>key：TOKEN_${Token的值}
value:
{
    &quot;createTime&quot;: 1565961654807,
    &quot;accountId&quot;: &quot;123&quot;,
    // 用户其他信息
    &quot;grantTicket&quot;: ${GrantTicket的值}  // token关联GT，用于注销时实现全局注销
}

key：GRANT_TICKET_${GrantTicket的值}
value:
{
    &quot;createTime&quot;: 1565961654807,
    &quot;accountId&quot;: &quot;123&quot;,
}

key：SERVICE_TICKET_${ServiceTicket的值}
value:
{
    &quot;createTime&quot;: 1565961654807,
    &quot;grantTicket&quot;: ${GrantTicket的值} // ST关联GT，用于判断该ST是否有效，换取token后删除
}

// token与grantTicket的记录，注销时，根据token中关联的GT，找到所有与之关联的token，进行删除，这里推荐使用Redis的scan命令进行分段查询，原因是Redis是单线程的，如果数据量太大使用keys命令遍历太久，阻塞Redis接收其他命令
key：{grantTicket}-{token}
value：无
</code></pre><h1 id="基于oauth20的第三方登录">基于OAuth2.0的第三方登录</h1>
<p>可参考：<a class="link" href="https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html"  target="_blank" rel="noopener"
    >理解OAuth 2.0</a>，这样基本就入门了，这里是总结项目中如何接入，一般在集成facebook和google的第三方登录也是类似的流程机制，这里只用到了access_token，对于refresh_token，是用来延长access_token的过期时间的，减少短时间内的重复登录，这里就没有涉及到了</p>
<p><figure 
	>
	<a href="https://github.com/Nixum/Java-Note/raw/master/picture/%e5%9f%ba%e4%ba%8eoauth2%e7%9a%84%e7%ac%ac%e4%b8%89%e6%96%b9%e7%99%bb%e5%bd%95%e6%b5%81%e7%a8%8b.png" >
		<img src="https://github.com/Nixum/Java-Note/raw/master/picture/%e5%9f%ba%e4%ba%8eoauth2%e7%9a%84%e7%ac%ac%e4%b8%89%e6%96%b9%e7%99%bb%e5%bd%95%e6%b5%81%e7%a8%8b.png"
			
			
			
			loading="lazy"
			alt="基于OAuth2的第三方登录">
	</a>
	
	<figcaption>基于OAuth2的第三方登录</figcaption>
	
</figure></p>
<p>为什么要后端要根据code + clientId + secret换成access_token，再根据access_token换用户个人信息？</p>
<p>为什么后端不直接code + clientId + secret换用户个人信息呢？</p>
<p>主要还是为了安全，防止中间人攻击</p>
<ul>
<li>
<p>重定向的参数是带在url里的，是直接暴露在客户端的，如果直接返回access_token就不安全，因此才多了code这一层，为了降低code被拦截泄漏后的风险，code的过期时间一般都很短，且是一次性的；</p>
</li>
<li>
<p>另外就是后端对于外部的请求都是不信任的，因此接收到的参数(code)首先还要配合凭证去验证其合法性，对于验证通过后获得的access_token也有更多的操作空间，由后端持有，不会暴露出去</p>
<p>像上图那种登录方案，后端只需要用户个人信息换完token就算完事了，所以看起来好像直接使用code + clientId + secret换用户个人信息就行，但是如果此时需要再获取用户的其他信息，就没有没办法再用code去换了，只能要求用户再次登录，此时如果有access_token就显得多么重要了</p>
</li>
</ul>
<h1 id="压测">压测</h1>
<p>总结一下做过的压测，压测工具jmetter，利用jmette可以多线程并发请求和可以实时查看简易报告的能力</p>
<ol>
<li>
<p>先对被压测服务的接口针对不同场景编写压测用例，设定好TPS的起始和目标值，作为压测计划</p>
</li>
<li>
<p>画压测机器部署关系图，部署压测环境</p>
<ul>
<li>
<p>对于被压测的服务，一般会mock掉与该服务相关关联的服务，比如该服务还连了数据库，该接口请求依赖一些独立部署的中间件，或者依赖其他服务，则会对这些相关的依赖用桩来代替，用于维持通信，以减少这些额外服务的影响。</p>
</li>
<li>
<p>一般一台机器只部署一个服务，特别是被压测服务，此外还要注意被压测服务所在的机器上网络设置相关的参数，比如TCP最大连接数、回收策略之类的设置</p>
</li>
</ul>
</li>
<li>
<p>编写压测脚本，压测脚本越简单越好，尽量让压测工具不影响被压测服务，<strong>脚本最重要的几个设置</strong>： 发起请求时的并发线程数、响应的断言、TPS数，其他那些花里胡哨的输出树状图，饼图啊那些都不用配了，用最简单的报告输出即可</p>
</li>
<li>
<p>部署完后，将脚本配置放到jmeter的机器上，启动压测</p>
<pre tabindex="0"><code>nohup java -jar bin/ApacheJMeter.jar -n -t jmetter脚本路径/config.jmx &gt; test.out &amp;
</code></pre><p>输出到当前目录下的test.out文件里，这里启动是使用默认参数启动，如果对jmetter的JVM设置有要求，也可以在启动时指定JVM参数，如</p>
<pre tabindex="0"><code>nohup java -server -XX:+HeapDumpOnOutOfMemoryError -Xms512m -Xmx512m -XX:+UseG1GC -XX:MaxGCPauseMillis=250 -XX:G1ReservePercent=20 -Djava.security.egd=file:/dev/urandom -jar bin/ApacheJMeter.jar -n -t jmetter脚本路径/config.jmx &gt; test.out &amp;
</code></pre><p>压测开启后可以打开test.out文件查看压测报告</p>
</li>
<li>
<p>一般是按照TPS从小往大压，小的TPS压，在正常延时的情况下可以先判断程序是否有问题，比如内存泄漏，内存溢出，没问题了再逐步往大了压。如果先从大往小压，延时又上不去，此时判断不了是程序内部问题还是过大的TPS导致。压测时间一般最少压一天</p>
</li>
<li>
<p>输出压测报告</p>
</li>
</ol>
<p>一般有如下几个点要注意，这些点到时也要输出到压测报告上</p>
<table>
<thead>
<tr>
<th>监控点</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>jmetter端的TPS、延时、错误率</td>
<td>观察TPS是否符合预期、延时是否达到预期且稳定、错误率要为0。<strong>当程序正常时降低RT的手段</strong>：减少不必要的日志输出、业务逻辑算法是否还有优化空间，是否有IO占用或者频繁序列化反序列化、内部队列是否阻塞</td>
</tr>
<tr>
<td>被压测服务的gc</td>
<td>fgc，ygc不要太频繁，一般来说<strong>fgc 一小时要小于3~4次</strong>；<strong>ygc一分钟要小于3~4次为佳</strong>。</td>
</tr>
<tr>
<td>jmetter端的CPU、内存使用率等</td>
<td>注意jmetter端的CPU是否过高或波动很大，避免影响压测结论</td>
</tr>
<tr>
<td>被压测服务端的CPU、磁盘、内存使用率等</td>
<td>如果cpu过高，如果连续达到90以上，基本上是内存泄漏导致了频繁的fgc；磁盘的占用情况，注意生成的日志是否把磁盘占满了</td>
</tr>
</tbody>
</table>
<p>使用 <code>jstat -gcutil [pid] [时间间隔，每几秒打印] [打印次数]</code>查看GC情况</p>
<p>当被压测端的gc不正常时，应尽量保存事发环境</p>
<p>​	1、收集内存使用基本情况统计：<code>jmap -heap [pid] &gt; [文件名，如heap.log]</code></p>
<p>​	2、收集线程堆栈运行信息：<code>jstack [pid] &gt; [文件名，如stack.log]</code></p>
<p>​	3、收集内存详细使用信息，生成dump内存快照：<code>jmap -dump:format=b,file=[文件名，如heap.dump] [pid]</code></p>
<p>一般使用eclipse mat工具进行内存快照的分析，排查出内存泄漏的问题。</p>
<p>mat的使用参见：<a class="link" href="https://www.cnblogs.com/yueshutong/p/9824772.html"  target="_blank" rel="noopener"
    >Eclipse MAT内存分析工具</a></p>
<p><strong>一般压测脚本的模板：</strong></p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-xml" data-lang="xml"><span class="cp">&lt;?xml version=&#34;1.0&#34; encoding=&#34;UTF-8&#34;?&gt;</span>
<span class="nt">&lt;jmeterTestPlan</span> <span class="na">version=</span><span class="s">&#34;1.2&#34;</span> <span class="na">properties=</span><span class="s">&#34;3.2&#34;</span> <span class="na">jmeter=</span><span class="s">&#34;3.2 r1790748&#34;</span><span class="nt">&gt;</span>
  <span class="nt">&lt;hashTree&gt;</span>
    <span class="nt">&lt;TestPlan</span> <span class="na">guiclass=</span><span class="s">&#34;TestPlanGui&#34;</span> <span class="na">testclass=</span><span class="s">&#34;TestPlan&#34;</span> <span class="na">testname=</span><span class="s">&#34;测试计划&#34;</span> <span class="na">enabled=</span><span class="s">&#34;true&#34;</span><span class="nt">&gt;</span>
        <span class="c">&lt;!-- 一般写压测计划中的序号+名称 --&gt;</span>
      <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;TestPlan.comments&#34;</span><span class="nt">&gt;&lt;/stringProp&gt;</span>
      <span class="nt">&lt;boolProp</span> <span class="na">name=</span><span class="s">&#34;TestPlan.functional_mode&#34;</span><span class="nt">&gt;</span>false<span class="nt">&lt;/boolProp&gt;</span>
      <span class="nt">&lt;boolProp</span> <span class="na">name=</span><span class="s">&#34;TestPlan.serialize_threadgroups&#34;</span><span class="nt">&gt;</span>false<span class="nt">&lt;/boolProp&gt;</span>
      <span class="nt">&lt;elementProp</span> <span class="na">name=</span><span class="s">&#34;TestPlan.user_defined_variables&#34;</span> <span class="na">elementType=</span><span class="s">&#34;Arguments&#34;</span> <span class="na">guiclass=</span><span class="s">&#34;ArgumentsPanel&#34;</span> <span class="na">testclass=</span><span class="s">&#34;Arguments&#34;</span> <span class="na">testname=</span><span class="s">&#34;用户定义的变量&#34;</span> <span class="na">enabled=</span><span class="s">&#34;true&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;collectionProp</span> <span class="na">name=</span><span class="s">&#34;Arguments.arguments&#34;</span><span class="nt">/&gt;</span>
      <span class="nt">&lt;/elementProp&gt;</span>
      <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;TestPlan.user_define_classpath&#34;</span><span class="nt">&gt;&lt;/stringProp&gt;</span>
    <span class="nt">&lt;/TestPlan&gt;</span>
    <span class="nt">&lt;hashTree&gt;</span>
      <span class="nt">&lt;ThreadGroup</span> <span class="na">guiclass=</span><span class="s">&#34;ThreadGroupGui&#34;</span> <span class="na">testclass=</span><span class="s">&#34;ThreadGroup&#34;</span> <span class="na">testname=</span><span class="s">&#34;Thread Group&#34;</span> <span class="na">enabled=</span><span class="s">&#34;true&#34;</span><span class="nt">&gt;</span>
        <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;ThreadGroup.on_sample_error&#34;</span><span class="nt">&gt;</span>continue<span class="nt">&lt;/stringProp&gt;</span>
        <span class="nt">&lt;elementProp</span> <span class="na">name=</span><span class="s">&#34;ThreadGroup.main_controller&#34;</span> <span class="na">elementType=</span><span class="s">&#34;LoopController&#34;</span> <span class="na">guiclass=</span><span class="s">&#34;LoopControlPanel&#34;</span> <span class="na">testclass=</span><span class="s">&#34;LoopController&#34;</span> <span class="na">testname=</span><span class="s">&#34;循环控制器&#34;</span> <span class="na">enabled=</span><span class="s">&#34;true&#34;</span><span class="nt">&gt;</span>
          <span class="nt">&lt;boolProp</span> <span class="na">name=</span><span class="s">&#34;LoopController.continue_forever&#34;</span><span class="nt">&gt;</span>false<span class="nt">&lt;/boolProp&gt;</span>
          <span class="nt">&lt;intProp</span> <span class="na">name=</span><span class="s">&#34;LoopController.loops&#34;</span><span class="nt">&gt;</span>-1<span class="nt">&lt;/intProp&gt;</span>
        <span class="nt">&lt;/elementProp&gt;</span>
        <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;ThreadGroup.num_threads&#34;</span><span class="nt">&gt;</span>500<span class="nt">&lt;/stringProp&gt;</span>                                             <span class="c">&lt;!-- 发起请求时的并发线程数，这里设置为500个并发线程，表示使用这么多的线程数来达到下面设置的TPS数 --&gt;</span>
        <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;ThreadGroup.ramp_time&#34;</span><span class="nt">&gt;</span>8<span class="nt">&lt;/stringProp&gt;</span>
        <span class="nt">&lt;longProp</span> <span class="na">name=</span><span class="s">&#34;ThreadGroup.start_time&#34;</span><span class="nt">&gt;</span>1509332694000<span class="nt">&lt;/longProp&gt;</span>
        <span class="nt">&lt;longProp</span> <span class="na">name=</span><span class="s">&#34;ThreadGroup.end_time&#34;</span><span class="nt">&gt;</span>1509332694000<span class="nt">&lt;/longProp&gt;</span>
        <span class="nt">&lt;boolProp</span> <span class="na">name=</span><span class="s">&#34;ThreadGroup.scheduler&#34;</span><span class="nt">&gt;</span>false<span class="nt">&lt;/boolProp&gt;</span>
        <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;ThreadGroup.duration&#34;</span><span class="nt">&gt;&lt;/stringProp&gt;</span>
        <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;ThreadGroup.delay&#34;</span><span class="nt">&gt;&lt;/stringProp&gt;</span>
      <span class="nt">&lt;/ThreadGroup&gt;</span>
      <span class="nt">&lt;hashTree&gt;</span>
        <span class="nt">&lt;HTTPSamplerProxy</span> <span class="na">guiclass=</span><span class="s">&#34;HttpTestSampleGui&#34;</span> <span class="na">testclass=</span><span class="s">&#34;HTTPSamplerProxy&#34;</span> <span class="na">testname=</span><span class="s">&#34;click http request&#34;</span> <span class="na">enabled=</span><span class="s">&#34;true&#34;</span><span class="nt">&gt;</span>
          <span class="nt">&lt;elementProp</span> <span class="na">name=</span><span class="s">&#34;HTTPsampler.Arguments&#34;</span> <span class="na">elementType=</span><span class="s">&#34;Arguments&#34;</span> <span class="na">guiclass=</span><span class="s">&#34;HTTPArgumentsPanel&#34;</span> <span class="na">testclass=</span><span class="s">&#34;Arguments&#34;</span> <span class="na">testname=</span><span class="s">&#34;用户定义的变量&#34;</span> <span class="na">enabled=</span><span class="s">&#34;true&#34;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;collectionProp</span> <span class="na">name=</span><span class="s">&#34;Arguments.arguments&#34;</span><span class="nt">/&gt;</span>
          <span class="nt">&lt;/elementProp&gt;</span>
          <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;HTTPSampler.domain&#34;</span><span class="nt">&gt;</span>192.168.1.123<span class="nt">&lt;/stringProp&gt;</span>         <span class="c">&lt;!-- 此处为被压测服务的host --&gt;</span>
          <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;HTTPSampler.port&#34;</span><span class="nt">&gt;</span>12345<span class="nt">&lt;/stringProp&gt;</span>                    <span class="c">&lt;!-- 此处为被压测服务的port --&gt;</span>
          <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;HTTPSampler.protocol&#34;</span><span class="nt">&gt;</span>http<span class="nt">&lt;/stringProp&gt;</span>
          <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;HTTPSampler.contentEncoding&#34;</span><span class="nt">&gt;&lt;/stringProp&gt;</span>
          <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;HTTPSampler.path&#34;</span><span class="nt">&gt;</span>${__StringFromFile(/home/urls.log,,,)}<span class="nt">&lt;/stringProp&gt;</span>  <span class="c">&lt;!-- 发起的http请求uri从文件读取，文件路径 --&gt;</span>
          <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;HTTPSampler.method&#34;</span><span class="nt">&gt;</span>GET<span class="nt">&lt;/stringProp&gt;</span>
          <span class="nt">&lt;boolProp</span> <span class="na">name=</span><span class="s">&#34;HTTPSampler.follow_redirects&#34;</span><span class="nt">&gt;</span>false<span class="nt">&lt;/boolProp&gt;</span>
          <span class="nt">&lt;boolProp</span> <span class="na">name=</span><span class="s">&#34;HTTPSampler.auto_redirects&#34;</span><span class="nt">&gt;</span>false<span class="nt">&lt;/boolProp&gt;</span>
          <span class="nt">&lt;boolProp</span> <span class="na">name=</span><span class="s">&#34;HTTPSampler.use_keepalive&#34;</span><span class="nt">&gt;</span>true<span class="nt">&lt;/boolProp&gt;</span>
          <span class="nt">&lt;boolProp</span> <span class="na">name=</span><span class="s">&#34;HTTPSampler.DO_MULTIPART_POST&#34;</span><span class="nt">&gt;</span>false<span class="nt">&lt;/boolProp&gt;</span>
          <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;HTTPSampler.embedded_url_re&#34;</span><span class="nt">&gt;&lt;/stringProp&gt;</span>
          <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;HTTPSampler.implementation&#34;</span><span class="nt">&gt;</span>Java<span class="nt">&lt;/stringProp&gt;</span>
          <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;HTTPSampler.connect_timeout&#34;</span><span class="nt">&gt;&lt;/stringProp&gt;</span>
          <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;HTTPSampler.response_timeout&#34;</span><span class="nt">&gt;&lt;/stringProp&gt;</span>
        <span class="nt">&lt;/HTTPSamplerProxy&gt;</span>
        <span class="nt">&lt;hashTree/&gt;</span>
        <span class="nt">&lt;ResponseAssertion</span> <span class="na">guiclass=</span><span class="s">&#34;AssertionGui&#34;</span> <span class="na">testclass=</span><span class="s">&#34;ResponseAssertion&#34;</span> <span class="na">testname=</span><span class="s">&#34;Response Assertion&#34;</span> <span class="na">enabled=</span><span class="s">&#34;true&#34;</span><span class="nt">&gt;</span>
          <span class="nt">&lt;collectionProp</span> <span class="na">name=</span><span class="s">&#34;Asserion.test_strings&#34;</span><span class="nt">&gt;</span>
            <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;49586&#34;</span><span class="nt">&gt;</span>200<span class="nt">&lt;/stringProp&gt;</span>                                       <span class="c">&lt;!-- http请求的响应断言，要求返回的http code为200才判定为成功 --&gt;</span>
          <span class="nt">&lt;/collectionProp&gt;</span>
          <span class="nt">&lt;stringProp</span> <span class="na">name=</span><span class="s">&#34;Assertion.test_field&#34;</span><span class="nt">&gt;</span>Assertion.response_code<span class="nt">&lt;/stringProp&gt;</span>
          <span class="nt">&lt;boolProp</span> <span class="na">name=</span><span class="s">&#34;Assertion.assume_success&#34;</span><span class="nt">&gt;</span>false<span class="nt">&lt;/boolProp&gt;</span>
          <span class="nt">&lt;intProp</span> <span class="na">name=</span><span class="s">&#34;Assertion.test_type&#34;</span><span class="nt">&gt;</span>8<span class="nt">&lt;/intProp&gt;</span>
        <span class="nt">&lt;/ResponseAssertion&gt;</span>
        <span class="nt">&lt;hashTree/&gt;</span>
        <span class="nt">&lt;ConstantThroughputTimer</span> <span class="na">guiclass=</span><span class="s">&#34;TestBeanGUI&#34;</span> <span class="na">testclass=</span><span class="s">&#34;ConstantThroughputTimer&#34;</span> <span class="na">testname=</span><span class="s">&#34;Constant Throughput Timer&#34;</span> <span class="na">enabled=</span><span class="s">&#34;true&#34;</span><span class="nt">&gt;</span>
          <span class="nt">&lt;intProp</span> <span class="na">name=</span><span class="s">&#34;calcMode&#34;</span><span class="nt">&gt;</span>1<span class="nt">&lt;/intProp&gt;</span>
          <span class="nt">&lt;doubleProp&gt;</span>
            <span class="nt">&lt;name&gt;</span>throughput<span class="nt">&lt;/name&gt;</span>
            <span class="nt">&lt;value&gt;</span>30000.0<span class="nt">&lt;/value&gt;</span>          <span class="c">&lt;!-- 1分钟内发起的请求数，换算为tps为500 --&gt;</span>
            <span class="nt">&lt;savedValue&gt;</span>0.0<span class="nt">&lt;/savedValue&gt;</span>
          <span class="nt">&lt;/doubleProp&gt;</span>
        <span class="nt">&lt;/ConstantThroughputTimer&gt;</span>
        <span class="nt">&lt;hashTree/&gt;</span>
      <span class="nt">&lt;/hashTree&gt;</span>
    <span class="nt">&lt;/hashTree&gt;</span>
    <span class="nt">&lt;WorkBench</span> <span class="na">guiclass=</span><span class="s">&#34;WorkBenchGui&#34;</span> <span class="na">testclass=</span><span class="s">&#34;WorkBench&#34;</span> <span class="na">testname=</span><span class="s">&#34;工作台&#34;</span> <span class="na">enabled=</span><span class="s">&#34;true&#34;</span><span class="nt">&gt;</span>
      <span class="nt">&lt;boolProp</span> <span class="na">name=</span><span class="s">&#34;WorkBench.save&#34;</span><span class="nt">&gt;</span>true<span class="nt">&lt;/boolProp&gt;</span>
    <span class="nt">&lt;/WorkBench&gt;</span>
    <span class="nt">&lt;hashTree/&gt;</span>
  <span class="nt">&lt;/hashTree&gt;</span>
<span class="nt">&lt;/jmeterTestPlan&gt;</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="调优">调优</h1>
<p>参考：https://tech.meituan.com/2016/12/02/performance-tunning.html</p>
<h1 id="布隆过滤器">布隆过滤器</h1>
<p>本质上是基于hash的概率性数据结构，是一个很长的二进制数组，主要用于判断元素可能存在集合中，或者一定不在集合中。</p>
<h2 id="原理-1">原理</h2>
<ol>
<li>有一个长度为m的bit数组，初始每个bit都是0，另外还有k个hash函数；</li>
<li>当加入一个元素时，先调用k个hash函数得到k个结果，将这k个结果与bit数组长度取模得到k个数组下标，将这k个数组下标对应的值置为 1；</li>
<li>查询元素时，同样经过上面步骤的计算，最终得到k个数组下标，判断这些下标对应的值是否为1，如果为1，说明元素可能存在，如果有一个不为1，说明元素一定不存在，返回结果；</li>
</ol>
<h2 id="误判率计算">误判率计算</h2>
<blockquote>
<p>涉及到3个重要的参数：</p>
<ol>
<li><code>m</code>表示bit数组的长度</li>
<li><code>k</code>表示散列函数的个数</li>
<li><code>n</code>表示插入的元素个数</li>
</ol>
<p>布隆过滤器中，一个元素插入后，某个bit为0的概率是<code>(1 − 1/m)^k</code></p>
<p>n元素插入后，某个bit为0的概率是<code>(1 − 1/m)^(n*k)</code></p>
<p>false positive的概率是<code>(1−(1−1/m)^n*k)^k</code></p>
<p>因为需要的是<code>k</code>个不同的bit被设置成1，概率是大约是<code>(1−e^(−k*n/m))^k</code></p>
</blockquote>
<h2 id="实现">实现</h2>
<p>可以基于redis实现，但这里只给出go版本的实现，支持并发安全</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">const</span> <span class="p">(</span>
	<span class="nx">mod7</span>       <span class="p">=</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="mi">3</span> <span class="o">-</span> <span class="mi">1</span>
	<span class="nx">bitPerByte</span> <span class="p">=</span> <span class="mi">8</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Filter</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">lock</span>       <span class="o">*</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span>
	<span class="nx">concurrent</span> <span class="kt">bool</span>
	<span class="c1">// 长度之所以要取2的指数是因为要将取模操作优化成与操作， % 等于 &amp;(2^n-1)
</span><span class="c1"></span>	<span class="nx">m</span>     <span class="kt">uint64</span> <span class="c1">// bit array of m bits, m will be ceiling to power of 2
</span><span class="c1"></span>	<span class="nx">n</span>     <span class="kt">uint64</span> <span class="c1">// number of inserted elements
</span><span class="c1"></span>	<span class="nx">log2m</span> <span class="kt">uint64</span> <span class="c1">// log_2 of m
</span><span class="c1"></span>	<span class="nx">k</span>     <span class="kt">uint64</span> <span class="c1">// the number of hash function
</span><span class="c1"></span>	<span class="nx">keys</span>  <span class="p">[]</span><span class="kt">byte</span> <span class="c1">// byte array to store hash value
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">size</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">k</span> <span class="kt">uint64</span><span class="p">,</span> <span class="nx">race</span> <span class="kt">bool</span><span class="p">)</span> <span class="o">*</span><span class="nx">Filter</span> <span class="p">{</span>
	<span class="nx">log2</span> <span class="o">:=</span> <span class="nb">uint64</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Ceil</span><span class="p">(</span><span class="nx">math</span><span class="p">.</span><span class="nf">Log2</span><span class="p">(</span><span class="nb">float64</span><span class="p">(</span><span class="nx">size</span><span class="p">))))</span>
	<span class="nx">filter</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">Filter</span><span class="p">{</span>
		<span class="nx">m</span><span class="p">:</span>          <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">log2</span><span class="p">,</span>
		<span class="nx">log2m</span><span class="p">:</span>      <span class="nx">log2</span><span class="p">,</span>
		<span class="nx">k</span><span class="p">:</span>          <span class="nx">k</span><span class="p">,</span>
		<span class="nx">keys</span><span class="p">:</span>       <span class="nb">make</span><span class="p">([]</span><span class="kt">byte</span><span class="p">,</span> <span class="mi">1</span><span class="o">&lt;&lt;</span><span class="nx">log2</span><span class="p">),</span>
		<span class="nx">concurrent</span><span class="p">:</span> <span class="nx">race</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">filter</span><span class="p">.</span><span class="nx">concurrent</span> <span class="p">{</span>
		<span class="nx">filter</span><span class="p">.</span><span class="nx">lock</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">sync</span><span class="p">.</span><span class="nx">RWMutex</span><span class="p">{}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">filter</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Filter</span><span class="p">)</span> <span class="nf">Add</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="o">*</span><span class="nx">Filter</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">f</span><span class="p">.</span><span class="nx">concurrent</span> <span class="p">{</span>
		<span class="nx">f</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
		<span class="k">defer</span> <span class="nx">f</span><span class="p">.</span><span class="nx">lock</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">h</span> <span class="o">:=</span> <span class="nf">baseHash</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="nb">uint64</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="nx">f</span><span class="p">.</span><span class="nx">k</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">loc</span> <span class="o">:=</span> <span class="nf">location</span><span class="p">(</span><span class="nx">h</span><span class="p">,</span> <span class="nx">i</span><span class="p">)</span>
		<span class="nx">slot</span><span class="p">,</span> <span class="nx">mod</span> <span class="o">:=</span> <span class="nx">f</span><span class="p">.</span><span class="nf">location</span><span class="p">(</span><span class="nx">loc</span><span class="p">)</span>
		<span class="nx">f</span><span class="p">.</span><span class="nx">keys</span><span class="p">[</span><span class="nx">slot</span><span class="p">]</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="nx">mod</span>
	<span class="p">}</span>
	<span class="nx">f</span><span class="p">.</span><span class="nx">n</span><span class="o">++</span>
	<span class="k">return</span> <span class="nx">f</span>
<span class="p">}</span>

<span class="c1">// location returns the bit position in byte array
</span><span class="c1">// &amp; (f.m - 1) is the quick way for mod operation
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">f</span> <span class="o">*</span><span class="nx">Filter</span><span class="p">)</span> <span class="nf">location</span><span class="p">(</span><span class="nx">h</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">(</span><span class="kt">uint64</span><span class="p">,</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">slot</span> <span class="o">:=</span> <span class="p">(</span><span class="nx">h</span> <span class="o">/</span> <span class="nx">bitPerByte</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="nx">f</span><span class="p">.</span><span class="nx">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
	<span class="nx">mod</span> <span class="o">:=</span> <span class="nx">h</span> <span class="o">&amp;</span> <span class="nx">mod7</span>
	<span class="k">return</span> <span class="nx">slot</span><span class="p">,</span> <span class="nx">mod</span>
<span class="p">}</span>

<span class="c1">// baseHash returns the murmur3 128-bit hash
</span><span class="c1"></span><span class="kd">func</span> <span class="nf">baseHash</span><span class="p">(</span><span class="nx">data</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">[]</span><span class="kt">uint64</span> <span class="p">{</span>
	<span class="nx">a1</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span> <span class="c1">// to grab another bit of data
</span><span class="c1"></span>	<span class="nx">hasher</span> <span class="o">:=</span> <span class="nx">murmur3</span><span class="p">.</span><span class="nf">New128</span><span class="p">()</span>
	<span class="nx">hasher</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">data</span><span class="p">)</span> <span class="c1">// #nosec
</span><span class="c1"></span>	<span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span> <span class="o">:=</span> <span class="nx">hasher</span><span class="p">.</span><span class="nf">Sum128</span><span class="p">()</span>
	<span class="nx">hasher</span><span class="p">.</span><span class="nf">Write</span><span class="p">(</span><span class="nx">a1</span><span class="p">)</span> <span class="c1">// #nosec
</span><span class="c1"></span>	<span class="nx">v3</span><span class="p">,</span> <span class="nx">v4</span> <span class="o">:=</span> <span class="nx">hasher</span><span class="p">.</span><span class="nf">Sum128</span><span class="p">()</span>
	<span class="k">return</span> <span class="p">[]</span><span class="kt">uint64</span><span class="p">{</span>
		<span class="nx">v1</span><span class="p">,</span> <span class="nx">v2</span><span class="p">,</span> <span class="nx">v3</span><span class="p">,</span> <span class="nx">v4</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="淘汰算法">淘汰算法</h1>
<h2 id="lru">LRU</h2>
<p>java实现，非线程安全</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span><span class="lnt">106
</span><span class="lnt">107
</span><span class="lnt">108
</span><span class="lnt">109
</span><span class="lnt">110
</span><span class="lnt">111
</span><span class="lnt">112
</span><span class="lnt">113
</span><span class="lnt">114
</span><span class="lnt">115
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="c1">// 注意每一次对节点有操作对需要同时操作 nodeMap和lruQueue
</span><span class="c1">// LRU本质是利用 hashMap 和 双向链表 实现
</span><span class="c1"></span><span class="kd">public</span> <span class="kd">class</span> <span class="nc">LRUCache</span> <span class="o">{</span>

  <span class="kd">private</span> <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Node</span><span class="o">&gt;</span> <span class="n">nodeMap</span><span class="o">;</span>
  <span class="kd">private</span> <span class="n">DoubleLinkedList</span> <span class="n">lruQueue</span><span class="o">;</span>
  <span class="kd">private</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

  <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">()</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">(</span><span class="n">3</span><span class="o">);</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="nf">LRUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">size</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">this</span><span class="o">.</span><span class="na">size</span> <span class="o">=</span> <span class="n">size</span><span class="o">;</span>
    <span class="k">this</span><span class="o">.</span><span class="na">nodeMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
    <span class="k">this</span><span class="o">.</span><span class="na">lruQueue</span> <span class="o">=</span> <span class="k">new</span> <span class="n">DoubleLinkedList</span><span class="o">();</span>
  <span class="o">}</span>


  <span class="kd">public</span> <span class="n">String</span> <span class="nf">get</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nodeMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">n</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="c1">// 获取后直接放到到最前的位置
</span><span class="c1"></span>    <span class="n">put</span><span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">key</span><span class="o">,</span> <span class="n">n</span><span class="o">.</span><span class="na">value</span><span class="o">);</span>
    <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="na">value</span><span class="o">;</span>
  <span class="o">}</span>

  <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
    <span class="n">Node</span> <span class="n">newNode</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Node</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">value</span><span class="o">);</span>
    <span class="c1">// 如果包含，则放到最前
</span><span class="c1"></span>    <span class="k">if</span> <span class="o">(</span><span class="n">nodeMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
      <span class="n">lruQueue</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">nodeMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">));</span>
      <span class="n">lruQueue</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">newNode</span><span class="o">);</span>
      <span class="c1">// 记得更新map
</span><span class="c1"></span>      <span class="n">nodeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">newNode</span><span class="o">);</span>
    <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
      <span class="c1">// 如果满了，则移除最后一个
</span><span class="c1"></span>      <span class="k">if</span> <span class="o">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">lruQueue</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
        <span class="n">Node</span> <span class="n">last</span> <span class="o">=</span> <span class="n">lruQueue</span><span class="o">.</span><span class="na">removeLast</span><span class="o">();</span>
        <span class="n">nodeMap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">last</span><span class="o">.</span><span class="na">key</span><span class="o">);</span>
      <span class="o">}</span>
      <span class="n">nodeMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">newNode</span><span class="o">);</span>
      <span class="n">lruQueue</span><span class="o">.</span><span class="na">addFirst</span><span class="o">(</span><span class="n">newNode</span><span class="o">);</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="kd">private</span> <span class="kd">class</span> <span class="nc">Node</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">key</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">String</span> <span class="n">value</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="n">pre</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="n">next</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Node</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">String</span> <span class="n">value</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">this</span><span class="o">.</span><span class="na">key</span> <span class="o">=</span> <span class="n">key</span><span class="o">;</span>
      <span class="k">this</span><span class="o">.</span><span class="na">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>

  <span class="c1">// 封装双向链表方法，构建时要注意前后节点指向和空指针问题
</span><span class="c1"></span>  <span class="kd">private</span> <span class="kd">class</span> <span class="nc">DoubleLinkedList</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="n">head</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">Node</span> <span class="n">tail</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">addFirst</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">==</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="n">count</span> <span class="o">++;</span>
      <span class="n">n</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">head</span><span class="o">;</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">head</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">head</span><span class="o">.</span><span class="na">pre</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">Node</span> <span class="nf">removeLast</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="kc">null</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="n">Node</span> <span class="n">result</span> <span class="o">=</span> <span class="n">tail</span><span class="o">;</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">tail</span><span class="o">.</span><span class="na">pre</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">tail</span><span class="o">.</span><span class="na">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">head</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="kc">null</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="n">count</span> <span class="o">--;</span>
      <span class="k">return</span> <span class="n">result</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">remove</span><span class="o">(</span><span class="n">Node</span> <span class="n">n</span><span class="o">)</span> <span class="o">{</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="o">;</span>
      <span class="o">}</span>
      <span class="n">count</span> <span class="o">--;</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">pre</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">n</span><span class="o">.</span><span class="na">pre</span><span class="o">.</span><span class="na">next</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">;</span>
      <span class="o">}</span>
      <span class="k">if</span> <span class="o">(</span><span class="n">n</span><span class="o">.</span><span class="na">next</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">n</span><span class="o">.</span><span class="na">next</span><span class="o">.</span><span class="na">pre</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">pre</span><span class="o">;</span>
      <span class="o">}</span> <span class="k">else</span> <span class="o">{</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="na">pre</span><span class="o">;</span>
      <span class="o">}</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">int</span> <span class="nf">size</span><span class="o">()</span> <span class="o">{</span>
      <span class="k">return</span> <span class="n">count</span><span class="o">;</span>
    <span class="o">}</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>golang实现，非并发安全，下面这种写法是平铺了双向链表，链表的长度通过map的长度计算得到</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span><span class="lnt">76
</span><span class="lnt">77
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">LRUCache</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">nodeMap</span>  <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">Node</span>
	<span class="nx">head</span>     <span class="o">*</span><span class="nx">Node</span>
	<span class="nx">tail</span>     <span class="o">*</span><span class="nx">Node</span>
	<span class="nx">cap</span>      <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Node</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">key</span>   <span class="kt">string</span>
	<span class="nx">val</span>   <span class="kt">string</span>
	<span class="nx">next</span>  <span class="o">*</span><span class="nx">Node</span>
	<span class="nx">pre</span>   <span class="o">*</span><span class="nx">Node</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewLRUCache</span><span class="p">(</span><span class="nx">capacity</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">LRUCache</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">LRUCache</span><span class="p">{</span><span class="nx">nodeMap</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">Node</span><span class="p">),</span> <span class="nx">cap</span><span class="p">:</span> <span class="nx">capacity</span><span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">lru</span> <span class="o">*</span><span class="nx">LRUCache</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">existNode</span><span class="p">,</span> <span class="nx">exist</span> <span class="o">:=</span> <span class="nx">lru</span><span class="p">.</span><span class="nx">nodeMap</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">exist</span> <span class="p">{</span>
        <span class="nx">lru</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">existNode</span><span class="p">)</span>
        <span class="nx">lru</span><span class="p">.</span><span class="nf">addFirst</span><span class="p">(</span><span class="nx">existNode</span><span class="p">)</span>
        <span class="k">return</span> <span class="nx">existNode</span><span class="p">.</span><span class="nx">val</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">lru</span> <span class="o">*</span><span class="nx">LRUCache</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">val</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">existNode</span><span class="p">,</span> <span class="nx">exist</span> <span class="o">:=</span> <span class="nx">lru</span><span class="p">.</span><span class="nx">nodeMap</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">exist</span> <span class="p">{</span>
        <span class="nx">existNode</span><span class="p">.</span><span class="nx">val</span> <span class="p">=</span> <span class="nx">val</span>
        <span class="nx">lru</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">existNode</span><span class="p">)</span>
        <span class="nx">lru</span><span class="p">.</span><span class="nf">addFirst</span><span class="p">(</span><span class="nx">existNode</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="nx">newNode</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">node</span><span class="p">{</span><span class="nx">key</span><span class="p">:</span> <span class="nx">key</span><span class="p">,</span> <span class="nx">val</span><span class="p">:</span> <span class="nx">val</span><span class="p">}</span>
        <span class="nx">lru</span><span class="p">.</span><span class="nx">nodeMap</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">newNode</span>
        <span class="nx">lru</span><span class="p">.</span><span class="nf">addFirst</span><span class="p">(</span><span class="nx">newNode</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">lru</span><span class="p">.</span><span class="nx">nodeMap</span><span class="p">)</span> <span class="p">&gt;</span> <span class="nx">lru</span><span class="p">.</span><span class="nx">cap</span> <span class="p">{</span>
        <span class="c1">// 一定要先delete，不然执行完remove，
</span><span class="c1"></span>        <span class="nb">delete</span><span class="p">(</span><span class="nx">lru</span><span class="p">.</span><span class="nx">nodeMap</span><span class="p">,</span> <span class="nx">lru</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span>
        <span class="nx">lru</span><span class="p">.</span><span class="nf">remove</span><span class="p">(</span><span class="nx">lru</span><span class="p">.</span><span class="nx">tail</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">lru</span> <span class="o">*</span><span class="nx">LRUCache</span><span class="p">)</span> <span class="nf">addFirst</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">n</span><span class="p">.</span><span class="nx">pre</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="nx">n</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">lru</span><span class="p">.</span><span class="nx">head</span>
    <span class="k">if</span> <span class="nx">lru</span><span class="p">.</span><span class="nx">head</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">lru</span><span class="p">.</span><span class="nx">head</span><span class="p">.</span><span class="nx">pre</span> <span class="p">=</span> <span class="nx">n</span>
    <span class="p">}</span>
    <span class="nx">lru</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">n</span>
    <span class="k">if</span> <span class="nx">lru</span><span class="p">.</span><span class="nx">tail</span> <span class="o">==</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">lru</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="nx">n</span>
        <span class="nx">lru</span><span class="p">.</span><span class="nx">tail</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="kc">nil</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">lru</span> <span class="o">*</span><span class="nx">LRUCache</span><span class="p">)</span> <span class="nf">remove</span><span class="p">(</span><span class="nx">n</span> <span class="o">*</span><span class="nx">Node</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// n的next和pre要置为null，防止内存泄漏
</span><span class="c1"></span>    <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="nx">lru</span><span class="p">.</span><span class="nx">head</span> <span class="p">{</span>
        <span class="nx">lru</span><span class="p">.</span><span class="nx">head</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">next</span>
        <span class="k">if</span> <span class="nx">n</span><span class="p">.</span><span class="nx">next</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
            <span class="nx">n</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">pre</span> <span class="p">=</span> <span class="kc">nil</span>
        <span class="p">}</span>
        <span class="nx">n</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="kc">nil</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="nx">n</span> <span class="o">==</span> <span class="nx">lru</span><span class="p">.</span><span class="nx">tail</span> <span class="p">{</span>
        <span class="nx">lru</span><span class="p">.</span><span class="nx">tail</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">pre</span>
        <span class="nx">n</span><span class="p">.</span><span class="nx">pre</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="kc">nil</span>
        <span class="nx">n</span><span class="p">.</span><span class="nx">pre</span> <span class="p">=</span> <span class="kc">nil</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="nx">n</span><span class="p">.</span><span class="nx">pre</span><span class="p">.</span><span class="nx">next</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">next</span>
    <span class="nx">n</span><span class="p">.</span><span class="nx">next</span><span class="p">.</span><span class="nx">pre</span> <span class="p">=</span> <span class="nx">n</span><span class="p">.</span><span class="nx">pre</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>关于并发安全，最简单的实现就是在调用Get和Put方法时加读写锁，但是这种做法锁的粒度比较大，每次会锁住整个底层的双向链表和map，导致在高并发情况下吞吐量不高，优化的思路就是对map分片，通过分片上锁来减小锁的粒度，然后再双向链表节点的操作上进行优化。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">capacity</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">LRUCache</span> <span class="p">{</span>
	<span class="nx">shards</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">LRUCacheShard</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
	<span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">i</span> <span class="p">&lt;</span> <span class="mi">256</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
		<span class="nx">shards</span><span class="p">[</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%02x&#34;</span><span class="p">,</span> <span class="nx">i</span><span class="p">)]</span> <span class="p">=</span> <span class="o">&amp;</span><span class="nx">LRUCacheShard</span><span class="p">{</span>
			<span class="nx">Cap</span><span class="p">:</span>  <span class="nx">capacity</span><span class="p">,</span>
			<span class="nx">Keys</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="nx">list</span><span class="p">.</span><span class="nx">Element</span><span class="p">),</span>
			<span class="nx">List</span><span class="p">:</span> <span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">(),</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">LRUCache</span><span class="p">{</span>
		<span class="nx">shards</span><span class="p">:</span> <span class="nx">shards</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">LRUCache</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
	<span class="nx">shard</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">GetShard</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nf">RLock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">shard</span><span class="p">.</span><span class="nf">RUnlock</span><span class="p">()</span>
	<span class="err">……</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">LRUCache</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">key</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
  	<span class="nx">shard</span> <span class="o">:=</span> <span class="nx">c</span><span class="p">.</span><span class="nf">GetShard</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
	<span class="nx">shard</span><span class="p">.</span><span class="nf">Lock</span><span class="p">()</span>
	<span class="k">defer</span> <span class="nx">shard</span><span class="p">.</span><span class="nf">Unlock</span><span class="p">()</span>
	<span class="err">……</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">LRUCache</span><span class="p">)</span> <span class="nf">GetShard</span><span class="p">(</span><span class="nx">key</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="nx">shard</span> <span class="o">*</span><span class="nx">LRUCacheShard</span><span class="p">)</span> <span class="p">{</span>
  <span class="nx">hasher</span> <span class="o">:=</span> <span class="nx">sha1</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
  <span class="nx">hasher</span><span class="p">.</span><span class="nf">Write</span><span class="p">([]</span><span class="nb">byte</span><span class="p">(</span><span class="nx">key</span><span class="p">))</span>
  <span class="nx">shardKey</span> <span class="o">:=</span>  <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span><span class="s">&#34;%x&#34;</span><span class="p">,</span> <span class="nx">hasher</span><span class="p">.</span><span class="nf">Sum</span><span class="p">(</span><span class="kc">nil</span><span class="p">))[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
  <span class="k">return</span> <span class="nx">c</span><span class="p">.</span><span class="nx">shards</span><span class="p">[</span><span class="nx">shardKey</span><span class="p">]</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>其中，在Get方法中，如果存在，还需要修改key所在节点的位置，直接调put即可，当然这种方式的粒度还是比较大，再次优化的思路是对map的操作还是得上锁，但对双向链表的操作无需上锁，双向链表移动节点和删除节点可以同时操作，可以通过两个channel实现，<a class="link" href="https://github.com/halfrost/LeetCode-Go/blob/master/template/CLRUCache.go"  target="_blank" rel="noopener"
    >参考</a></p>
<h2 id="lfu">LFU</h2>
<p>java实现，非线程安全</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span><span class="lnt">74
</span><span class="lnt">75
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-java" data-lang="java"><span class="cm">/**
</span><span class="cm"> * 频次最少使用
</span><span class="cm"> * 设定容量，每次get key会修改使用次数和使用时间，当满容量时，移除次数最少的那个
</span><span class="cm"> * 如果有多个key的使用次数一样，则移除使用时间最旧的那个
</span><span class="cm"> */</span>
<span class="kd">public</span> <span class="kd">class</span> <span class="nc">LFUCache</span> <span class="o">{</span>

    <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">String</span><span class="o">&gt;</span> <span class="n">keyValMap</span><span class="o">;</span>
    <span class="n">Map</span><span class="o">&lt;</span><span class="n">String</span><span class="o">,</span> <span class="n">Integer</span><span class="o">&gt;</span> <span class="n">key2FreqMap</span><span class="o">;</span> <span class="c1">// key和使用频率的映射
</span><span class="c1"></span>    <span class="c1">// 用LinkHashSet来模拟使用时间，使用LinkHashSet还有一个目的是便于根据key进行删除
</span><span class="c1"></span>    <span class="n">Map</span><span class="o">&lt;</span><span class="n">Integer</span><span class="o">,</span> <span class="n">LinkedHashSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;&gt;</span> <span class="n">freq2KeysMap</span><span class="o">;</span> <span class="c1">// 使用频率和key的映射
</span><span class="c1"></span>    <span class="kt">int</span> <span class="n">minFreq</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">cap</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">LFUCache</span><span class="o">(</span><span class="kt">int</span> <span class="n">cap</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">keyValMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">key2FreqMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="n">freq2KeysMap</span> <span class="o">=</span> <span class="k">new</span> <span class="n">HashMap</span><span class="o">&lt;&gt;();</span>
        <span class="k">this</span><span class="o">.</span><span class="na">cap</span> <span class="o">=</span> <span class="n">cap</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">minFreq</span> <span class="o">=</span> <span class="n">0</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="n">String</span> <span class="nf">get</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(!</span><span class="n">keyValMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
            <span class="k">return</span> <span class="s">&#34;&#34;</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="n">increaseFreq</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">return</span> <span class="n">keyValMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
    <span class="o">}</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">put</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">,</span> <span class="n">String</span> <span class="n">val</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">cap</span> <span class="o">&lt;=</span> <span class="n">0</span><span class="o">)</span> <span class="o">{</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">keyValMap</span><span class="o">.</span><span class="na">containsKey</span><span class="o">(</span><span class="n">key</span><span class="o">))</span> <span class="o">{</span>
            <span class="n">keyValMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
            <span class="n">increaseFreq</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
            <span class="k">return</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">if</span> <span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">cap</span> <span class="o">&lt;=</span> <span class="n">keyValMap</span><span class="o">.</span><span class="na">size</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">removeMinFreqKey</span><span class="o">();</span>
        <span class="o">}</span>
        <span class="n">keyValMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">val</span><span class="o">);</span>
        <span class="n">key2FreqMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">1</span><span class="o">);</span>
        <span class="n">freq2KeysMap</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">1</span><span class="o">,</span> <span class="k">new</span> <span class="n">LinkedHashSet</span><span class="o">&lt;&gt;());</span>
        <span class="n">freq2KeysMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">1</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">this</span><span class="o">.</span><span class="na">minFreq</span> <span class="o">=</span> <span class="n">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">increaseFreq</span><span class="o">(</span><span class="n">String</span> <span class="n">key</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">key2FreqMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="n">key2FreqMap</span><span class="o">.</span><span class="na">put</span><span class="o">(</span><span class="n">key</span><span class="o">,</span> <span class="n">freq</span><span class="o">+</span><span class="n">1</span><span class="o">);</span>
        <span class="n">freq2KeysMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">freq</span><span class="o">).</span><span class="na">remove</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="n">freq2KeysMap</span><span class="o">.</span><span class="na">putIfAbsent</span><span class="o">(</span><span class="n">freq</span> <span class="o">+</span> <span class="n">1</span><span class="o">,</span> <span class="k">new</span> <span class="n">LinkedHashSet</span><span class="o">&lt;&gt;());</span>
        <span class="n">freq2KeysMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">freq</span> <span class="o">+</span> <span class="n">1</span><span class="o">).</span><span class="na">add</span><span class="o">(</span><span class="n">key</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">freq2KeysMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="n">freq</span><span class="o">).</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">freq2KeysMap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">freq</span><span class="o">);</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">freq</span> <span class="o">==</span> <span class="k">this</span><span class="o">.</span><span class="na">minFreq</span><span class="o">)</span> <span class="o">{</span>
                <span class="k">this</span><span class="o">.</span><span class="na">minFreq</span><span class="o">++;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>

    <span class="kt">void</span> <span class="nf">removeMinFreqKey</span><span class="o">()</span> <span class="o">{</span>
        <span class="n">LinkedHashSet</span><span class="o">&lt;</span><span class="n">String</span><span class="o">&gt;</span> <span class="n">keys</span> <span class="o">=</span> <span class="n">freq2KeysMap</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">minFreq</span><span class="o">);</span>
        <span class="n">String</span> <span class="n">delKey</span> <span class="o">=</span> <span class="n">keys</span><span class="o">.</span><span class="na">iterator</span><span class="o">().</span><span class="na">next</span><span class="o">();</span>
        <span class="n">keys</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">delKey</span><span class="o">);</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">keys</span><span class="o">.</span><span class="na">isEmpty</span><span class="o">())</span> <span class="o">{</span>
            <span class="n">freq2KeysMap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="k">this</span><span class="o">.</span><span class="na">minFreq</span><span class="o">);</span>
            <span class="c1">// 这里无需更新 minFreq 的值，因为该方法是在插入新key时使用，此时minFreq一定是1
</span><span class="c1"></span>        <span class="o">}</span>
        <span class="n">keyValMap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">delKey</span><span class="o">);</span>
        <span class="n">key2FreqMap</span><span class="o">.</span><span class="na">remove</span><span class="o">(</span><span class="n">delKey</span><span class="o">);</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></td></tr></table>
</div>
</div><p>golang实现，非并发安全，利用 优先级队列（最小堆） + map实现，使用的是go自带的heap数据结构，通过Item数组结构实现</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">  1
</span><span class="lnt">  2
</span><span class="lnt">  3
</span><span class="lnt">  4
</span><span class="lnt">  5
</span><span class="lnt">  6
</span><span class="lnt">  7
</span><span class="lnt">  8
</span><span class="lnt">  9
</span><span class="lnt"> 10
</span><span class="lnt"> 11
</span><span class="lnt"> 12
</span><span class="lnt"> 13
</span><span class="lnt"> 14
</span><span class="lnt"> 15
</span><span class="lnt"> 16
</span><span class="lnt"> 17
</span><span class="lnt"> 18
</span><span class="lnt"> 19
</span><span class="lnt"> 20
</span><span class="lnt"> 21
</span><span class="lnt"> 22
</span><span class="lnt"> 23
</span><span class="lnt"> 24
</span><span class="lnt"> 25
</span><span class="lnt"> 26
</span><span class="lnt"> 27
</span><span class="lnt"> 28
</span><span class="lnt"> 29
</span><span class="lnt"> 30
</span><span class="lnt"> 31
</span><span class="lnt"> 32
</span><span class="lnt"> 33
</span><span class="lnt"> 34
</span><span class="lnt"> 35
</span><span class="lnt"> 36
</span><span class="lnt"> 37
</span><span class="lnt"> 38
</span><span class="lnt"> 39
</span><span class="lnt"> 40
</span><span class="lnt"> 41
</span><span class="lnt"> 42
</span><span class="lnt"> 43
</span><span class="lnt"> 44
</span><span class="lnt"> 45
</span><span class="lnt"> 46
</span><span class="lnt"> 47
</span><span class="lnt"> 48
</span><span class="lnt"> 49
</span><span class="lnt"> 50
</span><span class="lnt"> 51
</span><span class="lnt"> 52
</span><span class="lnt"> 53
</span><span class="lnt"> 54
</span><span class="lnt"> 55
</span><span class="lnt"> 56
</span><span class="lnt"> 57
</span><span class="lnt"> 58
</span><span class="lnt"> 59
</span><span class="lnt"> 60
</span><span class="lnt"> 61
</span><span class="lnt"> 62
</span><span class="lnt"> 63
</span><span class="lnt"> 64
</span><span class="lnt"> 65
</span><span class="lnt"> 66
</span><span class="lnt"> 67
</span><span class="lnt"> 68
</span><span class="lnt"> 69
</span><span class="lnt"> 70
</span><span class="lnt"> 71
</span><span class="lnt"> 72
</span><span class="lnt"> 73
</span><span class="lnt"> 74
</span><span class="lnt"> 75
</span><span class="lnt"> 76
</span><span class="lnt"> 77
</span><span class="lnt"> 78
</span><span class="lnt"> 79
</span><span class="lnt"> 80
</span><span class="lnt"> 81
</span><span class="lnt"> 82
</span><span class="lnt"> 83
</span><span class="lnt"> 84
</span><span class="lnt"> 85
</span><span class="lnt"> 86
</span><span class="lnt"> 87
</span><span class="lnt"> 88
</span><span class="lnt"> 89
</span><span class="lnt"> 90
</span><span class="lnt"> 91
</span><span class="lnt"> 92
</span><span class="lnt"> 93
</span><span class="lnt"> 94
</span><span class="lnt"> 95
</span><span class="lnt"> 96
</span><span class="lnt"> 97
</span><span class="lnt"> 98
</span><span class="lnt"> 99
</span><span class="lnt">100
</span><span class="lnt">101
</span><span class="lnt">102
</span><span class="lnt">103
</span><span class="lnt">104
</span><span class="lnt">105
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kn">import</span> <span class="s">&#34;container/heap&#34;</span>

<span class="kd">type</span> <span class="nx">LFUNode</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">val</span>   <span class="kt">string</span>
	<span class="nx">key</span>   <span class="kt">string</span>
	<span class="nx">freq</span>  <span class="kt">int</span> <span class="c1">// 用于优先级，key的使用频率
</span><span class="c1"></span>	<span class="nx">count</span> <span class="kt">int</span> <span class="c1">// 用于当freq相同时的比较淘汰，总的获取次数，类似时间戳的概念
</span><span class="c1"></span>	<span class="nx">index</span> <span class="kt">int</span> <span class="c1">// 最小堆中元素的下标，用于重建最小堆.
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">type</span> <span class="nx">PriorityQueue</span> <span class="p">[]</span><span class="o">*</span><span class="nx">LFUNode</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">pq</span> <span class="nx">PriorityQueue</span><span class="p">)</span> <span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="nx">pq</span><span class="p">)</span> <span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">pq</span> <span class="nx">PriorityQueue</span><span class="p">)</span> <span class="nf">Less</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
	<span class="c1">// 优先根据使用频率排列，相等时才使用count，从小到大排序
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">pq</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">freq</span> <span class="o">==</span> <span class="nx">pq</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">freq</span> <span class="p">{</span>
		<span class="k">return</span> <span class="nx">pq</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">count</span> <span class="p">&lt;</span> <span class="nx">pq</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">count</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">pq</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">freq</span> <span class="p">&lt;</span> <span class="nx">pq</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">freq</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">pq</span> <span class="nx">PriorityQueue</span><span class="p">)</span> <span class="nf">Swap</span><span class="p">(</span><span class="nx">i</span><span class="p">,</span> <span class="nx">j</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">pq</span><span class="p">[</span><span class="nx">i</span><span class="p">],</span> <span class="nx">pq</span><span class="p">[</span><span class="nx">j</span><span class="p">]</span> <span class="p">=</span> <span class="nx">pq</span><span class="p">[</span><span class="nx">j</span><span class="p">],</span> <span class="nx">pq</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
	<span class="nx">pq</span><span class="p">[</span><span class="nx">i</span><span class="p">].</span><span class="nx">index</span> <span class="p">=</span> <span class="nx">i</span>
	<span class="nx">pq</span><span class="p">[</span><span class="nx">j</span><span class="p">].</span><span class="nx">index</span> <span class="p">=</span> <span class="nx">j</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">pq</span> <span class="o">*</span><span class="nx">PriorityQueue</span><span class="p">)</span> <span class="nf">Push</span><span class="p">(</span><span class="nx">x</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">{</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="o">*</span><span class="nx">pq</span><span class="p">)</span>
	<span class="nx">node</span> <span class="o">:=</span> <span class="nx">x</span><span class="p">.(</span><span class="o">*</span><span class="nx">LFUNode</span><span class="p">)</span>
	<span class="nx">node</span><span class="p">.</span><span class="nx">index</span> <span class="p">=</span> <span class="nx">n</span>
	<span class="o">*</span><span class="nx">pq</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="o">*</span><span class="nx">pq</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">pq</span> <span class="o">*</span><span class="nx">PriorityQueue</span><span class="p">)</span> <span class="nf">Pop</span><span class="p">()</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
	<span class="nx">old</span> <span class="o">:=</span> <span class="o">*</span><span class="nx">pq</span>
	<span class="nx">n</span> <span class="o">:=</span> <span class="nb">len</span><span class="p">(</span><span class="nx">old</span><span class="p">)</span>
	<span class="nx">node</span> <span class="o">:=</span> <span class="nx">old</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">old</span><span class="p">[</span><span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="kc">nil</span>  <span class="c1">// 防止内存泄露
</span><span class="c1"></span>	<span class="nx">node</span><span class="p">.</span><span class="nx">index</span> <span class="p">=</span> <span class="o">-</span><span class="mi">1</span> <span class="c1">// pop时重置下标保证安全
</span><span class="c1"></span>	<span class="o">*</span><span class="nx">pq</span> <span class="p">=</span> <span class="nx">old</span><span class="p">[</span><span class="mi">0</span> <span class="p">:</span> <span class="nx">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
	<span class="k">return</span> <span class="nx">node</span>
<span class="p">}</span>

<span class="c1">// 更新最小堆里的元素
</span><span class="c1"></span><span class="kd">func</span> <span class="p">(</span><span class="nx">pq</span> <span class="o">*</span><span class="nx">PriorityQueue</span><span class="p">)</span> <span class="nf">update</span><span class="p">(</span><span class="nx">node</span> <span class="o">*</span><span class="nx">LFUNode</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">frequency</span> <span class="kt">int</span><span class="p">,</span> <span class="nx">count</span> <span class="kt">int</span><span class="p">)</span> <span class="p">{</span>
	<span class="nx">node</span><span class="p">.</span><span class="nx">val</span> <span class="p">=</span> <span class="nx">value</span>
	<span class="nx">node</span><span class="p">.</span><span class="nx">count</span> <span class="p">=</span> <span class="nx">count</span>
	<span class="nx">node</span><span class="p">.</span><span class="nx">freq</span> <span class="p">=</span> <span class="nx">frequency</span>
	<span class="nx">heap</span><span class="p">.</span><span class="nf">Fix</span><span class="p">(</span><span class="nx">pq</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">index</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// ==========================================
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">LFUCache</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">cap</span>      <span class="kt">int</span>
	<span class="nx">pq</span>       <span class="nx">PriorityQueue</span>
	<span class="nx">nodeMap</span>  <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">LFUNode</span>
	<span class="nx">counter</span>  <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewLFUCache</span><span class="p">(</span><span class="nx">capacity</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">LFUCache</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">LFUCache</span><span class="p">{</span>
		<span class="nx">pq</span><span class="p">:</span>       <span class="nx">PriorityQueue</span><span class="p">{},</span>
		<span class="nx">nodeMap</span><span class="p">:</span>  <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">LFUNode</span><span class="p">,</span> <span class="nx">capacity</span><span class="p">),</span>
		<span class="nx">cap</span><span class="p">:</span>      <span class="nx">capacity</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">lfu</span> <span class="o">*</span><span class="nx">LFUCache</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">cap</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">nodeMap</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">lfu</span><span class="p">.</span><span class="nx">counter</span><span class="o">++</span>
		<span class="nx">lfu</span><span class="p">.</span><span class="nx">pq</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">val</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">freq</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">counter</span><span class="p">)</span>
		<span class="k">return</span> <span class="nx">node</span><span class="p">.</span><span class="nx">val</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="s">&#34;&#34;</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">lfu</span> <span class="o">*</span><span class="nx">LFUCache</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">cap</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="nx">lfu</span><span class="p">.</span><span class="nx">counter</span><span class="o">++</span>
	<span class="c1">// 如果存在，增加 frequency，再调整堆
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">node</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">nodeMap</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">lfu</span><span class="p">.</span><span class="nx">pq</span><span class="p">.</span><span class="nf">update</span><span class="p">(</span><span class="nx">node</span><span class="p">,</span> <span class="nx">value</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">freq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">counter</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 如果不存在且缓存满了，需要删除。在 hashmap 和 pq 中删除。
</span><span class="c1"></span>	<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nx">lfu</span><span class="p">.</span><span class="nx">pq</span><span class="p">)</span> <span class="o">==</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">cap</span> <span class="p">{</span>
		<span class="nx">node</span> <span class="o">:=</span> <span class="nx">heap</span><span class="p">.</span><span class="nf">Pop</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">lfu</span><span class="p">.</span><span class="nx">pq</span><span class="p">).(</span><span class="o">*</span><span class="nx">LFUNode</span><span class="p">)</span>
		<span class="nb">delete</span><span class="p">(</span><span class="nx">lfu</span><span class="p">.</span><span class="nx">nodeMap</span><span class="p">,</span> <span class="nx">node</span><span class="p">.</span><span class="nx">key</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 新建结点，在 hashmap 和 pq 中添加。
</span><span class="c1"></span>	<span class="nx">node</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">LFUNode</span><span class="p">{</span>
		<span class="nx">val</span><span class="p">:</span>   <span class="nx">value</span><span class="p">,</span>
		<span class="nx">key</span><span class="p">:</span>   <span class="nx">key</span><span class="p">,</span>
		<span class="nx">count</span><span class="p">:</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">counter</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="nx">heap</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">lfu</span><span class="p">.</span><span class="nx">pq</span><span class="p">,</span> <span class="nx">node</span><span class="p">)</span>
	<span class="nx">lfu</span><span class="p">.</span><span class="nx">nodeMap</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">node</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><p>另一个版本实现，利用go本身提供的双向链表，但是由于go没泛型，在类型推断方面导致整体性能不会很高</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span><span class="lnt">24
</span><span class="lnt">25
</span><span class="lnt">26
</span><span class="lnt">27
</span><span class="lnt">28
</span><span class="lnt">29
</span><span class="lnt">30
</span><span class="lnt">31
</span><span class="lnt">32
</span><span class="lnt">33
</span><span class="lnt">34
</span><span class="lnt">35
</span><span class="lnt">36
</span><span class="lnt">37
</span><span class="lnt">38
</span><span class="lnt">39
</span><span class="lnt">40
</span><span class="lnt">41
</span><span class="lnt">42
</span><span class="lnt">43
</span><span class="lnt">44
</span><span class="lnt">45
</span><span class="lnt">46
</span><span class="lnt">47
</span><span class="lnt">48
</span><span class="lnt">49
</span><span class="lnt">50
</span><span class="lnt">51
</span><span class="lnt">52
</span><span class="lnt">53
</span><span class="lnt">54
</span><span class="lnt">55
</span><span class="lnt">56
</span><span class="lnt">57
</span><span class="lnt">58
</span><span class="lnt">59
</span><span class="lnt">60
</span><span class="lnt">61
</span><span class="lnt">62
</span><span class="lnt">63
</span><span class="lnt">64
</span><span class="lnt">65
</span><span class="lnt">66
</span><span class="lnt">67
</span><span class="lnt">68
</span><span class="lnt">69
</span><span class="lnt">70
</span><span class="lnt">71
</span><span class="lnt">72
</span><span class="lnt">73
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-go" data-lang="go"><span class="kd">type</span> <span class="nx">LFUCache2</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">nodeMap</span>       <span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">list</span><span class="p">.</span><span class="nx">Element</span>
	<span class="nx">freq2NodeList</span> <span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="nx">list</span><span class="p">.</span><span class="nx">List</span>
	<span class="nx">cap</span>           <span class="kt">int</span>
	<span class="nx">min</span>           <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">node</span> <span class="kd">struct</span> <span class="p">{</span>
	<span class="nx">key</span>       <span class="kt">string</span>
	<span class="nx">value</span>     <span class="kt">string</span>
	<span class="nx">freq</span>      <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">NewLFUCache2</span><span class="p">(</span><span class="nx">capacity</span> <span class="kt">int</span><span class="p">)</span> <span class="nx">LFUCache2</span> <span class="p">{</span>
	<span class="k">return</span> <span class="nx">LFUCache2</span><span class="p">{</span><span class="nx">nodeMap</span><span class="p">:</span> <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="o">*</span><span class="nx">list</span><span class="p">.</span><span class="nx">Element</span><span class="p">),</span>
		<span class="nx">freq2NodeList</span><span class="p">:</span>    <span class="nb">make</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">int</span><span class="p">]</span><span class="o">*</span><span class="nx">list</span><span class="p">.</span><span class="nx">List</span><span class="p">),</span>
		<span class="nx">cap</span><span class="p">:</span>      <span class="nx">capacity</span><span class="p">,</span>
		<span class="nx">min</span><span class="p">:</span>      <span class="mi">0</span><span class="p">,</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">lfu</span> <span class="o">*</span><span class="nx">LFUCache2</span><span class="p">)</span> <span class="nf">Get</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">string</span> <span class="p">{</span>
	<span class="nx">value</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">nodeMap</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span>
	<span class="k">if</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="k">return</span> <span class="s">&#34;&#34;</span>
	<span class="p">}</span>
	<span class="nx">currentNode</span> <span class="o">:=</span> <span class="nx">value</span><span class="p">.</span><span class="nx">Value</span><span class="p">.(</span><span class="o">*</span><span class="nx">node</span><span class="p">)</span>
	<span class="nx">lfu</span><span class="p">.</span><span class="nx">freq2NodeList</span><span class="p">[</span><span class="nx">currentNode</span><span class="p">.</span><span class="nx">freq</span><span class="p">].</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">value</span><span class="p">)</span>
	<span class="nx">currentNode</span><span class="p">.</span><span class="nx">freq</span><span class="o">++</span>
	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">freq2NodeList</span><span class="p">[</span><span class="nx">currentNode</span><span class="p">.</span><span class="nx">freq</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">lfu</span><span class="p">.</span><span class="nx">freq2NodeList</span><span class="p">[</span><span class="nx">currentNode</span><span class="p">.</span><span class="nx">freq</span><span class="p">]</span> <span class="p">=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">newList</span> <span class="o">:=</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">freq2NodeList</span><span class="p">[</span><span class="nx">currentNode</span><span class="p">.</span><span class="nx">freq</span><span class="p">]</span>
	<span class="nx">newNode</span> <span class="o">:=</span> <span class="nx">newList</span><span class="p">.</span><span class="nf">PushFront</span><span class="p">(</span><span class="nx">currentNode</span><span class="p">)</span>
	<span class="nx">lfu</span><span class="p">.</span><span class="nx">nodeMap</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">newNode</span>
	<span class="k">if</span> <span class="nx">currentNode</span><span class="p">.</span><span class="nx">freq</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">min</span> <span class="o">&amp;&amp;</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">freq2NodeList</span><span class="p">[</span><span class="nx">currentNode</span><span class="p">.</span><span class="nx">freq</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="nf">Len</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="nx">lfu</span><span class="p">.</span><span class="nx">min</span><span class="o">++</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nx">currentNode</span><span class="p">.</span><span class="nx">value</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="p">(</span><span class="nx">lfu</span> <span class="o">*</span><span class="nx">LFUCache2</span><span class="p">)</span> <span class="nf">Put</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">,</span> <span class="nx">value</span> <span class="kt">string</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">cap</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 如果存在，更新访问次数
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">currentValue</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">nodeMap</span><span class="p">[</span><span class="nx">key</span><span class="p">];</span> <span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">currentNode</span> <span class="o">:=</span> <span class="nx">currentValue</span><span class="p">.</span><span class="nx">Value</span><span class="p">.(</span><span class="o">*</span><span class="nx">node</span><span class="p">)</span>
		<span class="nx">currentNode</span><span class="p">.</span><span class="nx">value</span> <span class="p">=</span> <span class="nx">value</span>
		<span class="nx">lfu</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="nx">key</span><span class="p">)</span>
		<span class="k">return</span>
	<span class="p">}</span>
	<span class="c1">// 如果不存在且缓存满了，需要删除
</span><span class="c1"></span>	<span class="k">if</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">cap</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="nx">lfu</span><span class="p">.</span><span class="nx">nodeMap</span><span class="p">)</span> <span class="p">{</span>
		<span class="nx">currentList</span> <span class="o">:=</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">freq2NodeList</span><span class="p">[</span><span class="nx">lfu</span><span class="p">.</span><span class="nx">min</span><span class="p">]</span>
		<span class="nx">backNode</span> <span class="o">:=</span> <span class="nx">currentList</span><span class="p">.</span><span class="nf">Back</span><span class="p">()</span>
		<span class="nb">delete</span><span class="p">(</span><span class="nx">lfu</span><span class="p">.</span><span class="nx">nodeMap</span><span class="p">,</span> <span class="nx">backNode</span><span class="p">.</span><span class="nx">Value</span><span class="p">.(</span><span class="o">*</span><span class="nx">node</span><span class="p">).</span><span class="nx">key</span><span class="p">)</span>
		<span class="nx">currentList</span><span class="p">.</span><span class="nf">Remove</span><span class="p">(</span><span class="nx">backNode</span><span class="p">)</span>
	<span class="p">}</span>
	<span class="c1">// 新建结点，插入到 2 个 map 中
</span><span class="c1"></span>	<span class="nx">lfu</span><span class="p">.</span><span class="nx">min</span> <span class="p">=</span> <span class="mi">1</span>
	<span class="nx">currentNode</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">node</span><span class="p">{</span>
		<span class="nx">key</span><span class="p">:</span>       <span class="nx">key</span><span class="p">,</span>
		<span class="nx">value</span><span class="p">:</span>     <span class="nx">value</span><span class="p">,</span>
		<span class="nx">freq</span><span class="p">:</span>      <span class="mi">1</span><span class="p">,</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="nx">_</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">freq2NodeList</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="p">!</span><span class="nx">ok</span> <span class="p">{</span>
		<span class="nx">lfu</span><span class="p">.</span><span class="nx">freq2NodeList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">=</span> <span class="nx">list</span><span class="p">.</span><span class="nf">New</span><span class="p">()</span>
	<span class="p">}</span>
	<span class="nx">newList</span> <span class="o">:=</span> <span class="nx">lfu</span><span class="p">.</span><span class="nx">freq2NodeList</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
	<span class="nx">newNode</span> <span class="o">:=</span> <span class="nx">newList</span><span class="p">.</span><span class="nf">PushFront</span><span class="p">(</span><span class="nx">currentNode</span><span class="p">)</span>
	<span class="nx">lfu</span><span class="p">.</span><span class="nx">nodeMap</span><span class="p">[</span><span class="nx">key</span><span class="p">]</span> <span class="p">=</span> <span class="nx">newNode</span>
<span class="p">}</span>
</code></pre></td></tr></table>
</div>
</div><h1 id="参考">参考</h1>
<p><a class="link" href="https://liangyaopei.github.io/2020/07/29/bloom-filter/"  target="_blank" rel="noopener"
    >布隆过滤器原理及golang实现</a></p>
<p><a class="link" href="https://halfrost.com/lru_lfu_interview/"  target="_blank" rel="noopener"
    >LRU / LFU 的青铜与王者</a></p>

</section>


    <footer class="article-footer">
    
    <section class="article-tags">
        
            <a href="/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/">定时任务</a>
        
            <a href="/tags/session%E5%92%8Ccookie/">session和cookie</a>
        
            <a href="/tags/jwt/">JWT</a>
        
            <a href="/tags/%E5%8E%8B%E6%B5%8B%E8%B0%83%E4%BC%98/">压测调优</a>
        
            <a href="/tags/%E5%B8%B8%E8%A7%81%E4%B8%9A%E5%8A%A1%E6%96%B9%E6%A1%88/">常见业务方案</a>
        
            <a href="/tags/%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/">布隆过滤器</a>
        
            <a href="/tags/%E6%B7%98%E6%B1%B0%E7%AE%97%E6%B3%95/">淘汰算法</a>
        
    </section>


    
    <section class="article-copyright">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <path d="M14.5 9a3.5 4 0 1 0 0 6" />
</svg>



        <span>Licensed under CC BY-NC-SA 4.0</span>
    </section>
    <section class="article-lastmod">
        <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="12" cy="12" r="9" />
  <polyline points="12 7 12 12 15 15" />
</svg>



        <span>
            Last updated on Sep 03, 2021 00:00 UTC
        </span>
    </section></footer>


    
        <link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.css"integrity="sha384-RZU/ijkSsFbcmivfdRBQDtwuwVqK7GMOw6IMvKyeWL2K5UAlyp6WonmB8m7Jd0Hn"crossorigin="anonymous"
            ><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/katex.min.js"integrity="sha384-pK1WpvzWVBQiP0/GjnvRxV4mOb0oxFuyRxJlk6vVw146n3egcN5C925NCP7a7BY8"crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/katex@0.13.13/dist/contrib/auto-render.min.js"integrity="sha384-vZTG03m&#43;2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl"crossorigin="anonymous"
                defer="true"
                >
            </script><script>
    window.addEventListener("DOMContentLoaded", () => {
        renderMathInElement(document.querySelector(`.article-content`), {
            delimiters: [
                { left: "$$", right: "$$", display: true },
                { left: "$", right: "$", display: false },
                { left: "\\(", right: "\\)", display: false },
                { left: "\\[", right: "\\]", display: true }
            ]
        });})
</script>
    
</article>

    

    <aside class="related-contents--wrapper">
    
    
</aside>

     
    
        
    <script src="https://utteranc.es/client.js" 
        repo="Nixum/blog"
        issue-term="pathname"
        
        crossorigin="anonymous"
        async
        >
</script>

<style>
    .utterances {
        max-width: unset;
    }
</style>

<script>
    function setUtterancesTheme(theme) {
        let utterances = document.querySelector('.utterances iframe');
        if (utterances) {
            utterances.contentWindow.postMessage(
                {
                    type: 'set-theme',
                    theme: `github-${theme}`
                },
                'https://utteranc.es'
            );
        }
    }

    addEventListener('message', event => {
        if (event.origin !== 'https://utteranc.es') return;
        setUtterancesTheme(document.documentElement.dataset.scheme)
    });

    window.addEventListener('onColorSchemeChange', (e) => {
        setUtterancesTheme(e.detail)
    })
</script>


    

    <footer class="site-footer">
    <section class="copyright">
        &copy; 
        
            2020 - 
        
        2023 Nixum Blog
    </section>
    
    <section class="powerby">
        Built with <a href="https://gohugo.io/" target="_blank" rel="noopener">Hugo</a> <br />
        Theme <b><a href="https://github.com/CaiJimmy/hugo-theme-stack" target="_blank" rel="noopener" data-version="3.6.0">Stack</a></b> designed by <a href="https://jimmycai.com" target="_blank" rel="noopener">Jimmy</a>
    </section>
</footer>


    
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    
    <div class="pswp__bg"></div>

    
    <div class="pswp__scroll-wrap">

        
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                
                
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo="crossorigin="anonymous"
                defer="true"
                >
            </script><script 
                src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU="crossorigin="anonymous"
                defer="true"
                >
            </script><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.css"integrity="sha256-c0uckgykQ9v5k&#43;IqViZOZKc47Jn7KQil4/MP3ySA3F8="crossorigin="anonymous"
            ><link 
                rel="stylesheet" 
                href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.css"integrity="sha256-SBLU4vv6CA6lHsZ1XyTdhyjJxCjPif/TRkjnsyGAGnE="crossorigin="anonymous"
            >

            </main>
    
        <aside class="sidebar right-sidebar sticky">

            <section class="widget archives">
                <form action="/search/" class="search-form widget" >
        <p>
            <label>Search</label>
            <input name="keyword" required placeholder="Type something..." />
        
            <button title="Search">
                <svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round">
  <path stroke="none" d="M0 0h24v24H0z"/>
  <circle cx="10" cy="10" r="7" />
  <line x1="21" y1="21" x2="15" y2="15" />
</svg>



            </button>
        </p>
    </form>
            </section>

            <section class="widget archives">
                <h2 class="widget-title section-title">Contents</h2>

                <div class="widget--toc">
                    <nav id="TableOfContents">
  <ol>
    <li><a href="#quartz">Quartz</a>
      <ol>
        <li><a href="#其他定时器">其他定时器</a></li>
      </ol>
    </li>
    <li><a href="#cors">CORS</a></li>
    <li><a href="#session和cookie">session和cookie</a></li>
    <li><a href="#jwt">JWT</a>
      <ol>
        <li><a href="#原理">原理</a></li>
        <li><a href="#使用">使用</a></li>
      </ol>
    </li>
    <li><a href="#cas模型---sso单点登录">CAS模型 - SSO(单点登录)</a></li>
    <li><a href="#基于oauth20的第三方登录">基于OAuth2.0的第三方登录</a></li>
    <li><a href="#压测">压测</a></li>
    <li><a href="#调优">调优</a></li>
    <li><a href="#布隆过滤器">布隆过滤器</a>
      <ol>
        <li><a href="#原理-1">原理</a></li>
        <li><a href="#误判率计算">误判率计算</a></li>
        <li><a href="#实现">实现</a></li>
      </ol>
    </li>
    <li><a href="#淘汰算法">淘汰算法</a>
      <ol>
        <li><a href="#lru">LRU</a></li>
        <li><a href="#lfu">LFU</a></li>
      </ol>
    </li>
    <li><a href="#参考">参考</a></li>
  </ol>
</nav>
                </div>
            </section>

            <section class="widget archives">
                <h2 class="widget-title section-title">Other Article Tags</h2>
                <section class="widget tagCloud">
    <div class="tagCloud-tags">
        
            <a href="/tags/%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84/" class="font_size_3">
                主从架构
            </a>
        
            <a href="/tags/javase/" class="font_size_2">
                JavaSE
            </a>
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/" class="font_size_2">
                数据库
            </a>
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93-%E9%94%81/" class="font_size_2">
                数据库-锁
            </a>
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/" class="font_size_2">
                数据库事务
            </a>
        
            <a href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/" class="font_size_2">
                数据库优化
            </a>
        
            <a href="/tags/%E7%B4%A2%E5%BC%95/" class="font_size_2">
                索引
            </a>
        
            <a href="/tags/context%E5%8E%9F%E7%90%86/" class="font_size_1">
                context原理
            </a>
        
            <a href="/tags/docker/" class="font_size_1">
                docker
            </a>
        
            <a href="/tags/etcd/" class="font_size_1">
                etcd
            </a>
        
            <a href="/tags/git/" class="font_size_1">
                git
            </a>
        
            <a href="/tags/go/" class="font_size_1">
                Go
            </a>
        
            <a href="/tags/go-channel%E5%8E%9F%E7%90%86/" class="font_size_1">
                Go channel原理
            </a>
        
            <a href="/tags/go-gc/" class="font_size_1">
                Go GC
            </a>
        
            <a href="/tags/go-gin%E5%8E%9F%E7%90%86/" class="font_size_1">
                Go Gin原理
            </a>
        
            <a href="/tags/go-slice%E5%92%8Cmap%E5%8E%9F%E7%90%86/" class="font_size_1">
                Go slice和map原理
            </a>
        
            <a href="/tags/go-sync%E5%8C%85/" class="font_size_1">
                Go sync包
            </a>
        
            <a href="/tags/goroutine/" class="font_size_1">
                Goroutine
            </a>
        
            <a href="/tags/go%E5%B9%B6%E5%8F%91/" class="font_size_1">
                Go并发
            </a>
        
            <a href="/tags/http/" class="font_size_1">
                HTTP
            </a>
        
            <a href="/tags/ioc%E5%92%8Caop/" class="font_size_1">
                IOC和AOP
            </a>
        
            <a href="/tags/istio/" class="font_size_1">
                Istio
            </a>
        
            <a href="/tags/java-bio/" class="font_size_1">
                Java BIO
            </a>
        
            <a href="/tags/java-gc/" class="font_size_1">
                Java GC
            </a>
        
            <a href="/tags/java-nio/" class="font_size_1">
                Java NIO
            </a>
        
            <a href="/tags/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/" class="font_size_1">
                Java内存模型
            </a>
        
            <a href="/tags/java%E5%B9%B6%E5%8F%91/" class="font_size_1">
                Java并发
            </a>
        
            <a href="/tags/java%E9%9B%86%E5%90%88%E7%B1%BB%E5%8E%9F%E7%90%86/" class="font_size_1">
                Java集合类原理
            </a>
        
            <a href="/tags/juc/" class="font_size_1">
                JUC
            </a>
        
            <a href="/tags/jvm/" class="font_size_1">
                JVM
            </a>
        
            <a href="/tags/jwt/" class="font_size_1">
                JWT
            </a>
        
            <a href="/tags/kubernetes/" class="font_size_1">
                Kubernetes
            </a>
        
            <a href="/tags/linux/" class="font_size_1">
                Linux
            </a>
        
            <a href="/tags/mongodb/" class="font_size_1">
                MongoDB
            </a>
        
            <a href="/tags/mysql/" class="font_size_1">
                MySQL
            </a>
        
            <a href="/tags/netty/" class="font_size_1">
                Netty
            </a>
        
            <a href="/tags/orm/" class="font_size_1">
                ORM
            </a>
        
            <a href="/tags/redis/" class="font_size_1">
                Redis
            </a>
        
            <a href="/tags/rpc/" class="font_size_1">
                RPC
            </a>
        
            <a href="/tags/session%E5%92%8Ccookie/" class="font_size_1">
                session和cookie
            </a>
        
            <a href="/tags/socket/" class="font_size_1">
                socket
            </a>
        
            <a href="/tags/spring/" class="font_size_1">
                Spring
            </a>
        
            <a href="/tags/spring-security/" class="font_size_1">
                Spring Security
            </a>
        
            <a href="/tags/springboot/" class="font_size_1">
                SpringBoot
            </a>
        
            <a href="/tags/springmvc/" class="font_size_1">
                SpringMVC
            </a>
        
            <a href="/tags/tcp/" class="font_size_1">
                TCP
            </a>
        
            <a href="/tags/udp/" class="font_size_1">
                UDP
            </a>
        
            <a href="/tags/uml/" class="font_size_1">
                UML
            </a>
        
            <a href="/tags/web%E6%A1%86%E6%9E%B6/" class="font_size_1">
                web框架
            </a>
        
            <a href="/tags/zookeeper/" class="font_size_1">
                zookeeper
            </a>
        
    </div>
</section>
            </section>

        </aside>
    

        </div>
        <script 
                src="https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js"integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g="crossorigin="anonymous"
                defer="false"
                >
            </script><script type="text/javascript" src="/ts/main.js" defer></script>
<script>
    (function () {
        const customFont = document.createElement('link');
        customFont.href = "https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";

        customFont.type = "text/css";
        customFont.rel = "stylesheet";

        document.head.appendChild(customFont);
    }());
</script>


    </body>
</html>
